ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 1


   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.syntax unified
  15              		.file	"queue.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.comm	xQueueRegistry,80,4
  20              		.section	.text.xQueueGenericReset,"ax",%progbits
  21              		.align	2
  22              		.global	xQueueGenericReset
  23              		.thumb
  24              		.thumb_func
  25              		.type	xQueueGenericReset, %function
  26              	xQueueGenericReset:
  27              	.LFB68:
  28              		.file 1 "Source\\queue.c"
   1:Source/queue.c **** /*
   2:Source/queue.c ****  * FreeRTOS Kernel V10.3.1
   3:Source/queue.c ****  * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:Source/queue.c ****  *
   5:Source/queue.c ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   6:Source/queue.c ****  * this software and associated documentation files (the "Software"), to deal in
   7:Source/queue.c ****  * the Software without restriction, including without limitation the rights to
   8:Source/queue.c ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   9:Source/queue.c ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  10:Source/queue.c ****  * subject to the following conditions:
  11:Source/queue.c ****  *
  12:Source/queue.c ****  * The above copyright notice and this permission notice shall be included in all
  13:Source/queue.c ****  * copies or substantial portions of the Software.
  14:Source/queue.c ****  *
  15:Source/queue.c ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:Source/queue.c ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  17:Source/queue.c ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  18:Source/queue.c ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  19:Source/queue.c ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  20:Source/queue.c ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  21:Source/queue.c ****  *
  22:Source/queue.c ****  * http://www.FreeRTOS.org
  23:Source/queue.c ****  * http://aws.amazon.com/freertos
  24:Source/queue.c ****  *
  25:Source/queue.c ****  * 1 tab == 4 spaces!
  26:Source/queue.c ****  */
  27:Source/queue.c **** 
  28:Source/queue.c **** #include <stdlib.h>
  29:Source/queue.c **** #include <string.h>
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 2


  30:Source/queue.c **** 
  31:Source/queue.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  32:Source/queue.c **** all the API functions to use the MPU wrappers.  That should only be done when
  33:Source/queue.c **** task.h is included from an application file. */
  34:Source/queue.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  35:Source/queue.c **** 
  36:Source/queue.c **** #include "FreeRTOS.h"
  37:Source/queue.c **** #include "task.h"
  38:Source/queue.c **** #include "queue.h"
  39:Source/queue.c **** 
  40:Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
  41:Source/queue.c **** 	#include "croutine.h"
  42:Source/queue.c **** #endif
  43:Source/queue.c **** 
  44:Source/queue.c **** /* Lint e9021, e961 and e750 are suppressed as a MISRA exception justified
  45:Source/queue.c **** because the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined
  46:Source/queue.c **** for the header files above, but not in this file, in order to generate the
  47:Source/queue.c **** correct privileged Vs unprivileged linkage and placement. */
  48:Source/queue.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750 !e9021. */
  49:Source/queue.c **** 
  50:Source/queue.c **** 
  51:Source/queue.c **** /* Constants used with the cRxLock and cTxLock structure members. */
  52:Source/queue.c **** #define queueUNLOCKED					( ( int8_t ) -1 )
  53:Source/queue.c **** #define queueLOCKED_UNMODIFIED			( ( int8_t ) 0 )
  54:Source/queue.c **** 
  55:Source/queue.c **** /* When the Queue_t structure is used to represent a base queue its pcHead and
  56:Source/queue.c **** pcTail members are used as pointers into the queue storage area.  When the
  57:Source/queue.c **** Queue_t structure is used to represent a mutex pcHead and pcTail pointers are
  58:Source/queue.c **** not necessary, and the pcHead pointer is set to NULL to indicate that the
  59:Source/queue.c **** structure instead holds a pointer to the mutex holder (if any).  Map alternative
  60:Source/queue.c **** names to the pcHead and structure member to ensure the readability of the code
  61:Source/queue.c **** is maintained.  The QueuePointers_t and SemaphoreData_t types are used to form
  62:Source/queue.c **** a union as their usage is mutually exclusive dependent on what the queue is
  63:Source/queue.c **** being used for. */
  64:Source/queue.c **** #define uxQueueType						pcHead
  65:Source/queue.c **** #define queueQUEUE_IS_MUTEX				NULL
  66:Source/queue.c **** 
  67:Source/queue.c **** typedef struct QueuePointers
  68:Source/queue.c **** {
  69:Source/queue.c **** 	int8_t *pcTail;					/*< Points to the byte at the end of the queue storage area.  Once more byte i
  70:Source/queue.c **** 	int8_t *pcReadFrom;				/*< Points to the last place that a queued item was read from when the stru
  71:Source/queue.c **** } QueuePointers_t;
  72:Source/queue.c **** 
  73:Source/queue.c **** typedef struct SemaphoreData
  74:Source/queue.c **** {
  75:Source/queue.c **** 	TaskHandle_t xMutexHolder;		 /*< The handle of the task that holds the mutex. */
  76:Source/queue.c **** 	UBaseType_t uxRecursiveCallCount;/*< Maintains a count of the number of times a recursive mutex ha
  77:Source/queue.c **** } SemaphoreData_t;
  78:Source/queue.c **** 
  79:Source/queue.c **** /* Semaphores do not actually store or copy data, so have an item size of
  80:Source/queue.c **** zero. */
  81:Source/queue.c **** #define queueSEMAPHORE_QUEUE_ITEM_LENGTH ( ( UBaseType_t ) 0 )
  82:Source/queue.c **** #define queueMUTEX_GIVE_BLOCK_TIME		 ( ( TickType_t ) 0U )
  83:Source/queue.c **** 
  84:Source/queue.c **** #if( configUSE_PREEMPTION == 0 )
  85:Source/queue.c **** 	/* If the cooperative scheduler is being used then a yield should not be
  86:Source/queue.c **** 	performed just because a higher priority task has been woken. */
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 3


  87:Source/queue.c **** 	#define queueYIELD_IF_USING_PREEMPTION()
  88:Source/queue.c **** #else
  89:Source/queue.c **** 	#define queueYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
  90:Source/queue.c **** #endif
  91:Source/queue.c **** 
  92:Source/queue.c **** /*
  93:Source/queue.c ****  * Definition of the queue used by the scheduler.
  94:Source/queue.c ****  * Items are queued by copy, not reference.  See the following link for the
  95:Source/queue.c ****  * rationale: https://www.freertos.org/Embedded-RTOS-Queues.html
  96:Source/queue.c ****  */
  97:Source/queue.c **** typedef struct QueueDefinition 		/* The old naming convention is used to prevent breaking kernel aw
  98:Source/queue.c **** {
  99:Source/queue.c **** 	int8_t *pcHead;					/*< Points to the beginning of the queue storage area. */
 100:Source/queue.c **** 	int8_t *pcWriteTo;				/*< Points to the free next place in the storage area. */
 101:Source/queue.c **** 
 102:Source/queue.c **** 	union
 103:Source/queue.c **** 	{
 104:Source/queue.c **** 		QueuePointers_t xQueue;		/*< Data required exclusively when this structure is used as a queue. */
 105:Source/queue.c **** 		SemaphoreData_t xSemaphore; /*< Data required exclusively when this structure is used as a semaph
 106:Source/queue.c **** 	} u;
 107:Source/queue.c **** 
 108:Source/queue.c **** 	List_t xTasksWaitingToSend;		/*< List of tasks that are blocked waiting to post onto this queue.  
 109:Source/queue.c **** 	List_t xTasksWaitingToReceive;	/*< List of tasks that are blocked waiting to read from this queue.
 110:Source/queue.c **** 
 111:Source/queue.c **** 	volatile UBaseType_t uxMessagesWaiting;/*< The number of items currently in the queue. */
 112:Source/queue.c **** 	UBaseType_t uxLength;			/*< The length of the queue defined as the number of items it will hold, n
 113:Source/queue.c **** 	UBaseType_t uxItemSize;			/*< The size of each items that the queue will hold. */
 114:Source/queue.c **** 
 115:Source/queue.c **** 	volatile int8_t cRxLock;		/*< Stores the number of items received from the queue (removed from the
 116:Source/queue.c **** 	volatile int8_t cTxLock;		/*< Stores the number of items transmitted to the queue (added to the qu
 117:Source/queue.c **** 
 118:Source/queue.c **** 	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 119:Source/queue.c **** 		uint8_t ucStaticallyAllocated;	/*< Set to pdTRUE if the memory used by the queue was statically a
 120:Source/queue.c **** 	#endif
 121:Source/queue.c **** 
 122:Source/queue.c **** 	#if ( configUSE_QUEUE_SETS == 1 )
 123:Source/queue.c **** 		struct QueueDefinition *pxQueueSetContainer;
 124:Source/queue.c **** 	#endif
 125:Source/queue.c **** 
 126:Source/queue.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 127:Source/queue.c **** 		UBaseType_t uxQueueNumber;
 128:Source/queue.c **** 		uint8_t ucQueueType;
 129:Source/queue.c **** 	#endif
 130:Source/queue.c **** 
 131:Source/queue.c **** } xQUEUE;
 132:Source/queue.c **** 
 133:Source/queue.c **** /* The old xQUEUE name is maintained above then typedefed to the new Queue_t
 134:Source/queue.c **** name below to enable the use of older kernel aware debuggers. */
 135:Source/queue.c **** typedef xQUEUE Queue_t;
 136:Source/queue.c **** 
 137:Source/queue.c **** /*-----------------------------------------------------------*/
 138:Source/queue.c **** 
 139:Source/queue.c **** /*
 140:Source/queue.c ****  * The queue registry is just a means for kernel aware debuggers to locate
 141:Source/queue.c ****  * queue structures.  It has no other purpose so is an optional component.
 142:Source/queue.c ****  */
 143:Source/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 4


 144:Source/queue.c **** 
 145:Source/queue.c **** 	/* The type stored within the queue registry array.  This allows a name
 146:Source/queue.c **** 	to be assigned to each queue making kernel aware debugging a little
 147:Source/queue.c **** 	more user friendly. */
 148:Source/queue.c **** 	typedef struct QUEUE_REGISTRY_ITEM
 149:Source/queue.c **** 	{
 150:Source/queue.c **** 		const char *pcQueueName; /*lint !e971 Unqualified char types are allowed for strings and single c
 151:Source/queue.c **** 		QueueHandle_t xHandle;
 152:Source/queue.c **** 	} xQueueRegistryItem;
 153:Source/queue.c **** 
 154:Source/queue.c **** 	/* The old xQueueRegistryItem name is maintained above then typedefed to the
 155:Source/queue.c **** 	new xQueueRegistryItem name below to enable the use of older kernel aware
 156:Source/queue.c **** 	debuggers. */
 157:Source/queue.c **** 	typedef xQueueRegistryItem QueueRegistryItem_t;
 158:Source/queue.c **** 
 159:Source/queue.c **** 	/* The queue registry is simply an array of QueueRegistryItem_t structures.
 160:Source/queue.c **** 	The pcQueueName member of a structure being NULL is indicative of the
 161:Source/queue.c **** 	array position being vacant. */
 162:Source/queue.c **** 	PRIVILEGED_DATA QueueRegistryItem_t xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];
 163:Source/queue.c **** 
 164:Source/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
 165:Source/queue.c **** 
 166:Source/queue.c **** /*
 167:Source/queue.c ****  * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not
 168:Source/queue.c ****  * prevent an ISR from adding or removing items to the queue, but does prevent
 169:Source/queue.c ****  * an ISR from removing tasks from the queue event lists.  If an ISR finds a
 170:Source/queue.c ****  * queue is locked it will instead increment the appropriate queue lock count
 171:Source/queue.c ****  * to indicate that a task may require unblocking.  When the queue in unlocked
 172:Source/queue.c ****  * these lock counts are inspected, and the appropriate action taken.
 173:Source/queue.c ****  */
 174:Source/queue.c **** static void prvUnlockQueue( Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;
 175:Source/queue.c **** 
 176:Source/queue.c **** /*
 177:Source/queue.c ****  * Uses a critical section to determine if there is any data in a queue.
 178:Source/queue.c ****  *
 179:Source/queue.c ****  * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
 180:Source/queue.c ****  */
 181:Source/queue.c **** static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
 182:Source/queue.c **** 
 183:Source/queue.c **** /*
 184:Source/queue.c ****  * Uses a critical section to determine if there is any space in a queue.
 185:Source/queue.c ****  *
 186:Source/queue.c ****  * @return pdTRUE if there is no space, otherwise pdFALSE;
 187:Source/queue.c ****  */
 188:Source/queue.c **** static BaseType_t prvIsQueueFull( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
 189:Source/queue.c **** 
 190:Source/queue.c **** /*
 191:Source/queue.c ****  * Copies an item into the queue, either at the front of the queue or the
 192:Source/queue.c ****  * back of the queue.
 193:Source/queue.c ****  */
 194:Source/queue.c **** static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const Bas
 195:Source/queue.c **** 
 196:Source/queue.c **** /*
 197:Source/queue.c ****  * Copies an item out of a queue.
 198:Source/queue.c ****  */
 199:Source/queue.c **** static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer ) PRIVILEGED_FUNCT
 200:Source/queue.c **** 
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 5


 201:Source/queue.c **** #if ( configUSE_QUEUE_SETS == 1 )
 202:Source/queue.c **** 	/*
 203:Source/queue.c **** 	 * Checks to see if a queue is a member of a queue set, and if so, notifies
 204:Source/queue.c **** 	 * the queue set that the queue contains data.
 205:Source/queue.c **** 	 */
 206:Source/queue.c **** 	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;
 207:Source/queue.c **** #endif
 208:Source/queue.c **** 
 209:Source/queue.c **** /*
 210:Source/queue.c ****  * Called after a Queue_t structure has been allocated either statically or
 211:Source/queue.c ****  * dynamically to fill in the structure's members.
 212:Source/queue.c ****  */
 213:Source/queue.c **** static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, u
 214:Source/queue.c **** 
 215:Source/queue.c **** /*
 216:Source/queue.c ****  * Mutexes are a special type of queue.  When a mutex is created, first the
 217:Source/queue.c ****  * queue is created, then prvInitialiseMutex() is called to configure the queue
 218:Source/queue.c ****  * as a mutex.
 219:Source/queue.c ****  */
 220:Source/queue.c **** #if( configUSE_MUTEXES == 1 )
 221:Source/queue.c **** 	static void prvInitialiseMutex( Queue_t *pxNewQueue ) PRIVILEGED_FUNCTION;
 222:Source/queue.c **** #endif
 223:Source/queue.c **** 
 224:Source/queue.c **** #if( configUSE_MUTEXES == 1 )
 225:Source/queue.c **** 	/*
 226:Source/queue.c **** 	 * If a task waiting for a mutex causes the mutex holder to inherit a
 227:Source/queue.c **** 	 * priority, but the waiting task times out, then the holder should
 228:Source/queue.c **** 	 * disinherit the priority - but only down to the highest priority of any
 229:Source/queue.c **** 	 * other tasks that are waiting for the same mutex.  This function returns
 230:Source/queue.c **** 	 * that priority.
 231:Source/queue.c **** 	 */
 232:Source/queue.c **** 	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue ) PRIVILEGE
 233:Source/queue.c **** #endif
 234:Source/queue.c **** /*-----------------------------------------------------------*/
 235:Source/queue.c **** 
 236:Source/queue.c **** /*
 237:Source/queue.c ****  * Macro to mark a queue as locked.  Locking a queue prevents an ISR from
 238:Source/queue.c ****  * accessing the queue event lists.
 239:Source/queue.c ****  */
 240:Source/queue.c **** #define prvLockQueue( pxQueue )								\
 241:Source/queue.c **** 	taskENTER_CRITICAL();									\
 242:Source/queue.c **** 	{														\
 243:Source/queue.c **** 		if( ( pxQueue )->cRxLock == queueUNLOCKED )			\
 244:Source/queue.c **** 		{													\
 245:Source/queue.c **** 			( pxQueue )->cRxLock = queueLOCKED_UNMODIFIED;	\
 246:Source/queue.c **** 		}													\
 247:Source/queue.c **** 		if( ( pxQueue )->cTxLock == queueUNLOCKED )			\
 248:Source/queue.c **** 		{													\
 249:Source/queue.c **** 			( pxQueue )->cTxLock = queueLOCKED_UNMODIFIED;	\
 250:Source/queue.c **** 		}													\
 251:Source/queue.c **** 	}														\
 252:Source/queue.c **** 	taskEXIT_CRITICAL()
 253:Source/queue.c **** /*-----------------------------------------------------------*/
 254:Source/queue.c **** 
 255:Source/queue.c **** BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
 256:Source/queue.c **** {
  29              		.loc 1 256 0
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 6


  30              		.cfi_startproc
  31              		@ args = 0, pretend = 0, frame = 16
  32              		@ frame_needed = 1, uses_anonymous_args = 0
  33 0000 80B5     		push	{r7, lr}
  34              		.cfi_def_cfa_offset 8
  35              		.cfi_offset 7, -8
  36              		.cfi_offset 14, -4
  37 0002 84B0     		sub	sp, sp, #16
  38              		.cfi_def_cfa_offset 24
  39 0004 00AF     		add	r7, sp, #0
  40              		.cfi_def_cfa_register 7
  41 0006 7860     		str	r0, [r7, #4]
  42 0008 3960     		str	r1, [r7]
 257:Source/queue.c **** Queue_t * const pxQueue = xQueue;
  43              		.loc 1 257 0
  44 000a 7B68     		ldr	r3, [r7, #4]
  45 000c FB60     		str	r3, [r7, #12]
 258:Source/queue.c **** 
 259:Source/queue.c **** 	configASSERT( pxQueue );
 260:Source/queue.c **** 
 261:Source/queue.c **** 	taskENTER_CRITICAL();
  46              		.loc 1 261 0
  47 000e FFF7FEFF 		bl	vPortEnterCritical
 262:Source/queue.c **** 	{
 263:Source/queue.c **** 		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint 
  48              		.loc 1 263 0
  49 0012 FB68     		ldr	r3, [r7, #12]
  50 0014 1A68     		ldr	r2, [r3]
  51 0016 FB68     		ldr	r3, [r7, #12]
  52 0018 DB6B     		ldr	r3, [r3, #60]
  53 001a F968     		ldr	r1, [r7, #12]
  54 001c 096C     		ldr	r1, [r1, #64]
  55 001e 01FB03F3 		mul	r3, r1, r3
  56 0022 1A44     		add	r2, r2, r3
  57 0024 FB68     		ldr	r3, [r7, #12]
  58 0026 9A60     		str	r2, [r3, #8]
 264:Source/queue.c **** 		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
  59              		.loc 1 264 0
  60 0028 FB68     		ldr	r3, [r7, #12]
  61 002a 0022     		movs	r2, #0
  62 002c 9A63     		str	r2, [r3, #56]
 265:Source/queue.c **** 		pxQueue->pcWriteTo = pxQueue->pcHead;
  63              		.loc 1 265 0
  64 002e FB68     		ldr	r3, [r7, #12]
  65 0030 1A68     		ldr	r2, [r3]
  66 0032 FB68     		ldr	r3, [r7, #12]
  67 0034 5A60     		str	r2, [r3, #4]
 266:Source/queue.c **** 		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSi
  68              		.loc 1 266 0
  69 0036 FB68     		ldr	r3, [r7, #12]
  70 0038 1A68     		ldr	r2, [r3]
  71 003a FB68     		ldr	r3, [r7, #12]
  72 003c DB6B     		ldr	r3, [r3, #60]
  73 003e 013B     		subs	r3, r3, #1
  74 0040 F968     		ldr	r1, [r7, #12]
  75 0042 096C     		ldr	r1, [r1, #64]
  76 0044 01FB03F3 		mul	r3, r1, r3
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 7


  77 0048 1A44     		add	r2, r2, r3
  78 004a FB68     		ldr	r3, [r7, #12]
  79 004c DA60     		str	r2, [r3, #12]
 267:Source/queue.c **** 		pxQueue->cRxLock = queueUNLOCKED;
  80              		.loc 1 267 0
  81 004e FB68     		ldr	r3, [r7, #12]
  82 0050 FF22     		movs	r2, #255
  83 0052 83F84420 		strb	r2, [r3, #68]
 268:Source/queue.c **** 		pxQueue->cTxLock = queueUNLOCKED;
  84              		.loc 1 268 0
  85 0056 FB68     		ldr	r3, [r7, #12]
  86 0058 FF22     		movs	r2, #255
  87 005a 83F84520 		strb	r2, [r3, #69]
 269:Source/queue.c **** 
 270:Source/queue.c **** 		if( xNewQueue == pdFALSE )
  88              		.loc 1 270 0
  89 005e 3B68     		ldr	r3, [r7]
  90 0060 002B     		cmp	r3, #0
  91 0062 14D1     		bne	.L2
 271:Source/queue.c **** 		{
 272:Source/queue.c **** 			/* If there are tasks blocked waiting to read from the queue, then
 273:Source/queue.c **** 			the tasks will remain blocked as after this function exits the queue
 274:Source/queue.c **** 			will still be empty.  If there are tasks blocked waiting to write to
 275:Source/queue.c **** 			the queue, then one should be unblocked as after this function exits
 276:Source/queue.c **** 			it will be possible to write to it. */
 277:Source/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  92              		.loc 1 277 0
  93 0064 FB68     		ldr	r3, [r7, #12]
  94 0066 1B69     		ldr	r3, [r3, #16]
  95 0068 002B     		cmp	r3, #0
  96 006a 1AD0     		beq	.L3
 278:Source/queue.c **** 			{
 279:Source/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
  97              		.loc 1 279 0
  98 006c FB68     		ldr	r3, [r7, #12]
  99 006e 1033     		adds	r3, r3, #16
 100 0070 1846     		mov	r0, r3
 101 0072 FFF7FEFF 		bl	xTaskRemoveFromEventList
 102 0076 0346     		mov	r3, r0
 103 0078 002B     		cmp	r3, #0
 104 007a 12D0     		beq	.L3
 280:Source/queue.c **** 				{
 281:Source/queue.c **** 					queueYIELD_IF_USING_PREEMPTION();
 105              		.loc 1 281 0
 106 007c 0C4B     		ldr	r3, .L5
 107 007e 4FF08052 		mov	r2, #268435456
 108 0082 1A60     		str	r2, [r3]
 109              		.syntax unified
 110              	@ 281 "Source\queue.c" 1
 111 0084 BFF34F8F 		dsb
 112              	@ 0 "" 2
 113              	@ 281 "Source\queue.c" 1
 114 0088 BFF36F8F 		isb
 115              	@ 0 "" 2
 116              		.thumb
 117              		.syntax unified
 118 008c 09E0     		b	.L3
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 8


 119              	.L2:
 282:Source/queue.c **** 				}
 283:Source/queue.c **** 				else
 284:Source/queue.c **** 				{
 285:Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
 286:Source/queue.c **** 				}
 287:Source/queue.c **** 			}
 288:Source/queue.c **** 			else
 289:Source/queue.c **** 			{
 290:Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
 291:Source/queue.c **** 			}
 292:Source/queue.c **** 		}
 293:Source/queue.c **** 		else
 294:Source/queue.c **** 		{
 295:Source/queue.c **** 			/* Ensure the event queues start in the correct state. */
 296:Source/queue.c **** 			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 120              		.loc 1 296 0
 121 008e FB68     		ldr	r3, [r7, #12]
 122 0090 1033     		adds	r3, r3, #16
 123 0092 1846     		mov	r0, r3
 124 0094 FFF7FEFF 		bl	vListInitialise
 297:Source/queue.c **** 			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 125              		.loc 1 297 0
 126 0098 FB68     		ldr	r3, [r7, #12]
 127 009a 2433     		adds	r3, r3, #36
 128 009c 1846     		mov	r0, r3
 129 009e FFF7FEFF 		bl	vListInitialise
 130              	.L3:
 298:Source/queue.c **** 		}
 299:Source/queue.c **** 	}
 300:Source/queue.c **** 	taskEXIT_CRITICAL();
 131              		.loc 1 300 0
 132 00a2 FFF7FEFF 		bl	vPortExitCritical
 301:Source/queue.c **** 
 302:Source/queue.c **** 	/* A value is returned for calling semantic consistency with previous
 303:Source/queue.c **** 	versions. */
 304:Source/queue.c **** 	return pdPASS;
 133              		.loc 1 304 0
 134 00a6 0123     		movs	r3, #1
 305:Source/queue.c **** }
 135              		.loc 1 305 0
 136 00a8 1846     		mov	r0, r3
 137 00aa 1037     		adds	r7, r7, #16
 138              		.cfi_def_cfa_offset 8
 139 00ac BD46     		mov	sp, r7
 140              		.cfi_def_cfa_register 13
 141              		@ sp needed
 142 00ae 80BD     		pop	{r7, pc}
 143              	.L6:
 144              		.align	2
 145              	.L5:
 146 00b0 04ED00E0 		.word	-536810236
 147              		.cfi_endproc
 148              	.LFE68:
 149              		.size	xQueueGenericReset, .-xQueueGenericReset
 150              		.section	.text.xQueueGenericCreate,"ax",%progbits
 151              		.align	2
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 9


 152              		.global	xQueueGenericCreate
 153              		.thumb
 154              		.thumb_func
 155              		.type	xQueueGenericCreate, %function
 156              	xQueueGenericCreate:
 157              	.LFB69:
 306:Source/queue.c **** /*-----------------------------------------------------------*/
 307:Source/queue.c **** 
 308:Source/queue.c **** #if( configSUPPORT_STATIC_ALLOCATION == 1 )
 309:Source/queue.c **** 
 310:Source/queue.c **** 	QueueHandle_t xQueueGenericCreateStatic( const UBaseType_t uxQueueLength, const UBaseType_t uxItem
 311:Source/queue.c **** 	{
 312:Source/queue.c **** 	Queue_t *pxNewQueue;
 313:Source/queue.c **** 
 314:Source/queue.c **** 		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 315:Source/queue.c **** 
 316:Source/queue.c **** 		/* The StaticQueue_t structure and the queue storage area must be
 317:Source/queue.c **** 		supplied. */
 318:Source/queue.c **** 		configASSERT( pxStaticQueue != NULL );
 319:Source/queue.c **** 
 320:Source/queue.c **** 		/* A queue storage area should be provided if the item size is not 0, and
 321:Source/queue.c **** 		should not be provided if the item size is 0. */
 322:Source/queue.c **** 		configASSERT( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) );
 323:Source/queue.c **** 		configASSERT( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) );
 324:Source/queue.c **** 
 325:Source/queue.c **** 		#if( configASSERT_DEFINED == 1 )
 326:Source/queue.c **** 		{
 327:Source/queue.c **** 			/* Sanity check that the size of the structure used to declare a
 328:Source/queue.c **** 			variable of type StaticQueue_t or StaticSemaphore_t equals the size of
 329:Source/queue.c **** 			the real queue and semaphore structures. */
 330:Source/queue.c **** 			volatile size_t xSize = sizeof( StaticQueue_t );
 331:Source/queue.c **** 			configASSERT( xSize == sizeof( Queue_t ) );
 332:Source/queue.c **** 			( void ) xSize; /* Keeps lint quiet when configASSERT() is not defined. */
 333:Source/queue.c **** 		}
 334:Source/queue.c **** 		#endif /* configASSERT_DEFINED */
 335:Source/queue.c **** 
 336:Source/queue.c **** 		/* The address of a statically allocated queue was passed in, use it.
 337:Source/queue.c **** 		The address of a statically allocated storage area was also passed in
 338:Source/queue.c **** 		but is already set. */
 339:Source/queue.c **** 		pxNewQueue = ( Queue_t * ) pxStaticQueue; /*lint !e740 !e9087 Unusual cast is ok as the structure
 340:Source/queue.c **** 
 341:Source/queue.c **** 		if( pxNewQueue != NULL )
 342:Source/queue.c **** 		{
 343:Source/queue.c **** 			#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 344:Source/queue.c **** 			{
 345:Source/queue.c **** 				/* Queues can be allocated wither statically or dynamically, so
 346:Source/queue.c **** 				note this queue was allocated statically in case the queue is
 347:Source/queue.c **** 				later deleted. */
 348:Source/queue.c **** 				pxNewQueue->ucStaticallyAllocated = pdTRUE;
 349:Source/queue.c **** 			}
 350:Source/queue.c **** 			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
 351:Source/queue.c **** 
 352:Source/queue.c **** 			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
 353:Source/queue.c **** 		}
 354:Source/queue.c **** 		else
 355:Source/queue.c **** 		{
 356:Source/queue.c **** 			traceQUEUE_CREATE_FAILED( ucQueueType );
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 10


 357:Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
 358:Source/queue.c **** 		}
 359:Source/queue.c **** 
 360:Source/queue.c **** 		return pxNewQueue;
 361:Source/queue.c **** 	}
 362:Source/queue.c **** 
 363:Source/queue.c **** #endif /* configSUPPORT_STATIC_ALLOCATION */
 364:Source/queue.c **** /*-----------------------------------------------------------*/
 365:Source/queue.c **** 
 366:Source/queue.c **** #if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 367:Source/queue.c **** 
 368:Source/queue.c **** 	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, 
 369:Source/queue.c **** 	{
 158              		.loc 1 369 0
 159              		.cfi_startproc
 160              		@ args = 0, pretend = 0, frame = 32
 161              		@ frame_needed = 1, uses_anonymous_args = 0
 162 0000 80B5     		push	{r7, lr}
 163              		.cfi_def_cfa_offset 8
 164              		.cfi_offset 7, -8
 165              		.cfi_offset 14, -4
 166 0002 8AB0     		sub	sp, sp, #40
 167              		.cfi_def_cfa_offset 48
 168 0004 02AF     		add	r7, sp, #8
 169              		.cfi_def_cfa 7, 40
 170 0006 F860     		str	r0, [r7, #12]
 171 0008 B960     		str	r1, [r7, #8]
 172 000a 1346     		mov	r3, r2
 173 000c FB71     		strb	r3, [r7, #7]
 370:Source/queue.c **** 	Queue_t *pxNewQueue;
 371:Source/queue.c **** 	size_t xQueueSizeInBytes;
 372:Source/queue.c **** 	uint8_t *pucQueueStorage;
 373:Source/queue.c **** 
 374:Source/queue.c **** 		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 375:Source/queue.c **** 
 376:Source/queue.c **** 		/* Allocate enough space to hold the maximum number of items that
 377:Source/queue.c **** 		can be in the queue at any time.  It is valid for uxItemSize to be
 378:Source/queue.c **** 		zero in the case the queue is used as a semaphore. */
 379:Source/queue.c **** 		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as th
 174              		.loc 1 379 0
 175 000e FB68     		ldr	r3, [r7, #12]
 176 0010 BA68     		ldr	r2, [r7, #8]
 177 0012 02FB03F3 		mul	r3, r2, r3
 178 0016 FB61     		str	r3, [r7, #28]
 380:Source/queue.c **** 
 381:Source/queue.c **** 		/* Allocate the queue and storage area.  Justification for MISRA
 382:Source/queue.c **** 		deviation as follows:  pvPortMalloc() always ensures returned memory
 383:Source/queue.c **** 		blocks are aligned per the requirements of the MCU stack.  In this case
 384:Source/queue.c **** 		pvPortMalloc() must return a pointer that is guaranteed to meet the
 385:Source/queue.c **** 		alignment requirements of the Queue_t structure - which in this case
 386:Source/queue.c **** 		is an int8_t *.  Therefore, whenever the stack alignment requirements
 387:Source/queue.c **** 		are greater than or equal to the pointer to char requirements the cast
 388:Source/queue.c **** 		is safe.  In other cases alignment requirements are not strict (one or
 389:Source/queue.c **** 		two bytes). */
 390:Source/queue.c **** 		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !
 179              		.loc 1 390 0
 180 0018 FB69     		ldr	r3, [r7, #28]
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 11


 181 001a 4833     		adds	r3, r3, #72
 182 001c 1846     		mov	r0, r3
 183 001e FFF7FEFF 		bl	pvPortMalloc
 184 0022 B861     		str	r0, [r7, #24]
 391:Source/queue.c **** 
 392:Source/queue.c **** 		if( pxNewQueue != NULL )
 185              		.loc 1 392 0
 186 0024 BB69     		ldr	r3, [r7, #24]
 187 0026 002B     		cmp	r3, #0
 188 0028 0DD0     		beq	.L8
 393:Source/queue.c **** 		{
 394:Source/queue.c **** 			/* Jump past the queue structure to find the location of the queue
 395:Source/queue.c **** 			storage area. */
 396:Source/queue.c **** 			pucQueueStorage = ( uint8_t * ) pxNewQueue;
 189              		.loc 1 396 0
 190 002a BB69     		ldr	r3, [r7, #24]
 191 002c 7B61     		str	r3, [r7, #20]
 397:Source/queue.c **** 			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, es
 192              		.loc 1 397 0
 193 002e 7B69     		ldr	r3, [r7, #20]
 194 0030 4833     		adds	r3, r3, #72
 195 0032 7B61     		str	r3, [r7, #20]
 398:Source/queue.c **** 
 399:Source/queue.c **** 			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
 400:Source/queue.c **** 			{
 401:Source/queue.c **** 				/* Queues can be created either statically or dynamically, so
 402:Source/queue.c **** 				note this task was created dynamically in case it is later
 403:Source/queue.c **** 				deleted. */
 404:Source/queue.c **** 				pxNewQueue->ucStaticallyAllocated = pdFALSE;
 405:Source/queue.c **** 			}
 406:Source/queue.c **** 			#endif /* configSUPPORT_STATIC_ALLOCATION */
 407:Source/queue.c **** 
 408:Source/queue.c **** 			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
 196              		.loc 1 408 0
 197 0034 FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 198 0036 BB69     		ldr	r3, [r7, #24]
 199 0038 0093     		str	r3, [sp]
 200 003a 1346     		mov	r3, r2
 201 003c 7A69     		ldr	r2, [r7, #20]
 202 003e B968     		ldr	r1, [r7, #8]
 203 0040 F868     		ldr	r0, [r7, #12]
 204 0042 FFF7FEFF 		bl	prvInitialiseNewQueue
 205              	.L8:
 409:Source/queue.c **** 		}
 410:Source/queue.c **** 		else
 411:Source/queue.c **** 		{
 412:Source/queue.c **** 			traceQUEUE_CREATE_FAILED( ucQueueType );
 413:Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
 414:Source/queue.c **** 		}
 415:Source/queue.c **** 
 416:Source/queue.c **** 		return pxNewQueue;
 206              		.loc 1 416 0
 207 0046 BB69     		ldr	r3, [r7, #24]
 417:Source/queue.c **** 	}
 208              		.loc 1 417 0
 209 0048 1846     		mov	r0, r3
 210 004a 2037     		adds	r7, r7, #32
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 12


 211              		.cfi_def_cfa_offset 8
 212 004c BD46     		mov	sp, r7
 213              		.cfi_def_cfa_register 13
 214              		@ sp needed
 215 004e 80BD     		pop	{r7, pc}
 216              		.cfi_endproc
 217              	.LFE69:
 218              		.size	xQueueGenericCreate, .-xQueueGenericCreate
 219              		.section	.text.prvInitialiseNewQueue,"ax",%progbits
 220              		.align	2
 221              		.thumb
 222              		.thumb_func
 223              		.type	prvInitialiseNewQueue, %function
 224              	prvInitialiseNewQueue:
 225              	.LFB70:
 418:Source/queue.c **** 
 419:Source/queue.c **** #endif /* configSUPPORT_STATIC_ALLOCATION */
 420:Source/queue.c **** /*-----------------------------------------------------------*/
 421:Source/queue.c **** 
 422:Source/queue.c **** static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, u
 423:Source/queue.c **** {
 226              		.loc 1 423 0
 227              		.cfi_startproc
 228              		@ args = 4, pretend = 0, frame = 16
 229              		@ frame_needed = 1, uses_anonymous_args = 0
 230 0000 80B5     		push	{r7, lr}
 231              		.cfi_def_cfa_offset 8
 232              		.cfi_offset 7, -8
 233              		.cfi_offset 14, -4
 234 0002 84B0     		sub	sp, sp, #16
 235              		.cfi_def_cfa_offset 24
 236 0004 00AF     		add	r7, sp, #0
 237              		.cfi_def_cfa_register 7
 238 0006 F860     		str	r0, [r7, #12]
 239 0008 B960     		str	r1, [r7, #8]
 240 000a 7A60     		str	r2, [r7, #4]
 241 000c FB70     		strb	r3, [r7, #3]
 424:Source/queue.c **** 	/* Remove compiler warnings about unused parameters should
 425:Source/queue.c **** 	configUSE_TRACE_FACILITY not be set to 1. */
 426:Source/queue.c **** 	( void ) ucQueueType;
 427:Source/queue.c **** 
 428:Source/queue.c **** 	if( uxItemSize == ( UBaseType_t ) 0 )
 242              		.loc 1 428 0
 243 000e BB68     		ldr	r3, [r7, #8]
 244 0010 002B     		cmp	r3, #0
 245 0012 03D1     		bne	.L11
 429:Source/queue.c **** 	{
 430:Source/queue.c **** 		/* No RAM was allocated for the queue storage area, but PC head cannot
 431:Source/queue.c **** 		be set to NULL because NULL is used as a key to say the queue is used as
 432:Source/queue.c **** 		a mutex.  Therefore just set pcHead to point to the queue as a benign
 433:Source/queue.c **** 		value that is known to be within the memory map. */
 434:Source/queue.c **** 		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 246              		.loc 1 434 0
 247 0014 BB69     		ldr	r3, [r7, #24]
 248 0016 BA69     		ldr	r2, [r7, #24]
 249 0018 1A60     		str	r2, [r3]
 250 001a 02E0     		b	.L12
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 13


 251              	.L11:
 435:Source/queue.c **** 	}
 436:Source/queue.c **** 	else
 437:Source/queue.c **** 	{
 438:Source/queue.c **** 		/* Set the head to the start of the queue storage area. */
 439:Source/queue.c **** 		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 252              		.loc 1 439 0
 253 001c BB69     		ldr	r3, [r7, #24]
 254 001e 7A68     		ldr	r2, [r7, #4]
 255 0020 1A60     		str	r2, [r3]
 256              	.L12:
 440:Source/queue.c **** 	}
 441:Source/queue.c **** 
 442:Source/queue.c **** 	/* Initialise the queue members as described where the queue type is
 443:Source/queue.c **** 	defined. */
 444:Source/queue.c **** 	pxNewQueue->uxLength = uxQueueLength;
 257              		.loc 1 444 0
 258 0022 BB69     		ldr	r3, [r7, #24]
 259 0024 FA68     		ldr	r2, [r7, #12]
 260 0026 DA63     		str	r2, [r3, #60]
 445:Source/queue.c **** 	pxNewQueue->uxItemSize = uxItemSize;
 261              		.loc 1 445 0
 262 0028 BB69     		ldr	r3, [r7, #24]
 263 002a BA68     		ldr	r2, [r7, #8]
 264 002c 1A64     		str	r2, [r3, #64]
 446:Source/queue.c **** 	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 265              		.loc 1 446 0
 266 002e 0121     		movs	r1, #1
 267 0030 B869     		ldr	r0, [r7, #24]
 268 0032 FFF7FEFF 		bl	xQueueGenericReset
 447:Source/queue.c **** 
 448:Source/queue.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 449:Source/queue.c **** 	{
 450:Source/queue.c **** 		pxNewQueue->ucQueueType = ucQueueType;
 451:Source/queue.c **** 	}
 452:Source/queue.c **** 	#endif /* configUSE_TRACE_FACILITY */
 453:Source/queue.c **** 
 454:Source/queue.c **** 	#if( configUSE_QUEUE_SETS == 1 )
 455:Source/queue.c **** 	{
 456:Source/queue.c **** 		pxNewQueue->pxQueueSetContainer = NULL;
 457:Source/queue.c **** 	}
 458:Source/queue.c **** 	#endif /* configUSE_QUEUE_SETS */
 459:Source/queue.c **** 
 460:Source/queue.c **** 	traceQUEUE_CREATE( pxNewQueue );
 461:Source/queue.c **** }
 269              		.loc 1 461 0
 270 0036 00BF     		nop
 271 0038 1037     		adds	r7, r7, #16
 272              		.cfi_def_cfa_offset 8
 273 003a BD46     		mov	sp, r7
 274              		.cfi_def_cfa_register 13
 275              		@ sp needed
 276 003c 80BD     		pop	{r7, pc}
 277              		.cfi_endproc
 278              	.LFE70:
 279              		.size	prvInitialiseNewQueue, .-prvInitialiseNewQueue
 280 003e 00BF     		.section	.text.prvInitialiseMutex,"ax",%progbits
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 14


 281              		.align	2
 282              		.thumb
 283              		.thumb_func
 284              		.type	prvInitialiseMutex, %function
 285              	prvInitialiseMutex:
 286              	.LFB71:
 462:Source/queue.c **** /*-----------------------------------------------------------*/
 463:Source/queue.c **** 
 464:Source/queue.c **** #if( configUSE_MUTEXES == 1 )
 465:Source/queue.c **** 
 466:Source/queue.c **** 	static void prvInitialiseMutex( Queue_t *pxNewQueue )
 467:Source/queue.c **** 	{
 287              		.loc 1 467 0
 288              		.cfi_startproc
 289              		@ args = 0, pretend = 0, frame = 8
 290              		@ frame_needed = 1, uses_anonymous_args = 0
 291 0000 80B5     		push	{r7, lr}
 292              		.cfi_def_cfa_offset 8
 293              		.cfi_offset 7, -8
 294              		.cfi_offset 14, -4
 295 0002 82B0     		sub	sp, sp, #8
 296              		.cfi_def_cfa_offset 16
 297 0004 00AF     		add	r7, sp, #0
 298              		.cfi_def_cfa_register 7
 299 0006 7860     		str	r0, [r7, #4]
 468:Source/queue.c **** 		if( pxNewQueue != NULL )
 300              		.loc 1 468 0
 301 0008 7B68     		ldr	r3, [r7, #4]
 302 000a 002B     		cmp	r3, #0
 303 000c 0ED0     		beq	.L15
 469:Source/queue.c **** 		{
 470:Source/queue.c **** 			/* The queue create function will set all the queue structure members
 471:Source/queue.c **** 			correctly for a generic queue, but this function is creating a
 472:Source/queue.c **** 			mutex.  Overwrite those members that need to be set differently -
 473:Source/queue.c **** 			in particular the information required for priority inheritance. */
 474:Source/queue.c **** 			pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
 304              		.loc 1 474 0
 305 000e 7B68     		ldr	r3, [r7, #4]
 306 0010 0022     		movs	r2, #0
 307 0012 9A60     		str	r2, [r3, #8]
 475:Source/queue.c **** 			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 308              		.loc 1 475 0
 309 0014 7B68     		ldr	r3, [r7, #4]
 310 0016 0022     		movs	r2, #0
 311 0018 1A60     		str	r2, [r3]
 476:Source/queue.c **** 
 477:Source/queue.c **** 			/* In case this is a recursive mutex. */
 478:Source/queue.c **** 			pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
 312              		.loc 1 478 0
 313 001a 7B68     		ldr	r3, [r7, #4]
 314 001c 0022     		movs	r2, #0
 315 001e DA60     		str	r2, [r3, #12]
 479:Source/queue.c **** 
 480:Source/queue.c **** 			traceCREATE_MUTEX( pxNewQueue );
 481:Source/queue.c **** 
 482:Source/queue.c **** 			/* Start with the semaphore in the expected state. */
 483:Source/queue.c **** 			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 15


 316              		.loc 1 483 0
 317 0020 0023     		movs	r3, #0
 318 0022 0022     		movs	r2, #0
 319 0024 0021     		movs	r1, #0
 320 0026 7868     		ldr	r0, [r7, #4]
 321 0028 FFF7FEFF 		bl	xQueueGenericSend
 322              	.L15:
 484:Source/queue.c **** 		}
 485:Source/queue.c **** 		else
 486:Source/queue.c **** 		{
 487:Source/queue.c **** 			traceCREATE_MUTEX_FAILED();
 488:Source/queue.c **** 		}
 489:Source/queue.c **** 	}
 323              		.loc 1 489 0
 324 002c 00BF     		nop
 325 002e 0837     		adds	r7, r7, #8
 326              		.cfi_def_cfa_offset 8
 327 0030 BD46     		mov	sp, r7
 328              		.cfi_def_cfa_register 13
 329              		@ sp needed
 330 0032 80BD     		pop	{r7, pc}
 331              		.cfi_endproc
 332              	.LFE71:
 333              		.size	prvInitialiseMutex, .-prvInitialiseMutex
 334              		.section	.text.xQueueCreateMutex,"ax",%progbits
 335              		.align	2
 336              		.global	xQueueCreateMutex
 337              		.thumb
 338              		.thumb_func
 339              		.type	xQueueCreateMutex, %function
 340              	xQueueCreateMutex:
 341              	.LFB72:
 490:Source/queue.c **** 
 491:Source/queue.c **** #endif /* configUSE_MUTEXES */
 492:Source/queue.c **** /*-----------------------------------------------------------*/
 493:Source/queue.c **** 
 494:Source/queue.c **** #if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 495:Source/queue.c **** 
 496:Source/queue.c **** 	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
 497:Source/queue.c **** 	{
 342              		.loc 1 497 0
 343              		.cfi_startproc
 344              		@ args = 0, pretend = 0, frame = 24
 345              		@ frame_needed = 1, uses_anonymous_args = 0
 346 0000 80B5     		push	{r7, lr}
 347              		.cfi_def_cfa_offset 8
 348              		.cfi_offset 7, -8
 349              		.cfi_offset 14, -4
 350 0002 86B0     		sub	sp, sp, #24
 351              		.cfi_def_cfa_offset 32
 352 0004 00AF     		add	r7, sp, #0
 353              		.cfi_def_cfa_register 7
 354 0006 0346     		mov	r3, r0
 355 0008 FB71     		strb	r3, [r7, #7]
 498:Source/queue.c **** 	QueueHandle_t xNewQueue;
 499:Source/queue.c **** 	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
 356              		.loc 1 499 0
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 16


 357 000a 0123     		movs	r3, #1
 358 000c 7B61     		str	r3, [r7, #20]
 359 000e 0023     		movs	r3, #0
 360 0010 3B61     		str	r3, [r7, #16]
 500:Source/queue.c **** 
 501:Source/queue.c **** 		xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
 361              		.loc 1 501 0
 362 0012 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 363 0014 1A46     		mov	r2, r3
 364 0016 3969     		ldr	r1, [r7, #16]
 365 0018 7869     		ldr	r0, [r7, #20]
 366 001a FFF7FEFF 		bl	xQueueGenericCreate
 367 001e F860     		str	r0, [r7, #12]
 502:Source/queue.c **** 		prvInitialiseMutex( ( Queue_t * ) xNewQueue );
 368              		.loc 1 502 0
 369 0020 F868     		ldr	r0, [r7, #12]
 370 0022 FFF7FEFF 		bl	prvInitialiseMutex
 503:Source/queue.c **** 
 504:Source/queue.c **** 		return xNewQueue;
 371              		.loc 1 504 0
 372 0026 FB68     		ldr	r3, [r7, #12]
 505:Source/queue.c **** 	}
 373              		.loc 1 505 0
 374 0028 1846     		mov	r0, r3
 375 002a 1837     		adds	r7, r7, #24
 376              		.cfi_def_cfa_offset 8
 377 002c BD46     		mov	sp, r7
 378              		.cfi_def_cfa_register 13
 379              		@ sp needed
 380 002e 80BD     		pop	{r7, pc}
 381              		.cfi_endproc
 382              	.LFE72:
 383              		.size	xQueueCreateMutex, .-xQueueCreateMutex
 384              		.section	.text.xQueueGiveMutexRecursive,"ax",%progbits
 385              		.align	2
 386              		.global	xQueueGiveMutexRecursive
 387              		.thumb
 388              		.thumb_func
 389              		.type	xQueueGiveMutexRecursive, %function
 390              	xQueueGiveMutexRecursive:
 391              	.LFB73:
 506:Source/queue.c **** 
 507:Source/queue.c **** #endif /* configUSE_MUTEXES */
 508:Source/queue.c **** /*-----------------------------------------------------------*/
 509:Source/queue.c **** 
 510:Source/queue.c **** #if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
 511:Source/queue.c **** 
 512:Source/queue.c **** 	QueueHandle_t xQueueCreateMutexStatic( const uint8_t ucQueueType, StaticQueue_t *pxStaticQueue )
 513:Source/queue.c **** 	{
 514:Source/queue.c **** 	QueueHandle_t xNewQueue;
 515:Source/queue.c **** 	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
 516:Source/queue.c **** 
 517:Source/queue.c **** 		/* Prevent compiler warnings about unused parameters if
 518:Source/queue.c **** 		configUSE_TRACE_FACILITY does not equal 1. */
 519:Source/queue.c **** 		( void ) ucQueueType;
 520:Source/queue.c **** 
 521:Source/queue.c **** 		xNewQueue = xQueueGenericCreateStatic( uxMutexLength, uxMutexSize, NULL, pxStaticQueue, ucQueueTy
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 17


 522:Source/queue.c **** 		prvInitialiseMutex( ( Queue_t * ) xNewQueue );
 523:Source/queue.c **** 
 524:Source/queue.c **** 		return xNewQueue;
 525:Source/queue.c **** 	}
 526:Source/queue.c **** 
 527:Source/queue.c **** #endif /* configUSE_MUTEXES */
 528:Source/queue.c **** /*-----------------------------------------------------------*/
 529:Source/queue.c **** 
 530:Source/queue.c **** #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
 531:Source/queue.c **** 
 532:Source/queue.c **** 	TaskHandle_t xQueueGetMutexHolder( QueueHandle_t xSemaphore )
 533:Source/queue.c **** 	{
 534:Source/queue.c **** 	TaskHandle_t pxReturn;
 535:Source/queue.c **** 	Queue_t * const pxSemaphore = ( Queue_t * ) xSemaphore;
 536:Source/queue.c **** 
 537:Source/queue.c **** 		/* This function is called by xSemaphoreGetMutexHolder(), and should not
 538:Source/queue.c **** 		be called directly.  Note:  This is a good way of determining if the
 539:Source/queue.c **** 		calling task is the mutex holder, but not a good way of determining the
 540:Source/queue.c **** 		identity of the mutex holder, as the holder may change between the
 541:Source/queue.c **** 		following critical section exiting and the function returning. */
 542:Source/queue.c **** 		taskENTER_CRITICAL();
 543:Source/queue.c **** 		{
 544:Source/queue.c **** 			if( pxSemaphore->uxQueueType == queueQUEUE_IS_MUTEX )
 545:Source/queue.c **** 			{
 546:Source/queue.c **** 				pxReturn = pxSemaphore->u.xSemaphore.xMutexHolder;
 547:Source/queue.c **** 			}
 548:Source/queue.c **** 			else
 549:Source/queue.c **** 			{
 550:Source/queue.c **** 				pxReturn = NULL;
 551:Source/queue.c **** 			}
 552:Source/queue.c **** 		}
 553:Source/queue.c **** 		taskEXIT_CRITICAL();
 554:Source/queue.c **** 
 555:Source/queue.c **** 		return pxReturn;
 556:Source/queue.c **** 	} /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
 557:Source/queue.c **** 
 558:Source/queue.c **** #endif
 559:Source/queue.c **** /*-----------------------------------------------------------*/
 560:Source/queue.c **** 
 561:Source/queue.c **** #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
 562:Source/queue.c **** 
 563:Source/queue.c **** 	TaskHandle_t xQueueGetMutexHolderFromISR( QueueHandle_t xSemaphore )
 564:Source/queue.c **** 	{
 565:Source/queue.c **** 	TaskHandle_t pxReturn;
 566:Source/queue.c **** 
 567:Source/queue.c **** 		configASSERT( xSemaphore );
 568:Source/queue.c **** 
 569:Source/queue.c **** 		/* Mutexes cannot be used in interrupt service routines, so the mutex
 570:Source/queue.c **** 		holder should not change in an ISR, and therefore a critical section is
 571:Source/queue.c **** 		not required here. */
 572:Source/queue.c **** 		if( ( ( Queue_t * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
 573:Source/queue.c **** 		{
 574:Source/queue.c **** 			pxReturn = ( ( Queue_t * ) xSemaphore )->u.xSemaphore.xMutexHolder;
 575:Source/queue.c **** 		}
 576:Source/queue.c **** 		else
 577:Source/queue.c **** 		{
 578:Source/queue.c **** 			pxReturn = NULL;
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 18


 579:Source/queue.c **** 		}
 580:Source/queue.c **** 
 581:Source/queue.c **** 		return pxReturn;
 582:Source/queue.c **** 	} /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
 583:Source/queue.c **** 
 584:Source/queue.c **** #endif
 585:Source/queue.c **** /*-----------------------------------------------------------*/
 586:Source/queue.c **** 
 587:Source/queue.c **** #if ( configUSE_RECURSIVE_MUTEXES == 1 )
 588:Source/queue.c **** 
 589:Source/queue.c **** 	BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
 590:Source/queue.c **** 	{
 392              		.loc 1 590 0
 393              		.cfi_startproc
 394              		@ args = 0, pretend = 0, frame = 16
 395              		@ frame_needed = 1, uses_anonymous_args = 0
 396 0000 90B5     		push	{r4, r7, lr}
 397              		.cfi_def_cfa_offset 12
 398              		.cfi_offset 4, -12
 399              		.cfi_offset 7, -8
 400              		.cfi_offset 14, -4
 401 0002 85B0     		sub	sp, sp, #20
 402              		.cfi_def_cfa_offset 32
 403 0004 00AF     		add	r7, sp, #0
 404              		.cfi_def_cfa_register 7
 405 0006 7860     		str	r0, [r7, #4]
 591:Source/queue.c **** 	BaseType_t xReturn;
 592:Source/queue.c **** 	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 406              		.loc 1 592 0
 407 0008 7B68     		ldr	r3, [r7, #4]
 408 000a BB60     		str	r3, [r7, #8]
 593:Source/queue.c **** 
 594:Source/queue.c **** 		configASSERT( pxMutex );
 595:Source/queue.c **** 
 596:Source/queue.c **** 		/* If this is the task that holds the mutex then xMutexHolder will not
 597:Source/queue.c **** 		change outside of this task.  If this task does not hold the mutex then
 598:Source/queue.c **** 		pxMutexHolder can never coincidentally equal the tasks handle, and as
 599:Source/queue.c **** 		this is the only condition we are interested in it does not matter if
 600:Source/queue.c **** 		pxMutexHolder is accessed simultaneously by another task.  Therefore no
 601:Source/queue.c **** 		mutual exclusion is required to test the pxMutexHolder variable. */
 602:Source/queue.c **** 		if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
 409              		.loc 1 602 0
 410 000c BB68     		ldr	r3, [r7, #8]
 411 000e 9C68     		ldr	r4, [r3, #8]
 412 0010 FFF7FEFF 		bl	xTaskGetCurrentTaskHandle
 413 0014 0346     		mov	r3, r0
 414 0016 9C42     		cmp	r4, r3
 415 0018 11D1     		bne	.L19
 603:Source/queue.c **** 		{
 604:Source/queue.c **** 			traceGIVE_MUTEX_RECURSIVE( pxMutex );
 605:Source/queue.c **** 
 606:Source/queue.c **** 			/* uxRecursiveCallCount cannot be zero if xMutexHolder is equal to
 607:Source/queue.c **** 			the task handle, therefore no underflow check is required.  Also,
 608:Source/queue.c **** 			uxRecursiveCallCount is only modified by the mutex holder, and as
 609:Source/queue.c **** 			there can only be one, no mutual exclusion is required to modify the
 610:Source/queue.c **** 			uxRecursiveCallCount member. */
 611:Source/queue.c **** 			( pxMutex->u.xSemaphore.uxRecursiveCallCount )--;
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 19


 416              		.loc 1 611 0
 417 001a BB68     		ldr	r3, [r7, #8]
 418 001c DB68     		ldr	r3, [r3, #12]
 419 001e 5A1E     		subs	r2, r3, #1
 420 0020 BB68     		ldr	r3, [r7, #8]
 421 0022 DA60     		str	r2, [r3, #12]
 612:Source/queue.c **** 
 613:Source/queue.c **** 			/* Has the recursive call count unwound to 0? */
 614:Source/queue.c **** 			if( pxMutex->u.xSemaphore.uxRecursiveCallCount == ( UBaseType_t ) 0 )
 422              		.loc 1 614 0
 423 0024 BB68     		ldr	r3, [r7, #8]
 424 0026 DB68     		ldr	r3, [r3, #12]
 425 0028 002B     		cmp	r3, #0
 426 002a 05D1     		bne	.L20
 615:Source/queue.c **** 			{
 616:Source/queue.c **** 				/* Return the mutex.  This will automatically unblock any other
 617:Source/queue.c **** 				task that might be waiting to access the mutex. */
 618:Source/queue.c **** 				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
 427              		.loc 1 618 0
 428 002c 0023     		movs	r3, #0
 429 002e 0022     		movs	r2, #0
 430 0030 0021     		movs	r1, #0
 431 0032 B868     		ldr	r0, [r7, #8]
 432 0034 FFF7FEFF 		bl	xQueueGenericSend
 433              	.L20:
 619:Source/queue.c **** 			}
 620:Source/queue.c **** 			else
 621:Source/queue.c **** 			{
 622:Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
 623:Source/queue.c **** 			}
 624:Source/queue.c **** 
 625:Source/queue.c **** 			xReturn = pdPASS;
 434              		.loc 1 625 0
 435 0038 0123     		movs	r3, #1
 436 003a FB60     		str	r3, [r7, #12]
 437 003c 01E0     		b	.L21
 438              	.L19:
 626:Source/queue.c **** 		}
 627:Source/queue.c **** 		else
 628:Source/queue.c **** 		{
 629:Source/queue.c **** 			/* The mutex cannot be given because the calling task is not the
 630:Source/queue.c **** 			holder. */
 631:Source/queue.c **** 			xReturn = pdFAIL;
 439              		.loc 1 631 0
 440 003e 0023     		movs	r3, #0
 441 0040 FB60     		str	r3, [r7, #12]
 442              	.L21:
 632:Source/queue.c **** 
 633:Source/queue.c **** 			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
 634:Source/queue.c **** 		}
 635:Source/queue.c **** 
 636:Source/queue.c **** 		return xReturn;
 443              		.loc 1 636 0
 444 0042 FB68     		ldr	r3, [r7, #12]
 637:Source/queue.c **** 	}
 445              		.loc 1 637 0
 446 0044 1846     		mov	r0, r3
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 20


 447 0046 1437     		adds	r7, r7, #20
 448              		.cfi_def_cfa_offset 12
 449 0048 BD46     		mov	sp, r7
 450              		.cfi_def_cfa_register 13
 451              		@ sp needed
 452 004a 90BD     		pop	{r4, r7, pc}
 453              		.cfi_endproc
 454              	.LFE73:
 455              		.size	xQueueGiveMutexRecursive, .-xQueueGiveMutexRecursive
 456              		.section	.text.xQueueTakeMutexRecursive,"ax",%progbits
 457              		.align	2
 458              		.global	xQueueTakeMutexRecursive
 459              		.thumb
 460              		.thumb_func
 461              		.type	xQueueTakeMutexRecursive, %function
 462              	xQueueTakeMutexRecursive:
 463              	.LFB74:
 638:Source/queue.c **** 
 639:Source/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 640:Source/queue.c **** /*-----------------------------------------------------------*/
 641:Source/queue.c **** 
 642:Source/queue.c **** #if ( configUSE_RECURSIVE_MUTEXES == 1 )
 643:Source/queue.c **** 
 644:Source/queue.c **** 	BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )
 645:Source/queue.c **** 	{
 464              		.loc 1 645 0
 465              		.cfi_startproc
 466              		@ args = 0, pretend = 0, frame = 16
 467              		@ frame_needed = 1, uses_anonymous_args = 0
 468 0000 90B5     		push	{r4, r7, lr}
 469              		.cfi_def_cfa_offset 12
 470              		.cfi_offset 4, -12
 471              		.cfi_offset 7, -8
 472              		.cfi_offset 14, -4
 473 0002 85B0     		sub	sp, sp, #20
 474              		.cfi_def_cfa_offset 32
 475 0004 00AF     		add	r7, sp, #0
 476              		.cfi_def_cfa_register 7
 477 0006 7860     		str	r0, [r7, #4]
 478 0008 3960     		str	r1, [r7]
 646:Source/queue.c **** 	BaseType_t xReturn;
 647:Source/queue.c **** 	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 479              		.loc 1 647 0
 480 000a 7B68     		ldr	r3, [r7, #4]
 481 000c BB60     		str	r3, [r7, #8]
 648:Source/queue.c **** 
 649:Source/queue.c **** 		configASSERT( pxMutex );
 650:Source/queue.c **** 
 651:Source/queue.c **** 		/* Comments regarding mutual exclusion as per those within
 652:Source/queue.c **** 		xQueueGiveMutexRecursive(). */
 653:Source/queue.c **** 
 654:Source/queue.c **** 		traceTAKE_MUTEX_RECURSIVE( pxMutex );
 655:Source/queue.c **** 
 656:Source/queue.c **** 		if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
 482              		.loc 1 656 0
 483 000e BB68     		ldr	r3, [r7, #8]
 484 0010 9C68     		ldr	r4, [r3, #8]
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 21


 485 0012 FFF7FEFF 		bl	xTaskGetCurrentTaskHandle
 486 0016 0346     		mov	r3, r0
 487 0018 9C42     		cmp	r4, r3
 488 001a 07D1     		bne	.L24
 657:Source/queue.c **** 		{
 658:Source/queue.c **** 			( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
 489              		.loc 1 658 0
 490 001c BB68     		ldr	r3, [r7, #8]
 491 001e DB68     		ldr	r3, [r3, #12]
 492 0020 5A1C     		adds	r2, r3, #1
 493 0022 BB68     		ldr	r3, [r7, #8]
 494 0024 DA60     		str	r2, [r3, #12]
 659:Source/queue.c **** 			xReturn = pdPASS;
 495              		.loc 1 659 0
 496 0026 0123     		movs	r3, #1
 497 0028 FB60     		str	r3, [r7, #12]
 498 002a 0CE0     		b	.L25
 499              	.L24:
 660:Source/queue.c **** 		}
 661:Source/queue.c **** 		else
 662:Source/queue.c **** 		{
 663:Source/queue.c **** 			xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
 500              		.loc 1 663 0
 501 002c 3968     		ldr	r1, [r7]
 502 002e B868     		ldr	r0, [r7, #8]
 503 0030 FFF7FEFF 		bl	xQueueSemaphoreTake
 504 0034 F860     		str	r0, [r7, #12]
 664:Source/queue.c **** 
 665:Source/queue.c **** 			/* pdPASS will only be returned if the mutex was successfully
 666:Source/queue.c **** 			obtained.  The calling task may have entered the Blocked state
 667:Source/queue.c **** 			before reaching here. */
 668:Source/queue.c **** 			if( xReturn != pdFAIL )
 505              		.loc 1 668 0
 506 0036 FB68     		ldr	r3, [r7, #12]
 507 0038 002B     		cmp	r3, #0
 508 003a 04D0     		beq	.L25
 669:Source/queue.c **** 			{
 670:Source/queue.c **** 				( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
 509              		.loc 1 670 0
 510 003c BB68     		ldr	r3, [r7, #8]
 511 003e DB68     		ldr	r3, [r3, #12]
 512 0040 5A1C     		adds	r2, r3, #1
 513 0042 BB68     		ldr	r3, [r7, #8]
 514 0044 DA60     		str	r2, [r3, #12]
 515              	.L25:
 671:Source/queue.c **** 			}
 672:Source/queue.c **** 			else
 673:Source/queue.c **** 			{
 674:Source/queue.c **** 				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
 675:Source/queue.c **** 			}
 676:Source/queue.c **** 		}
 677:Source/queue.c **** 
 678:Source/queue.c **** 		return xReturn;
 516              		.loc 1 678 0
 517 0046 FB68     		ldr	r3, [r7, #12]
 679:Source/queue.c **** 	}
 518              		.loc 1 679 0
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 22


 519 0048 1846     		mov	r0, r3
 520 004a 1437     		adds	r7, r7, #20
 521              		.cfi_def_cfa_offset 12
 522 004c BD46     		mov	sp, r7
 523              		.cfi_def_cfa_register 13
 524              		@ sp needed
 525 004e 90BD     		pop	{r4, r7, pc}
 526              		.cfi_endproc
 527              	.LFE74:
 528              		.size	xQueueTakeMutexRecursive, .-xQueueTakeMutexRecursive
 529              		.section	.text.xQueueCreateCountingSemaphore,"ax",%progbits
 530              		.align	2
 531              		.global	xQueueCreateCountingSemaphore
 532              		.thumb
 533              		.thumb_func
 534              		.type	xQueueCreateCountingSemaphore, %function
 535              	xQueueCreateCountingSemaphore:
 536              	.LFB75:
 680:Source/queue.c **** 
 681:Source/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 682:Source/queue.c **** /*-----------------------------------------------------------*/
 683:Source/queue.c **** 
 684:Source/queue.c **** #if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
 685:Source/queue.c **** 
 686:Source/queue.c **** 	QueueHandle_t xQueueCreateCountingSemaphoreStatic( const UBaseType_t uxMaxCount, const UBaseType_t
 687:Source/queue.c **** 	{
 688:Source/queue.c **** 	QueueHandle_t xHandle;
 689:Source/queue.c **** 
 690:Source/queue.c **** 		configASSERT( uxMaxCount != 0 );
 691:Source/queue.c **** 		configASSERT( uxInitialCount <= uxMaxCount );
 692:Source/queue.c **** 
 693:Source/queue.c **** 		xHandle = xQueueGenericCreateStatic( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, NULL, pxStatic
 694:Source/queue.c **** 
 695:Source/queue.c **** 		if( xHandle != NULL )
 696:Source/queue.c **** 		{
 697:Source/queue.c **** 			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 698:Source/queue.c **** 
 699:Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE();
 700:Source/queue.c **** 		}
 701:Source/queue.c **** 		else
 702:Source/queue.c **** 		{
 703:Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE_FAILED();
 704:Source/queue.c **** 		}
 705:Source/queue.c **** 
 706:Source/queue.c **** 		return xHandle;
 707:Source/queue.c **** 	}
 708:Source/queue.c **** 
 709:Source/queue.c **** #endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) *
 710:Source/queue.c **** /*-----------------------------------------------------------*/
 711:Source/queue.c **** 
 712:Source/queue.c **** #if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 713:Source/queue.c **** 
 714:Source/queue.c **** 	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxIni
 715:Source/queue.c **** 	{
 537              		.loc 1 715 0
 538              		.cfi_startproc
 539              		@ args = 0, pretend = 0, frame = 16
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 23


 540              		@ frame_needed = 1, uses_anonymous_args = 0
 541 0000 80B5     		push	{r7, lr}
 542              		.cfi_def_cfa_offset 8
 543              		.cfi_offset 7, -8
 544              		.cfi_offset 14, -4
 545 0002 84B0     		sub	sp, sp, #16
 546              		.cfi_def_cfa_offset 24
 547 0004 00AF     		add	r7, sp, #0
 548              		.cfi_def_cfa_register 7
 549 0006 7860     		str	r0, [r7, #4]
 550 0008 3960     		str	r1, [r7]
 716:Source/queue.c **** 	QueueHandle_t xHandle;
 717:Source/queue.c **** 
 718:Source/queue.c **** 		configASSERT( uxMaxCount != 0 );
 719:Source/queue.c **** 		configASSERT( uxInitialCount <= uxMaxCount );
 720:Source/queue.c **** 
 721:Source/queue.c **** 		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUN
 551              		.loc 1 721 0
 552 000a 0222     		movs	r2, #2
 553 000c 0021     		movs	r1, #0
 554 000e 7868     		ldr	r0, [r7, #4]
 555 0010 FFF7FEFF 		bl	xQueueGenericCreate
 556 0014 F860     		str	r0, [r7, #12]
 722:Source/queue.c **** 
 723:Source/queue.c **** 		if( xHandle != NULL )
 557              		.loc 1 723 0
 558 0016 FB68     		ldr	r3, [r7, #12]
 559 0018 002B     		cmp	r3, #0
 560 001a 02D0     		beq	.L28
 724:Source/queue.c **** 		{
 725:Source/queue.c **** 			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 561              		.loc 1 725 0
 562 001c FB68     		ldr	r3, [r7, #12]
 563 001e 3A68     		ldr	r2, [r7]
 564 0020 9A63     		str	r2, [r3, #56]
 565              	.L28:
 726:Source/queue.c **** 
 727:Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE();
 728:Source/queue.c **** 		}
 729:Source/queue.c **** 		else
 730:Source/queue.c **** 		{
 731:Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE_FAILED();
 732:Source/queue.c **** 		}
 733:Source/queue.c **** 
 734:Source/queue.c **** 		return xHandle;
 566              		.loc 1 734 0
 567 0022 FB68     		ldr	r3, [r7, #12]
 735:Source/queue.c **** 	}
 568              		.loc 1 735 0
 569 0024 1846     		mov	r0, r3
 570 0026 1037     		adds	r7, r7, #16
 571              		.cfi_def_cfa_offset 8
 572 0028 BD46     		mov	sp, r7
 573              		.cfi_def_cfa_register 13
 574              		@ sp needed
 575 002a 80BD     		pop	{r7, pc}
 576              		.cfi_endproc
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 24


 577              	.LFE75:
 578              		.size	xQueueCreateCountingSemaphore, .-xQueueCreateCountingSemaphore
 579              		.section	.text.xQueueGenericSend,"ax",%progbits
 580              		.align	2
 581              		.global	xQueueGenericSend
 582              		.thumb
 583              		.thumb_func
 584              		.type	xQueueGenericSend, %function
 585              	xQueueGenericSend:
 586              	.LFB76:
 736:Source/queue.c **** 
 737:Source/queue.c **** #endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) *
 738:Source/queue.c **** /*-----------------------------------------------------------*/
 739:Source/queue.c **** 
 740:Source/queue.c **** BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xT
 741:Source/queue.c **** {
 587              		.loc 1 741 0
 588              		.cfi_startproc
 589              		@ args = 0, pretend = 0, frame = 40
 590              		@ frame_needed = 1, uses_anonymous_args = 0
 591 0000 80B5     		push	{r7, lr}
 592              		.cfi_def_cfa_offset 8
 593              		.cfi_offset 7, -8
 594              		.cfi_offset 14, -4
 595 0002 8AB0     		sub	sp, sp, #40
 596              		.cfi_def_cfa_offset 48
 597 0004 00AF     		add	r7, sp, #0
 598              		.cfi_def_cfa_register 7
 599 0006 F860     		str	r0, [r7, #12]
 600 0008 B960     		str	r1, [r7, #8]
 601 000a 7A60     		str	r2, [r7, #4]
 602 000c 3B60     		str	r3, [r7]
 742:Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 603              		.loc 1 742 0
 604 000e 0023     		movs	r3, #0
 605 0010 7B62     		str	r3, [r7, #36]
 743:Source/queue.c **** TimeOut_t xTimeOut;
 744:Source/queue.c **** Queue_t * const pxQueue = xQueue;
 606              		.loc 1 744 0
 607 0012 FB68     		ldr	r3, [r7, #12]
 608 0014 3B62     		str	r3, [r7, #32]
 609              	.L45:
 745:Source/queue.c **** 
 746:Source/queue.c **** 	configASSERT( pxQueue );
 747:Source/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 748:Source/queue.c **** 	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 749:Source/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
 750:Source/queue.c **** 	{
 751:Source/queue.c **** 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 )
 752:Source/queue.c **** 	}
 753:Source/queue.c **** 	#endif
 754:Source/queue.c **** 
 755:Source/queue.c **** 
 756:Source/queue.c **** 	/*lint -save -e904 This function relaxes the coding standard somewhat to
 757:Source/queue.c **** 	allow return statements within the function itself.  This is done in the
 758:Source/queue.c **** 	interest of execution time efficiency. */
 759:Source/queue.c **** 	for( ;; )
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 25


 760:Source/queue.c **** 	{
 761:Source/queue.c **** 		taskENTER_CRITICAL();
 610              		.loc 1 761 0
 611 0016 FFF7FEFF 		bl	vPortEnterCritical
 762:Source/queue.c **** 		{
 763:Source/queue.c **** 			/* Is there room on the queue now?  The running task must be the
 764:Source/queue.c **** 			highest priority task wanting to access the queue.  If the head item
 765:Source/queue.c **** 			in the queue is to be overwritten then it does not matter if the
 766:Source/queue.c **** 			queue is full. */
 767:Source/queue.c **** 			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 612              		.loc 1 767 0
 613 001a 3B6A     		ldr	r3, [r7, #32]
 614 001c 9A6B     		ldr	r2, [r3, #56]
 615 001e 3B6A     		ldr	r3, [r7, #32]
 616 0020 DB6B     		ldr	r3, [r3, #60]
 617 0022 9A42     		cmp	r2, r3
 618 0024 02D3     		bcc	.L31
 619              		.loc 1 767 0 is_stmt 0 discriminator 1
 620 0026 3B68     		ldr	r3, [r7]
 621 0028 022B     		cmp	r3, #2
 622 002a 29D1     		bne	.L32
 623              	.L31:
 768:Source/queue.c **** 			{
 769:Source/queue.c **** 				traceQUEUE_SEND( pxQueue );
 770:Source/queue.c **** 
 771:Source/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
 772:Source/queue.c **** 				{
 773:Source/queue.c **** 				const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
 774:Source/queue.c **** 
 775:Source/queue.c **** 					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 776:Source/queue.c **** 
 777:Source/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
 778:Source/queue.c **** 					{
 779:Source/queue.c **** 						if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting != ( UBaseType_t ) 0 )
 780:Source/queue.c **** 						{
 781:Source/queue.c **** 							/* Do not notify the queue set as an existing item
 782:Source/queue.c **** 							was overwritten in the queue so the number of items
 783:Source/queue.c **** 							in the queue has not changed. */
 784:Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 785:Source/queue.c **** 						}
 786:Source/queue.c **** 						else if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
 787:Source/queue.c **** 						{
 788:Source/queue.c **** 							/* The queue is a member of a queue set, and posting
 789:Source/queue.c **** 							to the queue set caused a higher priority task to
 790:Source/queue.c **** 							unblock. A context switch is required. */
 791:Source/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 792:Source/queue.c **** 						}
 793:Source/queue.c **** 						else
 794:Source/queue.c **** 						{
 795:Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 796:Source/queue.c **** 						}
 797:Source/queue.c **** 					}
 798:Source/queue.c **** 					else
 799:Source/queue.c **** 					{
 800:Source/queue.c **** 						/* If there was a task waiting for data to arrive on the
 801:Source/queue.c **** 						queue then unblock it now. */
 802:Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 26


 803:Source/queue.c **** 						{
 804:Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 805:Source/queue.c **** 							{
 806:Source/queue.c **** 								/* The unblocked task has a priority higher than
 807:Source/queue.c **** 								our own so yield immediately.  Yes it is ok to
 808:Source/queue.c **** 								do this from within the critical section - the
 809:Source/queue.c **** 								kernel takes care of that. */
 810:Source/queue.c **** 								queueYIELD_IF_USING_PREEMPTION();
 811:Source/queue.c **** 							}
 812:Source/queue.c **** 							else
 813:Source/queue.c **** 							{
 814:Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
 815:Source/queue.c **** 							}
 816:Source/queue.c **** 						}
 817:Source/queue.c **** 						else if( xYieldRequired != pdFALSE )
 818:Source/queue.c **** 						{
 819:Source/queue.c **** 							/* This path is a special case that will only get
 820:Source/queue.c **** 							executed if the task was holding multiple mutexes
 821:Source/queue.c **** 							and the mutexes were given back in an order that is
 822:Source/queue.c **** 							different to that in which they were taken. */
 823:Source/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 824:Source/queue.c **** 						}
 825:Source/queue.c **** 						else
 826:Source/queue.c **** 						{
 827:Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 828:Source/queue.c **** 						}
 829:Source/queue.c **** 					}
 830:Source/queue.c **** 				}
 831:Source/queue.c **** 				#else /* configUSE_QUEUE_SETS */
 832:Source/queue.c **** 				{
 833:Source/queue.c **** 					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 624              		.loc 1 833 0 is_stmt 1
 625 002c 3A68     		ldr	r2, [r7]
 626 002e B968     		ldr	r1, [r7, #8]
 627 0030 386A     		ldr	r0, [r7, #32]
 628 0032 FFF7FEFF 		bl	prvCopyDataToQueue
 629 0036 F861     		str	r0, [r7, #28]
 834:Source/queue.c **** 
 835:Source/queue.c **** 					/* If there was a task waiting for data to arrive on the
 836:Source/queue.c **** 					queue then unblock it now. */
 837:Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 630              		.loc 1 837 0
 631 0038 3B6A     		ldr	r3, [r7, #32]
 632 003a 5B6A     		ldr	r3, [r3, #36]
 633 003c 002B     		cmp	r3, #0
 634 003e 10D0     		beq	.L33
 838:Source/queue.c **** 					{
 839:Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 635              		.loc 1 839 0
 636 0040 3B6A     		ldr	r3, [r7, #32]
 637 0042 2433     		adds	r3, r3, #36
 638 0044 1846     		mov	r0, r3
 639 0046 FFF7FEFF 		bl	xTaskRemoveFromEventList
 640 004a 0346     		mov	r3, r0
 641 004c 002B     		cmp	r3, #0
 642 004e 13D0     		beq	.L34
 840:Source/queue.c **** 						{
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 27


 841:Source/queue.c **** 							/* The unblocked task has a priority higher than
 842:Source/queue.c **** 							our own so yield immediately.  Yes it is ok to do
 843:Source/queue.c **** 							this from within the critical section - the kernel
 844:Source/queue.c **** 							takes care of that. */
 845:Source/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 643              		.loc 1 845 0
 644 0050 3F4B     		ldr	r3, .L47
 645 0052 4FF08052 		mov	r2, #268435456
 646 0056 1A60     		str	r2, [r3]
 647              		.syntax unified
 648              	@ 845 "Source\queue.c" 1
 649 0058 BFF34F8F 		dsb
 650              	@ 0 "" 2
 651              	@ 845 "Source\queue.c" 1
 652 005c BFF36F8F 		isb
 653              	@ 0 "" 2
 654              		.thumb
 655              		.syntax unified
 656 0060 0AE0     		b	.L34
 657              	.L33:
 846:Source/queue.c **** 						}
 847:Source/queue.c **** 						else
 848:Source/queue.c **** 						{
 849:Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 850:Source/queue.c **** 						}
 851:Source/queue.c **** 					}
 852:Source/queue.c **** 					else if( xYieldRequired != pdFALSE )
 658              		.loc 1 852 0
 659 0062 FB69     		ldr	r3, [r7, #28]
 660 0064 002B     		cmp	r3, #0
 661 0066 07D0     		beq	.L34
 853:Source/queue.c **** 					{
 854:Source/queue.c **** 						/* This path is a special case that will only get
 855:Source/queue.c **** 						executed if the task was holding multiple mutexes and
 856:Source/queue.c **** 						the mutexes were given back in an order that is
 857:Source/queue.c **** 						different to that in which they were taken. */
 858:Source/queue.c **** 						queueYIELD_IF_USING_PREEMPTION();
 662              		.loc 1 858 0
 663 0068 394B     		ldr	r3, .L47
 664 006a 4FF08052 		mov	r2, #268435456
 665 006e 1A60     		str	r2, [r3]
 666              		.syntax unified
 667              	@ 858 "Source\queue.c" 1
 668 0070 BFF34F8F 		dsb
 669              	@ 0 "" 2
 670              	@ 858 "Source\queue.c" 1
 671 0074 BFF36F8F 		isb
 672              	@ 0 "" 2
 673              		.thumb
 674              		.syntax unified
 675              	.L34:
 859:Source/queue.c **** 					}
 860:Source/queue.c **** 					else
 861:Source/queue.c **** 					{
 862:Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
 863:Source/queue.c **** 					}
 864:Source/queue.c **** 				}
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 28


 865:Source/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
 866:Source/queue.c **** 
 867:Source/queue.c **** 				taskEXIT_CRITICAL();
 676              		.loc 1 867 0
 677 0078 FFF7FEFF 		bl	vPortExitCritical
 868:Source/queue.c **** 				return pdPASS;
 678              		.loc 1 868 0
 679 007c 0123     		movs	r3, #1
 680 007e 63E0     		b	.L46
 681              	.L32:
 869:Source/queue.c **** 			}
 870:Source/queue.c **** 			else
 871:Source/queue.c **** 			{
 872:Source/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
 682              		.loc 1 872 0
 683 0080 7B68     		ldr	r3, [r7, #4]
 684 0082 002B     		cmp	r3, #0
 685 0084 03D1     		bne	.L36
 873:Source/queue.c **** 				{
 874:Source/queue.c **** 					/* The queue was full and no block time is specified (or
 875:Source/queue.c **** 					the block time has expired) so leave now. */
 876:Source/queue.c **** 					taskEXIT_CRITICAL();
 686              		.loc 1 876 0
 687 0086 FFF7FEFF 		bl	vPortExitCritical
 877:Source/queue.c **** 
 878:Source/queue.c **** 					/* Return to the original privilege level before exiting
 879:Source/queue.c **** 					the function. */
 880:Source/queue.c **** 					traceQUEUE_SEND_FAILED( pxQueue );
 881:Source/queue.c **** 					return errQUEUE_FULL;
 688              		.loc 1 881 0
 689 008a 0023     		movs	r3, #0
 690 008c 5CE0     		b	.L46
 691              	.L36:
 882:Source/queue.c **** 				}
 883:Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 692              		.loc 1 883 0
 693 008e 7B6A     		ldr	r3, [r7, #36]
 694 0090 002B     		cmp	r3, #0
 695 0092 06D1     		bne	.L37
 884:Source/queue.c **** 				{
 885:Source/queue.c **** 					/* The queue was full and a block time was specified so
 886:Source/queue.c **** 					configure the timeout structure. */
 887:Source/queue.c **** 					vTaskInternalSetTimeOutState( &xTimeOut );
 696              		.loc 1 887 0
 697 0094 07F11403 		add	r3, r7, #20
 698 0098 1846     		mov	r0, r3
 699 009a FFF7FEFF 		bl	vTaskInternalSetTimeOutState
 888:Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 700              		.loc 1 888 0
 701 009e 0123     		movs	r3, #1
 702 00a0 7B62     		str	r3, [r7, #36]
 703              	.L37:
 889:Source/queue.c **** 				}
 890:Source/queue.c **** 				else
 891:Source/queue.c **** 				{
 892:Source/queue.c **** 					/* Entry time was already set. */
 893:Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 29


 894:Source/queue.c **** 				}
 895:Source/queue.c **** 			}
 896:Source/queue.c **** 		}
 897:Source/queue.c **** 		taskEXIT_CRITICAL();
 704              		.loc 1 897 0
 705 00a2 FFF7FEFF 		bl	vPortExitCritical
 898:Source/queue.c **** 
 899:Source/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
 900:Source/queue.c **** 		now the critical section has been exited. */
 901:Source/queue.c **** 
 902:Source/queue.c **** 		vTaskSuspendAll();
 706              		.loc 1 902 0
 707 00a6 FFF7FEFF 		bl	vTaskSuspendAll
 903:Source/queue.c **** 		prvLockQueue( pxQueue );
 708              		.loc 1 903 0
 709 00aa FFF7FEFF 		bl	vPortEnterCritical
 710 00ae 3B6A     		ldr	r3, [r7, #32]
 711 00b0 93F84430 		ldrb	r3, [r3, #68]
 712 00b4 5BB2     		sxtb	r3, r3
 713 00b6 B3F1FF3F 		cmp	r3, #-1
 714 00ba 03D1     		bne	.L38
 715              		.loc 1 903 0 is_stmt 0 discriminator 1
 716 00bc 3B6A     		ldr	r3, [r7, #32]
 717 00be 0022     		movs	r2, #0
 718 00c0 83F84420 		strb	r2, [r3, #68]
 719              	.L38:
 720              		.loc 1 903 0 discriminator 3
 721 00c4 3B6A     		ldr	r3, [r7, #32]
 722 00c6 93F84530 		ldrb	r3, [r3, #69]
 723 00ca 5BB2     		sxtb	r3, r3
 724 00cc B3F1FF3F 		cmp	r3, #-1
 725 00d0 03D1     		bne	.L39
 726              		.loc 1 903 0 discriminator 4
 727 00d2 3B6A     		ldr	r3, [r7, #32]
 728 00d4 0022     		movs	r2, #0
 729 00d6 83F84520 		strb	r2, [r3, #69]
 730              	.L39:
 731              		.loc 1 903 0 discriminator 6
 732 00da FFF7FEFF 		bl	vPortExitCritical
 904:Source/queue.c **** 
 905:Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
 906:Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 733              		.loc 1 906 0 is_stmt 1 discriminator 6
 734 00de 3A1D     		adds	r2, r7, #4
 735 00e0 07F11403 		add	r3, r7, #20
 736 00e4 1146     		mov	r1, r2
 737 00e6 1846     		mov	r0, r3
 738 00e8 FFF7FEFF 		bl	xTaskCheckForTimeOut
 739 00ec 0346     		mov	r3, r0
 740 00ee 002B     		cmp	r3, #0
 741 00f0 24D1     		bne	.L40
 907:Source/queue.c **** 		{
 908:Source/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 742              		.loc 1 908 0
 743 00f2 386A     		ldr	r0, [r7, #32]
 744 00f4 FFF7FEFF 		bl	prvIsQueueFull
 745 00f8 0346     		mov	r3, r0
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 30


 746 00fa 002B     		cmp	r3, #0
 747 00fc 18D0     		beq	.L41
 909:Source/queue.c **** 			{
 910:Source/queue.c **** 				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
 911:Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 748              		.loc 1 911 0
 749 00fe 3B6A     		ldr	r3, [r7, #32]
 750 0100 1033     		adds	r3, r3, #16
 751 0102 7A68     		ldr	r2, [r7, #4]
 752 0104 1146     		mov	r1, r2
 753 0106 1846     		mov	r0, r3
 754 0108 FFF7FEFF 		bl	vTaskPlaceOnEventList
 912:Source/queue.c **** 
 913:Source/queue.c **** 				/* Unlocking the queue means queue events can effect the
 914:Source/queue.c **** 				event list.  It is possible that interrupts occurring now
 915:Source/queue.c **** 				remove this task from the event list again - but as the
 916:Source/queue.c **** 				scheduler is suspended the task will go onto the pending
 917:Source/queue.c **** 				ready last instead of the actual ready list. */
 918:Source/queue.c **** 				prvUnlockQueue( pxQueue );
 755              		.loc 1 918 0
 756 010c 386A     		ldr	r0, [r7, #32]
 757 010e FFF7FEFF 		bl	prvUnlockQueue
 919:Source/queue.c **** 
 920:Source/queue.c **** 				/* Resuming the scheduler will move tasks from the pending
 921:Source/queue.c **** 				ready list into the ready list - so it is feasible that this
 922:Source/queue.c **** 				task is already in a ready list before it yields - in which
 923:Source/queue.c **** 				case the yield will not cause a context switch unless there
 924:Source/queue.c **** 				is also a higher priority task in the pending ready list. */
 925:Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 758              		.loc 1 925 0
 759 0112 FFF7FEFF 		bl	xTaskResumeAll
 760 0116 0346     		mov	r3, r0
 761 0118 002B     		cmp	r3, #0
 762 011a 7FF47CAF 		bne	.L45
 926:Source/queue.c **** 				{
 927:Source/queue.c **** 					portYIELD_WITHIN_API();
 763              		.loc 1 927 0
 764 011e 0C4B     		ldr	r3, .L47
 765 0120 4FF08052 		mov	r2, #268435456
 766 0124 1A60     		str	r2, [r3]
 767              		.syntax unified
 768              	@ 927 "Source\queue.c" 1
 769 0126 BFF34F8F 		dsb
 770              	@ 0 "" 2
 771              	@ 927 "Source\queue.c" 1
 772 012a BFF36F8F 		isb
 773              	@ 0 "" 2
 774              		.thumb
 775              		.syntax unified
 776 012e 72E7     		b	.L45
 777              	.L41:
 928:Source/queue.c **** 				}
 929:Source/queue.c **** 			}
 930:Source/queue.c **** 			else
 931:Source/queue.c **** 			{
 932:Source/queue.c **** 				/* Try again. */
 933:Source/queue.c **** 				prvUnlockQueue( pxQueue );
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 31


 778              		.loc 1 933 0
 779 0130 386A     		ldr	r0, [r7, #32]
 780 0132 FFF7FEFF 		bl	prvUnlockQueue
 934:Source/queue.c **** 				( void ) xTaskResumeAll();
 781              		.loc 1 934 0
 782 0136 FFF7FEFF 		bl	xTaskResumeAll
 783 013a 6CE7     		b	.L45
 784              	.L40:
 935:Source/queue.c **** 			}
 936:Source/queue.c **** 		}
 937:Source/queue.c **** 		else
 938:Source/queue.c **** 		{
 939:Source/queue.c **** 			/* The timeout has expired. */
 940:Source/queue.c **** 			prvUnlockQueue( pxQueue );
 785              		.loc 1 940 0
 786 013c 386A     		ldr	r0, [r7, #32]
 787 013e FFF7FEFF 		bl	prvUnlockQueue
 941:Source/queue.c **** 			( void ) xTaskResumeAll();
 788              		.loc 1 941 0
 789 0142 FFF7FEFF 		bl	xTaskResumeAll
 942:Source/queue.c **** 
 943:Source/queue.c **** 			traceQUEUE_SEND_FAILED( pxQueue );
 944:Source/queue.c **** 			return errQUEUE_FULL;
 790              		.loc 1 944 0
 791 0146 0023     		movs	r3, #0
 792              	.L46:
 945:Source/queue.c **** 		}
 946:Source/queue.c **** 	} /*lint -restore */
 947:Source/queue.c **** }
 793              		.loc 1 947 0 discriminator 3
 794 0148 1846     		mov	r0, r3
 795 014a 2837     		adds	r7, r7, #40
 796              		.cfi_def_cfa_offset 8
 797 014c BD46     		mov	sp, r7
 798              		.cfi_def_cfa_register 13
 799              		@ sp needed
 800 014e 80BD     		pop	{r7, pc}
 801              	.L48:
 802              		.align	2
 803              	.L47:
 804 0150 04ED00E0 		.word	-536810236
 805              		.cfi_endproc
 806              	.LFE76:
 807              		.size	xQueueGenericSend, .-xQueueGenericSend
 808              		.section	.text.xQueueGenericSendFromISR,"ax",%progbits
 809              		.align	2
 810              		.global	xQueueGenericSendFromISR
 811              		.thumb
 812              		.thumb_func
 813              		.type	xQueueGenericSendFromISR, %function
 814              	xQueueGenericSendFromISR:
 815              	.LFB77:
 948:Source/queue.c **** /*-----------------------------------------------------------*/
 949:Source/queue.c **** 
 950:Source/queue.c **** BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseTy
 951:Source/queue.c **** {
 816              		.loc 1 951 0
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 32


 817              		.cfi_startproc
 818              		@ args = 0, pretend = 0, frame = 48
 819              		@ frame_needed = 1, uses_anonymous_args = 0
 820 0000 80B5     		push	{r7, lr}
 821              		.cfi_def_cfa_offset 8
 822              		.cfi_offset 7, -8
 823              		.cfi_offset 14, -4
 824 0002 8CB0     		sub	sp, sp, #48
 825              		.cfi_def_cfa_offset 56
 826 0004 00AF     		add	r7, sp, #0
 827              		.cfi_def_cfa_register 7
 828 0006 F860     		str	r0, [r7, #12]
 829 0008 B960     		str	r1, [r7, #8]
 830 000a 7A60     		str	r2, [r7, #4]
 831 000c 3B60     		str	r3, [r7]
 952:Source/queue.c **** BaseType_t xReturn;
 953:Source/queue.c **** UBaseType_t uxSavedInterruptStatus;
 954:Source/queue.c **** Queue_t * const pxQueue = xQueue;
 832              		.loc 1 954 0
 833 000e FB68     		ldr	r3, [r7, #12]
 834 0010 BB62     		str	r3, [r7, #40]
 835              	.LBB23:
 836              	.LBB24:
 837              		.file 2 ".\\Source\\portable\\GCC\\ARM_CM3/portmacro.h"
   1:.\Source\portable\GCC\ARM_CM3/portmacro.h **** /*
   2:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * FreeRTOS Kernel V10.3.1
   3:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  *
   5:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   6:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * this software and associated documentation files (the "Software"), to deal in
   7:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * the Software without restriction, including without limitation the rights to
   8:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   9:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  10:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * subject to the following conditions:
  11:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  *
  12:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * The above copyright notice and this permission notice shall be included in all
  13:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * copies or substantial portions of the Software.
  14:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  *
  15:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  17:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  18:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  19:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  20:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  21:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  *
  22:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * http://www.FreeRTOS.org
  23:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * http://aws.amazon.com/freertos
  24:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  *
  25:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * 1 tab == 4 spaces!
  26:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  */
  27:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  28:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  29:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #ifndef PORTMACRO_H
  30:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define PORTMACRO_H
  31:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  32:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #ifdef __cplusplus
  33:.\Source\portable\GCC\ARM_CM3/portmacro.h **** extern "C" {
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 33


  34:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #endif
  35:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  36:.\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------
  37:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * Port specific definitions.
  38:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  *
  39:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * The settings in this file configure FreeRTOS correctly for the
  40:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * given hardware and compiler.
  41:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  *
  42:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * These settings should not be altered.
  43:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  *-----------------------------------------------------------
  44:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  */
  45:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  46:.\Source\portable\GCC\ARM_CM3/portmacro.h **** /* Type definitions. */
  47:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portCHAR		char
  48:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portFLOAT		float
  49:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portDOUBLE		double
  50:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portLONG		long
  51:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portSHORT		short
  52:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portSTACK_TYPE	uint32_t
  53:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portBASE_TYPE	long
  54:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  55:.\Source\portable\GCC\ARM_CM3/portmacro.h **** typedef portSTACK_TYPE StackType_t;
  56:.\Source\portable\GCC\ARM_CM3/portmacro.h **** typedef long BaseType_t;
  57:.\Source\portable\GCC\ARM_CM3/portmacro.h **** typedef unsigned long UBaseType_t;
  58:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  59:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #if( configUSE_16_BIT_TICKS == 1 )
  60:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	typedef uint16_t TickType_t;
  61:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#define portMAX_DELAY ( TickType_t ) 0xffff
  62:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #else
  63:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	typedef uint32_t TickType_t;
  64:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#define portMAX_DELAY ( TickType_t ) 0xffffffffUL
  65:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  66:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	/* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
  67:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	not need to be guarded with a critical section. */
  68:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#define portTICK_TYPE_IS_ATOMIC 1
  69:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #endif
  70:.\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
  71:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  72:.\Source\portable\GCC\ARM_CM3/portmacro.h **** /* Architecture specifics. */
  73:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portSTACK_GROWTH			( -1 )
  74:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portTICK_PERIOD_MS			( ( TickType_t ) 1000 / configTICK_RATE_HZ )
  75:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portBYTE_ALIGNMENT			8
  76:.\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
  77:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  78:.\Source\portable\GCC\ARM_CM3/portmacro.h **** /* Scheduler utilities. */
  79:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portYIELD() 															\
  80:.\Source\portable\GCC\ARM_CM3/portmacro.h **** {																				\
  81:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	/* Set a PendSV to request a context switch. */								\
  82:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;								\
  83:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 																				\
  84:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	/* Barriers are normally not required but do ensure the code is completely	\
  85:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	within the specified behaviour for the architecture. */						\
  86:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	__asm volatile( "dsb" ::: "memory" );										\
  87:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	__asm volatile( "isb" );													\
  88:.\Source\portable\GCC\ARM_CM3/portmacro.h **** }
  89:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  90:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portNVIC_INT_CTRL_REG		( * ( ( volatile uint32_t * ) 0xe000ed04 ) )
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 34


  91:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portNVIC_PENDSVSET_BIT		( 1UL << 28UL )
  92:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portEND_SWITCHING_ISR( xSwitchRequired ) if( xSwitchRequired != pdFALSE ) portYIELD()
  93:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portYIELD_FROM_ISR( x ) portEND_SWITCHING_ISR( x )
  94:.\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
  95:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  96:.\Source\portable\GCC\ARM_CM3/portmacro.h **** /* Critical section management. */
  97:.\Source\portable\GCC\ARM_CM3/portmacro.h **** extern void vPortEnterCritical( void );
  98:.\Source\portable\GCC\ARM_CM3/portmacro.h **** extern void vPortExitCritical( void );
  99:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portSET_INTERRUPT_MASK_FROM_ISR()		ulPortRaiseBASEPRI()
 100:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portCLEAR_INTERRUPT_MASK_FROM_ISR(x)	vPortSetBASEPRI(x)
 101:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portDISABLE_INTERRUPTS()				vPortRaiseBASEPRI()
 102:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portENABLE_INTERRUPTS()					vPortSetBASEPRI(0)
 103:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portENTER_CRITICAL()					vPortEnterCritical()
 104:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portEXIT_CRITICAL()						vPortExitCritical()
 105:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 106:.\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 107:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 108:.\Source\portable\GCC\ARM_CM3/portmacro.h **** /* Task function macros as described on the FreeRTOS.org WEB site.  These are
 109:.\Source\portable\GCC\ARM_CM3/portmacro.h **** not necessary for to use this port.  They are defined so the common demo files
 110:.\Source\portable\GCC\ARM_CM3/portmacro.h **** (which build with all the ports) will build. */
 111:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portTASK_FUNCTION_PROTO( vFunction, pvParameters ) void vFunction( void *pvParameters )
 112:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portTASK_FUNCTION( vFunction, pvParameters ) void vFunction( void *pvParameters )
 113:.\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 114:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 115:.\Source\portable\GCC\ARM_CM3/portmacro.h **** /* Tickless idle/low power functionality. */
 116:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #ifndef portSUPPRESS_TICKS_AND_SLEEP
 117:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	extern void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime );
 118:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime ) vPortSuppressTicksAndSleep( xExpectedIdl
 119:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #endif
 120:.\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 121:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 122:.\Source\portable\GCC\ARM_CM3/portmacro.h **** /* Architecture specific optimisations. */
 123:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
 124:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#define configUSE_PORT_OPTIMISED_TASK_SELECTION 1
 125:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #endif
 126:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 127:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #if configUSE_PORT_OPTIMISED_TASK_SELECTION == 1
 128:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 129:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	/* Generic helper function. */
 130:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	__attribute__( ( always_inline ) ) static inline uint8_t ucPortCountLeadingZeros( uint32_t ulBitma
 131:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	{
 132:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	uint8_t ucReturn;
 133:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 134:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
 135:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 		return ucReturn;
 136:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	}
 137:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 138:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	/* Check the configuration. */
 139:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#if( configMAX_PRIORITIES > 32 )
 140:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 		#error configUSE_PORT_OPTIMISED_TASK_SELECTION can only be set to 1 when configMAX_PRIORITIES is 
 141:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#endif
 142:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 143:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	/* Store/clear the ready priorities in a bit map. */
 144:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#define portRECORD_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) |= ( 1UL 
 145:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#define portRESET_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) &= ~( 1UL 
 146:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 147:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	/*-----------------------------------------------------------*/
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 35


 148:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 149:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#define portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities ) uxTopPriority = ( 31UL - ( ui
 150:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 151:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 152:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 153:.\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 154:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 155:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #ifdef configASSERT
 156:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	void vPortValidateInterruptPriority( void );
 157:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#define portASSERT_IF_INTERRUPT_PRIORITY_INVALID() 	vPortValidateInterruptPriority()
 158:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #endif
 159:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 160:.\Source\portable\GCC\ARM_CM3/portmacro.h **** /* portNOP() is not required by this port. */
 161:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portNOP()
 162:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 163:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portINLINE	__inline
 164:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 165:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #ifndef portFORCE_INLINE
 166:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#define portFORCE_INLINE inline __attribute__(( always_inline))
 167:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #endif
 168:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 169:.\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 170:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 171:.\Source\portable\GCC\ARM_CM3/portmacro.h **** portFORCE_INLINE static BaseType_t xPortIsInsideInterrupt( void )
 172:.\Source\portable\GCC\ARM_CM3/portmacro.h **** {
 173:.\Source\portable\GCC\ARM_CM3/portmacro.h **** uint32_t ulCurrentInterrupt;
 174:.\Source\portable\GCC\ARM_CM3/portmacro.h **** BaseType_t xReturn;
 175:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 176:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	/* Obtain the number of the currently executing interrupt. */
 177:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
 178:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 179:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	if( ulCurrentInterrupt == 0 )
 180:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	{
 181:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 		xReturn = pdFALSE;
 182:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	}
 183:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	else
 184:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	{
 185:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 		xReturn = pdTRUE;
 186:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	}
 187:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 188:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	return xReturn;
 189:.\Source\portable\GCC\ARM_CM3/portmacro.h **** }
 190:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 191:.\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 192:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 193:.\Source\portable\GCC\ARM_CM3/portmacro.h **** portFORCE_INLINE static void vPortRaiseBASEPRI( void )
 194:.\Source\portable\GCC\ARM_CM3/portmacro.h **** {
 195:.\Source\portable\GCC\ARM_CM3/portmacro.h **** uint32_t ulNewBASEPRI;
 196:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 197:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	__asm volatile
 198:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	(
 199:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 		"	mov %0, %1												\n" \
 200:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 		"	msr basepri, %0											\n" \
 201:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 		"	isb														\n" \
 202:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 		"	dsb														\n" \
 203:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 		:"=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
 204:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	);
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 36


 205:.\Source\portable\GCC\ARM_CM3/portmacro.h **** }
 206:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 207:.\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 208:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 209:.\Source\portable\GCC\ARM_CM3/portmacro.h **** portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
 210:.\Source\portable\GCC\ARM_CM3/portmacro.h **** {
 211:.\Source\portable\GCC\ARM_CM3/portmacro.h **** uint32_t ulOriginalBASEPRI, ulNewBASEPRI;
 212:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 213:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	__asm volatile
 838              		.loc 2 213 0
 839              		.syntax unified
 840              	@ 213 ".\Source\portable\GCC\ARM_CM3/portmacro.h" 1
 841 0012 EFF31182 			mrs r2, basepri											
 842 0016 4FF0A003 		mov r3, #160												
 843 001a 83F31188 		msr basepri, r3											
 844 001e BFF36F8F 		isb														
 845 0022 BFF34F8F 		dsb														
 846              	
 847              	@ 0 "" 2
 848              		.thumb
 849              		.syntax unified
 850 0026 7A61     		str	r2, [r7, #20]
 851 0028 3B61     		str	r3, [r7, #16]
 214:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	(
 215:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 		"	mrs %0, basepri											\n" \
 216:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 		"	mov %1, %2												\n" \
 217:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 		"	msr basepri, %1											\n" \
 218:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 		"	isb														\n" \
 219:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 		"	dsb														\n" \
 220:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "
 221:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	);
 222:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 223:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	/* This return will not be reached but is necessary to prevent compiler
 224:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	warnings. */
 225:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	return ulOriginalBASEPRI;
 852              		.loc 2 225 0
 853 002a 7B69     		ldr	r3, [r7, #20]
 854              	.LBE24:
 855              	.LBE23:
 955:Source/queue.c **** 
 956:Source/queue.c **** 	configASSERT( pxQueue );
 957:Source/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 958:Source/queue.c **** 	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 959:Source/queue.c **** 
 960:Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
 961:Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
 962:Source/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
 963:Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
 964:Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
 965:Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
 966:Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
 967:Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
 968:Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
 969:Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
 970:Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
 971:Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
 972:Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 37


 973:Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
 974:Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 975:Source/queue.c **** 
 976:Source/queue.c **** 	/* Similar to xQueueGenericSend, except without blocking if there is no room
 977:Source/queue.c **** 	in the queue.  Also don't directly wake a task that was blocked on a queue
 978:Source/queue.c **** 	read, instead return a flag to say whether a context switch is required or
 979:Source/queue.c **** 	not (i.e. has a task with a higher priority than us been woken by this
 980:Source/queue.c **** 	post). */
 981:Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 856              		.loc 1 981 0
 857 002c 3B62     		str	r3, [r7, #32]
 982:Source/queue.c **** 	{
 983:Source/queue.c **** 		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 858              		.loc 1 983 0
 859 002e BB6A     		ldr	r3, [r7, #40]
 860 0030 9A6B     		ldr	r2, [r3, #56]
 861 0032 BB6A     		ldr	r3, [r7, #40]
 862 0034 DB6B     		ldr	r3, [r3, #60]
 863 0036 9A42     		cmp	r2, r3
 864 0038 02D3     		bcc	.L51
 865              		.loc 1 983 0 is_stmt 0 discriminator 1
 866 003a 3B68     		ldr	r3, [r7]
 867 003c 022B     		cmp	r3, #2
 868 003e 2DD1     		bne	.L52
 869              	.L51:
 870              	.LBB25:
 984:Source/queue.c **** 		{
 985:Source/queue.c **** 			const int8_t cTxLock = pxQueue->cTxLock;
 871              		.loc 1 985 0 is_stmt 1
 872 0040 BB6A     		ldr	r3, [r7, #40]
 873 0042 93F84530 		ldrb	r3, [r3, #69]
 874 0046 FB77     		strb	r3, [r7, #31]
 986:Source/queue.c **** 			const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
 875              		.loc 1 986 0
 876 0048 BB6A     		ldr	r3, [r7, #40]
 877 004a 9B6B     		ldr	r3, [r3, #56]
 878 004c BB61     		str	r3, [r7, #24]
 987:Source/queue.c **** 
 988:Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR( pxQueue );
 989:Source/queue.c **** 
 990:Source/queue.c **** 			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
 991:Source/queue.c **** 			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
 992:Source/queue.c **** 			in a task disinheriting a priority and prvCopyDataToQueue() can be
 993:Source/queue.c **** 			called here even though the disinherit function does not check if
 994:Source/queue.c **** 			the scheduler is suspended before accessing the ready lists. */
 995:Source/queue.c **** 			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 879              		.loc 1 995 0
 880 004e 3A68     		ldr	r2, [r7]
 881 0050 B968     		ldr	r1, [r7, #8]
 882 0052 B86A     		ldr	r0, [r7, #40]
 883 0054 FFF7FEFF 		bl	prvCopyDataToQueue
 996:Source/queue.c **** 
 997:Source/queue.c **** 			/* The event list is not altered if the queue is locked.  This will
 998:Source/queue.c **** 			be done when the queue is unlocked later. */
 999:Source/queue.c **** 			if( cTxLock == queueUNLOCKED )
 884              		.loc 1 999 0
 885 0058 97F91F30 		ldrsb	r3, [r7, #31]
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 38


 886 005c B3F1FF3F 		cmp	r3, #-1
 887 0060 12D1     		bne	.L53
1000:Source/queue.c **** 			{
1001:Source/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
1002:Source/queue.c **** 				{
1003:Source/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
1004:Source/queue.c **** 					{
1005:Source/queue.c **** 						if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting != ( UBaseType_t ) 0 )
1006:Source/queue.c **** 						{
1007:Source/queue.c **** 							/* Do not notify the queue set as an existing item
1008:Source/queue.c **** 							was overwritten in the queue so the number of items
1009:Source/queue.c **** 							in the queue has not changed. */
1010:Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1011:Source/queue.c **** 						}
1012:Source/queue.c **** 						else if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
1013:Source/queue.c **** 						{
1014:Source/queue.c **** 							/* The queue is a member of a queue set, and posting
1015:Source/queue.c **** 							to the queue set caused a higher priority task to
1016:Source/queue.c **** 							unblock.  A context switch is required. */
1017:Source/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
1018:Source/queue.c **** 							{
1019:Source/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
1020:Source/queue.c **** 							}
1021:Source/queue.c **** 							else
1022:Source/queue.c **** 							{
1023:Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1024:Source/queue.c **** 							}
1025:Source/queue.c **** 						}
1026:Source/queue.c **** 						else
1027:Source/queue.c **** 						{
1028:Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1029:Source/queue.c **** 						}
1030:Source/queue.c **** 					}
1031:Source/queue.c **** 					else
1032:Source/queue.c **** 					{
1033:Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1034:Source/queue.c **** 						{
1035:Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1036:Source/queue.c **** 							{
1037:Source/queue.c **** 								/* The task waiting has a higher priority so
1038:Source/queue.c **** 								record that a context switch is required. */
1039:Source/queue.c **** 								if( pxHigherPriorityTaskWoken != NULL )
1040:Source/queue.c **** 								{
1041:Source/queue.c **** 									*pxHigherPriorityTaskWoken = pdTRUE;
1042:Source/queue.c **** 								}
1043:Source/queue.c **** 								else
1044:Source/queue.c **** 								{
1045:Source/queue.c **** 									mtCOVERAGE_TEST_MARKER();
1046:Source/queue.c **** 								}
1047:Source/queue.c **** 							}
1048:Source/queue.c **** 							else
1049:Source/queue.c **** 							{
1050:Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1051:Source/queue.c **** 							}
1052:Source/queue.c **** 						}
1053:Source/queue.c **** 						else
1054:Source/queue.c **** 						{
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 39


1055:Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1056:Source/queue.c **** 						}
1057:Source/queue.c **** 					}
1058:Source/queue.c **** 				}
1059:Source/queue.c **** 				#else /* configUSE_QUEUE_SETS */
1060:Source/queue.c **** 				{
1061:Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 888              		.loc 1 1061 0
 889 0062 BB6A     		ldr	r3, [r7, #40]
 890 0064 5B6A     		ldr	r3, [r3, #36]
 891 0066 002B     		cmp	r3, #0
 892 0068 15D0     		beq	.L54
1062:Source/queue.c **** 					{
1063:Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 893              		.loc 1 1063 0
 894 006a BB6A     		ldr	r3, [r7, #40]
 895 006c 2433     		adds	r3, r3, #36
 896 006e 1846     		mov	r0, r3
 897 0070 FFF7FEFF 		bl	xTaskRemoveFromEventList
 898 0074 0346     		mov	r3, r0
 899 0076 002B     		cmp	r3, #0
 900 0078 0DD0     		beq	.L54
1064:Source/queue.c **** 						{
1065:Source/queue.c **** 							/* The task waiting has a higher priority so record that a
1066:Source/queue.c **** 							context	switch is required. */
1067:Source/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
 901              		.loc 1 1067 0
 902 007a 7B68     		ldr	r3, [r7, #4]
 903 007c 002B     		cmp	r3, #0
 904 007e 0AD0     		beq	.L54
1068:Source/queue.c **** 							{
1069:Source/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
 905              		.loc 1 1069 0
 906 0080 7B68     		ldr	r3, [r7, #4]
 907 0082 0122     		movs	r2, #1
 908 0084 1A60     		str	r2, [r3]
 909 0086 06E0     		b	.L54
 910              	.L53:
1070:Source/queue.c **** 							}
1071:Source/queue.c **** 							else
1072:Source/queue.c **** 							{
1073:Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1074:Source/queue.c **** 							}
1075:Source/queue.c **** 						}
1076:Source/queue.c **** 						else
1077:Source/queue.c **** 						{
1078:Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1079:Source/queue.c **** 						}
1080:Source/queue.c **** 					}
1081:Source/queue.c **** 					else
1082:Source/queue.c **** 					{
1083:Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1084:Source/queue.c **** 					}
1085:Source/queue.c **** 					
1086:Source/queue.c **** 					/* Not used in this path. */
1087:Source/queue.c **** 					( void ) uxPreviousMessagesWaiting;
1088:Source/queue.c **** 				}
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 40


1089:Source/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
1090:Source/queue.c **** 			}
1091:Source/queue.c **** 			else
1092:Source/queue.c **** 			{
1093:Source/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1094:Source/queue.c **** 				knows that data was posted while it was locked. */
1095:Source/queue.c **** 				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 911              		.loc 1 1095 0
 912 0088 FB7F     		ldrb	r3, [r7, #31]	@ zero_extendqisi2
 913 008a 0133     		adds	r3, r3, #1
 914 008c DBB2     		uxtb	r3, r3
 915 008e 5AB2     		sxtb	r2, r3
 916 0090 BB6A     		ldr	r3, [r7, #40]
 917 0092 83F84520 		strb	r2, [r3, #69]
 918              	.L54:
1096:Source/queue.c **** 			}
1097:Source/queue.c **** 
1098:Source/queue.c **** 			xReturn = pdPASS;
 919              		.loc 1 1098 0
 920 0096 0123     		movs	r3, #1
 921 0098 FB62     		str	r3, [r7, #44]
 922              	.LBE25:
 984:Source/queue.c **** 			const int8_t cTxLock = pxQueue->cTxLock;
 923              		.loc 1 984 0
 924 009a 01E0     		b	.L55
 925              	.L52:
1099:Source/queue.c **** 		}
1100:Source/queue.c **** 		else
1101:Source/queue.c **** 		{
1102:Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1103:Source/queue.c **** 			xReturn = errQUEUE_FULL;
 926              		.loc 1 1103 0
 927 009c 0023     		movs	r3, #0
 928 009e FB62     		str	r3, [r7, #44]
 929              	.L55:
 930 00a0 3B6A     		ldr	r3, [r7, #32]
 931 00a2 7B62     		str	r3, [r7, #36]
 932              	.LBB26:
 933              	.LBB27:
 226:.\Source\portable\GCC\ARM_CM3/portmacro.h **** }
 227:.\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 228:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 229:.\Source\portable\GCC\ARM_CM3/portmacro.h **** portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
 230:.\Source\portable\GCC\ARM_CM3/portmacro.h **** {
 231:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	__asm volatile
 934              		.loc 2 231 0
 935 00a4 7B6A     		ldr	r3, [r7, #36]
 936              		.syntax unified
 937              	@ 231 ".\Source\portable\GCC\ARM_CM3/portmacro.h" 1
 938 00a6 83F31188 			msr basepri, r3	
 939              	@ 0 "" 2
 940              		.thumb
 941              		.syntax unified
 942              	.LBE27:
 943              	.LBE26:
1104:Source/queue.c **** 		}
1105:Source/queue.c **** 	}
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 41


1106:Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1107:Source/queue.c **** 
1108:Source/queue.c **** 	return xReturn;
 944              		.loc 1 1108 0
 945 00aa FB6A     		ldr	r3, [r7, #44]
1109:Source/queue.c **** }
 946              		.loc 1 1109 0
 947 00ac 1846     		mov	r0, r3
 948 00ae 3037     		adds	r7, r7, #48
 949              		.cfi_def_cfa_offset 8
 950 00b0 BD46     		mov	sp, r7
 951              		.cfi_def_cfa_register 13
 952              		@ sp needed
 953 00b2 80BD     		pop	{r7, pc}
 954              		.cfi_endproc
 955              	.LFE77:
 956              		.size	xQueueGenericSendFromISR, .-xQueueGenericSendFromISR
 957              		.section	.text.xQueueGiveFromISR,"ax",%progbits
 958              		.align	2
 959              		.global	xQueueGiveFromISR
 960              		.thumb
 961              		.thumb_func
 962              		.type	xQueueGiveFromISR, %function
 963              	xQueueGiveFromISR:
 964              	.LFB78:
1110:Source/queue.c **** /*-----------------------------------------------------------*/
1111:Source/queue.c **** 
1112:Source/queue.c **** BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
1113:Source/queue.c **** {
 965              		.loc 1 1113 0
 966              		.cfi_startproc
 967              		@ args = 0, pretend = 0, frame = 40
 968              		@ frame_needed = 1, uses_anonymous_args = 0
 969 0000 80B5     		push	{r7, lr}
 970              		.cfi_def_cfa_offset 8
 971              		.cfi_offset 7, -8
 972              		.cfi_offset 14, -4
 973 0002 8AB0     		sub	sp, sp, #40
 974              		.cfi_def_cfa_offset 48
 975 0004 00AF     		add	r7, sp, #0
 976              		.cfi_def_cfa_register 7
 977 0006 7860     		str	r0, [r7, #4]
 978 0008 3960     		str	r1, [r7]
1114:Source/queue.c **** BaseType_t xReturn;
1115:Source/queue.c **** UBaseType_t uxSavedInterruptStatus;
1116:Source/queue.c **** Queue_t * const pxQueue = xQueue;
 979              		.loc 1 1116 0
 980 000a 7B68     		ldr	r3, [r7, #4]
 981 000c 3B62     		str	r3, [r7, #32]
 982              	.LBB28:
 983              	.LBB29:
 213:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	(
 984              		.loc 2 213 0
 985              		.syntax unified
 986              	@ 213 ".\Source\portable\GCC\ARM_CM3/portmacro.h" 1
 987 000e EFF31182 			mrs r2, basepri											
 988 0012 4FF0A003 		mov r3, #160												
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 42


 989 0016 83F31188 		msr basepri, r3											
 990 001a BFF36F8F 		isb														
 991 001e BFF34F8F 		dsb														
 992              	
 993              	@ 0 "" 2
 994              		.thumb
 995              		.syntax unified
 996 0022 FA60     		str	r2, [r7, #12]
 997 0024 BB60     		str	r3, [r7, #8]
 225:.\Source\portable\GCC\ARM_CM3/portmacro.h **** }
 998              		.loc 2 225 0
 999 0026 FB68     		ldr	r3, [r7, #12]
 1000              	.LBE29:
 1001              	.LBE28:
1117:Source/queue.c **** 
1118:Source/queue.c **** 	/* Similar to xQueueGenericSendFromISR() but used with semaphores where the
1119:Source/queue.c **** 	item size is 0.  Don't directly wake a task that was blocked on a queue
1120:Source/queue.c **** 	read, instead return a flag to say whether a context switch is required or
1121:Source/queue.c **** 	not (i.e. has a task with a higher priority than us been woken by this
1122:Source/queue.c **** 	post). */
1123:Source/queue.c **** 
1124:Source/queue.c **** 	configASSERT( pxQueue );
1125:Source/queue.c **** 
1126:Source/queue.c **** 	/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
1127:Source/queue.c **** 	if the item size is not 0. */
1128:Source/queue.c **** 	configASSERT( pxQueue->uxItemSize == 0 );
1129:Source/queue.c **** 
1130:Source/queue.c **** 	/* Normally a mutex would not be given from an interrupt, especially if
1131:Source/queue.c **** 	there is a mutex holder, as priority inheritance makes no sense for an
1132:Source/queue.c **** 	interrupts, only tasks. */
1133:Source/queue.c **** 	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMutex
1134:Source/queue.c **** 
1135:Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1136:Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1137:Source/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
1138:Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1139:Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1140:Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1141:Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1142:Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
1143:Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1144:Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1145:Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1146:Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1147:Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1148:Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1149:Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1150:Source/queue.c **** 
1151:Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1002              		.loc 1 1151 0
 1003 0028 BB61     		str	r3, [r7, #24]
 1004              	.LBB30:
1152:Source/queue.c **** 	{
1153:Source/queue.c **** 		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 1005              		.loc 1 1153 0
 1006 002a 3B6A     		ldr	r3, [r7, #32]
 1007 002c 9B6B     		ldr	r3, [r3, #56]
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 43


 1008 002e 7B61     		str	r3, [r7, #20]
1154:Source/queue.c **** 
1155:Source/queue.c **** 		/* When the queue is used to implement a semaphore no data is ever
1156:Source/queue.c **** 		moved through the queue but it is still valid to see if the queue 'has
1157:Source/queue.c **** 		space'. */
1158:Source/queue.c **** 		if( uxMessagesWaiting < pxQueue->uxLength )
 1009              		.loc 1 1158 0
 1010 0030 3B6A     		ldr	r3, [r7, #32]
 1011 0032 DA6B     		ldr	r2, [r3, #60]
 1012 0034 7B69     		ldr	r3, [r7, #20]
 1013 0036 9A42     		cmp	r2, r3
 1014 0038 29D9     		bls	.L59
 1015              	.LBB31:
1159:Source/queue.c **** 		{
1160:Source/queue.c **** 			const int8_t cTxLock = pxQueue->cTxLock;
 1016              		.loc 1 1160 0
 1017 003a 3B6A     		ldr	r3, [r7, #32]
 1018 003c 93F84530 		ldrb	r3, [r3, #69]
 1019 0040 FB74     		strb	r3, [r7, #19]
1161:Source/queue.c **** 
1162:Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR( pxQueue );
1163:Source/queue.c **** 
1164:Source/queue.c **** 			/* A task can only have an inherited priority if it is a mutex
1165:Source/queue.c **** 			holder - and if there is a mutex holder then the mutex cannot be
1166:Source/queue.c **** 			given from an ISR.  As this is the ISR version of the function it
1167:Source/queue.c **** 			can be assumed there is no mutex holder and no need to determine if
1168:Source/queue.c **** 			priority disinheritance is needed.  Simply increase the count of
1169:Source/queue.c **** 			messages (semaphores) available. */
1170:Source/queue.c **** 			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 1020              		.loc 1 1170 0
 1021 0042 7B69     		ldr	r3, [r7, #20]
 1022 0044 5A1C     		adds	r2, r3, #1
 1023 0046 3B6A     		ldr	r3, [r7, #32]
 1024 0048 9A63     		str	r2, [r3, #56]
1171:Source/queue.c **** 
1172:Source/queue.c **** 			/* The event list is not altered if the queue is locked.  This will
1173:Source/queue.c **** 			be done when the queue is unlocked later. */
1174:Source/queue.c **** 			if( cTxLock == queueUNLOCKED )
 1025              		.loc 1 1174 0
 1026 004a 97F91330 		ldrsb	r3, [r7, #19]
 1027 004e B3F1FF3F 		cmp	r3, #-1
 1028 0052 12D1     		bne	.L60
1175:Source/queue.c **** 			{
1176:Source/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
1177:Source/queue.c **** 				{
1178:Source/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
1179:Source/queue.c **** 					{
1180:Source/queue.c **** 						if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
1181:Source/queue.c **** 						{
1182:Source/queue.c **** 							/* The semaphore is a member of a queue set, and
1183:Source/queue.c **** 							posting	to the queue set caused a higher priority
1184:Source/queue.c **** 							task to	unblock.  A context switch is required. */
1185:Source/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
1186:Source/queue.c **** 							{
1187:Source/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
1188:Source/queue.c **** 							}
1189:Source/queue.c **** 							else
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 44


1190:Source/queue.c **** 							{
1191:Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1192:Source/queue.c **** 							}
1193:Source/queue.c **** 						}
1194:Source/queue.c **** 						else
1195:Source/queue.c **** 						{
1196:Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1197:Source/queue.c **** 						}
1198:Source/queue.c **** 					}
1199:Source/queue.c **** 					else
1200:Source/queue.c **** 					{
1201:Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1202:Source/queue.c **** 						{
1203:Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1204:Source/queue.c **** 							{
1205:Source/queue.c **** 								/* The task waiting has a higher priority so
1206:Source/queue.c **** 								record that a context switch is required. */
1207:Source/queue.c **** 								if( pxHigherPriorityTaskWoken != NULL )
1208:Source/queue.c **** 								{
1209:Source/queue.c **** 									*pxHigherPriorityTaskWoken = pdTRUE;
1210:Source/queue.c **** 								}
1211:Source/queue.c **** 								else
1212:Source/queue.c **** 								{
1213:Source/queue.c **** 									mtCOVERAGE_TEST_MARKER();
1214:Source/queue.c **** 								}
1215:Source/queue.c **** 							}
1216:Source/queue.c **** 							else
1217:Source/queue.c **** 							{
1218:Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1219:Source/queue.c **** 							}
1220:Source/queue.c **** 						}
1221:Source/queue.c **** 						else
1222:Source/queue.c **** 						{
1223:Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1224:Source/queue.c **** 						}
1225:Source/queue.c **** 					}
1226:Source/queue.c **** 				}
1227:Source/queue.c **** 				#else /* configUSE_QUEUE_SETS */
1228:Source/queue.c **** 				{
1229:Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 1029              		.loc 1 1229 0
 1030 0054 3B6A     		ldr	r3, [r7, #32]
 1031 0056 5B6A     		ldr	r3, [r3, #36]
 1032 0058 002B     		cmp	r3, #0
 1033 005a 15D0     		beq	.L61
1230:Source/queue.c **** 					{
1231:Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 1034              		.loc 1 1231 0
 1035 005c 3B6A     		ldr	r3, [r7, #32]
 1036 005e 2433     		adds	r3, r3, #36
 1037 0060 1846     		mov	r0, r3
 1038 0062 FFF7FEFF 		bl	xTaskRemoveFromEventList
 1039 0066 0346     		mov	r3, r0
 1040 0068 002B     		cmp	r3, #0
 1041 006a 0DD0     		beq	.L61
1232:Source/queue.c **** 						{
1233:Source/queue.c **** 							/* The task waiting has a higher priority so record that a
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 45


1234:Source/queue.c **** 							context	switch is required. */
1235:Source/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
 1042              		.loc 1 1235 0
 1043 006c 3B68     		ldr	r3, [r7]
 1044 006e 002B     		cmp	r3, #0
 1045 0070 0AD0     		beq	.L61
1236:Source/queue.c **** 							{
1237:Source/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
 1046              		.loc 1 1237 0
 1047 0072 3B68     		ldr	r3, [r7]
 1048 0074 0122     		movs	r2, #1
 1049 0076 1A60     		str	r2, [r3]
 1050 0078 06E0     		b	.L61
 1051              	.L60:
1238:Source/queue.c **** 							}
1239:Source/queue.c **** 							else
1240:Source/queue.c **** 							{
1241:Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1242:Source/queue.c **** 							}
1243:Source/queue.c **** 						}
1244:Source/queue.c **** 						else
1245:Source/queue.c **** 						{
1246:Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1247:Source/queue.c **** 						}
1248:Source/queue.c **** 					}
1249:Source/queue.c **** 					else
1250:Source/queue.c **** 					{
1251:Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1252:Source/queue.c **** 					}
1253:Source/queue.c **** 				}
1254:Source/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
1255:Source/queue.c **** 			}
1256:Source/queue.c **** 			else
1257:Source/queue.c **** 			{
1258:Source/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1259:Source/queue.c **** 				knows that data was posted while it was locked. */
1260:Source/queue.c **** 				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 1052              		.loc 1 1260 0
 1053 007a FB7C     		ldrb	r3, [r7, #19]	@ zero_extendqisi2
 1054 007c 0133     		adds	r3, r3, #1
 1055 007e DBB2     		uxtb	r3, r3
 1056 0080 5AB2     		sxtb	r2, r3
 1057 0082 3B6A     		ldr	r3, [r7, #32]
 1058 0084 83F84520 		strb	r2, [r3, #69]
 1059              	.L61:
1261:Source/queue.c **** 			}
1262:Source/queue.c **** 
1263:Source/queue.c **** 			xReturn = pdPASS;
 1060              		.loc 1 1263 0
 1061 0088 0123     		movs	r3, #1
 1062 008a 7B62     		str	r3, [r7, #36]
 1063              	.LBE31:
 1064 008c 01E0     		b	.L62
 1065              	.L59:
1264:Source/queue.c **** 		}
1265:Source/queue.c **** 		else
1266:Source/queue.c **** 		{
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 46


1267:Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1268:Source/queue.c **** 			xReturn = errQUEUE_FULL;
 1066              		.loc 1 1268 0
 1067 008e 0023     		movs	r3, #0
 1068 0090 7B62     		str	r3, [r7, #36]
 1069              	.L62:
 1070 0092 BB69     		ldr	r3, [r7, #24]
 1071 0094 FB61     		str	r3, [r7, #28]
 1072              	.LBE30:
 1073              	.LBB32:
 1074              	.LBB33:
 1075              		.loc 2 231 0
 1076 0096 FB69     		ldr	r3, [r7, #28]
 1077              		.syntax unified
 1078              	@ 231 ".\Source\portable\GCC\ARM_CM3/portmacro.h" 1
 1079 0098 83F31188 			msr basepri, r3	
 1080              	@ 0 "" 2
 1081              		.thumb
 1082              		.syntax unified
 1083              	.LBE33:
 1084              	.LBE32:
1269:Source/queue.c **** 		}
1270:Source/queue.c **** 	}
1271:Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1272:Source/queue.c **** 
1273:Source/queue.c **** 	return xReturn;
 1085              		.loc 1 1273 0
 1086 009c 7B6A     		ldr	r3, [r7, #36]
1274:Source/queue.c **** }
 1087              		.loc 1 1274 0
 1088 009e 1846     		mov	r0, r3
 1089 00a0 2837     		adds	r7, r7, #40
 1090              		.cfi_def_cfa_offset 8
 1091 00a2 BD46     		mov	sp, r7
 1092              		.cfi_def_cfa_register 13
 1093              		@ sp needed
 1094 00a4 80BD     		pop	{r7, pc}
 1095              		.cfi_endproc
 1096              	.LFE78:
 1097              		.size	xQueueGiveFromISR, .-xQueueGiveFromISR
 1098 00a6 00BF     		.section	.text.xQueueReceive,"ax",%progbits
 1099              		.align	2
 1100              		.global	xQueueReceive
 1101              		.thumb
 1102              		.thumb_func
 1103              		.type	xQueueReceive, %function
 1104              	xQueueReceive:
 1105              	.LFB79:
1275:Source/queue.c **** /*-----------------------------------------------------------*/
1276:Source/queue.c **** 
1277:Source/queue.c **** BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
1278:Source/queue.c **** {
 1106              		.loc 1 1278 0
 1107              		.cfi_startproc
 1108              		@ args = 0, pretend = 0, frame = 40
 1109              		@ frame_needed = 1, uses_anonymous_args = 0
 1110 0000 80B5     		push	{r7, lr}
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 47


 1111              		.cfi_def_cfa_offset 8
 1112              		.cfi_offset 7, -8
 1113              		.cfi_offset 14, -4
 1114 0002 8AB0     		sub	sp, sp, #40
 1115              		.cfi_def_cfa_offset 48
 1116 0004 00AF     		add	r7, sp, #0
 1117              		.cfi_def_cfa_register 7
 1118 0006 F860     		str	r0, [r7, #12]
 1119 0008 B960     		str	r1, [r7, #8]
 1120 000a 7A60     		str	r2, [r7, #4]
1279:Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
 1121              		.loc 1 1279 0
 1122 000c 0023     		movs	r3, #0
 1123 000e 7B62     		str	r3, [r7, #36]
1280:Source/queue.c **** TimeOut_t xTimeOut;
1281:Source/queue.c **** Queue_t * const pxQueue = xQueue;
 1124              		.loc 1 1281 0
 1125 0010 FB68     		ldr	r3, [r7, #12]
 1126 0012 3B62     		str	r3, [r7, #32]
 1127              	.L76:
1282:Source/queue.c **** 
1283:Source/queue.c **** 	/* Check the pointer is not NULL. */
1284:Source/queue.c **** 	configASSERT( ( pxQueue ) );
1285:Source/queue.c **** 
1286:Source/queue.c **** 	/* The buffer into which data is received can only be NULL if the data size
1287:Source/queue.c **** 	is zero (so no data is copied into the buffer. */
1288:Source/queue.c **** 	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) )
1289:Source/queue.c **** 
1290:Source/queue.c **** 	/* Cannot block if the scheduler is suspended. */
1291:Source/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1292:Source/queue.c **** 	{
1293:Source/queue.c **** 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 )
1294:Source/queue.c **** 	}
1295:Source/queue.c **** 	#endif
1296:Source/queue.c **** 
1297:Source/queue.c **** 
1298:Source/queue.c **** 	/*lint -save -e904  This function relaxes the coding standard somewhat to
1299:Source/queue.c **** 	allow return statements within the function itself.  This is done in the
1300:Source/queue.c **** 	interest of execution time efficiency. */
1301:Source/queue.c **** 	for( ;; )
1302:Source/queue.c **** 	{
1303:Source/queue.c **** 		taskENTER_CRITICAL();
 1128              		.loc 1 1303 0
 1129 0014 FFF7FEFF 		bl	vPortEnterCritical
 1130              	.LBB34:
1304:Source/queue.c **** 		{
1305:Source/queue.c **** 			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 1131              		.loc 1 1305 0
 1132 0018 3B6A     		ldr	r3, [r7, #32]
 1133 001a 9B6B     		ldr	r3, [r3, #56]
 1134 001c FB61     		str	r3, [r7, #28]
1306:Source/queue.c **** 
1307:Source/queue.c **** 			/* Is there data in the queue now?  To be running the calling task
1308:Source/queue.c **** 			must be the highest priority task wanting to access the queue. */
1309:Source/queue.c **** 			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 1135              		.loc 1 1309 0
 1136 001e FB69     		ldr	r3, [r7, #28]
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 48


 1137 0020 002B     		cmp	r3, #0
 1138 0022 1FD0     		beq	.L65
1310:Source/queue.c **** 			{
1311:Source/queue.c **** 				/* Data available, remove one item. */
1312:Source/queue.c **** 				prvCopyDataFromQueue( pxQueue, pvBuffer );
 1139              		.loc 1 1312 0
 1140 0024 B968     		ldr	r1, [r7, #8]
 1141 0026 386A     		ldr	r0, [r7, #32]
 1142 0028 FFF7FEFF 		bl	prvCopyDataFromQueue
1313:Source/queue.c **** 				traceQUEUE_RECEIVE( pxQueue );
1314:Source/queue.c **** 				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 1143              		.loc 1 1314 0
 1144 002c FB69     		ldr	r3, [r7, #28]
 1145 002e 5A1E     		subs	r2, r3, #1
 1146 0030 3B6A     		ldr	r3, [r7, #32]
 1147 0032 9A63     		str	r2, [r3, #56]
1315:Source/queue.c **** 
1316:Source/queue.c **** 				/* There is now space in the queue, were any tasks waiting to
1317:Source/queue.c **** 				post to the queue?  If so, unblock the highest priority waiting
1318:Source/queue.c **** 				task. */
1319:Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 1148              		.loc 1 1319 0
 1149 0034 3B6A     		ldr	r3, [r7, #32]
 1150 0036 1B69     		ldr	r3, [r3, #16]
 1151 0038 002B     		cmp	r3, #0
 1152 003a 0FD0     		beq	.L66
1320:Source/queue.c **** 				{
1321:Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 1153              		.loc 1 1321 0
 1154 003c 3B6A     		ldr	r3, [r7, #32]
 1155 003e 1033     		adds	r3, r3, #16
 1156 0040 1846     		mov	r0, r3
 1157 0042 FFF7FEFF 		bl	xTaskRemoveFromEventList
 1158 0046 0346     		mov	r3, r0
 1159 0048 002B     		cmp	r3, #0
 1160 004a 07D0     		beq	.L66
1322:Source/queue.c **** 					{
1323:Source/queue.c **** 						queueYIELD_IF_USING_PREEMPTION();
 1161              		.loc 1 1323 0
 1162 004c 3C4B     		ldr	r3, .L78
 1163 004e 4FF08052 		mov	r2, #268435456
 1164 0052 1A60     		str	r2, [r3]
 1165              		.syntax unified
 1166              	@ 1323 "Source\queue.c" 1
 1167 0054 BFF34F8F 		dsb
 1168              	@ 0 "" 2
 1169              	@ 1323 "Source\queue.c" 1
 1170 0058 BFF36F8F 		isb
 1171              	@ 0 "" 2
 1172              		.thumb
 1173              		.syntax unified
 1174              	.L66:
1324:Source/queue.c **** 					}
1325:Source/queue.c **** 					else
1326:Source/queue.c **** 					{
1327:Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1328:Source/queue.c **** 					}
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 49


1329:Source/queue.c **** 				}
1330:Source/queue.c **** 				else
1331:Source/queue.c **** 				{
1332:Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1333:Source/queue.c **** 				}
1334:Source/queue.c **** 
1335:Source/queue.c **** 				taskEXIT_CRITICAL();
 1175              		.loc 1 1335 0
 1176 005c FFF7FEFF 		bl	vPortExitCritical
1336:Source/queue.c **** 				return pdPASS;
 1177              		.loc 1 1336 0
 1178 0060 0123     		movs	r3, #1
 1179 0062 69E0     		b	.L77
 1180              	.L65:
1337:Source/queue.c **** 			}
1338:Source/queue.c **** 			else
1339:Source/queue.c **** 			{
1340:Source/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
 1181              		.loc 1 1340 0
 1182 0064 7B68     		ldr	r3, [r7, #4]
 1183 0066 002B     		cmp	r3, #0
 1184 0068 03D1     		bne	.L68
1341:Source/queue.c **** 				{
1342:Source/queue.c **** 					/* The queue was empty and no block time is specified (or
1343:Source/queue.c **** 					the block time has expired) so leave now. */
1344:Source/queue.c **** 					taskEXIT_CRITICAL();
 1185              		.loc 1 1344 0
 1186 006a FFF7FEFF 		bl	vPortExitCritical
1345:Source/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
1346:Source/queue.c **** 					return errQUEUE_EMPTY;
 1187              		.loc 1 1346 0
 1188 006e 0023     		movs	r3, #0
 1189 0070 62E0     		b	.L77
 1190              	.L68:
1347:Source/queue.c **** 				}
1348:Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 1191              		.loc 1 1348 0
 1192 0072 7B6A     		ldr	r3, [r7, #36]
 1193 0074 002B     		cmp	r3, #0
 1194 0076 06D1     		bne	.L69
1349:Source/queue.c **** 				{
1350:Source/queue.c **** 					/* The queue was empty and a block time was specified so
1351:Source/queue.c **** 					configure the timeout structure. */
1352:Source/queue.c **** 					vTaskInternalSetTimeOutState( &xTimeOut );
 1195              		.loc 1 1352 0
 1196 0078 07F11403 		add	r3, r7, #20
 1197 007c 1846     		mov	r0, r3
 1198 007e FFF7FEFF 		bl	vTaskInternalSetTimeOutState
1353:Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 1199              		.loc 1 1353 0
 1200 0082 0123     		movs	r3, #1
 1201 0084 7B62     		str	r3, [r7, #36]
 1202              	.L69:
 1203              	.LBE34:
1354:Source/queue.c **** 				}
1355:Source/queue.c **** 				else
1356:Source/queue.c **** 				{
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 50


1357:Source/queue.c **** 					/* Entry time was already set. */
1358:Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1359:Source/queue.c **** 				}
1360:Source/queue.c **** 			}
1361:Source/queue.c **** 		}
1362:Source/queue.c **** 		taskEXIT_CRITICAL();
 1204              		.loc 1 1362 0
 1205 0086 FFF7FEFF 		bl	vPortExitCritical
1363:Source/queue.c **** 
1364:Source/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
1365:Source/queue.c **** 		now the critical section has been exited. */
1366:Source/queue.c **** 
1367:Source/queue.c **** 		vTaskSuspendAll();
 1206              		.loc 1 1367 0
 1207 008a FFF7FEFF 		bl	vTaskSuspendAll
1368:Source/queue.c **** 		prvLockQueue( pxQueue );
 1208              		.loc 1 1368 0
 1209 008e FFF7FEFF 		bl	vPortEnterCritical
 1210 0092 3B6A     		ldr	r3, [r7, #32]
 1211 0094 93F84430 		ldrb	r3, [r3, #68]
 1212 0098 5BB2     		sxtb	r3, r3
 1213 009a B3F1FF3F 		cmp	r3, #-1
 1214 009e 03D1     		bne	.L70
 1215              		.loc 1 1368 0 is_stmt 0 discriminator 1
 1216 00a0 3B6A     		ldr	r3, [r7, #32]
 1217 00a2 0022     		movs	r2, #0
 1218 00a4 83F84420 		strb	r2, [r3, #68]
 1219              	.L70:
 1220              		.loc 1 1368 0 discriminator 3
 1221 00a8 3B6A     		ldr	r3, [r7, #32]
 1222 00aa 93F84530 		ldrb	r3, [r3, #69]
 1223 00ae 5BB2     		sxtb	r3, r3
 1224 00b0 B3F1FF3F 		cmp	r3, #-1
 1225 00b4 03D1     		bne	.L71
 1226              		.loc 1 1368 0 discriminator 4
 1227 00b6 3B6A     		ldr	r3, [r7, #32]
 1228 00b8 0022     		movs	r2, #0
 1229 00ba 83F84520 		strb	r2, [r3, #69]
 1230              	.L71:
 1231              		.loc 1 1368 0 discriminator 6
 1232 00be FFF7FEFF 		bl	vPortExitCritical
1369:Source/queue.c **** 
1370:Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
1371:Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 1233              		.loc 1 1371 0 is_stmt 1 discriminator 6
 1234 00c2 3A1D     		adds	r2, r7, #4
 1235 00c4 07F11403 		add	r3, r7, #20
 1236 00c8 1146     		mov	r1, r2
 1237 00ca 1846     		mov	r0, r3
 1238 00cc FFF7FEFF 		bl	xTaskCheckForTimeOut
 1239 00d0 0346     		mov	r3, r0
 1240 00d2 002B     		cmp	r3, #0
 1241 00d4 23D1     		bne	.L72
1372:Source/queue.c **** 		{
1373:Source/queue.c **** 			/* The timeout has not expired.  If the queue is still empty place
1374:Source/queue.c **** 			the task on the list of tasks waiting to receive from the queue. */
1375:Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 51


 1242              		.loc 1 1375 0
 1243 00d6 386A     		ldr	r0, [r7, #32]
 1244 00d8 FFF7FEFF 		bl	prvIsQueueEmpty
 1245 00dc 0346     		mov	r3, r0
 1246 00de 002B     		cmp	r3, #0
 1247 00e0 17D0     		beq	.L73
1376:Source/queue.c **** 			{
1377:Source/queue.c **** 				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
1378:Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 1248              		.loc 1 1378 0
 1249 00e2 3B6A     		ldr	r3, [r7, #32]
 1250 00e4 2433     		adds	r3, r3, #36
 1251 00e6 7A68     		ldr	r2, [r7, #4]
 1252 00e8 1146     		mov	r1, r2
 1253 00ea 1846     		mov	r0, r3
 1254 00ec FFF7FEFF 		bl	vTaskPlaceOnEventList
1379:Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1255              		.loc 1 1379 0
 1256 00f0 386A     		ldr	r0, [r7, #32]
 1257 00f2 FFF7FEFF 		bl	prvUnlockQueue
1380:Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 1258              		.loc 1 1380 0
 1259 00f6 FFF7FEFF 		bl	xTaskResumeAll
 1260 00fa 0346     		mov	r3, r0
 1261 00fc 002B     		cmp	r3, #0
 1262 00fe 89D1     		bne	.L76
1381:Source/queue.c **** 				{
1382:Source/queue.c **** 					portYIELD_WITHIN_API();
 1263              		.loc 1 1382 0
 1264 0100 0F4B     		ldr	r3, .L78
 1265 0102 4FF08052 		mov	r2, #268435456
 1266 0106 1A60     		str	r2, [r3]
 1267              		.syntax unified
 1268              	@ 1382 "Source\queue.c" 1
 1269 0108 BFF34F8F 		dsb
 1270              	@ 0 "" 2
 1271              	@ 1382 "Source\queue.c" 1
 1272 010c BFF36F8F 		isb
 1273              	@ 0 "" 2
 1274              		.thumb
 1275              		.syntax unified
 1276 0110 80E7     		b	.L76
 1277              	.L73:
1383:Source/queue.c **** 				}
1384:Source/queue.c **** 				else
1385:Source/queue.c **** 				{
1386:Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1387:Source/queue.c **** 				}
1388:Source/queue.c **** 			}
1389:Source/queue.c **** 			else
1390:Source/queue.c **** 			{
1391:Source/queue.c **** 				/* The queue contains data again.  Loop back to try and read the
1392:Source/queue.c **** 				data. */
1393:Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1278              		.loc 1 1393 0
 1279 0112 386A     		ldr	r0, [r7, #32]
 1280 0114 FFF7FEFF 		bl	prvUnlockQueue
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 52


1394:Source/queue.c **** 				( void ) xTaskResumeAll();
 1281              		.loc 1 1394 0
 1282 0118 FFF7FEFF 		bl	xTaskResumeAll
 1283 011c 7AE7     		b	.L76
 1284              	.L72:
1395:Source/queue.c **** 			}
1396:Source/queue.c **** 		}
1397:Source/queue.c **** 		else
1398:Source/queue.c **** 		{
1399:Source/queue.c **** 			/* Timed out.  If there is no data in the queue exit, otherwise loop
1400:Source/queue.c **** 			back and attempt to read the data. */
1401:Source/queue.c **** 			prvUnlockQueue( pxQueue );
 1285              		.loc 1 1401 0
 1286 011e 386A     		ldr	r0, [r7, #32]
 1287 0120 FFF7FEFF 		bl	prvUnlockQueue
1402:Source/queue.c **** 			( void ) xTaskResumeAll();
 1288              		.loc 1 1402 0
 1289 0124 FFF7FEFF 		bl	xTaskResumeAll
1403:Source/queue.c **** 
1404:Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 1290              		.loc 1 1404 0
 1291 0128 386A     		ldr	r0, [r7, #32]
 1292 012a FFF7FEFF 		bl	prvIsQueueEmpty
 1293 012e 0346     		mov	r3, r0
 1294 0130 002B     		cmp	r3, #0
 1295 0132 3FF46FAF 		beq	.L76
1405:Source/queue.c **** 			{
1406:Source/queue.c **** 				traceQUEUE_RECEIVE_FAILED( pxQueue );
1407:Source/queue.c **** 				return errQUEUE_EMPTY;
 1296              		.loc 1 1407 0
 1297 0136 0023     		movs	r3, #0
 1298              	.L77:
1408:Source/queue.c **** 			}
1409:Source/queue.c **** 			else
1410:Source/queue.c **** 			{
1411:Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
1412:Source/queue.c **** 			}
1413:Source/queue.c **** 		}
1414:Source/queue.c **** 	} /*lint -restore */
1415:Source/queue.c **** }
 1299              		.loc 1 1415 0 discriminator 3
 1300 0138 1846     		mov	r0, r3
 1301 013a 2837     		adds	r7, r7, #40
 1302              		.cfi_def_cfa_offset 8
 1303 013c BD46     		mov	sp, r7
 1304              		.cfi_def_cfa_register 13
 1305              		@ sp needed
 1306 013e 80BD     		pop	{r7, pc}
 1307              	.L79:
 1308              		.align	2
 1309              	.L78:
 1310 0140 04ED00E0 		.word	-536810236
 1311              		.cfi_endproc
 1312              	.LFE79:
 1313              		.size	xQueueReceive, .-xQueueReceive
 1314              		.section	.text.xQueueSemaphoreTake,"ax",%progbits
 1315              		.align	2
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 53


 1316              		.global	xQueueSemaphoreTake
 1317              		.thumb
 1318              		.thumb_func
 1319              		.type	xQueueSemaphoreTake, %function
 1320              	xQueueSemaphoreTake:
 1321              	.LFB80:
1416:Source/queue.c **** /*-----------------------------------------------------------*/
1417:Source/queue.c **** 
1418:Source/queue.c **** BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
1419:Source/queue.c **** {
 1322              		.loc 1 1419 0
 1323              		.cfi_startproc
 1324              		@ args = 0, pretend = 0, frame = 40
 1325              		@ frame_needed = 1, uses_anonymous_args = 0
 1326 0000 80B5     		push	{r7, lr}
 1327              		.cfi_def_cfa_offset 8
 1328              		.cfi_offset 7, -8
 1329              		.cfi_offset 14, -4
 1330 0002 8AB0     		sub	sp, sp, #40
 1331              		.cfi_def_cfa_offset 48
 1332 0004 00AF     		add	r7, sp, #0
 1333              		.cfi_def_cfa_register 7
 1334 0006 7860     		str	r0, [r7, #4]
 1335 0008 3960     		str	r1, [r7]
1420:Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
 1336              		.loc 1 1420 0
 1337 000a 0023     		movs	r3, #0
 1338 000c 7B62     		str	r3, [r7, #36]
1421:Source/queue.c **** TimeOut_t xTimeOut;
1422:Source/queue.c **** Queue_t * const pxQueue = xQueue;
 1339              		.loc 1 1422 0
 1340 000e 7B68     		ldr	r3, [r7, #4]
 1341 0010 FB61     		str	r3, [r7, #28]
1423:Source/queue.c **** 
1424:Source/queue.c **** #if( configUSE_MUTEXES == 1 )
1425:Source/queue.c **** 	BaseType_t xInheritanceOccurred = pdFALSE;
 1342              		.loc 1 1425 0
 1343 0012 0023     		movs	r3, #0
 1344 0014 3B62     		str	r3, [r7, #32]
 1345              	.L95:
1426:Source/queue.c **** #endif
1427:Source/queue.c **** 
1428:Source/queue.c **** 	/* Check the queue pointer is not NULL. */
1429:Source/queue.c **** 	configASSERT( ( pxQueue ) );
1430:Source/queue.c **** 
1431:Source/queue.c **** 	/* Check this really is a semaphore, in which case the item size will be
1432:Source/queue.c **** 	0. */
1433:Source/queue.c **** 	configASSERT( pxQueue->uxItemSize == 0 );
1434:Source/queue.c **** 
1435:Source/queue.c **** 	/* Cannot block if the scheduler is suspended. */
1436:Source/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1437:Source/queue.c **** 	{
1438:Source/queue.c **** 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 )
1439:Source/queue.c **** 	}
1440:Source/queue.c **** 	#endif
1441:Source/queue.c **** 
1442:Source/queue.c **** 
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 54


1443:Source/queue.c **** 	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
1444:Source/queue.c **** 	statements within the function itself.  This is done in the interest
1445:Source/queue.c **** 	of execution time efficiency. */
1446:Source/queue.c **** 	for( ;; )
1447:Source/queue.c **** 	{
1448:Source/queue.c **** 		taskENTER_CRITICAL();
 1346              		.loc 1 1448 0
 1347 0016 FFF7FEFF 		bl	vPortEnterCritical
 1348              	.LBB35:
1449:Source/queue.c **** 		{
1450:Source/queue.c **** 			/* Semaphores are queues with an item size of 0, and where the
1451:Source/queue.c **** 			number of messages in the queue is the semaphore's count value. */
1452:Source/queue.c **** 			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
 1349              		.loc 1 1452 0
 1350 001a FB69     		ldr	r3, [r7, #28]
 1351 001c 9B6B     		ldr	r3, [r3, #56]
 1352 001e BB61     		str	r3, [r7, #24]
1453:Source/queue.c **** 
1454:Source/queue.c **** 			/* Is there data in the queue now?  To be running the calling task
1455:Source/queue.c **** 			must be the highest priority task wanting to access the queue. */
1456:Source/queue.c **** 			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
 1353              		.loc 1 1456 0
 1354 0020 BB69     		ldr	r3, [r7, #24]
 1355 0022 002B     		cmp	r3, #0
 1356 0024 24D0     		beq	.L81
1457:Source/queue.c **** 			{
1458:Source/queue.c **** 				traceQUEUE_RECEIVE( pxQueue );
1459:Source/queue.c **** 
1460:Source/queue.c **** 				/* Semaphores are queues with a data size of zero and where the
1461:Source/queue.c **** 				messages waiting is the semaphore's count.  Reduce the count. */
1462:Source/queue.c **** 				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
 1357              		.loc 1 1462 0
 1358 0026 BB69     		ldr	r3, [r7, #24]
 1359 0028 5A1E     		subs	r2, r3, #1
 1360 002a FB69     		ldr	r3, [r7, #28]
 1361 002c 9A63     		str	r2, [r3, #56]
1463:Source/queue.c **** 
1464:Source/queue.c **** 				#if ( configUSE_MUTEXES == 1 )
1465:Source/queue.c **** 				{
1466:Source/queue.c **** 					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 1362              		.loc 1 1466 0
 1363 002e FB69     		ldr	r3, [r7, #28]
 1364 0030 1B68     		ldr	r3, [r3]
 1365 0032 002B     		cmp	r3, #0
 1366 0034 04D1     		bne	.L82
1467:Source/queue.c **** 					{
1468:Source/queue.c **** 						/* Record the information required to implement
1469:Source/queue.c **** 						priority inheritance should it become necessary. */
1470:Source/queue.c **** 						pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
 1367              		.loc 1 1470 0
 1368 0036 FFF7FEFF 		bl	pvTaskIncrementMutexHeldCount
 1369 003a 0246     		mov	r2, r0
 1370 003c FB69     		ldr	r3, [r7, #28]
 1371 003e 9A60     		str	r2, [r3, #8]
 1372              	.L82:
1471:Source/queue.c **** 					}
1472:Source/queue.c **** 					else
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 55


1473:Source/queue.c **** 					{
1474:Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1475:Source/queue.c **** 					}
1476:Source/queue.c **** 				}
1477:Source/queue.c **** 				#endif /* configUSE_MUTEXES */
1478:Source/queue.c **** 
1479:Source/queue.c **** 				/* Check to see if other tasks are blocked waiting to give the
1480:Source/queue.c **** 				semaphore, and if so, unblock the highest priority such task. */
1481:Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 1373              		.loc 1 1481 0
 1374 0040 FB69     		ldr	r3, [r7, #28]
 1375 0042 1B69     		ldr	r3, [r3, #16]
 1376 0044 002B     		cmp	r3, #0
 1377 0046 0FD0     		beq	.L83
1482:Source/queue.c **** 				{
1483:Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 1378              		.loc 1 1483 0
 1379 0048 FB69     		ldr	r3, [r7, #28]
 1380 004a 1033     		adds	r3, r3, #16
 1381 004c 1846     		mov	r0, r3
 1382 004e FFF7FEFF 		bl	xTaskRemoveFromEventList
 1383 0052 0346     		mov	r3, r0
 1384 0054 002B     		cmp	r3, #0
 1385 0056 07D0     		beq	.L83
1484:Source/queue.c **** 					{
1485:Source/queue.c **** 						queueYIELD_IF_USING_PREEMPTION();
 1386              		.loc 1 1485 0
 1387 0058 4C4B     		ldr	r3, .L97
 1388 005a 4FF08052 		mov	r2, #268435456
 1389 005e 1A60     		str	r2, [r3]
 1390              		.syntax unified
 1391              	@ 1485 "Source\queue.c" 1
 1392 0060 BFF34F8F 		dsb
 1393              	@ 0 "" 2
 1394              	@ 1485 "Source\queue.c" 1
 1395 0064 BFF36F8F 		isb
 1396              	@ 0 "" 2
 1397              		.thumb
 1398              		.syntax unified
 1399              	.L83:
1486:Source/queue.c **** 					}
1487:Source/queue.c **** 					else
1488:Source/queue.c **** 					{
1489:Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1490:Source/queue.c **** 					}
1491:Source/queue.c **** 				}
1492:Source/queue.c **** 				else
1493:Source/queue.c **** 				{
1494:Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1495:Source/queue.c **** 				}
1496:Source/queue.c **** 
1497:Source/queue.c **** 				taskEXIT_CRITICAL();
 1400              		.loc 1 1497 0
 1401 0068 FFF7FEFF 		bl	vPortExitCritical
1498:Source/queue.c **** 				return pdPASS;
 1402              		.loc 1 1498 0
 1403 006c 0123     		movs	r3, #1
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 56


 1404 006e 89E0     		b	.L96
 1405              	.L81:
1499:Source/queue.c **** 			}
1500:Source/queue.c **** 			else
1501:Source/queue.c **** 			{
1502:Source/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
 1406              		.loc 1 1502 0
 1407 0070 3B68     		ldr	r3, [r7]
 1408 0072 002B     		cmp	r3, #0
 1409 0074 03D1     		bne	.L85
1503:Source/queue.c **** 				{
1504:Source/queue.c **** 					/* For inheritance to have occurred there must have been an
1505:Source/queue.c **** 					initial timeout, and an adjusted timeout cannot become 0, as
1506:Source/queue.c **** 					if it were 0 the function would have exited. */
1507:Source/queue.c **** 					#if( configUSE_MUTEXES == 1 )
1508:Source/queue.c **** 					{
1509:Source/queue.c **** 						configASSERT( xInheritanceOccurred == pdFALSE );
1510:Source/queue.c **** 					}
1511:Source/queue.c **** 					#endif /* configUSE_MUTEXES */
1512:Source/queue.c **** 
1513:Source/queue.c **** 					/* The semaphore count was 0 and no block time is specified
1514:Source/queue.c **** 					(or the block time has expired) so exit now. */
1515:Source/queue.c **** 					taskEXIT_CRITICAL();
 1410              		.loc 1 1515 0
 1411 0076 FFF7FEFF 		bl	vPortExitCritical
1516:Source/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
1517:Source/queue.c **** 					return errQUEUE_EMPTY;
 1412              		.loc 1 1517 0
 1413 007a 0023     		movs	r3, #0
 1414 007c 82E0     		b	.L96
 1415              	.L85:
1518:Source/queue.c **** 				}
1519:Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 1416              		.loc 1 1519 0
 1417 007e 7B6A     		ldr	r3, [r7, #36]
 1418 0080 002B     		cmp	r3, #0
 1419 0082 06D1     		bne	.L86
1520:Source/queue.c **** 				{
1521:Source/queue.c **** 					/* The semaphore count was 0 and a block time was specified
1522:Source/queue.c **** 					so configure the timeout structure ready to block. */
1523:Source/queue.c **** 					vTaskInternalSetTimeOutState( &xTimeOut );
 1420              		.loc 1 1523 0
 1421 0084 07F10C03 		add	r3, r7, #12
 1422 0088 1846     		mov	r0, r3
 1423 008a FFF7FEFF 		bl	vTaskInternalSetTimeOutState
1524:Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 1424              		.loc 1 1524 0
 1425 008e 0123     		movs	r3, #1
 1426 0090 7B62     		str	r3, [r7, #36]
 1427              	.L86:
 1428              	.LBE35:
1525:Source/queue.c **** 				}
1526:Source/queue.c **** 				else
1527:Source/queue.c **** 				{
1528:Source/queue.c **** 					/* Entry time was already set. */
1529:Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1530:Source/queue.c **** 				}
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 57


1531:Source/queue.c **** 			}
1532:Source/queue.c **** 		}
1533:Source/queue.c **** 		taskEXIT_CRITICAL();
 1429              		.loc 1 1533 0
 1430 0092 FFF7FEFF 		bl	vPortExitCritical
1534:Source/queue.c **** 
1535:Source/queue.c **** 		/* Interrupts and other tasks can give to and take from the semaphore
1536:Source/queue.c **** 		now the critical section has been exited. */
1537:Source/queue.c **** 
1538:Source/queue.c **** 		vTaskSuspendAll();
 1431              		.loc 1 1538 0
 1432 0096 FFF7FEFF 		bl	vTaskSuspendAll
1539:Source/queue.c **** 		prvLockQueue( pxQueue );
 1433              		.loc 1 1539 0
 1434 009a FFF7FEFF 		bl	vPortEnterCritical
 1435 009e FB69     		ldr	r3, [r7, #28]
 1436 00a0 93F84430 		ldrb	r3, [r3, #68]
 1437 00a4 5BB2     		sxtb	r3, r3
 1438 00a6 B3F1FF3F 		cmp	r3, #-1
 1439 00aa 03D1     		bne	.L87
 1440              		.loc 1 1539 0 is_stmt 0 discriminator 1
 1441 00ac FB69     		ldr	r3, [r7, #28]
 1442 00ae 0022     		movs	r2, #0
 1443 00b0 83F84420 		strb	r2, [r3, #68]
 1444              	.L87:
 1445              		.loc 1 1539 0 discriminator 3
 1446 00b4 FB69     		ldr	r3, [r7, #28]
 1447 00b6 93F84530 		ldrb	r3, [r3, #69]
 1448 00ba 5BB2     		sxtb	r3, r3
 1449 00bc B3F1FF3F 		cmp	r3, #-1
 1450 00c0 03D1     		bne	.L88
 1451              		.loc 1 1539 0 discriminator 4
 1452 00c2 FB69     		ldr	r3, [r7, #28]
 1453 00c4 0022     		movs	r2, #0
 1454 00c6 83F84520 		strb	r2, [r3, #69]
 1455              	.L88:
 1456              		.loc 1 1539 0 discriminator 6
 1457 00ca FFF7FEFF 		bl	vPortExitCritical
1540:Source/queue.c **** 
1541:Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
1542:Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 1458              		.loc 1 1542 0 is_stmt 1 discriminator 6
 1459 00ce 3A46     		mov	r2, r7
 1460 00d0 07F10C03 		add	r3, r7, #12
 1461 00d4 1146     		mov	r1, r2
 1462 00d6 1846     		mov	r0, r3
 1463 00d8 FFF7FEFF 		bl	xTaskCheckForTimeOut
 1464 00dc 0346     		mov	r3, r0
 1465 00de 002B     		cmp	r3, #0
 1466 00e0 32D1     		bne	.L89
1543:Source/queue.c **** 		{
1544:Source/queue.c **** 			/* A block time is specified and not expired.  If the semaphore
1545:Source/queue.c **** 			count is 0 then enter the Blocked state to wait for a semaphore to
1546:Source/queue.c **** 			become available.  As semaphores are implemented with queues the
1547:Source/queue.c **** 			queue being empty is equivalent to the semaphore count being 0. */
1548:Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 1467              		.loc 1 1548 0
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 58


 1468 00e2 F869     		ldr	r0, [r7, #28]
 1469 00e4 FFF7FEFF 		bl	prvIsQueueEmpty
 1470 00e8 0346     		mov	r3, r0
 1471 00ea 002B     		cmp	r3, #0
 1472 00ec 26D0     		beq	.L90
1549:Source/queue.c **** 			{
1550:Source/queue.c **** 				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
1551:Source/queue.c **** 
1552:Source/queue.c **** 				#if ( configUSE_MUTEXES == 1 )
1553:Source/queue.c **** 				{
1554:Source/queue.c **** 					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 1473              		.loc 1 1554 0
 1474 00ee FB69     		ldr	r3, [r7, #28]
 1475 00f0 1B68     		ldr	r3, [r3]
 1476 00f2 002B     		cmp	r3, #0
 1477 00f4 09D1     		bne	.L91
1555:Source/queue.c **** 					{
1556:Source/queue.c **** 						taskENTER_CRITICAL();
 1478              		.loc 1 1556 0
 1479 00f6 FFF7FEFF 		bl	vPortEnterCritical
1557:Source/queue.c **** 						{
1558:Source/queue.c **** 							xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
 1480              		.loc 1 1558 0
 1481 00fa FB69     		ldr	r3, [r7, #28]
 1482 00fc 9B68     		ldr	r3, [r3, #8]
 1483 00fe 1846     		mov	r0, r3
 1484 0100 FFF7FEFF 		bl	xTaskPriorityInherit
 1485 0104 3862     		str	r0, [r7, #32]
1559:Source/queue.c **** 						}
1560:Source/queue.c **** 						taskEXIT_CRITICAL();
 1486              		.loc 1 1560 0
 1487 0106 FFF7FEFF 		bl	vPortExitCritical
 1488              	.L91:
1561:Source/queue.c **** 					}
1562:Source/queue.c **** 					else
1563:Source/queue.c **** 					{
1564:Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1565:Source/queue.c **** 					}
1566:Source/queue.c **** 				}
1567:Source/queue.c **** 				#endif
1568:Source/queue.c **** 
1569:Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 1489              		.loc 1 1569 0
 1490 010a FB69     		ldr	r3, [r7, #28]
 1491 010c 2433     		adds	r3, r3, #36
 1492 010e 3A68     		ldr	r2, [r7]
 1493 0110 1146     		mov	r1, r2
 1494 0112 1846     		mov	r0, r3
 1495 0114 FFF7FEFF 		bl	vTaskPlaceOnEventList
1570:Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1496              		.loc 1 1570 0
 1497 0118 F869     		ldr	r0, [r7, #28]
 1498 011a FFF7FEFF 		bl	prvUnlockQueue
1571:Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 1499              		.loc 1 1571 0
 1500 011e FFF7FEFF 		bl	xTaskResumeAll
 1501 0122 0346     		mov	r3, r0
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 59


 1502 0124 002B     		cmp	r3, #0
 1503 0126 7FF476AF 		bne	.L95
1572:Source/queue.c **** 				{
1573:Source/queue.c **** 					portYIELD_WITHIN_API();
 1504              		.loc 1 1573 0
 1505 012a 184B     		ldr	r3, .L97
 1506 012c 4FF08052 		mov	r2, #268435456
 1507 0130 1A60     		str	r2, [r3]
 1508              		.syntax unified
 1509              	@ 1573 "Source\queue.c" 1
 1510 0132 BFF34F8F 		dsb
 1511              	@ 0 "" 2
 1512              	@ 1573 "Source\queue.c" 1
 1513 0136 BFF36F8F 		isb
 1514              	@ 0 "" 2
 1515              		.thumb
 1516              		.syntax unified
 1517 013a 6CE7     		b	.L95
 1518              	.L90:
1574:Source/queue.c **** 				}
1575:Source/queue.c **** 				else
1576:Source/queue.c **** 				{
1577:Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1578:Source/queue.c **** 				}
1579:Source/queue.c **** 			}
1580:Source/queue.c **** 			else
1581:Source/queue.c **** 			{
1582:Source/queue.c **** 				/* There was no timeout and the semaphore count was not 0, so
1583:Source/queue.c **** 				attempt to take the semaphore again. */
1584:Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1519              		.loc 1 1584 0
 1520 013c F869     		ldr	r0, [r7, #28]
 1521 013e FFF7FEFF 		bl	prvUnlockQueue
1585:Source/queue.c **** 				( void ) xTaskResumeAll();
 1522              		.loc 1 1585 0
 1523 0142 FFF7FEFF 		bl	xTaskResumeAll
 1524 0146 66E7     		b	.L95
 1525              	.L89:
1586:Source/queue.c **** 			}
1587:Source/queue.c **** 		}
1588:Source/queue.c **** 		else
1589:Source/queue.c **** 		{
1590:Source/queue.c **** 			/* Timed out. */
1591:Source/queue.c **** 			prvUnlockQueue( pxQueue );
 1526              		.loc 1 1591 0
 1527 0148 F869     		ldr	r0, [r7, #28]
 1528 014a FFF7FEFF 		bl	prvUnlockQueue
1592:Source/queue.c **** 			( void ) xTaskResumeAll();
 1529              		.loc 1 1592 0
 1530 014e FFF7FEFF 		bl	xTaskResumeAll
1593:Source/queue.c **** 
1594:Source/queue.c **** 			/* If the semaphore count is 0 exit now as the timeout has
1595:Source/queue.c **** 			expired.  Otherwise return to attempt to take the semaphore that is
1596:Source/queue.c **** 			known to be available.  As semaphores are implemented by queues the
1597:Source/queue.c **** 			queue being empty is equivalent to the semaphore count being 0. */
1598:Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 1531              		.loc 1 1598 0
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 60


 1532 0152 F869     		ldr	r0, [r7, #28]
 1533 0154 FFF7FEFF 		bl	prvIsQueueEmpty
 1534 0158 0346     		mov	r3, r0
 1535 015a 002B     		cmp	r3, #0
 1536 015c 3FF45BAF 		beq	.L95
1599:Source/queue.c **** 			{
1600:Source/queue.c **** 				#if ( configUSE_MUTEXES == 1 )
1601:Source/queue.c **** 				{
1602:Source/queue.c **** 					/* xInheritanceOccurred could only have be set if
1603:Source/queue.c **** 					pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
1604:Source/queue.c **** 					test the mutex type again to check it is actually a mutex. */
1605:Source/queue.c **** 					if( xInheritanceOccurred != pdFALSE )
 1537              		.loc 1 1605 0
 1538 0160 3B6A     		ldr	r3, [r7, #32]
 1539 0162 002B     		cmp	r3, #0
 1540 0164 0DD0     		beq	.L94
1606:Source/queue.c **** 					{
1607:Source/queue.c **** 						taskENTER_CRITICAL();
 1541              		.loc 1 1607 0
 1542 0166 FFF7FEFF 		bl	vPortEnterCritical
 1543              	.LBB36:
1608:Source/queue.c **** 						{
1609:Source/queue.c **** 							UBaseType_t uxHighestWaitingPriority;
1610:Source/queue.c **** 
1611:Source/queue.c **** 							/* This task blocking on the mutex caused another
1612:Source/queue.c **** 							task to inherit this task's priority.  Now this task
1613:Source/queue.c **** 							has timed out the priority should be disinherited
1614:Source/queue.c **** 							again, but only as low as the next highest priority
1615:Source/queue.c **** 							task that is waiting for the same mutex. */
1616:Source/queue.c **** 							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
 1544              		.loc 1 1616 0
 1545 016a F869     		ldr	r0, [r7, #28]
 1546 016c FFF7FEFF 		bl	prvGetDisinheritPriorityAfterTimeout
 1547 0170 7861     		str	r0, [r7, #20]
1617:Source/queue.c **** 							vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPri
 1548              		.loc 1 1617 0
 1549 0172 FB69     		ldr	r3, [r7, #28]
 1550 0174 9B68     		ldr	r3, [r3, #8]
 1551 0176 7969     		ldr	r1, [r7, #20]
 1552 0178 1846     		mov	r0, r3
 1553 017a FFF7FEFF 		bl	vTaskPriorityDisinheritAfterTimeout
 1554              	.LBE36:
1618:Source/queue.c **** 						}
1619:Source/queue.c **** 						taskEXIT_CRITICAL();
 1555              		.loc 1 1619 0
 1556 017e FFF7FEFF 		bl	vPortExitCritical
 1557              	.L94:
1620:Source/queue.c **** 					}
1621:Source/queue.c **** 				}
1622:Source/queue.c **** 				#endif /* configUSE_MUTEXES */
1623:Source/queue.c **** 
1624:Source/queue.c **** 				traceQUEUE_RECEIVE_FAILED( pxQueue );
1625:Source/queue.c **** 				return errQUEUE_EMPTY;
 1558              		.loc 1 1625 0
 1559 0182 0023     		movs	r3, #0
 1560              	.L96:
1626:Source/queue.c **** 			}
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 61


1627:Source/queue.c **** 			else
1628:Source/queue.c **** 			{
1629:Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
1630:Source/queue.c **** 			}
1631:Source/queue.c **** 		}
1632:Source/queue.c **** 	} /*lint -restore */
1633:Source/queue.c **** }
 1561              		.loc 1 1633 0 discriminator 3
 1562 0184 1846     		mov	r0, r3
 1563 0186 2837     		adds	r7, r7, #40
 1564              		.cfi_def_cfa_offset 8
 1565 0188 BD46     		mov	sp, r7
 1566              		.cfi_def_cfa_register 13
 1567              		@ sp needed
 1568 018a 80BD     		pop	{r7, pc}
 1569              	.L98:
 1570              		.align	2
 1571              	.L97:
 1572 018c 04ED00E0 		.word	-536810236
 1573              		.cfi_endproc
 1574              	.LFE80:
 1575              		.size	xQueueSemaphoreTake, .-xQueueSemaphoreTake
 1576              		.section	.text.xQueuePeek,"ax",%progbits
 1577              		.align	2
 1578              		.global	xQueuePeek
 1579              		.thumb
 1580              		.thumb_func
 1581              		.type	xQueuePeek, %function
 1582              	xQueuePeek:
 1583              	.LFB81:
1634:Source/queue.c **** /*-----------------------------------------------------------*/
1635:Source/queue.c **** 
1636:Source/queue.c **** BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
1637:Source/queue.c **** {
 1584              		.loc 1 1637 0
 1585              		.cfi_startproc
 1586              		@ args = 0, pretend = 0, frame = 40
 1587              		@ frame_needed = 1, uses_anonymous_args = 0
 1588 0000 80B5     		push	{r7, lr}
 1589              		.cfi_def_cfa_offset 8
 1590              		.cfi_offset 7, -8
 1591              		.cfi_offset 14, -4
 1592 0002 8AB0     		sub	sp, sp, #40
 1593              		.cfi_def_cfa_offset 48
 1594 0004 00AF     		add	r7, sp, #0
 1595              		.cfi_def_cfa_register 7
 1596 0006 F860     		str	r0, [r7, #12]
 1597 0008 B960     		str	r1, [r7, #8]
 1598 000a 7A60     		str	r2, [r7, #4]
1638:Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
 1599              		.loc 1 1638 0
 1600 000c 0023     		movs	r3, #0
 1601 000e 7B62     		str	r3, [r7, #36]
1639:Source/queue.c **** TimeOut_t xTimeOut;
1640:Source/queue.c **** int8_t *pcOriginalReadPosition;
1641:Source/queue.c **** Queue_t * const pxQueue = xQueue;
 1602              		.loc 1 1641 0
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 62


 1603 0010 FB68     		ldr	r3, [r7, #12]
 1604 0012 3B62     		str	r3, [r7, #32]
 1605              	.L111:
1642:Source/queue.c **** 
1643:Source/queue.c **** 	/* Check the pointer is not NULL. */
1644:Source/queue.c **** 	configASSERT( ( pxQueue ) );
1645:Source/queue.c **** 
1646:Source/queue.c **** 	/* The buffer into which data is received can only be NULL if the data size
1647:Source/queue.c **** 	is zero (so no data is copied into the buffer. */
1648:Source/queue.c **** 	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) )
1649:Source/queue.c **** 
1650:Source/queue.c **** 	/* Cannot block if the scheduler is suspended. */
1651:Source/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1652:Source/queue.c **** 	{
1653:Source/queue.c **** 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 )
1654:Source/queue.c **** 	}
1655:Source/queue.c **** 	#endif
1656:Source/queue.c **** 
1657:Source/queue.c **** 
1658:Source/queue.c **** 	/*lint -save -e904  This function relaxes the coding standard somewhat to
1659:Source/queue.c **** 	allow return statements within the function itself.  This is done in the
1660:Source/queue.c **** 	interest of execution time efficiency. */
1661:Source/queue.c **** 	for( ;; )
1662:Source/queue.c **** 	{
1663:Source/queue.c **** 		taskENTER_CRITICAL();
 1606              		.loc 1 1663 0
 1607 0014 FFF7FEFF 		bl	vPortEnterCritical
 1608              	.LBB37:
1664:Source/queue.c **** 		{
1665:Source/queue.c **** 			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 1609              		.loc 1 1665 0
 1610 0018 3B6A     		ldr	r3, [r7, #32]
 1611 001a 9B6B     		ldr	r3, [r3, #56]
 1612 001c FB61     		str	r3, [r7, #28]
1666:Source/queue.c **** 
1667:Source/queue.c **** 			/* Is there data in the queue now?  To be running the calling task
1668:Source/queue.c **** 			must be the highest priority task wanting to access the queue. */
1669:Source/queue.c **** 			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 1613              		.loc 1 1669 0
 1614 001e FB69     		ldr	r3, [r7, #28]
 1615 0020 002B     		cmp	r3, #0
 1616 0022 21D0     		beq	.L100
1670:Source/queue.c **** 			{
1671:Source/queue.c **** 				/* Remember the read position so it can be reset after the data
1672:Source/queue.c **** 				is read from the queue as this function is only peeking the
1673:Source/queue.c **** 				data, not removing it. */
1674:Source/queue.c **** 				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
 1617              		.loc 1 1674 0
 1618 0024 3B6A     		ldr	r3, [r7, #32]
 1619 0026 DB68     		ldr	r3, [r3, #12]
 1620 0028 BB61     		str	r3, [r7, #24]
1675:Source/queue.c **** 
1676:Source/queue.c **** 				prvCopyDataFromQueue( pxQueue, pvBuffer );
 1621              		.loc 1 1676 0
 1622 002a B968     		ldr	r1, [r7, #8]
 1623 002c 386A     		ldr	r0, [r7, #32]
 1624 002e FFF7FEFF 		bl	prvCopyDataFromQueue
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 63


1677:Source/queue.c **** 				traceQUEUE_PEEK( pxQueue );
1678:Source/queue.c **** 
1679:Source/queue.c **** 				/* The data is not being removed, so reset the read pointer. */
1680:Source/queue.c **** 				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
 1625              		.loc 1 1680 0
 1626 0032 3B6A     		ldr	r3, [r7, #32]
 1627 0034 BA69     		ldr	r2, [r7, #24]
 1628 0036 DA60     		str	r2, [r3, #12]
1681:Source/queue.c **** 
1682:Source/queue.c **** 				/* The data is being left in the queue, so see if there are
1683:Source/queue.c **** 				any other tasks waiting for the data. */
1684:Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 1629              		.loc 1 1684 0
 1630 0038 3B6A     		ldr	r3, [r7, #32]
 1631 003a 5B6A     		ldr	r3, [r3, #36]
 1632 003c 002B     		cmp	r3, #0
 1633 003e 0FD0     		beq	.L101
1685:Source/queue.c **** 				{
1686:Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 1634              		.loc 1 1686 0
 1635 0040 3B6A     		ldr	r3, [r7, #32]
 1636 0042 2433     		adds	r3, r3, #36
 1637 0044 1846     		mov	r0, r3
 1638 0046 FFF7FEFF 		bl	xTaskRemoveFromEventList
 1639 004a 0346     		mov	r3, r0
 1640 004c 002B     		cmp	r3, #0
 1641 004e 07D0     		beq	.L101
1687:Source/queue.c **** 					{
1688:Source/queue.c **** 						/* The task waiting has a higher priority than this task. */
1689:Source/queue.c **** 						queueYIELD_IF_USING_PREEMPTION();
 1642              		.loc 1 1689 0
 1643 0050 3C4B     		ldr	r3, .L113
 1644 0052 4FF08052 		mov	r2, #268435456
 1645 0056 1A60     		str	r2, [r3]
 1646              		.syntax unified
 1647              	@ 1689 "Source\queue.c" 1
 1648 0058 BFF34F8F 		dsb
 1649              	@ 0 "" 2
 1650              	@ 1689 "Source\queue.c" 1
 1651 005c BFF36F8F 		isb
 1652              	@ 0 "" 2
 1653              		.thumb
 1654              		.syntax unified
 1655              	.L101:
1690:Source/queue.c **** 					}
1691:Source/queue.c **** 					else
1692:Source/queue.c **** 					{
1693:Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1694:Source/queue.c **** 					}
1695:Source/queue.c **** 				}
1696:Source/queue.c **** 				else
1697:Source/queue.c **** 				{
1698:Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1699:Source/queue.c **** 				}
1700:Source/queue.c **** 
1701:Source/queue.c **** 				taskEXIT_CRITICAL();
 1656              		.loc 1 1701 0
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 64


 1657 0060 FFF7FEFF 		bl	vPortExitCritical
1702:Source/queue.c **** 				return pdPASS;
 1658              		.loc 1 1702 0
 1659 0064 0123     		movs	r3, #1
 1660 0066 69E0     		b	.L112
 1661              	.L100:
1703:Source/queue.c **** 			}
1704:Source/queue.c **** 			else
1705:Source/queue.c **** 			{
1706:Source/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
 1662              		.loc 1 1706 0
 1663 0068 7B68     		ldr	r3, [r7, #4]
 1664 006a 002B     		cmp	r3, #0
 1665 006c 03D1     		bne	.L103
1707:Source/queue.c **** 				{
1708:Source/queue.c **** 					/* The queue was empty and no block time is specified (or
1709:Source/queue.c **** 					the block time has expired) so leave now. */
1710:Source/queue.c **** 					taskEXIT_CRITICAL();
 1666              		.loc 1 1710 0
 1667 006e FFF7FEFF 		bl	vPortExitCritical
1711:Source/queue.c **** 					traceQUEUE_PEEK_FAILED( pxQueue );
1712:Source/queue.c **** 					return errQUEUE_EMPTY;
 1668              		.loc 1 1712 0
 1669 0072 0023     		movs	r3, #0
 1670 0074 62E0     		b	.L112
 1671              	.L103:
1713:Source/queue.c **** 				}
1714:Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 1672              		.loc 1 1714 0
 1673 0076 7B6A     		ldr	r3, [r7, #36]
 1674 0078 002B     		cmp	r3, #0
 1675 007a 06D1     		bne	.L104
1715:Source/queue.c **** 				{
1716:Source/queue.c **** 					/* The queue was empty and a block time was specified so
1717:Source/queue.c **** 					configure the timeout structure ready to enter the blocked
1718:Source/queue.c **** 					state. */
1719:Source/queue.c **** 					vTaskInternalSetTimeOutState( &xTimeOut );
 1676              		.loc 1 1719 0
 1677 007c 07F11003 		add	r3, r7, #16
 1678 0080 1846     		mov	r0, r3
 1679 0082 FFF7FEFF 		bl	vTaskInternalSetTimeOutState
1720:Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 1680              		.loc 1 1720 0
 1681 0086 0123     		movs	r3, #1
 1682 0088 7B62     		str	r3, [r7, #36]
 1683              	.L104:
 1684              	.LBE37:
1721:Source/queue.c **** 				}
1722:Source/queue.c **** 				else
1723:Source/queue.c **** 				{
1724:Source/queue.c **** 					/* Entry time was already set. */
1725:Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1726:Source/queue.c **** 				}
1727:Source/queue.c **** 			}
1728:Source/queue.c **** 		}
1729:Source/queue.c **** 		taskEXIT_CRITICAL();
 1685              		.loc 1 1729 0
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 65


 1686 008a FFF7FEFF 		bl	vPortExitCritical
1730:Source/queue.c **** 
1731:Source/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
1732:Source/queue.c **** 		now the critical section has been exited. */
1733:Source/queue.c **** 
1734:Source/queue.c **** 		vTaskSuspendAll();
 1687              		.loc 1 1734 0
 1688 008e FFF7FEFF 		bl	vTaskSuspendAll
1735:Source/queue.c **** 		prvLockQueue( pxQueue );
 1689              		.loc 1 1735 0
 1690 0092 FFF7FEFF 		bl	vPortEnterCritical
 1691 0096 3B6A     		ldr	r3, [r7, #32]
 1692 0098 93F84430 		ldrb	r3, [r3, #68]
 1693 009c 5BB2     		sxtb	r3, r3
 1694 009e B3F1FF3F 		cmp	r3, #-1
 1695 00a2 03D1     		bne	.L105
 1696              		.loc 1 1735 0 is_stmt 0 discriminator 1
 1697 00a4 3B6A     		ldr	r3, [r7, #32]
 1698 00a6 0022     		movs	r2, #0
 1699 00a8 83F84420 		strb	r2, [r3, #68]
 1700              	.L105:
 1701              		.loc 1 1735 0 discriminator 3
 1702 00ac 3B6A     		ldr	r3, [r7, #32]
 1703 00ae 93F84530 		ldrb	r3, [r3, #69]
 1704 00b2 5BB2     		sxtb	r3, r3
 1705 00b4 B3F1FF3F 		cmp	r3, #-1
 1706 00b8 03D1     		bne	.L106
 1707              		.loc 1 1735 0 discriminator 4
 1708 00ba 3B6A     		ldr	r3, [r7, #32]
 1709 00bc 0022     		movs	r2, #0
 1710 00be 83F84520 		strb	r2, [r3, #69]
 1711              	.L106:
 1712              		.loc 1 1735 0 discriminator 6
 1713 00c2 FFF7FEFF 		bl	vPortExitCritical
1736:Source/queue.c **** 
1737:Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
1738:Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 1714              		.loc 1 1738 0 is_stmt 1 discriminator 6
 1715 00c6 3A1D     		adds	r2, r7, #4
 1716 00c8 07F11003 		add	r3, r7, #16
 1717 00cc 1146     		mov	r1, r2
 1718 00ce 1846     		mov	r0, r3
 1719 00d0 FFF7FEFF 		bl	xTaskCheckForTimeOut
 1720 00d4 0346     		mov	r3, r0
 1721 00d6 002B     		cmp	r3, #0
 1722 00d8 23D1     		bne	.L107
1739:Source/queue.c **** 		{
1740:Source/queue.c **** 			/* Timeout has not expired yet, check to see if there is data in the
1741:Source/queue.c **** 			queue now, and if not enter the Blocked state to wait for data. */
1742:Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 1723              		.loc 1 1742 0
 1724 00da 386A     		ldr	r0, [r7, #32]
 1725 00dc FFF7FEFF 		bl	prvIsQueueEmpty
 1726 00e0 0346     		mov	r3, r0
 1727 00e2 002B     		cmp	r3, #0
 1728 00e4 17D0     		beq	.L108
1743:Source/queue.c **** 			{
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 66


1744:Source/queue.c **** 				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
1745:Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 1729              		.loc 1 1745 0
 1730 00e6 3B6A     		ldr	r3, [r7, #32]
 1731 00e8 2433     		adds	r3, r3, #36
 1732 00ea 7A68     		ldr	r2, [r7, #4]
 1733 00ec 1146     		mov	r1, r2
 1734 00ee 1846     		mov	r0, r3
 1735 00f0 FFF7FEFF 		bl	vTaskPlaceOnEventList
1746:Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1736              		.loc 1 1746 0
 1737 00f4 386A     		ldr	r0, [r7, #32]
 1738 00f6 FFF7FEFF 		bl	prvUnlockQueue
1747:Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 1739              		.loc 1 1747 0
 1740 00fa FFF7FEFF 		bl	xTaskResumeAll
 1741 00fe 0346     		mov	r3, r0
 1742 0100 002B     		cmp	r3, #0
 1743 0102 87D1     		bne	.L111
1748:Source/queue.c **** 				{
1749:Source/queue.c **** 					portYIELD_WITHIN_API();
 1744              		.loc 1 1749 0
 1745 0104 0F4B     		ldr	r3, .L113
 1746 0106 4FF08052 		mov	r2, #268435456
 1747 010a 1A60     		str	r2, [r3]
 1748              		.syntax unified
 1749              	@ 1749 "Source\queue.c" 1
 1750 010c BFF34F8F 		dsb
 1751              	@ 0 "" 2
 1752              	@ 1749 "Source\queue.c" 1
 1753 0110 BFF36F8F 		isb
 1754              	@ 0 "" 2
 1755              		.thumb
 1756              		.syntax unified
 1757 0114 7EE7     		b	.L111
 1758              	.L108:
1750:Source/queue.c **** 				}
1751:Source/queue.c **** 				else
1752:Source/queue.c **** 				{
1753:Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1754:Source/queue.c **** 				}
1755:Source/queue.c **** 			}
1756:Source/queue.c **** 			else
1757:Source/queue.c **** 			{
1758:Source/queue.c **** 				/* There is data in the queue now, so don't enter the blocked
1759:Source/queue.c **** 				state, instead return to try and obtain the data. */
1760:Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1759              		.loc 1 1760 0
 1760 0116 386A     		ldr	r0, [r7, #32]
 1761 0118 FFF7FEFF 		bl	prvUnlockQueue
1761:Source/queue.c **** 				( void ) xTaskResumeAll();
 1762              		.loc 1 1761 0
 1763 011c FFF7FEFF 		bl	xTaskResumeAll
 1764 0120 78E7     		b	.L111
 1765              	.L107:
1762:Source/queue.c **** 			}
1763:Source/queue.c **** 		}
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 67


1764:Source/queue.c **** 		else
1765:Source/queue.c **** 		{
1766:Source/queue.c **** 			/* The timeout has expired.  If there is still no data in the queue
1767:Source/queue.c **** 			exit, otherwise go back and try to read the data again. */
1768:Source/queue.c **** 			prvUnlockQueue( pxQueue );
 1766              		.loc 1 1768 0
 1767 0122 386A     		ldr	r0, [r7, #32]
 1768 0124 FFF7FEFF 		bl	prvUnlockQueue
1769:Source/queue.c **** 			( void ) xTaskResumeAll();
 1769              		.loc 1 1769 0
 1770 0128 FFF7FEFF 		bl	xTaskResumeAll
1770:Source/queue.c **** 
1771:Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 1771              		.loc 1 1771 0
 1772 012c 386A     		ldr	r0, [r7, #32]
 1773 012e FFF7FEFF 		bl	prvIsQueueEmpty
 1774 0132 0346     		mov	r3, r0
 1775 0134 002B     		cmp	r3, #0
 1776 0136 3FF46DAF 		beq	.L111
1772:Source/queue.c **** 			{
1773:Source/queue.c **** 				traceQUEUE_PEEK_FAILED( pxQueue );
1774:Source/queue.c **** 				return errQUEUE_EMPTY;
 1777              		.loc 1 1774 0
 1778 013a 0023     		movs	r3, #0
 1779              	.L112:
1775:Source/queue.c **** 			}
1776:Source/queue.c **** 			else
1777:Source/queue.c **** 			{
1778:Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
1779:Source/queue.c **** 			}
1780:Source/queue.c **** 		}
1781:Source/queue.c **** 	} /*lint -restore */
1782:Source/queue.c **** }
 1780              		.loc 1 1782 0 discriminator 3
 1781 013c 1846     		mov	r0, r3
 1782 013e 2837     		adds	r7, r7, #40
 1783              		.cfi_def_cfa_offset 8
 1784 0140 BD46     		mov	sp, r7
 1785              		.cfi_def_cfa_register 13
 1786              		@ sp needed
 1787 0142 80BD     		pop	{r7, pc}
 1788              	.L114:
 1789              		.align	2
 1790              	.L113:
 1791 0144 04ED00E0 		.word	-536810236
 1792              		.cfi_endproc
 1793              	.LFE81:
 1794              		.size	xQueuePeek, .-xQueuePeek
 1795              		.section	.text.xQueueReceiveFromISR,"ax",%progbits
 1796              		.align	2
 1797              		.global	xQueueReceiveFromISR
 1798              		.thumb
 1799              		.thumb_func
 1800              		.type	xQueueReceiveFromISR, %function
 1801              	xQueueReceiveFromISR:
 1802              	.LFB82:
1783:Source/queue.c **** /*-----------------------------------------------------------*/
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 68


1784:Source/queue.c **** 
1785:Source/queue.c **** BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const px
1786:Source/queue.c **** {
 1803              		.loc 1 1786 0
 1804              		.cfi_startproc
 1805              		@ args = 0, pretend = 0, frame = 48
 1806              		@ frame_needed = 1, uses_anonymous_args = 0
 1807 0000 80B5     		push	{r7, lr}
 1808              		.cfi_def_cfa_offset 8
 1809              		.cfi_offset 7, -8
 1810              		.cfi_offset 14, -4
 1811 0002 8CB0     		sub	sp, sp, #48
 1812              		.cfi_def_cfa_offset 56
 1813 0004 00AF     		add	r7, sp, #0
 1814              		.cfi_def_cfa_register 7
 1815 0006 F860     		str	r0, [r7, #12]
 1816 0008 B960     		str	r1, [r7, #8]
 1817 000a 7A60     		str	r2, [r7, #4]
1787:Source/queue.c **** BaseType_t xReturn;
1788:Source/queue.c **** UBaseType_t uxSavedInterruptStatus;
1789:Source/queue.c **** Queue_t * const pxQueue = xQueue;
 1818              		.loc 1 1789 0
 1819 000c FB68     		ldr	r3, [r7, #12]
 1820 000e BB62     		str	r3, [r7, #40]
 1821              	.LBB38:
 1822              	.LBB39:
 213:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	(
 1823              		.loc 2 213 0
 1824              		.syntax unified
 1825              	@ 213 ".\Source\portable\GCC\ARM_CM3/portmacro.h" 1
 1826 0010 EFF31182 			mrs r2, basepri											
 1827 0014 4FF0A003 		mov r3, #160												
 1828 0018 83F31188 		msr basepri, r3											
 1829 001c BFF36F8F 		isb														
 1830 0020 BFF34F8F 		dsb														
 1831              	
 1832              	@ 0 "" 2
 1833              		.thumb
 1834              		.syntax unified
 1835 0024 7A61     		str	r2, [r7, #20]
 1836 0026 3B61     		str	r3, [r7, #16]
 225:.\Source\portable\GCC\ARM_CM3/portmacro.h **** }
 1837              		.loc 2 225 0
 1838 0028 7B69     		ldr	r3, [r7, #20]
 1839              	.LBE39:
 1840              	.LBE38:
1790:Source/queue.c **** 
1791:Source/queue.c **** 	configASSERT( pxQueue );
1792:Source/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1793:Source/queue.c **** 
1794:Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1795:Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1796:Source/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
1797:Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1798:Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1799:Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1800:Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 69


1801:Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
1802:Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1803:Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1804:Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1805:Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1806:Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1807:Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1808:Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1809:Source/queue.c **** 
1810:Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1841              		.loc 1 1810 0
 1842 002a 3B62     		str	r3, [r7, #32]
 1843              	.LBB40:
1811:Source/queue.c **** 	{
1812:Source/queue.c **** 		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 1844              		.loc 1 1812 0
 1845 002c BB6A     		ldr	r3, [r7, #40]
 1846 002e 9B6B     		ldr	r3, [r3, #56]
 1847 0030 FB61     		str	r3, [r7, #28]
1813:Source/queue.c **** 
1814:Source/queue.c **** 		/* Cannot block in an ISR, so check there is data available. */
1815:Source/queue.c **** 		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 1848              		.loc 1 1815 0
 1849 0032 FB69     		ldr	r3, [r7, #28]
 1850 0034 002B     		cmp	r3, #0
 1851 0036 2DD0     		beq	.L117
 1852              	.LBB41:
1816:Source/queue.c **** 		{
1817:Source/queue.c **** 			const int8_t cRxLock = pxQueue->cRxLock;
 1853              		.loc 1 1817 0
 1854 0038 BB6A     		ldr	r3, [r7, #40]
 1855 003a 93F84430 		ldrb	r3, [r3, #68]
 1856 003e FB76     		strb	r3, [r7, #27]
1818:Source/queue.c **** 
1819:Source/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
1820:Source/queue.c **** 
1821:Source/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
 1857              		.loc 1 1821 0
 1858 0040 B968     		ldr	r1, [r7, #8]
 1859 0042 B86A     		ldr	r0, [r7, #40]
 1860 0044 FFF7FEFF 		bl	prvCopyDataFromQueue
1822:Source/queue.c **** 			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 1861              		.loc 1 1822 0
 1862 0048 FB69     		ldr	r3, [r7, #28]
 1863 004a 5A1E     		subs	r2, r3, #1
 1864 004c BB6A     		ldr	r3, [r7, #40]
 1865 004e 9A63     		str	r2, [r3, #56]
1823:Source/queue.c **** 
1824:Source/queue.c **** 			/* If the queue is locked the event list will not be modified.
1825:Source/queue.c **** 			Instead update the lock count so the task that unlocks the queue
1826:Source/queue.c **** 			will know that an ISR has removed data while the queue was
1827:Source/queue.c **** 			locked. */
1828:Source/queue.c **** 			if( cRxLock == queueUNLOCKED )
 1866              		.loc 1 1828 0
 1867 0050 97F91B30 		ldrsb	r3, [r7, #27]
 1868 0054 B3F1FF3F 		cmp	r3, #-1
 1869 0058 12D1     		bne	.L118
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 70


1829:Source/queue.c **** 			{
1830:Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 1870              		.loc 1 1830 0
 1871 005a BB6A     		ldr	r3, [r7, #40]
 1872 005c 1B69     		ldr	r3, [r3, #16]
 1873 005e 002B     		cmp	r3, #0
 1874 0060 15D0     		beq	.L119
1831:Source/queue.c **** 				{
1832:Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 1875              		.loc 1 1832 0
 1876 0062 BB6A     		ldr	r3, [r7, #40]
 1877 0064 1033     		adds	r3, r3, #16
 1878 0066 1846     		mov	r0, r3
 1879 0068 FFF7FEFF 		bl	xTaskRemoveFromEventList
 1880 006c 0346     		mov	r3, r0
 1881 006e 002B     		cmp	r3, #0
 1882 0070 0DD0     		beq	.L119
1833:Source/queue.c **** 					{
1834:Source/queue.c **** 						/* The task waiting has a higher priority than us so
1835:Source/queue.c **** 						force a context switch. */
1836:Source/queue.c **** 						if( pxHigherPriorityTaskWoken != NULL )
 1883              		.loc 1 1836 0
 1884 0072 7B68     		ldr	r3, [r7, #4]
 1885 0074 002B     		cmp	r3, #0
 1886 0076 0AD0     		beq	.L119
1837:Source/queue.c **** 						{
1838:Source/queue.c **** 							*pxHigherPriorityTaskWoken = pdTRUE;
 1887              		.loc 1 1838 0
 1888 0078 7B68     		ldr	r3, [r7, #4]
 1889 007a 0122     		movs	r2, #1
 1890 007c 1A60     		str	r2, [r3]
 1891 007e 06E0     		b	.L119
 1892              	.L118:
1839:Source/queue.c **** 						}
1840:Source/queue.c **** 						else
1841:Source/queue.c **** 						{
1842:Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1843:Source/queue.c **** 						}
1844:Source/queue.c **** 					}
1845:Source/queue.c **** 					else
1846:Source/queue.c **** 					{
1847:Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1848:Source/queue.c **** 					}
1849:Source/queue.c **** 				}
1850:Source/queue.c **** 				else
1851:Source/queue.c **** 				{
1852:Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1853:Source/queue.c **** 				}
1854:Source/queue.c **** 			}
1855:Source/queue.c **** 			else
1856:Source/queue.c **** 			{
1857:Source/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1858:Source/queue.c **** 				knows that data was removed while it was locked. */
1859:Source/queue.c **** 				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
 1893              		.loc 1 1859 0
 1894 0080 FB7E     		ldrb	r3, [r7, #27]	@ zero_extendqisi2
 1895 0082 0133     		adds	r3, r3, #1
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 71


 1896 0084 DBB2     		uxtb	r3, r3
 1897 0086 5AB2     		sxtb	r2, r3
 1898 0088 BB6A     		ldr	r3, [r7, #40]
 1899 008a 83F84420 		strb	r2, [r3, #68]
 1900              	.L119:
1860:Source/queue.c **** 			}
1861:Source/queue.c **** 
1862:Source/queue.c **** 			xReturn = pdPASS;
 1901              		.loc 1 1862 0
 1902 008e 0123     		movs	r3, #1
 1903 0090 FB62     		str	r3, [r7, #44]
 1904              	.LBE41:
 1905 0092 01E0     		b	.L120
 1906              	.L117:
1863:Source/queue.c **** 		}
1864:Source/queue.c **** 		else
1865:Source/queue.c **** 		{
1866:Source/queue.c **** 			xReturn = pdFAIL;
 1907              		.loc 1 1866 0
 1908 0094 0023     		movs	r3, #0
 1909 0096 FB62     		str	r3, [r7, #44]
 1910              	.L120:
 1911 0098 3B6A     		ldr	r3, [r7, #32]
 1912 009a 7B62     		str	r3, [r7, #36]
 1913              	.LBE40:
 1914              	.LBB42:
 1915              	.LBB43:
 1916              		.loc 2 231 0
 1917 009c 7B6A     		ldr	r3, [r7, #36]
 1918              		.syntax unified
 1919              	@ 231 ".\Source\portable\GCC\ARM_CM3/portmacro.h" 1
 1920 009e 83F31188 			msr basepri, r3	
 1921              	@ 0 "" 2
 1922              		.thumb
 1923              		.syntax unified
 1924              	.LBE43:
 1925              	.LBE42:
1867:Source/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
1868:Source/queue.c **** 		}
1869:Source/queue.c **** 	}
1870:Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1871:Source/queue.c **** 
1872:Source/queue.c **** 	return xReturn;
 1926              		.loc 1 1872 0
 1927 00a2 FB6A     		ldr	r3, [r7, #44]
1873:Source/queue.c **** }
 1928              		.loc 1 1873 0
 1929 00a4 1846     		mov	r0, r3
 1930 00a6 3037     		adds	r7, r7, #48
 1931              		.cfi_def_cfa_offset 8
 1932 00a8 BD46     		mov	sp, r7
 1933              		.cfi_def_cfa_register 13
 1934              		@ sp needed
 1935 00aa 80BD     		pop	{r7, pc}
 1936              		.cfi_endproc
 1937              	.LFE82:
 1938              		.size	xQueueReceiveFromISR, .-xQueueReceiveFromISR
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 72


 1939              		.section	.text.xQueuePeekFromISR,"ax",%progbits
 1940              		.align	2
 1941              		.global	xQueuePeekFromISR
 1942              		.thumb
 1943              		.thumb_func
 1944              		.type	xQueuePeekFromISR, %function
 1945              	xQueuePeekFromISR:
 1946              	.LFB83:
1874:Source/queue.c **** /*-----------------------------------------------------------*/
1875:Source/queue.c **** 
1876:Source/queue.c **** BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
1877:Source/queue.c **** {
 1947              		.loc 1 1877 0
 1948              		.cfi_startproc
 1949              		@ args = 0, pretend = 0, frame = 40
 1950              		@ frame_needed = 1, uses_anonymous_args = 0
 1951 0000 80B5     		push	{r7, lr}
 1952              		.cfi_def_cfa_offset 8
 1953              		.cfi_offset 7, -8
 1954              		.cfi_offset 14, -4
 1955 0002 8AB0     		sub	sp, sp, #40
 1956              		.cfi_def_cfa_offset 48
 1957 0004 00AF     		add	r7, sp, #0
 1958              		.cfi_def_cfa_register 7
 1959 0006 7860     		str	r0, [r7, #4]
 1960 0008 3960     		str	r1, [r7]
1878:Source/queue.c **** BaseType_t xReturn;
1879:Source/queue.c **** UBaseType_t uxSavedInterruptStatus;
1880:Source/queue.c **** int8_t *pcOriginalReadPosition;
1881:Source/queue.c **** Queue_t * const pxQueue = xQueue;
 1961              		.loc 1 1881 0
 1962 000a 7B68     		ldr	r3, [r7, #4]
 1963 000c 3B62     		str	r3, [r7, #32]
 1964              	.LBB44:
 1965              	.LBB45:
 213:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	(
 1966              		.loc 2 213 0
 1967              		.syntax unified
 1968              	@ 213 ".\Source\portable\GCC\ARM_CM3/portmacro.h" 1
 1969 000e EFF31182 			mrs r2, basepri											
 1970 0012 4FF0A003 		mov r3, #160												
 1971 0016 83F31188 		msr basepri, r3											
 1972 001a BFF36F8F 		isb														
 1973 001e BFF34F8F 		dsb														
 1974              	
 1975              	@ 0 "" 2
 1976              		.thumb
 1977              		.syntax unified
 1978 0022 3A61     		str	r2, [r7, #16]
 1979 0024 FB60     		str	r3, [r7, #12]
 225:.\Source\portable\GCC\ARM_CM3/portmacro.h **** }
 1980              		.loc 2 225 0
 1981 0026 3B69     		ldr	r3, [r7, #16]
 1982              	.LBE45:
 1983              	.LBE44:
1882:Source/queue.c **** 
1883:Source/queue.c **** 	configASSERT( pxQueue );
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 73


1884:Source/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1885:Source/queue.c **** 	configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
1886:Source/queue.c **** 
1887:Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1888:Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1889:Source/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
1890:Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1891:Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1892:Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1893:Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1894:Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
1895:Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1896:Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1897:Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1898:Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1899:Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1900:Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1901:Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1902:Source/queue.c **** 
1903:Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1984              		.loc 1 1903 0
 1985 0028 BB61     		str	r3, [r7, #24]
1904:Source/queue.c **** 	{
1905:Source/queue.c **** 		/* Cannot block in an ISR, so check there is data available. */
1906:Source/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 1986              		.loc 1 1906 0
 1987 002a 3B6A     		ldr	r3, [r7, #32]
 1988 002c 9B6B     		ldr	r3, [r3, #56]
 1989 002e 002B     		cmp	r3, #0
 1990 0030 0CD0     		beq	.L124
1907:Source/queue.c **** 		{
1908:Source/queue.c **** 			traceQUEUE_PEEK_FROM_ISR( pxQueue );
1909:Source/queue.c **** 
1910:Source/queue.c **** 			/* Remember the read position so it can be reset as nothing is
1911:Source/queue.c **** 			actually being removed from the queue. */
1912:Source/queue.c **** 			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
 1991              		.loc 1 1912 0
 1992 0032 3B6A     		ldr	r3, [r7, #32]
 1993 0034 DB68     		ldr	r3, [r3, #12]
 1994 0036 7B61     		str	r3, [r7, #20]
1913:Source/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
 1995              		.loc 1 1913 0
 1996 0038 3968     		ldr	r1, [r7]
 1997 003a 386A     		ldr	r0, [r7, #32]
 1998 003c FFF7FEFF 		bl	prvCopyDataFromQueue
1914:Source/queue.c **** 			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
 1999              		.loc 1 1914 0
 2000 0040 3B6A     		ldr	r3, [r7, #32]
 2001 0042 7A69     		ldr	r2, [r7, #20]
 2002 0044 DA60     		str	r2, [r3, #12]
1915:Source/queue.c **** 
1916:Source/queue.c **** 			xReturn = pdPASS;
 2003              		.loc 1 1916 0
 2004 0046 0123     		movs	r3, #1
 2005 0048 7B62     		str	r3, [r7, #36]
 2006 004a 01E0     		b	.L125
 2007              	.L124:
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 74


1917:Source/queue.c **** 		}
1918:Source/queue.c **** 		else
1919:Source/queue.c **** 		{
1920:Source/queue.c **** 			xReturn = pdFAIL;
 2008              		.loc 1 1920 0
 2009 004c 0023     		movs	r3, #0
 2010 004e 7B62     		str	r3, [r7, #36]
 2011              	.L125:
 2012 0050 BB69     		ldr	r3, [r7, #24]
 2013 0052 FB61     		str	r3, [r7, #28]
 2014              	.LBB46:
 2015              	.LBB47:
 2016              		.loc 2 231 0
 2017 0054 FB69     		ldr	r3, [r7, #28]
 2018              		.syntax unified
 2019              	@ 231 ".\Source\portable\GCC\ARM_CM3/portmacro.h" 1
 2020 0056 83F31188 			msr basepri, r3	
 2021              	@ 0 "" 2
 2022              		.thumb
 2023              		.syntax unified
 2024              	.LBE47:
 2025              	.LBE46:
1921:Source/queue.c **** 			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
1922:Source/queue.c **** 		}
1923:Source/queue.c **** 	}
1924:Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1925:Source/queue.c **** 
1926:Source/queue.c **** 	return xReturn;
 2026              		.loc 1 1926 0
 2027 005a 7B6A     		ldr	r3, [r7, #36]
1927:Source/queue.c **** }
 2028              		.loc 1 1927 0
 2029 005c 1846     		mov	r0, r3
 2030 005e 2837     		adds	r7, r7, #40
 2031              		.cfi_def_cfa_offset 8
 2032 0060 BD46     		mov	sp, r7
 2033              		.cfi_def_cfa_register 13
 2034              		@ sp needed
 2035 0062 80BD     		pop	{r7, pc}
 2036              		.cfi_endproc
 2037              	.LFE83:
 2038              		.size	xQueuePeekFromISR, .-xQueuePeekFromISR
 2039              		.section	.text.uxQueueMessagesWaiting,"ax",%progbits
 2040              		.align	2
 2041              		.global	uxQueueMessagesWaiting
 2042              		.thumb
 2043              		.thumb_func
 2044              		.type	uxQueueMessagesWaiting, %function
 2045              	uxQueueMessagesWaiting:
 2046              	.LFB84:
1928:Source/queue.c **** /*-----------------------------------------------------------*/
1929:Source/queue.c **** 
1930:Source/queue.c **** UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
1931:Source/queue.c **** {
 2047              		.loc 1 1931 0
 2048              		.cfi_startproc
 2049              		@ args = 0, pretend = 0, frame = 16
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 75


 2050              		@ frame_needed = 1, uses_anonymous_args = 0
 2051 0000 80B5     		push	{r7, lr}
 2052              		.cfi_def_cfa_offset 8
 2053              		.cfi_offset 7, -8
 2054              		.cfi_offset 14, -4
 2055 0002 84B0     		sub	sp, sp, #16
 2056              		.cfi_def_cfa_offset 24
 2057 0004 00AF     		add	r7, sp, #0
 2058              		.cfi_def_cfa_register 7
 2059 0006 7860     		str	r0, [r7, #4]
1932:Source/queue.c **** UBaseType_t uxReturn;
1933:Source/queue.c **** 
1934:Source/queue.c **** 	configASSERT( xQueue );
1935:Source/queue.c **** 
1936:Source/queue.c **** 	taskENTER_CRITICAL();
 2060              		.loc 1 1936 0
 2061 0008 FFF7FEFF 		bl	vPortEnterCritical
1937:Source/queue.c **** 	{
1938:Source/queue.c **** 		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
 2062              		.loc 1 1938 0
 2063 000c 7B68     		ldr	r3, [r7, #4]
 2064 000e 9B6B     		ldr	r3, [r3, #56]
 2065 0010 FB60     		str	r3, [r7, #12]
1939:Source/queue.c **** 	}
1940:Source/queue.c **** 	taskEXIT_CRITICAL();
 2066              		.loc 1 1940 0
 2067 0012 FFF7FEFF 		bl	vPortExitCritical
1941:Source/queue.c **** 
1942:Source/queue.c **** 	return uxReturn;
 2068              		.loc 1 1942 0
 2069 0016 FB68     		ldr	r3, [r7, #12]
1943:Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 2070              		.loc 1 1943 0
 2071 0018 1846     		mov	r0, r3
 2072 001a 1037     		adds	r7, r7, #16
 2073              		.cfi_def_cfa_offset 8
 2074 001c BD46     		mov	sp, r7
 2075              		.cfi_def_cfa_register 13
 2076              		@ sp needed
 2077 001e 80BD     		pop	{r7, pc}
 2078              		.cfi_endproc
 2079              	.LFE84:
 2080              		.size	uxQueueMessagesWaiting, .-uxQueueMessagesWaiting
 2081              		.section	.text.uxQueueSpacesAvailable,"ax",%progbits
 2082              		.align	2
 2083              		.global	uxQueueSpacesAvailable
 2084              		.thumb
 2085              		.thumb_func
 2086              		.type	uxQueueSpacesAvailable, %function
 2087              	uxQueueSpacesAvailable:
 2088              	.LFB85:
1944:Source/queue.c **** /*-----------------------------------------------------------*/
1945:Source/queue.c **** 
1946:Source/queue.c **** UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
1947:Source/queue.c **** {
 2089              		.loc 1 1947 0
 2090              		.cfi_startproc
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 76


 2091              		@ args = 0, pretend = 0, frame = 16
 2092              		@ frame_needed = 1, uses_anonymous_args = 0
 2093 0000 80B5     		push	{r7, lr}
 2094              		.cfi_def_cfa_offset 8
 2095              		.cfi_offset 7, -8
 2096              		.cfi_offset 14, -4
 2097 0002 84B0     		sub	sp, sp, #16
 2098              		.cfi_def_cfa_offset 24
 2099 0004 00AF     		add	r7, sp, #0
 2100              		.cfi_def_cfa_register 7
 2101 0006 7860     		str	r0, [r7, #4]
1948:Source/queue.c **** UBaseType_t uxReturn;
1949:Source/queue.c **** Queue_t * const pxQueue = xQueue;
 2102              		.loc 1 1949 0
 2103 0008 7B68     		ldr	r3, [r7, #4]
 2104 000a FB60     		str	r3, [r7, #12]
1950:Source/queue.c **** 
1951:Source/queue.c **** 	configASSERT( pxQueue );
1952:Source/queue.c **** 
1953:Source/queue.c **** 	taskENTER_CRITICAL();
 2105              		.loc 1 1953 0
 2106 000c FFF7FEFF 		bl	vPortEnterCritical
1954:Source/queue.c **** 	{
1955:Source/queue.c **** 		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
 2107              		.loc 1 1955 0
 2108 0010 FB68     		ldr	r3, [r7, #12]
 2109 0012 DA6B     		ldr	r2, [r3, #60]
 2110 0014 FB68     		ldr	r3, [r7, #12]
 2111 0016 9B6B     		ldr	r3, [r3, #56]
 2112 0018 D31A     		subs	r3, r2, r3
 2113 001a BB60     		str	r3, [r7, #8]
1956:Source/queue.c **** 	}
1957:Source/queue.c **** 	taskEXIT_CRITICAL();
 2114              		.loc 1 1957 0
 2115 001c FFF7FEFF 		bl	vPortExitCritical
1958:Source/queue.c **** 
1959:Source/queue.c **** 	return uxReturn;
 2116              		.loc 1 1959 0
 2117 0020 BB68     		ldr	r3, [r7, #8]
1960:Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 2118              		.loc 1 1960 0
 2119 0022 1846     		mov	r0, r3
 2120 0024 1037     		adds	r7, r7, #16
 2121              		.cfi_def_cfa_offset 8
 2122 0026 BD46     		mov	sp, r7
 2123              		.cfi_def_cfa_register 13
 2124              		@ sp needed
 2125 0028 80BD     		pop	{r7, pc}
 2126              		.cfi_endproc
 2127              	.LFE85:
 2128              		.size	uxQueueSpacesAvailable, .-uxQueueSpacesAvailable
 2129 002a 00BF     		.section	.text.uxQueueMessagesWaitingFromISR,"ax",%progbits
 2130              		.align	2
 2131              		.global	uxQueueMessagesWaitingFromISR
 2132              		.thumb
 2133              		.thumb_func
 2134              		.type	uxQueueMessagesWaitingFromISR, %function
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 77


 2135              	uxQueueMessagesWaitingFromISR:
 2136              	.LFB86:
1961:Source/queue.c **** /*-----------------------------------------------------------*/
1962:Source/queue.c **** 
1963:Source/queue.c **** UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
1964:Source/queue.c **** {
 2137              		.loc 1 1964 0
 2138              		.cfi_startproc
 2139              		@ args = 0, pretend = 0, frame = 16
 2140              		@ frame_needed = 1, uses_anonymous_args = 0
 2141              		@ link register save eliminated.
 2142 0000 80B4     		push	{r7}
 2143              		.cfi_def_cfa_offset 4
 2144              		.cfi_offset 7, -4
 2145 0002 85B0     		sub	sp, sp, #20
 2146              		.cfi_def_cfa_offset 24
 2147 0004 00AF     		add	r7, sp, #0
 2148              		.cfi_def_cfa_register 7
 2149 0006 7860     		str	r0, [r7, #4]
1965:Source/queue.c **** UBaseType_t uxReturn;
1966:Source/queue.c **** Queue_t * const pxQueue = xQueue;
 2150              		.loc 1 1966 0
 2151 0008 7B68     		ldr	r3, [r7, #4]
 2152 000a FB60     		str	r3, [r7, #12]
1967:Source/queue.c **** 
1968:Source/queue.c **** 	configASSERT( pxQueue );
1969:Source/queue.c **** 	uxReturn = pxQueue->uxMessagesWaiting;
 2153              		.loc 1 1969 0
 2154 000c FB68     		ldr	r3, [r7, #12]
 2155 000e 9B6B     		ldr	r3, [r3, #56]
 2156 0010 BB60     		str	r3, [r7, #8]
1970:Source/queue.c **** 
1971:Source/queue.c **** 	return uxReturn;
 2157              		.loc 1 1971 0
 2158 0012 BB68     		ldr	r3, [r7, #8]
1972:Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 2159              		.loc 1 1972 0
 2160 0014 1846     		mov	r0, r3
 2161 0016 1437     		adds	r7, r7, #20
 2162              		.cfi_def_cfa_offset 4
 2163 0018 BD46     		mov	sp, r7
 2164              		.cfi_def_cfa_register 13
 2165              		@ sp needed
 2166 001a 80BC     		pop	{r7}
 2167              		.cfi_restore 7
 2168              		.cfi_def_cfa_offset 0
 2169 001c 7047     		bx	lr
 2170              		.cfi_endproc
 2171              	.LFE86:
 2172              		.size	uxQueueMessagesWaitingFromISR, .-uxQueueMessagesWaitingFromISR
 2173 001e 00BF     		.section	.text.vQueueDelete,"ax",%progbits
 2174              		.align	2
 2175              		.global	vQueueDelete
 2176              		.thumb
 2177              		.thumb_func
 2178              		.type	vQueueDelete, %function
 2179              	vQueueDelete:
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 78


 2180              	.LFB87:
1973:Source/queue.c **** /*-----------------------------------------------------------*/
1974:Source/queue.c **** 
1975:Source/queue.c **** void vQueueDelete( QueueHandle_t xQueue )
1976:Source/queue.c **** {
 2181              		.loc 1 1976 0
 2182              		.cfi_startproc
 2183              		@ args = 0, pretend = 0, frame = 16
 2184              		@ frame_needed = 1, uses_anonymous_args = 0
 2185 0000 80B5     		push	{r7, lr}
 2186              		.cfi_def_cfa_offset 8
 2187              		.cfi_offset 7, -8
 2188              		.cfi_offset 14, -4
 2189 0002 84B0     		sub	sp, sp, #16
 2190              		.cfi_def_cfa_offset 24
 2191 0004 00AF     		add	r7, sp, #0
 2192              		.cfi_def_cfa_register 7
 2193 0006 7860     		str	r0, [r7, #4]
1977:Source/queue.c **** Queue_t * const pxQueue = xQueue;
 2194              		.loc 1 1977 0
 2195 0008 7B68     		ldr	r3, [r7, #4]
 2196 000a FB60     		str	r3, [r7, #12]
1978:Source/queue.c **** 
1979:Source/queue.c **** 	configASSERT( pxQueue );
1980:Source/queue.c **** 	traceQUEUE_DELETE( pxQueue );
1981:Source/queue.c **** 
1982:Source/queue.c **** 	#if ( configQUEUE_REGISTRY_SIZE > 0 )
1983:Source/queue.c **** 	{
1984:Source/queue.c **** 		vQueueUnregisterQueue( pxQueue );
 2197              		.loc 1 1984 0
 2198 000c F868     		ldr	r0, [r7, #12]
 2199 000e FFF7FEFF 		bl	vQueueUnregisterQueue
1985:Source/queue.c **** 	}
1986:Source/queue.c **** 	#endif
1987:Source/queue.c **** 
1988:Source/queue.c **** 	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
1989:Source/queue.c **** 	{
1990:Source/queue.c **** 		/* The queue can only have been allocated dynamically - free it
1991:Source/queue.c **** 		again. */
1992:Source/queue.c **** 		vPortFree( pxQueue );
 2200              		.loc 1 1992 0
 2201 0012 F868     		ldr	r0, [r7, #12]
 2202 0014 FFF7FEFF 		bl	vPortFree
1993:Source/queue.c **** 	}
1994:Source/queue.c **** 	#elif( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
1995:Source/queue.c **** 	{
1996:Source/queue.c **** 		/* The queue could have been allocated statically or dynamically, so
1997:Source/queue.c **** 		check before attempting to free the memory. */
1998:Source/queue.c **** 		if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
1999:Source/queue.c **** 		{
2000:Source/queue.c **** 			vPortFree( pxQueue );
2001:Source/queue.c **** 		}
2002:Source/queue.c **** 		else
2003:Source/queue.c **** 		{
2004:Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2005:Source/queue.c **** 		}
2006:Source/queue.c **** 	}
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 79


2007:Source/queue.c **** 	#else
2008:Source/queue.c **** 	{
2009:Source/queue.c **** 		/* The queue must have been statically allocated, so is not going to be
2010:Source/queue.c **** 		deleted.  Avoid compiler warnings about the unused parameter. */
2011:Source/queue.c **** 		( void ) pxQueue;
2012:Source/queue.c **** 	}
2013:Source/queue.c **** 	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
2014:Source/queue.c **** }
 2203              		.loc 1 2014 0
 2204 0018 00BF     		nop
 2205 001a 1037     		adds	r7, r7, #16
 2206              		.cfi_def_cfa_offset 8
 2207 001c BD46     		mov	sp, r7
 2208              		.cfi_def_cfa_register 13
 2209              		@ sp needed
 2210 001e 80BD     		pop	{r7, pc}
 2211              		.cfi_endproc
 2212              	.LFE87:
 2213              		.size	vQueueDelete, .-vQueueDelete
 2214              		.section	.text.prvGetDisinheritPriorityAfterTimeout,"ax",%progbits
 2215              		.align	2
 2216              		.thumb
 2217              		.thumb_func
 2218              		.type	prvGetDisinheritPriorityAfterTimeout, %function
 2219              	prvGetDisinheritPriorityAfterTimeout:
 2220              	.LFB88:
2015:Source/queue.c **** /*-----------------------------------------------------------*/
2016:Source/queue.c **** 
2017:Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2018:Source/queue.c **** 
2019:Source/queue.c **** 	UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )
2020:Source/queue.c **** 	{
2021:Source/queue.c **** 		return ( ( Queue_t * ) xQueue )->uxQueueNumber;
2022:Source/queue.c **** 	}
2023:Source/queue.c **** 
2024:Source/queue.c **** #endif /* configUSE_TRACE_FACILITY */
2025:Source/queue.c **** /*-----------------------------------------------------------*/
2026:Source/queue.c **** 
2027:Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2028:Source/queue.c **** 
2029:Source/queue.c **** 	void vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber )
2030:Source/queue.c **** 	{
2031:Source/queue.c **** 		( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
2032:Source/queue.c **** 	}
2033:Source/queue.c **** 
2034:Source/queue.c **** #endif /* configUSE_TRACE_FACILITY */
2035:Source/queue.c **** /*-----------------------------------------------------------*/
2036:Source/queue.c **** 
2037:Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2038:Source/queue.c **** 
2039:Source/queue.c **** 	uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )
2040:Source/queue.c **** 	{
2041:Source/queue.c **** 		return ( ( Queue_t * ) xQueue )->ucQueueType;
2042:Source/queue.c **** 	}
2043:Source/queue.c **** 
2044:Source/queue.c **** #endif /* configUSE_TRACE_FACILITY */
2045:Source/queue.c **** /*-----------------------------------------------------------*/
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 80


2046:Source/queue.c **** 
2047:Source/queue.c **** #if( configUSE_MUTEXES == 1 )
2048:Source/queue.c **** 
2049:Source/queue.c **** 	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
2050:Source/queue.c **** 	{
 2221              		.loc 1 2050 0
 2222              		.cfi_startproc
 2223              		@ args = 0, pretend = 0, frame = 16
 2224              		@ frame_needed = 1, uses_anonymous_args = 0
 2225              		@ link register save eliminated.
 2226 0000 80B4     		push	{r7}
 2227              		.cfi_def_cfa_offset 4
 2228              		.cfi_offset 7, -4
 2229 0002 85B0     		sub	sp, sp, #20
 2230              		.cfi_def_cfa_offset 24
 2231 0004 00AF     		add	r7, sp, #0
 2232              		.cfi_def_cfa_register 7
 2233 0006 7860     		str	r0, [r7, #4]
2051:Source/queue.c **** 	UBaseType_t uxHighestPriorityOfWaitingTasks;
2052:Source/queue.c **** 
2053:Source/queue.c **** 		/* If a task waiting for a mutex causes the mutex holder to inherit a
2054:Source/queue.c **** 		priority, but the waiting task times out, then the holder should
2055:Source/queue.c **** 		disinherit the priority - but only down to the highest priority of any
2056:Source/queue.c **** 		other tasks that are waiting for the same mutex.  For this purpose,
2057:Source/queue.c **** 		return the priority of the highest priority task that is waiting for the
2058:Source/queue.c **** 		mutex. */
2059:Source/queue.c **** 		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
 2234              		.loc 1 2059 0
 2235 0008 7B68     		ldr	r3, [r7, #4]
 2236 000a 5B6A     		ldr	r3, [r3, #36]
 2237 000c 002B     		cmp	r3, #0
 2238 000e 06D0     		beq	.L135
2060:Source/queue.c **** 		{
2061:Source/queue.c **** 			uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET
 2239              		.loc 1 2061 0
 2240 0010 7B68     		ldr	r3, [r7, #4]
 2241 0012 1B6B     		ldr	r3, [r3, #48]
 2242 0014 1B68     		ldr	r3, [r3]
 2243 0016 C3F10503 		rsb	r3, r3, #5
 2244 001a FB60     		str	r3, [r7, #12]
 2245 001c 01E0     		b	.L136
 2246              	.L135:
2062:Source/queue.c **** 		}
2063:Source/queue.c **** 		else
2064:Source/queue.c **** 		{
2065:Source/queue.c **** 			uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
 2247              		.loc 1 2065 0
 2248 001e 0023     		movs	r3, #0
 2249 0020 FB60     		str	r3, [r7, #12]
 2250              	.L136:
2066:Source/queue.c **** 		}
2067:Source/queue.c **** 
2068:Source/queue.c **** 		return uxHighestPriorityOfWaitingTasks;
 2251              		.loc 1 2068 0
 2252 0022 FB68     		ldr	r3, [r7, #12]
2069:Source/queue.c **** 	}
 2253              		.loc 1 2069 0
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 81


 2254 0024 1846     		mov	r0, r3
 2255 0026 1437     		adds	r7, r7, #20
 2256              		.cfi_def_cfa_offset 4
 2257 0028 BD46     		mov	sp, r7
 2258              		.cfi_def_cfa_register 13
 2259              		@ sp needed
 2260 002a 80BC     		pop	{r7}
 2261              		.cfi_restore 7
 2262              		.cfi_def_cfa_offset 0
 2263 002c 7047     		bx	lr
 2264              		.cfi_endproc
 2265              	.LFE88:
 2266              		.size	prvGetDisinheritPriorityAfterTimeout, .-prvGetDisinheritPriorityAfterTimeout
 2267 002e 00BF     		.section	.text.prvCopyDataToQueue,"ax",%progbits
 2268              		.align	2
 2269              		.thumb
 2270              		.thumb_func
 2271              		.type	prvCopyDataToQueue, %function
 2272              	prvCopyDataToQueue:
 2273              	.LFB89:
2070:Source/queue.c **** 
2071:Source/queue.c **** #endif /* configUSE_MUTEXES */
2072:Source/queue.c **** /*-----------------------------------------------------------*/
2073:Source/queue.c **** 
2074:Source/queue.c **** static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const Bas
2075:Source/queue.c **** {
 2274              		.loc 1 2075 0
 2275              		.cfi_startproc
 2276              		@ args = 0, pretend = 0, frame = 24
 2277              		@ frame_needed = 1, uses_anonymous_args = 0
 2278 0000 80B5     		push	{r7, lr}
 2279              		.cfi_def_cfa_offset 8
 2280              		.cfi_offset 7, -8
 2281              		.cfi_offset 14, -4
 2282 0002 86B0     		sub	sp, sp, #24
 2283              		.cfi_def_cfa_offset 32
 2284 0004 00AF     		add	r7, sp, #0
 2285              		.cfi_def_cfa_register 7
 2286 0006 F860     		str	r0, [r7, #12]
 2287 0008 B960     		str	r1, [r7, #8]
 2288 000a 7A60     		str	r2, [r7, #4]
2076:Source/queue.c **** BaseType_t xReturn = pdFALSE;
 2289              		.loc 1 2076 0
 2290 000c 0023     		movs	r3, #0
 2291 000e 7B61     		str	r3, [r7, #20]
2077:Source/queue.c **** UBaseType_t uxMessagesWaiting;
2078:Source/queue.c **** 
2079:Source/queue.c **** 	/* This function is called from a critical section. */
2080:Source/queue.c **** 
2081:Source/queue.c **** 	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 2292              		.loc 1 2081 0
 2293 0010 FB68     		ldr	r3, [r7, #12]
 2294 0012 9B6B     		ldr	r3, [r3, #56]
 2295 0014 3B61     		str	r3, [r7, #16]
2082:Source/queue.c **** 
2083:Source/queue.c **** 	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 2296              		.loc 1 2083 0
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 82


 2297 0016 FB68     		ldr	r3, [r7, #12]
 2298 0018 1B6C     		ldr	r3, [r3, #64]
 2299 001a 002B     		cmp	r3, #0
 2300 001c 0DD1     		bne	.L139
2084:Source/queue.c **** 	{
2085:Source/queue.c **** 		#if ( configUSE_MUTEXES == 1 )
2086:Source/queue.c **** 		{
2087:Source/queue.c **** 			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 2301              		.loc 1 2087 0
 2302 001e FB68     		ldr	r3, [r7, #12]
 2303 0020 1B68     		ldr	r3, [r3]
 2304 0022 002B     		cmp	r3, #0
 2305 0024 4DD1     		bne	.L140
2088:Source/queue.c **** 			{
2089:Source/queue.c **** 				/* The mutex is no longer being held. */
2090:Source/queue.c **** 				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
 2306              		.loc 1 2090 0
 2307 0026 FB68     		ldr	r3, [r7, #12]
 2308 0028 9B68     		ldr	r3, [r3, #8]
 2309 002a 1846     		mov	r0, r3
 2310 002c FFF7FEFF 		bl	xTaskPriorityDisinherit
 2311 0030 7861     		str	r0, [r7, #20]
2091:Source/queue.c **** 				pxQueue->u.xSemaphore.xMutexHolder = NULL;
 2312              		.loc 1 2091 0
 2313 0032 FB68     		ldr	r3, [r7, #12]
 2314 0034 0022     		movs	r2, #0
 2315 0036 9A60     		str	r2, [r3, #8]
 2316 0038 43E0     		b	.L140
 2317              	.L139:
2092:Source/queue.c **** 			}
2093:Source/queue.c **** 			else
2094:Source/queue.c **** 			{
2095:Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2096:Source/queue.c **** 			}
2097:Source/queue.c **** 		}
2098:Source/queue.c **** 		#endif /* configUSE_MUTEXES */
2099:Source/queue.c **** 	}
2100:Source/queue.c **** 	else if( xPosition == queueSEND_TO_BACK )
 2318              		.loc 1 2100 0
 2319 003a 7B68     		ldr	r3, [r7, #4]
 2320 003c 002B     		cmp	r3, #0
 2321 003e 19D1     		bne	.L141
2101:Source/queue.c **** 	{
2102:Source/queue.c **** 		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); 
 2322              		.loc 1 2102 0
 2323 0040 FB68     		ldr	r3, [r7, #12]
 2324 0042 5868     		ldr	r0, [r3, #4]
 2325 0044 FB68     		ldr	r3, [r7, #12]
 2326 0046 1B6C     		ldr	r3, [r3, #64]
 2327 0048 1A46     		mov	r2, r3
 2328 004a B968     		ldr	r1, [r7, #8]
 2329 004c FFF7FEFF 		bl	memcpy
2103:Source/queue.c **** 		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, esp
 2330              		.loc 1 2103 0
 2331 0050 FB68     		ldr	r3, [r7, #12]
 2332 0052 5A68     		ldr	r2, [r3, #4]
 2333 0054 FB68     		ldr	r3, [r7, #12]
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 83


 2334 0056 1B6C     		ldr	r3, [r3, #64]
 2335 0058 1A44     		add	r2, r2, r3
 2336 005a FB68     		ldr	r3, [r7, #12]
 2337 005c 5A60     		str	r2, [r3, #4]
2104:Source/queue.c **** 		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as co
 2338              		.loc 1 2104 0
 2339 005e FB68     		ldr	r3, [r7, #12]
 2340 0060 5A68     		ldr	r2, [r3, #4]
 2341 0062 FB68     		ldr	r3, [r7, #12]
 2342 0064 9B68     		ldr	r3, [r3, #8]
 2343 0066 9A42     		cmp	r2, r3
 2344 0068 2BD3     		bcc	.L140
2105:Source/queue.c **** 		{
2106:Source/queue.c **** 			pxQueue->pcWriteTo = pxQueue->pcHead;
 2345              		.loc 1 2106 0
 2346 006a FB68     		ldr	r3, [r7, #12]
 2347 006c 1A68     		ldr	r2, [r3]
 2348 006e FB68     		ldr	r3, [r7, #12]
 2349 0070 5A60     		str	r2, [r3, #4]
 2350 0072 26E0     		b	.L140
 2351              	.L141:
2107:Source/queue.c **** 		}
2108:Source/queue.c **** 		else
2109:Source/queue.c **** 		{
2110:Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2111:Source/queue.c **** 		}
2112:Source/queue.c **** 	}
2113:Source/queue.c **** 	else
2114:Source/queue.c **** 	{
2115:Source/queue.c **** 		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxIt
 2352              		.loc 1 2115 0
 2353 0074 FB68     		ldr	r3, [r7, #12]
 2354 0076 D868     		ldr	r0, [r3, #12]
 2355 0078 FB68     		ldr	r3, [r7, #12]
 2356 007a 1B6C     		ldr	r3, [r3, #64]
 2357 007c 1A46     		mov	r2, r3
 2358 007e B968     		ldr	r1, [r7, #8]
 2359 0080 FFF7FEFF 		bl	memcpy
2116:Source/queue.c **** 		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
 2360              		.loc 1 2116 0
 2361 0084 FB68     		ldr	r3, [r7, #12]
 2362 0086 DA68     		ldr	r2, [r3, #12]
 2363 0088 FB68     		ldr	r3, [r7, #12]
 2364 008a 1B6C     		ldr	r3, [r3, #64]
 2365 008c 5B42     		negs	r3, r3
 2366 008e 1A44     		add	r2, r2, r3
 2367 0090 FB68     		ldr	r3, [r7, #12]
 2368 0092 DA60     		str	r2, [r3, #12]
2117:Source/queue.c **** 		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as co
 2369              		.loc 1 2117 0
 2370 0094 FB68     		ldr	r3, [r7, #12]
 2371 0096 DA68     		ldr	r2, [r3, #12]
 2372 0098 FB68     		ldr	r3, [r7, #12]
 2373 009a 1B68     		ldr	r3, [r3]
 2374 009c 9A42     		cmp	r2, r3
 2375 009e 07D2     		bcs	.L142
2118:Source/queue.c **** 		{
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 84


2119:Source/queue.c **** 			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
 2376              		.loc 1 2119 0
 2377 00a0 FB68     		ldr	r3, [r7, #12]
 2378 00a2 9A68     		ldr	r2, [r3, #8]
 2379 00a4 FB68     		ldr	r3, [r7, #12]
 2380 00a6 1B6C     		ldr	r3, [r3, #64]
 2381 00a8 5B42     		negs	r3, r3
 2382 00aa 1A44     		add	r2, r2, r3
 2383 00ac FB68     		ldr	r3, [r7, #12]
 2384 00ae DA60     		str	r2, [r3, #12]
 2385              	.L142:
2120:Source/queue.c **** 		}
2121:Source/queue.c **** 		else
2122:Source/queue.c **** 		{
2123:Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2124:Source/queue.c **** 		}
2125:Source/queue.c **** 
2126:Source/queue.c **** 		if( xPosition == queueOVERWRITE )
 2386              		.loc 1 2126 0
 2387 00b0 7B68     		ldr	r3, [r7, #4]
 2388 00b2 022B     		cmp	r3, #2
 2389 00b4 05D1     		bne	.L140
2127:Source/queue.c **** 		{
2128:Source/queue.c **** 			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 2390              		.loc 1 2128 0
 2391 00b6 3B69     		ldr	r3, [r7, #16]
 2392 00b8 002B     		cmp	r3, #0
 2393 00ba 02D0     		beq	.L140
2129:Source/queue.c **** 			{
2130:Source/queue.c **** 				/* An item is not being added but overwritten, so subtract
2131:Source/queue.c **** 				one from the recorded number of items in the queue so when
2132:Source/queue.c **** 				one is added again below the number of recorded items remains
2133:Source/queue.c **** 				correct. */
2134:Source/queue.c **** 				--uxMessagesWaiting;
 2394              		.loc 1 2134 0
 2395 00bc 3B69     		ldr	r3, [r7, #16]
 2396 00be 013B     		subs	r3, r3, #1
 2397 00c0 3B61     		str	r3, [r7, #16]
 2398              	.L140:
2135:Source/queue.c **** 			}
2136:Source/queue.c **** 			else
2137:Source/queue.c **** 			{
2138:Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2139:Source/queue.c **** 			}
2140:Source/queue.c **** 		}
2141:Source/queue.c **** 		else
2142:Source/queue.c **** 		{
2143:Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2144:Source/queue.c **** 		}
2145:Source/queue.c **** 	}
2146:Source/queue.c **** 
2147:Source/queue.c **** 	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 2399              		.loc 1 2147 0
 2400 00c2 3B69     		ldr	r3, [r7, #16]
 2401 00c4 5A1C     		adds	r2, r3, #1
 2402 00c6 FB68     		ldr	r3, [r7, #12]
 2403 00c8 9A63     		str	r2, [r3, #56]
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 85


2148:Source/queue.c **** 
2149:Source/queue.c **** 	return xReturn;
 2404              		.loc 1 2149 0
 2405 00ca 7B69     		ldr	r3, [r7, #20]
2150:Source/queue.c **** }
 2406              		.loc 1 2150 0
 2407 00cc 1846     		mov	r0, r3
 2408 00ce 1837     		adds	r7, r7, #24
 2409              		.cfi_def_cfa_offset 8
 2410 00d0 BD46     		mov	sp, r7
 2411              		.cfi_def_cfa_register 13
 2412              		@ sp needed
 2413 00d2 80BD     		pop	{r7, pc}
 2414              		.cfi_endproc
 2415              	.LFE89:
 2416              		.size	prvCopyDataToQueue, .-prvCopyDataToQueue
 2417              		.section	.text.prvCopyDataFromQueue,"ax",%progbits
 2418              		.align	2
 2419              		.thumb
 2420              		.thumb_func
 2421              		.type	prvCopyDataFromQueue, %function
 2422              	prvCopyDataFromQueue:
 2423              	.LFB90:
2151:Source/queue.c **** /*-----------------------------------------------------------*/
2152:Source/queue.c **** 
2153:Source/queue.c **** static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
2154:Source/queue.c **** {
 2424              		.loc 1 2154 0
 2425              		.cfi_startproc
 2426              		@ args = 0, pretend = 0, frame = 8
 2427              		@ frame_needed = 1, uses_anonymous_args = 0
 2428 0000 80B5     		push	{r7, lr}
 2429              		.cfi_def_cfa_offset 8
 2430              		.cfi_offset 7, -8
 2431              		.cfi_offset 14, -4
 2432 0002 82B0     		sub	sp, sp, #8
 2433              		.cfi_def_cfa_offset 16
 2434 0004 00AF     		add	r7, sp, #0
 2435              		.cfi_def_cfa_register 7
 2436 0006 7860     		str	r0, [r7, #4]
 2437 0008 3960     		str	r1, [r7]
2155:Source/queue.c **** 	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 2438              		.loc 1 2155 0
 2439 000a 7B68     		ldr	r3, [r7, #4]
 2440 000c 1B6C     		ldr	r3, [r3, #64]
 2441 000e 002B     		cmp	r3, #0
 2442 0010 18D0     		beq	.L147
2156:Source/queue.c **** 	{
2157:Source/queue.c **** 		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char typ
 2443              		.loc 1 2157 0
 2444 0012 7B68     		ldr	r3, [r7, #4]
 2445 0014 DA68     		ldr	r2, [r3, #12]
 2446 0016 7B68     		ldr	r3, [r7, #4]
 2447 0018 1B6C     		ldr	r3, [r3, #64]
 2448 001a 1A44     		add	r2, r2, r3
 2449 001c 7B68     		ldr	r3, [r7, #4]
 2450 001e DA60     		str	r2, [r3, #12]
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 86


2158:Source/queue.c **** 		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justi
 2451              		.loc 1 2158 0
 2452 0020 7B68     		ldr	r3, [r7, #4]
 2453 0022 DA68     		ldr	r2, [r3, #12]
 2454 0024 7B68     		ldr	r3, [r7, #4]
 2455 0026 9B68     		ldr	r3, [r3, #8]
 2456 0028 9A42     		cmp	r2, r3
 2457 002a 03D3     		bcc	.L146
2159:Source/queue.c **** 		{
2160:Source/queue.c **** 			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
 2458              		.loc 1 2160 0
 2459 002c 7B68     		ldr	r3, [r7, #4]
 2460 002e 1A68     		ldr	r2, [r3]
 2461 0030 7B68     		ldr	r3, [r7, #4]
 2462 0032 DA60     		str	r2, [r3, #12]
 2463              	.L146:
2161:Source/queue.c **** 		}
2162:Source/queue.c **** 		else
2163:Source/queue.c **** 		{
2164:Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2165:Source/queue.c **** 		}
2166:Source/queue.c **** 		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue
 2464              		.loc 1 2166 0
 2465 0034 7B68     		ldr	r3, [r7, #4]
 2466 0036 D968     		ldr	r1, [r3, #12]
 2467 0038 7B68     		ldr	r3, [r7, #4]
 2468 003a 1B6C     		ldr	r3, [r3, #64]
 2469 003c 1A46     		mov	r2, r3
 2470 003e 3868     		ldr	r0, [r7]
 2471 0040 FFF7FEFF 		bl	memcpy
 2472              	.L147:
2167:Source/queue.c **** 	}
2168:Source/queue.c **** }
 2473              		.loc 1 2168 0
 2474 0044 00BF     		nop
 2475 0046 0837     		adds	r7, r7, #8
 2476              		.cfi_def_cfa_offset 8
 2477 0048 BD46     		mov	sp, r7
 2478              		.cfi_def_cfa_register 13
 2479              		@ sp needed
 2480 004a 80BD     		pop	{r7, pc}
 2481              		.cfi_endproc
 2482              	.LFE90:
 2483              		.size	prvCopyDataFromQueue, .-prvCopyDataFromQueue
 2484              		.section	.text.prvUnlockQueue,"ax",%progbits
 2485              		.align	2
 2486              		.thumb
 2487              		.thumb_func
 2488              		.type	prvUnlockQueue, %function
 2489              	prvUnlockQueue:
 2490              	.LFB91:
2169:Source/queue.c **** /*-----------------------------------------------------------*/
2170:Source/queue.c **** 
2171:Source/queue.c **** static void prvUnlockQueue( Queue_t * const pxQueue )
2172:Source/queue.c **** {
 2491              		.loc 1 2172 0
 2492              		.cfi_startproc
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 87


 2493              		@ args = 0, pretend = 0, frame = 16
 2494              		@ frame_needed = 1, uses_anonymous_args = 0
 2495 0000 80B5     		push	{r7, lr}
 2496              		.cfi_def_cfa_offset 8
 2497              		.cfi_offset 7, -8
 2498              		.cfi_offset 14, -4
 2499 0002 84B0     		sub	sp, sp, #16
 2500              		.cfi_def_cfa_offset 24
 2501 0004 00AF     		add	r7, sp, #0
 2502              		.cfi_def_cfa_register 7
 2503 0006 7860     		str	r0, [r7, #4]
2173:Source/queue.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
2174:Source/queue.c **** 
2175:Source/queue.c **** 	/* The lock counts contains the number of extra data items placed or
2176:Source/queue.c **** 	removed from the queue while the queue was locked.  When a queue is
2177:Source/queue.c **** 	locked items can be added or removed, but the event lists cannot be
2178:Source/queue.c **** 	updated. */
2179:Source/queue.c **** 	taskENTER_CRITICAL();
 2504              		.loc 1 2179 0
 2505 0008 FFF7FEFF 		bl	vPortEnterCritical
 2506              	.LBB48:
2180:Source/queue.c **** 	{
2181:Source/queue.c **** 		int8_t cTxLock = pxQueue->cTxLock;
 2507              		.loc 1 2181 0
 2508 000c 7B68     		ldr	r3, [r7, #4]
 2509 000e 93F84530 		ldrb	r3, [r3, #69]
 2510 0012 FB73     		strb	r3, [r7, #15]
2182:Source/queue.c **** 
2183:Source/queue.c **** 		/* See if data was added to the queue while it was locked. */
2184:Source/queue.c **** 		while( cTxLock > queueLOCKED_UNMODIFIED )
 2511              		.loc 1 2184 0
 2512 0014 11E0     		b	.L149
 2513              	.L153:
2185:Source/queue.c **** 		{
2186:Source/queue.c **** 			/* Data was posted while the queue was locked.  Are any tasks
2187:Source/queue.c **** 			blocked waiting for data to become available? */
2188:Source/queue.c **** 			#if ( configUSE_QUEUE_SETS == 1 )
2189:Source/queue.c **** 			{
2190:Source/queue.c **** 				if( pxQueue->pxQueueSetContainer != NULL )
2191:Source/queue.c **** 				{
2192:Source/queue.c **** 					if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
2193:Source/queue.c **** 					{
2194:Source/queue.c **** 						/* The queue is a member of a queue set, and posting to
2195:Source/queue.c **** 						the queue set caused a higher priority task to unblock.
2196:Source/queue.c **** 						A context switch is required. */
2197:Source/queue.c **** 						vTaskMissedYield();
2198:Source/queue.c **** 					}
2199:Source/queue.c **** 					else
2200:Source/queue.c **** 					{
2201:Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2202:Source/queue.c **** 					}
2203:Source/queue.c **** 				}
2204:Source/queue.c **** 				else
2205:Source/queue.c **** 				{
2206:Source/queue.c **** 					/* Tasks that are removed from the event list will get
2207:Source/queue.c **** 					added to the pending ready list as the scheduler is still
2208:Source/queue.c **** 					suspended. */
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 88


2209:Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2210:Source/queue.c **** 					{
2211:Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
2212:Source/queue.c **** 						{
2213:Source/queue.c **** 							/* The task waiting has a higher priority so record that a
2214:Source/queue.c **** 							context	switch is required. */
2215:Source/queue.c **** 							vTaskMissedYield();
2216:Source/queue.c **** 						}
2217:Source/queue.c **** 						else
2218:Source/queue.c **** 						{
2219:Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
2220:Source/queue.c **** 						}
2221:Source/queue.c **** 					}
2222:Source/queue.c **** 					else
2223:Source/queue.c **** 					{
2224:Source/queue.c **** 						break;
2225:Source/queue.c **** 					}
2226:Source/queue.c **** 				}
2227:Source/queue.c **** 			}
2228:Source/queue.c **** 			#else /* configUSE_QUEUE_SETS */
2229:Source/queue.c **** 			{
2230:Source/queue.c **** 				/* Tasks that are removed from the event list will get added to
2231:Source/queue.c **** 				the pending ready list as the scheduler is still suspended. */
2232:Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 2514              		.loc 1 2232 0
 2515 0016 7B68     		ldr	r3, [r7, #4]
 2516 0018 5B6A     		ldr	r3, [r3, #36]
 2517 001a 002B     		cmp	r3, #0
 2518 001c 12D0     		beq	.L159
2233:Source/queue.c **** 				{
2234:Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 2519              		.loc 1 2234 0
 2520 001e 7B68     		ldr	r3, [r7, #4]
 2521 0020 2433     		adds	r3, r3, #36
 2522 0022 1846     		mov	r0, r3
 2523 0024 FFF7FEFF 		bl	xTaskRemoveFromEventList
 2524 0028 0346     		mov	r3, r0
 2525 002a 002B     		cmp	r3, #0
 2526 002c 01D0     		beq	.L151
2235:Source/queue.c **** 					{
2236:Source/queue.c **** 						/* The task waiting has a higher priority so record that
2237:Source/queue.c **** 						a context switch is required. */
2238:Source/queue.c **** 						vTaskMissedYield();
 2527              		.loc 1 2238 0
 2528 002e FFF7FEFF 		bl	vTaskMissedYield
 2529              	.L151:
2239:Source/queue.c **** 					}
2240:Source/queue.c **** 					else
2241:Source/queue.c **** 					{
2242:Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2243:Source/queue.c **** 					}
2244:Source/queue.c **** 				}
2245:Source/queue.c **** 				else
2246:Source/queue.c **** 				{
2247:Source/queue.c **** 					break;
2248:Source/queue.c **** 				}
2249:Source/queue.c **** 			}
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 89


2250:Source/queue.c **** 			#endif /* configUSE_QUEUE_SETS */
2251:Source/queue.c **** 
2252:Source/queue.c **** 			--cTxLock;
 2530              		.loc 1 2252 0
 2531 0032 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 2532 0034 013B     		subs	r3, r3, #1
 2533 0036 DBB2     		uxtb	r3, r3
 2534 0038 FB73     		strb	r3, [r7, #15]
 2535              	.L149:
2184:Source/queue.c **** 		{
 2536              		.loc 1 2184 0
 2537 003a 97F90F30 		ldrsb	r3, [r7, #15]
 2538 003e 002B     		cmp	r3, #0
 2539 0040 E9DC     		bgt	.L153
 2540 0042 00E0     		b	.L152
 2541              	.L159:
2247:Source/queue.c **** 				}
 2542              		.loc 1 2247 0
 2543 0044 00BF     		nop
 2544              	.L152:
2253:Source/queue.c **** 		}
2254:Source/queue.c **** 
2255:Source/queue.c **** 		pxQueue->cTxLock = queueUNLOCKED;
 2545              		.loc 1 2255 0
 2546 0046 7B68     		ldr	r3, [r7, #4]
 2547 0048 FF22     		movs	r2, #255
 2548 004a 83F84520 		strb	r2, [r3, #69]
 2549              	.LBE48:
2256:Source/queue.c **** 	}
2257:Source/queue.c **** 	taskEXIT_CRITICAL();
 2550              		.loc 1 2257 0
 2551 004e FFF7FEFF 		bl	vPortExitCritical
2258:Source/queue.c **** 
2259:Source/queue.c **** 	/* Do the same for the Rx lock. */
2260:Source/queue.c **** 	taskENTER_CRITICAL();
 2552              		.loc 1 2260 0
 2553 0052 FFF7FEFF 		bl	vPortEnterCritical
 2554              	.LBB49:
2261:Source/queue.c **** 	{
2262:Source/queue.c **** 		int8_t cRxLock = pxQueue->cRxLock;
 2555              		.loc 1 2262 0
 2556 0056 7B68     		ldr	r3, [r7, #4]
 2557 0058 93F84430 		ldrb	r3, [r3, #68]
 2558 005c BB73     		strb	r3, [r7, #14]
2263:Source/queue.c **** 
2264:Source/queue.c **** 		while( cRxLock > queueLOCKED_UNMODIFIED )
 2559              		.loc 1 2264 0
 2560 005e 11E0     		b	.L154
 2561              	.L158:
2265:Source/queue.c **** 		{
2266:Source/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 2562              		.loc 1 2266 0
 2563 0060 7B68     		ldr	r3, [r7, #4]
 2564 0062 1B69     		ldr	r3, [r3, #16]
 2565 0064 002B     		cmp	r3, #0
 2566 0066 12D0     		beq	.L160
2267:Source/queue.c **** 			{
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 90


2268:Source/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 2567              		.loc 1 2268 0
 2568 0068 7B68     		ldr	r3, [r7, #4]
 2569 006a 1033     		adds	r3, r3, #16
 2570 006c 1846     		mov	r0, r3
 2571 006e FFF7FEFF 		bl	xTaskRemoveFromEventList
 2572 0072 0346     		mov	r3, r0
 2573 0074 002B     		cmp	r3, #0
 2574 0076 01D0     		beq	.L156
2269:Source/queue.c **** 				{
2270:Source/queue.c **** 					vTaskMissedYield();
 2575              		.loc 1 2270 0
 2576 0078 FFF7FEFF 		bl	vTaskMissedYield
 2577              	.L156:
2271:Source/queue.c **** 				}
2272:Source/queue.c **** 				else
2273:Source/queue.c **** 				{
2274:Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2275:Source/queue.c **** 				}
2276:Source/queue.c **** 
2277:Source/queue.c **** 				--cRxLock;
 2578              		.loc 1 2277 0
 2579 007c BB7B     		ldrb	r3, [r7, #14]	@ zero_extendqisi2
 2580 007e 013B     		subs	r3, r3, #1
 2581 0080 DBB2     		uxtb	r3, r3
 2582 0082 BB73     		strb	r3, [r7, #14]
 2583              	.L154:
2264:Source/queue.c **** 		{
 2584              		.loc 1 2264 0
 2585 0084 97F90E30 		ldrsb	r3, [r7, #14]
 2586 0088 002B     		cmp	r3, #0
 2587 008a E9DC     		bgt	.L158
 2588 008c 00E0     		b	.L157
 2589              	.L160:
2278:Source/queue.c **** 			}
2279:Source/queue.c **** 			else
2280:Source/queue.c **** 			{
2281:Source/queue.c **** 				break;
 2590              		.loc 1 2281 0
 2591 008e 00BF     		nop
 2592              	.L157:
2282:Source/queue.c **** 			}
2283:Source/queue.c **** 		}
2284:Source/queue.c **** 
2285:Source/queue.c **** 		pxQueue->cRxLock = queueUNLOCKED;
 2593              		.loc 1 2285 0
 2594 0090 7B68     		ldr	r3, [r7, #4]
 2595 0092 FF22     		movs	r2, #255
 2596 0094 83F84420 		strb	r2, [r3, #68]
 2597              	.LBE49:
2286:Source/queue.c **** 	}
2287:Source/queue.c **** 	taskEXIT_CRITICAL();
 2598              		.loc 1 2287 0
 2599 0098 FFF7FEFF 		bl	vPortExitCritical
2288:Source/queue.c **** }
 2600              		.loc 1 2288 0
 2601 009c 00BF     		nop
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 91


 2602 009e 1037     		adds	r7, r7, #16
 2603              		.cfi_def_cfa_offset 8
 2604 00a0 BD46     		mov	sp, r7
 2605              		.cfi_def_cfa_register 13
 2606              		@ sp needed
 2607 00a2 80BD     		pop	{r7, pc}
 2608              		.cfi_endproc
 2609              	.LFE91:
 2610              		.size	prvUnlockQueue, .-prvUnlockQueue
 2611              		.section	.text.prvIsQueueEmpty,"ax",%progbits
 2612              		.align	2
 2613              		.thumb
 2614              		.thumb_func
 2615              		.type	prvIsQueueEmpty, %function
 2616              	prvIsQueueEmpty:
 2617              	.LFB92:
2289:Source/queue.c **** /*-----------------------------------------------------------*/
2290:Source/queue.c **** 
2291:Source/queue.c **** static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
2292:Source/queue.c **** {
 2618              		.loc 1 2292 0
 2619              		.cfi_startproc
 2620              		@ args = 0, pretend = 0, frame = 16
 2621              		@ frame_needed = 1, uses_anonymous_args = 0
 2622 0000 80B5     		push	{r7, lr}
 2623              		.cfi_def_cfa_offset 8
 2624              		.cfi_offset 7, -8
 2625              		.cfi_offset 14, -4
 2626 0002 84B0     		sub	sp, sp, #16
 2627              		.cfi_def_cfa_offset 24
 2628 0004 00AF     		add	r7, sp, #0
 2629              		.cfi_def_cfa_register 7
 2630 0006 7860     		str	r0, [r7, #4]
2293:Source/queue.c **** BaseType_t xReturn;
2294:Source/queue.c **** 
2295:Source/queue.c **** 	taskENTER_CRITICAL();
 2631              		.loc 1 2295 0
 2632 0008 FFF7FEFF 		bl	vPortEnterCritical
2296:Source/queue.c **** 	{
2297:Source/queue.c **** 		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 2633              		.loc 1 2297 0
 2634 000c 7B68     		ldr	r3, [r7, #4]
 2635 000e 9B6B     		ldr	r3, [r3, #56]
 2636 0010 002B     		cmp	r3, #0
 2637 0012 02D1     		bne	.L162
2298:Source/queue.c **** 		{
2299:Source/queue.c **** 			xReturn = pdTRUE;
 2638              		.loc 1 2299 0
 2639 0014 0123     		movs	r3, #1
 2640 0016 FB60     		str	r3, [r7, #12]
 2641 0018 01E0     		b	.L163
 2642              	.L162:
2300:Source/queue.c **** 		}
2301:Source/queue.c **** 		else
2302:Source/queue.c **** 		{
2303:Source/queue.c **** 			xReturn = pdFALSE;
 2643              		.loc 1 2303 0
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 92


 2644 001a 0023     		movs	r3, #0
 2645 001c FB60     		str	r3, [r7, #12]
 2646              	.L163:
2304:Source/queue.c **** 		}
2305:Source/queue.c **** 	}
2306:Source/queue.c **** 	taskEXIT_CRITICAL();
 2647              		.loc 1 2306 0
 2648 001e FFF7FEFF 		bl	vPortExitCritical
2307:Source/queue.c **** 
2308:Source/queue.c **** 	return xReturn;
 2649              		.loc 1 2308 0
 2650 0022 FB68     		ldr	r3, [r7, #12]
2309:Source/queue.c **** }
 2651              		.loc 1 2309 0
 2652 0024 1846     		mov	r0, r3
 2653 0026 1037     		adds	r7, r7, #16
 2654              		.cfi_def_cfa_offset 8
 2655 0028 BD46     		mov	sp, r7
 2656              		.cfi_def_cfa_register 13
 2657              		@ sp needed
 2658 002a 80BD     		pop	{r7, pc}
 2659              		.cfi_endproc
 2660              	.LFE92:
 2661              		.size	prvIsQueueEmpty, .-prvIsQueueEmpty
 2662              		.section	.text.xQueueIsQueueEmptyFromISR,"ax",%progbits
 2663              		.align	2
 2664              		.global	xQueueIsQueueEmptyFromISR
 2665              		.thumb
 2666              		.thumb_func
 2667              		.type	xQueueIsQueueEmptyFromISR, %function
 2668              	xQueueIsQueueEmptyFromISR:
 2669              	.LFB93:
2310:Source/queue.c **** /*-----------------------------------------------------------*/
2311:Source/queue.c **** 
2312:Source/queue.c **** BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
2313:Source/queue.c **** {
 2670              		.loc 1 2313 0
 2671              		.cfi_startproc
 2672              		@ args = 0, pretend = 0, frame = 16
 2673              		@ frame_needed = 1, uses_anonymous_args = 0
 2674              		@ link register save eliminated.
 2675 0000 80B4     		push	{r7}
 2676              		.cfi_def_cfa_offset 4
 2677              		.cfi_offset 7, -4
 2678 0002 85B0     		sub	sp, sp, #20
 2679              		.cfi_def_cfa_offset 24
 2680 0004 00AF     		add	r7, sp, #0
 2681              		.cfi_def_cfa_register 7
 2682 0006 7860     		str	r0, [r7, #4]
2314:Source/queue.c **** BaseType_t xReturn;
2315:Source/queue.c **** Queue_t * const pxQueue = xQueue;
 2683              		.loc 1 2315 0
 2684 0008 7B68     		ldr	r3, [r7, #4]
 2685 000a BB60     		str	r3, [r7, #8]
2316:Source/queue.c **** 
2317:Source/queue.c **** 	configASSERT( pxQueue );
2318:Source/queue.c **** 	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 93


 2686              		.loc 1 2318 0
 2687 000c BB68     		ldr	r3, [r7, #8]
 2688 000e 9B6B     		ldr	r3, [r3, #56]
 2689 0010 002B     		cmp	r3, #0
 2690 0012 02D1     		bne	.L166
2319:Source/queue.c **** 	{
2320:Source/queue.c **** 		xReturn = pdTRUE;
 2691              		.loc 1 2320 0
 2692 0014 0123     		movs	r3, #1
 2693 0016 FB60     		str	r3, [r7, #12]
 2694 0018 01E0     		b	.L167
 2695              	.L166:
2321:Source/queue.c **** 	}
2322:Source/queue.c **** 	else
2323:Source/queue.c **** 	{
2324:Source/queue.c **** 		xReturn = pdFALSE;
 2696              		.loc 1 2324 0
 2697 001a 0023     		movs	r3, #0
 2698 001c FB60     		str	r3, [r7, #12]
 2699              	.L167:
2325:Source/queue.c **** 	}
2326:Source/queue.c **** 
2327:Source/queue.c **** 	return xReturn;
 2700              		.loc 1 2327 0
 2701 001e FB68     		ldr	r3, [r7, #12]
2328:Source/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 2702              		.loc 1 2328 0
 2703 0020 1846     		mov	r0, r3
 2704 0022 1437     		adds	r7, r7, #20
 2705              		.cfi_def_cfa_offset 4
 2706 0024 BD46     		mov	sp, r7
 2707              		.cfi_def_cfa_register 13
 2708              		@ sp needed
 2709 0026 80BC     		pop	{r7}
 2710              		.cfi_restore 7
 2711              		.cfi_def_cfa_offset 0
 2712 0028 7047     		bx	lr
 2713              		.cfi_endproc
 2714              	.LFE93:
 2715              		.size	xQueueIsQueueEmptyFromISR, .-xQueueIsQueueEmptyFromISR
 2716 002a 00BF     		.section	.text.prvIsQueueFull,"ax",%progbits
 2717              		.align	2
 2718              		.thumb
 2719              		.thumb_func
 2720              		.type	prvIsQueueFull, %function
 2721              	prvIsQueueFull:
 2722              	.LFB94:
2329:Source/queue.c **** /*-----------------------------------------------------------*/
2330:Source/queue.c **** 
2331:Source/queue.c **** static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
2332:Source/queue.c **** {
 2723              		.loc 1 2332 0
 2724              		.cfi_startproc
 2725              		@ args = 0, pretend = 0, frame = 16
 2726              		@ frame_needed = 1, uses_anonymous_args = 0
 2727 0000 80B5     		push	{r7, lr}
 2728              		.cfi_def_cfa_offset 8
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 94


 2729              		.cfi_offset 7, -8
 2730              		.cfi_offset 14, -4
 2731 0002 84B0     		sub	sp, sp, #16
 2732              		.cfi_def_cfa_offset 24
 2733 0004 00AF     		add	r7, sp, #0
 2734              		.cfi_def_cfa_register 7
 2735 0006 7860     		str	r0, [r7, #4]
2333:Source/queue.c **** BaseType_t xReturn;
2334:Source/queue.c **** 
2335:Source/queue.c **** 	taskENTER_CRITICAL();
 2736              		.loc 1 2335 0
 2737 0008 FFF7FEFF 		bl	vPortEnterCritical
2336:Source/queue.c **** 	{
2337:Source/queue.c **** 		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 2738              		.loc 1 2337 0
 2739 000c 7B68     		ldr	r3, [r7, #4]
 2740 000e 9A6B     		ldr	r2, [r3, #56]
 2741 0010 7B68     		ldr	r3, [r7, #4]
 2742 0012 DB6B     		ldr	r3, [r3, #60]
 2743 0014 9A42     		cmp	r2, r3
 2744 0016 02D1     		bne	.L170
2338:Source/queue.c **** 		{
2339:Source/queue.c **** 			xReturn = pdTRUE;
 2745              		.loc 1 2339 0
 2746 0018 0123     		movs	r3, #1
 2747 001a FB60     		str	r3, [r7, #12]
 2748 001c 01E0     		b	.L171
 2749              	.L170:
2340:Source/queue.c **** 		}
2341:Source/queue.c **** 		else
2342:Source/queue.c **** 		{
2343:Source/queue.c **** 			xReturn = pdFALSE;
 2750              		.loc 1 2343 0
 2751 001e 0023     		movs	r3, #0
 2752 0020 FB60     		str	r3, [r7, #12]
 2753              	.L171:
2344:Source/queue.c **** 		}
2345:Source/queue.c **** 	}
2346:Source/queue.c **** 	taskEXIT_CRITICAL();
 2754              		.loc 1 2346 0
 2755 0022 FFF7FEFF 		bl	vPortExitCritical
2347:Source/queue.c **** 
2348:Source/queue.c **** 	return xReturn;
 2756              		.loc 1 2348 0
 2757 0026 FB68     		ldr	r3, [r7, #12]
2349:Source/queue.c **** }
 2758              		.loc 1 2349 0
 2759 0028 1846     		mov	r0, r3
 2760 002a 1037     		adds	r7, r7, #16
 2761              		.cfi_def_cfa_offset 8
 2762 002c BD46     		mov	sp, r7
 2763              		.cfi_def_cfa_register 13
 2764              		@ sp needed
 2765 002e 80BD     		pop	{r7, pc}
 2766              		.cfi_endproc
 2767              	.LFE94:
 2768              		.size	prvIsQueueFull, .-prvIsQueueFull
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 95


 2769              		.section	.text.xQueueIsQueueFullFromISR,"ax",%progbits
 2770              		.align	2
 2771              		.global	xQueueIsQueueFullFromISR
 2772              		.thumb
 2773              		.thumb_func
 2774              		.type	xQueueIsQueueFullFromISR, %function
 2775              	xQueueIsQueueFullFromISR:
 2776              	.LFB95:
2350:Source/queue.c **** /*-----------------------------------------------------------*/
2351:Source/queue.c **** 
2352:Source/queue.c **** BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
2353:Source/queue.c **** {
 2777              		.loc 1 2353 0
 2778              		.cfi_startproc
 2779              		@ args = 0, pretend = 0, frame = 16
 2780              		@ frame_needed = 1, uses_anonymous_args = 0
 2781              		@ link register save eliminated.
 2782 0000 80B4     		push	{r7}
 2783              		.cfi_def_cfa_offset 4
 2784              		.cfi_offset 7, -4
 2785 0002 85B0     		sub	sp, sp, #20
 2786              		.cfi_def_cfa_offset 24
 2787 0004 00AF     		add	r7, sp, #0
 2788              		.cfi_def_cfa_register 7
 2789 0006 7860     		str	r0, [r7, #4]
2354:Source/queue.c **** BaseType_t xReturn;
2355:Source/queue.c **** Queue_t * const pxQueue = xQueue;
 2790              		.loc 1 2355 0
 2791 0008 7B68     		ldr	r3, [r7, #4]
 2792 000a BB60     		str	r3, [r7, #8]
2356:Source/queue.c **** 
2357:Source/queue.c **** 	configASSERT( pxQueue );
2358:Source/queue.c **** 	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 2793              		.loc 1 2358 0
 2794 000c BB68     		ldr	r3, [r7, #8]
 2795 000e 9A6B     		ldr	r2, [r3, #56]
 2796 0010 BB68     		ldr	r3, [r7, #8]
 2797 0012 DB6B     		ldr	r3, [r3, #60]
 2798 0014 9A42     		cmp	r2, r3
 2799 0016 02D1     		bne	.L174
2359:Source/queue.c **** 	{
2360:Source/queue.c **** 		xReturn = pdTRUE;
 2800              		.loc 1 2360 0
 2801 0018 0123     		movs	r3, #1
 2802 001a FB60     		str	r3, [r7, #12]
 2803 001c 01E0     		b	.L175
 2804              	.L174:
2361:Source/queue.c **** 	}
2362:Source/queue.c **** 	else
2363:Source/queue.c **** 	{
2364:Source/queue.c **** 		xReturn = pdFALSE;
 2805              		.loc 1 2364 0
 2806 001e 0023     		movs	r3, #0
 2807 0020 FB60     		str	r3, [r7, #12]
 2808              	.L175:
2365:Source/queue.c **** 	}
2366:Source/queue.c **** 
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 96


2367:Source/queue.c **** 	return xReturn;
 2809              		.loc 1 2367 0
 2810 0022 FB68     		ldr	r3, [r7, #12]
2368:Source/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 2811              		.loc 1 2368 0
 2812 0024 1846     		mov	r0, r3
 2813 0026 1437     		adds	r7, r7, #20
 2814              		.cfi_def_cfa_offset 4
 2815 0028 BD46     		mov	sp, r7
 2816              		.cfi_def_cfa_register 13
 2817              		@ sp needed
 2818 002a 80BC     		pop	{r7}
 2819              		.cfi_restore 7
 2820              		.cfi_def_cfa_offset 0
 2821 002c 7047     		bx	lr
 2822              		.cfi_endproc
 2823              	.LFE95:
 2824              		.size	xQueueIsQueueFullFromISR, .-xQueueIsQueueFullFromISR
 2825 002e 00BF     		.section	.text.vQueueAddToRegistry,"ax",%progbits
 2826              		.align	2
 2827              		.global	vQueueAddToRegistry
 2828              		.thumb
 2829              		.thumb_func
 2830              		.type	vQueueAddToRegistry, %function
 2831              	vQueueAddToRegistry:
 2832              	.LFB96:
2369:Source/queue.c **** /*-----------------------------------------------------------*/
2370:Source/queue.c **** 
2371:Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2372:Source/queue.c **** 
2373:Source/queue.c **** 	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait 
2374:Source/queue.c **** 	{
2375:Source/queue.c **** 	BaseType_t xReturn;
2376:Source/queue.c **** 	Queue_t * const pxQueue = xQueue;
2377:Source/queue.c **** 
2378:Source/queue.c **** 		/* If the queue is already full we may have to block.  A critical section
2379:Source/queue.c **** 		is required to prevent an interrupt removing something from the queue
2380:Source/queue.c **** 		between the check to see if the queue is full and blocking on the queue. */
2381:Source/queue.c **** 		portDISABLE_INTERRUPTS();
2382:Source/queue.c **** 		{
2383:Source/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
2384:Source/queue.c **** 			{
2385:Source/queue.c **** 				/* The queue is full - do we want to block or just leave without
2386:Source/queue.c **** 				posting? */
2387:Source/queue.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
2388:Source/queue.c **** 				{
2389:Source/queue.c **** 					/* As this is called from a coroutine we cannot block directly, but
2390:Source/queue.c **** 					return indicating that we need to block. */
2391:Source/queue.c **** 					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
2392:Source/queue.c **** 					portENABLE_INTERRUPTS();
2393:Source/queue.c **** 					return errQUEUE_BLOCKED;
2394:Source/queue.c **** 				}
2395:Source/queue.c **** 				else
2396:Source/queue.c **** 				{
2397:Source/queue.c **** 					portENABLE_INTERRUPTS();
2398:Source/queue.c **** 					return errQUEUE_FULL;
2399:Source/queue.c **** 				}
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 97


2400:Source/queue.c **** 			}
2401:Source/queue.c **** 		}
2402:Source/queue.c **** 		portENABLE_INTERRUPTS();
2403:Source/queue.c **** 
2404:Source/queue.c **** 		portDISABLE_INTERRUPTS();
2405:Source/queue.c **** 		{
2406:Source/queue.c **** 			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
2407:Source/queue.c **** 			{
2408:Source/queue.c **** 				/* There is room in the queue, copy the data into the queue. */
2409:Source/queue.c **** 				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
2410:Source/queue.c **** 				xReturn = pdPASS;
2411:Source/queue.c **** 
2412:Source/queue.c **** 				/* Were any co-routines waiting for data to become available? */
2413:Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2414:Source/queue.c **** 				{
2415:Source/queue.c **** 					/* In this instance the co-routine could be placed directly
2416:Source/queue.c **** 					into the ready list as we are within a critical section.
2417:Source/queue.c **** 					Instead the same pending ready list mechanism is used as if
2418:Source/queue.c **** 					the event were caused from within an interrupt. */
2419:Source/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
2420:Source/queue.c **** 					{
2421:Source/queue.c **** 						/* The co-routine waiting has a higher priority so record
2422:Source/queue.c **** 						that a yield might be appropriate. */
2423:Source/queue.c **** 						xReturn = errQUEUE_YIELD;
2424:Source/queue.c **** 					}
2425:Source/queue.c **** 					else
2426:Source/queue.c **** 					{
2427:Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2428:Source/queue.c **** 					}
2429:Source/queue.c **** 				}
2430:Source/queue.c **** 				else
2431:Source/queue.c **** 				{
2432:Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2433:Source/queue.c **** 				}
2434:Source/queue.c **** 			}
2435:Source/queue.c **** 			else
2436:Source/queue.c **** 			{
2437:Source/queue.c **** 				xReturn = errQUEUE_FULL;
2438:Source/queue.c **** 			}
2439:Source/queue.c **** 		}
2440:Source/queue.c **** 		portENABLE_INTERRUPTS();
2441:Source/queue.c **** 
2442:Source/queue.c **** 		return xReturn;
2443:Source/queue.c **** 	}
2444:Source/queue.c **** 
2445:Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
2446:Source/queue.c **** /*-----------------------------------------------------------*/
2447:Source/queue.c **** 
2448:Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2449:Source/queue.c **** 
2450:Source/queue.c **** 	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
2451:Source/queue.c **** 	{
2452:Source/queue.c **** 	BaseType_t xReturn;
2453:Source/queue.c **** 	Queue_t * const pxQueue = xQueue;
2454:Source/queue.c **** 
2455:Source/queue.c **** 		/* If the queue is already empty we may have to block.  A critical section
2456:Source/queue.c **** 		is required to prevent an interrupt adding something to the queue
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 98


2457:Source/queue.c **** 		between the check to see if the queue is empty and blocking on the queue. */
2458:Source/queue.c **** 		portDISABLE_INTERRUPTS();
2459:Source/queue.c **** 		{
2460:Source/queue.c **** 			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
2461:Source/queue.c **** 			{
2462:Source/queue.c **** 				/* There are no messages in the queue, do we want to block or just
2463:Source/queue.c **** 				leave with nothing? */
2464:Source/queue.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
2465:Source/queue.c **** 				{
2466:Source/queue.c **** 					/* As this is a co-routine we cannot block directly, but return
2467:Source/queue.c **** 					indicating that we need to block. */
2468:Source/queue.c **** 					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
2469:Source/queue.c **** 					portENABLE_INTERRUPTS();
2470:Source/queue.c **** 					return errQUEUE_BLOCKED;
2471:Source/queue.c **** 				}
2472:Source/queue.c **** 				else
2473:Source/queue.c **** 				{
2474:Source/queue.c **** 					portENABLE_INTERRUPTS();
2475:Source/queue.c **** 					return errQUEUE_FULL;
2476:Source/queue.c **** 				}
2477:Source/queue.c **** 			}
2478:Source/queue.c **** 			else
2479:Source/queue.c **** 			{
2480:Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2481:Source/queue.c **** 			}
2482:Source/queue.c **** 		}
2483:Source/queue.c **** 		portENABLE_INTERRUPTS();
2484:Source/queue.c **** 
2485:Source/queue.c **** 		portDISABLE_INTERRUPTS();
2486:Source/queue.c **** 		{
2487:Source/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
2488:Source/queue.c **** 			{
2489:Source/queue.c **** 				/* Data is available from the queue. */
2490:Source/queue.c **** 				pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
2491:Source/queue.c **** 				if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
2492:Source/queue.c **** 				{
2493:Source/queue.c **** 					pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
2494:Source/queue.c **** 				}
2495:Source/queue.c **** 				else
2496:Source/queue.c **** 				{
2497:Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2498:Source/queue.c **** 				}
2499:Source/queue.c **** 				--( pxQueue->uxMessagesWaiting );
2500:Source/queue.c **** 				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQ
2501:Source/queue.c **** 
2502:Source/queue.c **** 				xReturn = pdPASS;
2503:Source/queue.c **** 
2504:Source/queue.c **** 				/* Were any co-routines waiting for space to become available? */
2505:Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
2506:Source/queue.c **** 				{
2507:Source/queue.c **** 					/* In this instance the co-routine could be placed directly
2508:Source/queue.c **** 					into the ready list as we are within a critical section.
2509:Source/queue.c **** 					Instead the same pending ready list mechanism is used as if
2510:Source/queue.c **** 					the event were caused from within an interrupt. */
2511:Source/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
2512:Source/queue.c **** 					{
2513:Source/queue.c **** 						xReturn = errQUEUE_YIELD;
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 99


2514:Source/queue.c **** 					}
2515:Source/queue.c **** 					else
2516:Source/queue.c **** 					{
2517:Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2518:Source/queue.c **** 					}
2519:Source/queue.c **** 				}
2520:Source/queue.c **** 				else
2521:Source/queue.c **** 				{
2522:Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2523:Source/queue.c **** 				}
2524:Source/queue.c **** 			}
2525:Source/queue.c **** 			else
2526:Source/queue.c **** 			{
2527:Source/queue.c **** 				xReturn = pdFAIL;
2528:Source/queue.c **** 			}
2529:Source/queue.c **** 		}
2530:Source/queue.c **** 		portENABLE_INTERRUPTS();
2531:Source/queue.c **** 
2532:Source/queue.c **** 		return xReturn;
2533:Source/queue.c **** 	}
2534:Source/queue.c **** 
2535:Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
2536:Source/queue.c **** /*-----------------------------------------------------------*/
2537:Source/queue.c **** 
2538:Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2539:Source/queue.c **** 
2540:Source/queue.c **** 	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRou
2541:Source/queue.c **** 	{
2542:Source/queue.c **** 	Queue_t * const pxQueue = xQueue;
2543:Source/queue.c **** 
2544:Source/queue.c **** 		/* Cannot block within an ISR so if there is no space on the queue then
2545:Source/queue.c **** 		exit without doing anything. */
2546:Source/queue.c **** 		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
2547:Source/queue.c **** 		{
2548:Source/queue.c **** 			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
2549:Source/queue.c **** 
2550:Source/queue.c **** 			/* We only want to wake one co-routine per ISR, so check that a
2551:Source/queue.c **** 			co-routine has not already been woken. */
2552:Source/queue.c **** 			if( xCoRoutinePreviouslyWoken == pdFALSE )
2553:Source/queue.c **** 			{
2554:Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2555:Source/queue.c **** 				{
2556:Source/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
2557:Source/queue.c **** 					{
2558:Source/queue.c **** 						return pdTRUE;
2559:Source/queue.c **** 					}
2560:Source/queue.c **** 					else
2561:Source/queue.c **** 					{
2562:Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2563:Source/queue.c **** 					}
2564:Source/queue.c **** 				}
2565:Source/queue.c **** 				else
2566:Source/queue.c **** 				{
2567:Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2568:Source/queue.c **** 				}
2569:Source/queue.c **** 			}
2570:Source/queue.c **** 			else
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 100


2571:Source/queue.c **** 			{
2572:Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2573:Source/queue.c **** 			}
2574:Source/queue.c **** 		}
2575:Source/queue.c **** 		else
2576:Source/queue.c **** 		{
2577:Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2578:Source/queue.c **** 		}
2579:Source/queue.c **** 
2580:Source/queue.c **** 		return xCoRoutinePreviouslyWoken;
2581:Source/queue.c **** 	}
2582:Source/queue.c **** 
2583:Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
2584:Source/queue.c **** /*-----------------------------------------------------------*/
2585:Source/queue.c **** 
2586:Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2587:Source/queue.c **** 
2588:Source/queue.c **** 	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWo
2589:Source/queue.c **** 	{
2590:Source/queue.c **** 	BaseType_t xReturn;
2591:Source/queue.c **** 	Queue_t * const pxQueue = xQueue;
2592:Source/queue.c **** 
2593:Source/queue.c **** 		/* We cannot block from an ISR, so check there is data available. If
2594:Source/queue.c **** 		not then just leave without doing anything. */
2595:Source/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
2596:Source/queue.c **** 		{
2597:Source/queue.c **** 			/* Copy the data from the queue. */
2598:Source/queue.c **** 			pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
2599:Source/queue.c **** 			if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
2600:Source/queue.c **** 			{
2601:Source/queue.c **** 				pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
2602:Source/queue.c **** 			}
2603:Source/queue.c **** 			else
2604:Source/queue.c **** 			{
2605:Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2606:Source/queue.c **** 			}
2607:Source/queue.c **** 			--( pxQueue->uxMessagesWaiting );
2608:Source/queue.c **** 			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQu
2609:Source/queue.c **** 
2610:Source/queue.c **** 			if( ( *pxCoRoutineWoken ) == pdFALSE )
2611:Source/queue.c **** 			{
2612:Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
2613:Source/queue.c **** 				{
2614:Source/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
2615:Source/queue.c **** 					{
2616:Source/queue.c **** 						*pxCoRoutineWoken = pdTRUE;
2617:Source/queue.c **** 					}
2618:Source/queue.c **** 					else
2619:Source/queue.c **** 					{
2620:Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2621:Source/queue.c **** 					}
2622:Source/queue.c **** 				}
2623:Source/queue.c **** 				else
2624:Source/queue.c **** 				{
2625:Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2626:Source/queue.c **** 				}
2627:Source/queue.c **** 			}
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 101


2628:Source/queue.c **** 			else
2629:Source/queue.c **** 			{
2630:Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2631:Source/queue.c **** 			}
2632:Source/queue.c **** 
2633:Source/queue.c **** 			xReturn = pdPASS;
2634:Source/queue.c **** 		}
2635:Source/queue.c **** 		else
2636:Source/queue.c **** 		{
2637:Source/queue.c **** 			xReturn = pdFAIL;
2638:Source/queue.c **** 		}
2639:Source/queue.c **** 
2640:Source/queue.c **** 		return xReturn;
2641:Source/queue.c **** 	}
2642:Source/queue.c **** 
2643:Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
2644:Source/queue.c **** /*-----------------------------------------------------------*/
2645:Source/queue.c **** 
2646:Source/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
2647:Source/queue.c **** 
2648:Source/queue.c **** 	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) /*lint !e971 Unqualified
2649:Source/queue.c **** 	{
 2833              		.loc 1 2649 0
 2834              		.cfi_startproc
 2835              		@ args = 0, pretend = 0, frame = 16
 2836              		@ frame_needed = 1, uses_anonymous_args = 0
 2837              		@ link register save eliminated.
 2838 0000 80B4     		push	{r7}
 2839              		.cfi_def_cfa_offset 4
 2840              		.cfi_offset 7, -4
 2841 0002 85B0     		sub	sp, sp, #20
 2842              		.cfi_def_cfa_offset 24
 2843 0004 00AF     		add	r7, sp, #0
 2844              		.cfi_def_cfa_register 7
 2845 0006 7860     		str	r0, [r7, #4]
 2846 0008 3960     		str	r1, [r7]
2650:Source/queue.c **** 	UBaseType_t ux;
2651:Source/queue.c **** 
2652:Source/queue.c **** 		/* See if there is an empty space in the registry.  A NULL name denotes
2653:Source/queue.c **** 		a free slot. */
2654:Source/queue.c **** 		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 2847              		.loc 1 2654 0
 2848 000a 0023     		movs	r3, #0
 2849 000c FB60     		str	r3, [r7, #12]
 2850 000e 14E0     		b	.L178
 2851              	.L181:
2655:Source/queue.c **** 		{
2656:Source/queue.c **** 			if( xQueueRegistry[ ux ].pcQueueName == NULL )
 2852              		.loc 1 2656 0
 2853 0010 0E4A     		ldr	r2, .L182
 2854 0012 FB68     		ldr	r3, [r7, #12]
 2855 0014 52F83330 		ldr	r3, [r2, r3, lsl #3]
 2856 0018 002B     		cmp	r3, #0
 2857 001a 0BD1     		bne	.L179
2657:Source/queue.c **** 			{
2658:Source/queue.c **** 				/* Store the information on this queue. */
2659:Source/queue.c **** 				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 102


 2858              		.loc 1 2659 0
 2859 001c 0B49     		ldr	r1, .L182
 2860 001e FB68     		ldr	r3, [r7, #12]
 2861 0020 3A68     		ldr	r2, [r7]
 2862 0022 41F83320 		str	r2, [r1, r3, lsl #3]
2660:Source/queue.c **** 				xQueueRegistry[ ux ].xHandle = xQueue;
 2863              		.loc 1 2660 0
 2864 0026 094A     		ldr	r2, .L182
 2865 0028 FB68     		ldr	r3, [r7, #12]
 2866 002a DB00     		lsls	r3, r3, #3
 2867 002c 1344     		add	r3, r3, r2
 2868 002e 7A68     		ldr	r2, [r7, #4]
 2869 0030 5A60     		str	r2, [r3, #4]
2661:Source/queue.c **** 
2662:Source/queue.c **** 				traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
2663:Source/queue.c **** 				break;
 2870              		.loc 1 2663 0
 2871 0032 05E0     		b	.L180
 2872              	.L179:
2654:Source/queue.c **** 		{
 2873              		.loc 1 2654 0 discriminator 2
 2874 0034 FB68     		ldr	r3, [r7, #12]
 2875 0036 0133     		adds	r3, r3, #1
 2876 0038 FB60     		str	r3, [r7, #12]
 2877              	.L178:
2654:Source/queue.c **** 		{
 2878              		.loc 1 2654 0 is_stmt 0 discriminator 1
 2879 003a FB68     		ldr	r3, [r7, #12]
 2880 003c 092B     		cmp	r3, #9
 2881 003e E7D9     		bls	.L181
 2882              	.L180:
2664:Source/queue.c **** 			}
2665:Source/queue.c **** 			else
2666:Source/queue.c **** 			{
2667:Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2668:Source/queue.c **** 			}
2669:Source/queue.c **** 		}
2670:Source/queue.c **** 	}
 2883              		.loc 1 2670 0 is_stmt 1
 2884 0040 00BF     		nop
 2885 0042 1437     		adds	r7, r7, #20
 2886              		.cfi_def_cfa_offset 4
 2887 0044 BD46     		mov	sp, r7
 2888              		.cfi_def_cfa_register 13
 2889              		@ sp needed
 2890 0046 80BC     		pop	{r7}
 2891              		.cfi_restore 7
 2892              		.cfi_def_cfa_offset 0
 2893 0048 7047     		bx	lr
 2894              	.L183:
 2895 004a 00BF     		.align	2
 2896              	.L182:
 2897 004c 00000000 		.word	xQueueRegistry
 2898              		.cfi_endproc
 2899              	.LFE96:
 2900              		.size	vQueueAddToRegistry, .-vQueueAddToRegistry
 2901              		.section	.text.pcQueueGetName,"ax",%progbits
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 103


 2902              		.align	2
 2903              		.global	pcQueueGetName
 2904              		.thumb
 2905              		.thumb_func
 2906              		.type	pcQueueGetName, %function
 2907              	pcQueueGetName:
 2908              	.LFB97:
2671:Source/queue.c **** 
2672:Source/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
2673:Source/queue.c **** /*-----------------------------------------------------------*/
2674:Source/queue.c **** 
2675:Source/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
2676:Source/queue.c **** 
2677:Source/queue.c **** 	const char *pcQueueGetName( QueueHandle_t xQueue ) /*lint !e971 Unqualified char types are allowed
2678:Source/queue.c **** 	{
 2909              		.loc 1 2678 0
 2910              		.cfi_startproc
 2911              		@ args = 0, pretend = 0, frame = 16
 2912              		@ frame_needed = 1, uses_anonymous_args = 0
 2913              		@ link register save eliminated.
 2914 0000 80B4     		push	{r7}
 2915              		.cfi_def_cfa_offset 4
 2916              		.cfi_offset 7, -4
 2917 0002 85B0     		sub	sp, sp, #20
 2918              		.cfi_def_cfa_offset 24
 2919 0004 00AF     		add	r7, sp, #0
 2920              		.cfi_def_cfa_register 7
 2921 0006 7860     		str	r0, [r7, #4]
2679:Source/queue.c **** 	UBaseType_t ux;
2680:Source/queue.c **** 	const char *pcReturn = NULL; /*lint !e971 Unqualified char types are allowed for strings and singl
 2922              		.loc 1 2680 0
 2923 0008 0023     		movs	r3, #0
 2924 000a BB60     		str	r3, [r7, #8]
2681:Source/queue.c **** 
2682:Source/queue.c **** 		/* Note there is nothing here to protect against another task adding or
2683:Source/queue.c **** 		removing entries from the registry while it is being searched. */
2684:Source/queue.c **** 		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 2925              		.loc 1 2684 0
 2926 000c 0023     		movs	r3, #0
 2927 000e FB60     		str	r3, [r7, #12]
 2928 0010 10E0     		b	.L185
 2929              	.L188:
2685:Source/queue.c **** 		{
2686:Source/queue.c **** 			if( xQueueRegistry[ ux ].xHandle == xQueue )
 2930              		.loc 1 2686 0
 2931 0012 0D4A     		ldr	r2, .L190
 2932 0014 FB68     		ldr	r3, [r7, #12]
 2933 0016 DB00     		lsls	r3, r3, #3
 2934 0018 1344     		add	r3, r3, r2
 2935 001a 5A68     		ldr	r2, [r3, #4]
 2936 001c 7B68     		ldr	r3, [r7, #4]
 2937 001e 9A42     		cmp	r2, r3
 2938 0020 05D1     		bne	.L186
2687:Source/queue.c **** 			{
2688:Source/queue.c **** 				pcReturn = xQueueRegistry[ ux ].pcQueueName;
 2939              		.loc 1 2688 0
 2940 0022 094A     		ldr	r2, .L190
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 104


 2941 0024 FB68     		ldr	r3, [r7, #12]
 2942 0026 52F83330 		ldr	r3, [r2, r3, lsl #3]
 2943 002a BB60     		str	r3, [r7, #8]
2689:Source/queue.c **** 				break;
 2944              		.loc 1 2689 0
 2945 002c 05E0     		b	.L187
 2946              	.L186:
2684:Source/queue.c **** 		{
 2947              		.loc 1 2684 0 discriminator 2
 2948 002e FB68     		ldr	r3, [r7, #12]
 2949 0030 0133     		adds	r3, r3, #1
 2950 0032 FB60     		str	r3, [r7, #12]
 2951              	.L185:
2684:Source/queue.c **** 		{
 2952              		.loc 1 2684 0 is_stmt 0 discriminator 1
 2953 0034 FB68     		ldr	r3, [r7, #12]
 2954 0036 092B     		cmp	r3, #9
 2955 0038 EBD9     		bls	.L188
 2956              	.L187:
2690:Source/queue.c **** 			}
2691:Source/queue.c **** 			else
2692:Source/queue.c **** 			{
2693:Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2694:Source/queue.c **** 			}
2695:Source/queue.c **** 		}
2696:Source/queue.c **** 
2697:Source/queue.c **** 		return pcReturn;
 2957              		.loc 1 2697 0 is_stmt 1
 2958 003a BB68     		ldr	r3, [r7, #8]
2698:Source/queue.c **** 	} /*lint !e818 xQueue cannot be a pointer to const because it is a typedef. */
 2959              		.loc 1 2698 0
 2960 003c 1846     		mov	r0, r3
 2961 003e 1437     		adds	r7, r7, #20
 2962              		.cfi_def_cfa_offset 4
 2963 0040 BD46     		mov	sp, r7
 2964              		.cfi_def_cfa_register 13
 2965              		@ sp needed
 2966 0042 80BC     		pop	{r7}
 2967              		.cfi_restore 7
 2968              		.cfi_def_cfa_offset 0
 2969 0044 7047     		bx	lr
 2970              	.L191:
 2971 0046 00BF     		.align	2
 2972              	.L190:
 2973 0048 00000000 		.word	xQueueRegistry
 2974              		.cfi_endproc
 2975              	.LFE97:
 2976              		.size	pcQueueGetName, .-pcQueueGetName
 2977              		.section	.text.vQueueUnregisterQueue,"ax",%progbits
 2978              		.align	2
 2979              		.global	vQueueUnregisterQueue
 2980              		.thumb
 2981              		.thumb_func
 2982              		.type	vQueueUnregisterQueue, %function
 2983              	vQueueUnregisterQueue:
 2984              	.LFB98:
2699:Source/queue.c **** 
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 105


2700:Source/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
2701:Source/queue.c **** /*-----------------------------------------------------------*/
2702:Source/queue.c **** 
2703:Source/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
2704:Source/queue.c **** 
2705:Source/queue.c **** 	void vQueueUnregisterQueue( QueueHandle_t xQueue )
2706:Source/queue.c **** 	{
 2985              		.loc 1 2706 0
 2986              		.cfi_startproc
 2987              		@ args = 0, pretend = 0, frame = 16
 2988              		@ frame_needed = 1, uses_anonymous_args = 0
 2989              		@ link register save eliminated.
 2990 0000 80B4     		push	{r7}
 2991              		.cfi_def_cfa_offset 4
 2992              		.cfi_offset 7, -4
 2993 0002 85B0     		sub	sp, sp, #20
 2994              		.cfi_def_cfa_offset 24
 2995 0004 00AF     		add	r7, sp, #0
 2996              		.cfi_def_cfa_register 7
 2997 0006 7860     		str	r0, [r7, #4]
2707:Source/queue.c **** 	UBaseType_t ux;
2708:Source/queue.c **** 
2709:Source/queue.c **** 		/* See if the handle of the queue being unregistered in actually in the
2710:Source/queue.c **** 		registry. */
2711:Source/queue.c **** 		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 2998              		.loc 1 2711 0
 2999 0008 0023     		movs	r3, #0
 3000 000a FB60     		str	r3, [r7, #12]
 3001 000c 16E0     		b	.L193
 3002              	.L196:
2712:Source/queue.c **** 		{
2713:Source/queue.c **** 			if( xQueueRegistry[ ux ].xHandle == xQueue )
 3003              		.loc 1 2713 0
 3004 000e 0F4A     		ldr	r2, .L197
 3005 0010 FB68     		ldr	r3, [r7, #12]
 3006 0012 DB00     		lsls	r3, r3, #3
 3007 0014 1344     		add	r3, r3, r2
 3008 0016 5A68     		ldr	r2, [r3, #4]
 3009 0018 7B68     		ldr	r3, [r7, #4]
 3010 001a 9A42     		cmp	r2, r3
 3011 001c 0BD1     		bne	.L194
2714:Source/queue.c **** 			{
2715:Source/queue.c **** 				/* Set the name to NULL to show that this slot if free again. */
2716:Source/queue.c **** 				xQueueRegistry[ ux ].pcQueueName = NULL;
 3012              		.loc 1 2716 0
 3013 001e 0B4A     		ldr	r2, .L197
 3014 0020 FB68     		ldr	r3, [r7, #12]
 3015 0022 0021     		movs	r1, #0
 3016 0024 42F83310 		str	r1, [r2, r3, lsl #3]
2717:Source/queue.c **** 
2718:Source/queue.c **** 				/* Set the handle to NULL to ensure the same queue handle cannot
2719:Source/queue.c **** 				appear in the registry twice if it is added, removed, then
2720:Source/queue.c **** 				added again. */
2721:Source/queue.c **** 				xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
 3017              		.loc 1 2721 0
 3018 0028 084A     		ldr	r2, .L197
 3019 002a FB68     		ldr	r3, [r7, #12]
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 106


 3020 002c DB00     		lsls	r3, r3, #3
 3021 002e 1344     		add	r3, r3, r2
 3022 0030 0022     		movs	r2, #0
 3023 0032 5A60     		str	r2, [r3, #4]
2722:Source/queue.c **** 				break;
 3024              		.loc 1 2722 0
 3025 0034 05E0     		b	.L195
 3026              	.L194:
2711:Source/queue.c **** 		{
 3027              		.loc 1 2711 0 discriminator 2
 3028 0036 FB68     		ldr	r3, [r7, #12]
 3029 0038 0133     		adds	r3, r3, #1
 3030 003a FB60     		str	r3, [r7, #12]
 3031              	.L193:
2711:Source/queue.c **** 		{
 3032              		.loc 1 2711 0 is_stmt 0 discriminator 1
 3033 003c FB68     		ldr	r3, [r7, #12]
 3034 003e 092B     		cmp	r3, #9
 3035 0040 E5D9     		bls	.L196
 3036              	.L195:
2723:Source/queue.c **** 			}
2724:Source/queue.c **** 			else
2725:Source/queue.c **** 			{
2726:Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2727:Source/queue.c **** 			}
2728:Source/queue.c **** 		}
2729:Source/queue.c **** 
2730:Source/queue.c **** 	} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 3037              		.loc 1 2730 0 is_stmt 1
 3038 0042 00BF     		nop
 3039 0044 1437     		adds	r7, r7, #20
 3040              		.cfi_def_cfa_offset 4
 3041 0046 BD46     		mov	sp, r7
 3042              		.cfi_def_cfa_register 13
 3043              		@ sp needed
 3044 0048 80BC     		pop	{r7}
 3045              		.cfi_restore 7
 3046              		.cfi_def_cfa_offset 0
 3047 004a 7047     		bx	lr
 3048              	.L198:
 3049              		.align	2
 3050              	.L197:
 3051 004c 00000000 		.word	xQueueRegistry
 3052              		.cfi_endproc
 3053              	.LFE98:
 3054              		.size	vQueueUnregisterQueue, .-vQueueUnregisterQueue
 3055              		.text
 3056              	.Letext0:
 3057              		.file 3 "c:\\program files (x86)\\cypress\\psoc creator\\4.3\\psoc creator\\import\\gnu\\arm\\5.4.
 3058              		.file 4 "c:\\program files (x86)\\cypress\\psoc creator\\4.3\\psoc creator\\import\\gnu\\arm\\5.4.
 3059              		.file 5 "c:\\program files (x86)\\cypress\\psoc creator\\4.3\\psoc creator\\import\\gnu\\arm\\5.4.
 3060              		.file 6 ".\\Source\\include/list.h"
 3061              		.file 7 ".\\Source\\include/task.h"
 3062              		.file 8 ".\\Source\\include/queue.h"
 3063              		.file 9 "Generated_Source\\PSoC5/core_cm3.h"
 3064              		.section	.debug_info,"",%progbits
 3065              	.Ldebug_info0:
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 107


 3066 0000 DE100000 		.4byte	0x10de
 3067 0004 0400     		.2byte	0x4
 3068 0006 00000000 		.4byte	.Ldebug_abbrev0
 3069 000a 04       		.byte	0x4
 3070 000b 01       		.uleb128 0x1
 3071 000c 05010000 		.4byte	.LASF140
 3072 0010 0C       		.byte	0xc
 3073 0011 2A020000 		.4byte	.LASF141
 3074 0015 0C080000 		.4byte	.LASF142
 3075 0019 00000000 		.4byte	.Ldebug_ranges0+0
 3076 001d 00000000 		.4byte	0
 3077 0021 00000000 		.4byte	.Ldebug_line0
 3078 0025 02       		.uleb128 0x2
 3079 0026 91030000 		.4byte	.LASF3
 3080 002a 03       		.byte	0x3
 3081 002b D8       		.byte	0xd8
 3082 002c 30000000 		.4byte	0x30
 3083 0030 03       		.uleb128 0x3
 3084 0031 04       		.byte	0x4
 3085 0032 07       		.byte	0x7
 3086 0033 B2000000 		.4byte	.LASF0
 3087 0037 04       		.uleb128 0x4
 3088 0038 04       		.byte	0x4
 3089 0039 05       		.byte	0x5
 3090 003a 696E7400 		.ascii	"int\000"
 3091 003e 03       		.uleb128 0x3
 3092 003f 08       		.byte	0x8
 3093 0040 05       		.byte	0x5
 3094 0041 40050000 		.4byte	.LASF1
 3095 0045 03       		.uleb128 0x3
 3096 0046 08       		.byte	0x8
 3097 0047 04       		.byte	0x4
 3098 0048 70060000 		.4byte	.LASF2
 3099 004c 02       		.uleb128 0x2
 3100 004d 59060000 		.4byte	.LASF4
 3101 0051 04       		.byte	0x4
 3102 0052 1B       		.byte	0x1b
 3103 0053 57000000 		.4byte	0x57
 3104 0057 03       		.uleb128 0x3
 3105 0058 01       		.byte	0x1
 3106 0059 06       		.byte	0x6
 3107 005a C7080000 		.4byte	.LASF5
 3108 005e 02       		.uleb128 0x2
 3109 005f 76070000 		.4byte	.LASF6
 3110 0063 04       		.byte	0x4
 3111 0064 1D       		.byte	0x1d
 3112 0065 69000000 		.4byte	0x69
 3113 0069 03       		.uleb128 0x3
 3114 006a 01       		.byte	0x1
 3115 006b 08       		.byte	0x8
 3116 006c DE070000 		.4byte	.LASF7
 3117 0070 03       		.uleb128 0x3
 3118 0071 02       		.byte	0x2
 3119 0072 05       		.byte	0x5
 3120 0073 E7060000 		.4byte	.LASF8
 3121 0077 03       		.uleb128 0x3
 3122 0078 02       		.byte	0x2
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 108


 3123 0079 07       		.byte	0x7
 3124 007a D3080000 		.4byte	.LASF9
 3125 007e 02       		.uleb128 0x2
 3126 007f DC000000 		.4byte	.LASF10
 3127 0083 04       		.byte	0x4
 3128 0084 3F       		.byte	0x3f
 3129 0085 89000000 		.4byte	0x89
 3130 0089 03       		.uleb128 0x3
 3131 008a 04       		.byte	0x4
 3132 008b 05       		.byte	0x5
 3133 008c FC060000 		.4byte	.LASF11
 3134 0090 02       		.uleb128 0x2
 3135 0091 EC070000 		.4byte	.LASF12
 3136 0095 04       		.byte	0x4
 3137 0096 41       		.byte	0x41
 3138 0097 9B000000 		.4byte	0x9b
 3139 009b 03       		.uleb128 0x3
 3140 009c 04       		.byte	0x4
 3141 009d 07       		.byte	0x7
 3142 009e 99070000 		.4byte	.LASF13
 3143 00a2 03       		.uleb128 0x3
 3144 00a3 08       		.byte	0x8
 3145 00a4 07       		.byte	0x7
 3146 00a5 E1020000 		.4byte	.LASF14
 3147 00a9 03       		.uleb128 0x3
 3148 00aa 04       		.byte	0x4
 3149 00ab 07       		.byte	0x7
 3150 00ac 90070000 		.4byte	.LASF15
 3151 00b0 05       		.uleb128 0x5
 3152 00b1 04       		.byte	0x4
 3153 00b2 03       		.uleb128 0x3
 3154 00b3 01       		.byte	0x1
 3155 00b4 08       		.byte	0x8
 3156 00b5 41040000 		.4byte	.LASF16
 3157 00b9 06       		.uleb128 0x6
 3158 00ba 04       		.byte	0x4
 3159 00bb BF000000 		.4byte	0xbf
 3160 00bf 07       		.uleb128 0x7
 3161 00c0 B2000000 		.4byte	0xb2
 3162 00c4 06       		.uleb128 0x6
 3163 00c5 04       		.byte	0x4
 3164 00c6 CA000000 		.4byte	0xca
 3165 00ca 08       		.uleb128 0x8
 3166 00cb 02       		.uleb128 0x2
 3167 00cc 90020000 		.4byte	.LASF17
 3168 00d0 05       		.byte	0x5
 3169 00d1 14       		.byte	0x14
 3170 00d2 4C000000 		.4byte	0x4c
 3171 00d6 02       		.uleb128 0x2
 3172 00d7 EC040000 		.4byte	.LASF18
 3173 00db 05       		.byte	0x5
 3174 00dc 18       		.byte	0x18
 3175 00dd 5E000000 		.4byte	0x5e
 3176 00e1 02       		.uleb128 0x2
 3177 00e2 AB070000 		.4byte	.LASF19
 3178 00e6 05       		.byte	0x5
 3179 00e7 2C       		.byte	0x2c
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 109


 3180 00e8 7E000000 		.4byte	0x7e
 3181 00ec 02       		.uleb128 0x2
 3182 00ed 87020000 		.4byte	.LASF20
 3183 00f1 05       		.byte	0x5
 3184 00f2 30       		.byte	0x30
 3185 00f3 90000000 		.4byte	0x90
 3186 00f7 03       		.uleb128 0x3
 3187 00f8 04       		.byte	0x4
 3188 00f9 04       		.byte	0x4
 3189 00fa CB020000 		.4byte	.LASF21
 3190 00fe 03       		.uleb128 0x3
 3191 00ff 08       		.byte	0x8
 3192 0100 04       		.byte	0x4
 3193 0101 FA080000 		.4byte	.LASF22
 3194 0105 02       		.uleb128 0x2
 3195 0106 61050000 		.4byte	.LASF23
 3196 010a 02       		.byte	0x2
 3197 010b 38       		.byte	0x38
 3198 010c 89000000 		.4byte	0x89
 3199 0110 02       		.uleb128 0x2
 3200 0111 7B040000 		.4byte	.LASF24
 3201 0115 02       		.byte	0x2
 3202 0116 39       		.byte	0x39
 3203 0117 9B000000 		.4byte	0x9b
 3204 011b 02       		.uleb128 0x2
 3205 011c 4E060000 		.4byte	.LASF25
 3206 0120 02       		.byte	0x2
 3207 0121 3F       		.byte	0x3f
 3208 0122 EC000000 		.4byte	0xec
 3209 0126 06       		.uleb128 0x6
 3210 0127 04       		.byte	0x4
 3211 0128 D6000000 		.4byte	0xd6
 3212 012c 09       		.uleb128 0x9
 3213 012d E6000000 		.4byte	.LASF31
 3214 0131 14       		.byte	0x14
 3215 0132 06       		.byte	0x6
 3216 0133 8C       		.byte	0x8c
 3217 0134 75010000 		.4byte	0x175
 3218 0138 0A       		.uleb128 0xa
 3219 0139 F1060000 		.4byte	.LASF26
 3220 013d 06       		.byte	0x6
 3221 013e 8F       		.byte	0x8f
 3222 013f 1B010000 		.4byte	0x11b
 3223 0143 00       		.byte	0
 3224 0144 0A       		.uleb128 0xa
 3225 0145 A7050000 		.4byte	.LASF27
 3226 0149 06       		.byte	0x6
 3227 014a 90       		.byte	0x90
 3228 014b 75010000 		.4byte	0x175
 3229 014f 04       		.byte	0x4
 3230 0150 0A       		.uleb128 0xa
 3231 0151 36030000 		.4byte	.LASF28
 3232 0155 06       		.byte	0x6
 3233 0156 91       		.byte	0x91
 3234 0157 75010000 		.4byte	0x175
 3235 015b 08       		.byte	0x8
 3236 015c 0A       		.uleb128 0xa
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 110


 3237 015d 63080000 		.4byte	.LASF29
 3238 0161 06       		.byte	0x6
 3239 0162 92       		.byte	0x92
 3240 0163 B0000000 		.4byte	0xb0
 3241 0167 0C       		.byte	0xc
 3242 0168 0A       		.uleb128 0xa
 3243 0169 AA060000 		.4byte	.LASF30
 3244 016d 06       		.byte	0x6
 3245 016e 93       		.byte	0x93
 3246 016f AC010000 		.4byte	0x1ac
 3247 0173 10       		.byte	0x10
 3248 0174 00       		.byte	0
 3249 0175 06       		.uleb128 0x6
 3250 0176 04       		.byte	0x4
 3251 0177 2C010000 		.4byte	0x12c
 3252 017b 09       		.uleb128 0x9
 3253 017c C5030000 		.4byte	.LASF32
 3254 0180 14       		.byte	0x14
 3255 0181 06       		.byte	0x6
 3256 0182 A4       		.byte	0xa4
 3257 0183 AC010000 		.4byte	0x1ac
 3258 0187 0A       		.uleb128 0xa
 3259 0188 00000000 		.4byte	.LASF33
 3260 018c 06       		.byte	0x6
 3261 018d A7       		.byte	0xa7
 3262 018e F9010000 		.4byte	0x1f9
 3263 0192 00       		.byte	0
 3264 0193 0A       		.uleb128 0xa
 3265 0194 BF000000 		.4byte	.LASF34
 3266 0198 06       		.byte	0x6
 3267 0199 A8       		.byte	0xa8
 3268 019a FE010000 		.4byte	0x1fe
 3269 019e 04       		.byte	0x4
 3270 019f 0A       		.uleb128 0xa
 3271 01a0 B6040000 		.4byte	.LASF35
 3272 01a4 06       		.byte	0x6
 3273 01a5 A9       		.byte	0xa9
 3274 01a6 EE010000 		.4byte	0x1ee
 3275 01aa 08       		.byte	0x8
 3276 01ab 00       		.byte	0
 3277 01ac 06       		.uleb128 0x6
 3278 01ad 04       		.byte	0x4
 3279 01ae 7B010000 		.4byte	0x17b
 3280 01b2 02       		.uleb128 0x2
 3281 01b3 46040000 		.4byte	.LASF36
 3282 01b7 06       		.byte	0x6
 3283 01b8 96       		.byte	0x96
 3284 01b9 2C010000 		.4byte	0x12c
 3285 01bd 09       		.uleb128 0x9
 3286 01be B5030000 		.4byte	.LASF37
 3287 01c2 0C       		.byte	0xc
 3288 01c3 06       		.byte	0x6
 3289 01c4 98       		.byte	0x98
 3290 01c5 EE010000 		.4byte	0x1ee
 3291 01c9 0A       		.uleb128 0xa
 3292 01ca F1060000 		.4byte	.LASF26
 3293 01ce 06       		.byte	0x6
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 111


 3294 01cf 9B       		.byte	0x9b
 3295 01d0 1B010000 		.4byte	0x11b
 3296 01d4 00       		.byte	0
 3297 01d5 0A       		.uleb128 0xa
 3298 01d6 A7050000 		.4byte	.LASF27
 3299 01da 06       		.byte	0x6
 3300 01db 9C       		.byte	0x9c
 3301 01dc 75010000 		.4byte	0x175
 3302 01e0 04       		.byte	0x4
 3303 01e1 0A       		.uleb128 0xa
 3304 01e2 36030000 		.4byte	.LASF28
 3305 01e6 06       		.byte	0x6
 3306 01e7 9D       		.byte	0x9d
 3307 01e8 75010000 		.4byte	0x175
 3308 01ec 08       		.byte	0x8
 3309 01ed 00       		.byte	0
 3310 01ee 02       		.uleb128 0x2
 3311 01ef DD040000 		.4byte	.LASF38
 3312 01f3 06       		.byte	0x6
 3313 01f4 9F       		.byte	0x9f
 3314 01f5 BD010000 		.4byte	0x1bd
 3315 01f9 0B       		.uleb128 0xb
 3316 01fa 10010000 		.4byte	0x110
 3317 01fe 06       		.uleb128 0x6
 3318 01ff 04       		.byte	0x4
 3319 0200 B2010000 		.4byte	0x1b2
 3320 0204 02       		.uleb128 0x2
 3321 0205 2C060000 		.4byte	.LASF39
 3322 0209 06       		.byte	0x6
 3323 020a AB       		.byte	0xab
 3324 020b 7B010000 		.4byte	0x17b
 3325 020f 02       		.uleb128 0x2
 3326 0210 E4050000 		.4byte	.LASF40
 3327 0214 07       		.byte	0x7
 3328 0215 46       		.byte	0x46
 3329 0216 1A020000 		.4byte	0x21a
 3330 021a 06       		.uleb128 0x6
 3331 021b 04       		.byte	0x4
 3332 021c 20020000 		.4byte	0x220
 3333 0220 0C       		.uleb128 0xc
 3334 0221 1E000000 		.4byte	.LASF143
 3335 0225 09       		.uleb128 0x9
 3336 0226 C7000000 		.4byte	.LASF41
 3337 022a 08       		.byte	0x8
 3338 022b 07       		.byte	0x7
 3339 022c 66       		.byte	0x66
 3340 022d 4A020000 		.4byte	0x24a
 3341 0231 0A       		.uleb128 0xa
 3342 0232 C6010000 		.4byte	.LASF42
 3343 0236 07       		.byte	0x7
 3344 0237 68       		.byte	0x68
 3345 0238 05010000 		.4byte	0x105
 3346 023c 00       		.byte	0
 3347 023d 0A       		.uleb128 0xa
 3348 023e 83050000 		.4byte	.LASF43
 3349 0242 07       		.byte	0x7
 3350 0243 69       		.byte	0x69
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 112


 3351 0244 1B010000 		.4byte	0x11b
 3352 0248 04       		.byte	0x4
 3353 0249 00       		.byte	0
 3354 024a 02       		.uleb128 0x2
 3355 024b C3050000 		.4byte	.LASF44
 3356 024f 07       		.byte	0x7
 3357 0250 6A       		.byte	0x6a
 3358 0251 25020000 		.4byte	0x225
 3359 0255 02       		.uleb128 0x2
 3360 0256 A8040000 		.4byte	.LASF45
 3361 025a 08       		.byte	0x8
 3362 025b 30       		.byte	0x30
 3363 025c 60020000 		.4byte	0x260
 3364 0260 06       		.uleb128 0x6
 3365 0261 04       		.byte	0x4
 3366 0262 66020000 		.4byte	0x266
 3367 0266 09       		.uleb128 0x9
 3368 0267 D1020000 		.4byte	.LASF46
 3369 026b 48       		.byte	0x48
 3370 026c 01       		.byte	0x1
 3371 026d 61       		.byte	0x61
 3372 026e E9020000 		.4byte	0x2e9
 3373 0272 0A       		.uleb128 0xa
 3374 0273 6B080000 		.4byte	.LASF47
 3375 0277 01       		.byte	0x1
 3376 0278 63       		.byte	0x63
 3377 0279 0E030000 		.4byte	0x30e
 3378 027d 00       		.byte	0
 3379 027e 0A       		.uleb128 0xa
 3380 027f 44060000 		.4byte	.LASF48
 3381 0283 01       		.byte	0x1
 3382 0284 64       		.byte	0x64
 3383 0285 0E030000 		.4byte	0x30e
 3384 0289 04       		.byte	0x4
 3385 028a 0D       		.uleb128 0xd
 3386 028b 7500     		.ascii	"u\000"
 3387 028d 01       		.byte	0x1
 3388 028e 6A       		.byte	0x6a
 3389 028f 4F030000 		.4byte	0x34f
 3390 0293 08       		.byte	0x8
 3391 0294 0A       		.uleb128 0xa
 3392 0295 93010000 		.4byte	.LASF49
 3393 0299 01       		.byte	0x1
 3394 029a 6C       		.byte	0x6c
 3395 029b 04020000 		.4byte	0x204
 3396 029f 10       		.byte	0x10
 3397 02a0 0A       		.uleb128 0xa
 3398 02a1 65000000 		.4byte	.LASF50
 3399 02a5 01       		.byte	0x1
 3400 02a6 6D       		.byte	0x6d
 3401 02a7 04020000 		.4byte	0x204
 3402 02ab 24       		.byte	0x24
 3403 02ac 0A       		.uleb128 0xa
 3404 02ad 41030000 		.4byte	.LASF51
 3405 02b1 01       		.byte	0x1
 3406 02b2 6F       		.byte	0x6f
 3407 02b3 F9010000 		.4byte	0x1f9
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 113


 3408 02b7 38       		.byte	0x38
 3409 02b8 0A       		.uleb128 0xa
 3410 02b9 DE060000 		.4byte	.LASF52
 3411 02bd 01       		.byte	0x1
 3412 02be 70       		.byte	0x70
 3413 02bf 10010000 		.4byte	0x110
 3414 02c3 3C       		.byte	0x3c
 3415 02c4 0A       		.uleb128 0xa
 3416 02c5 19040000 		.4byte	.LASF53
 3417 02c9 01       		.byte	0x1
 3418 02ca 71       		.byte	0x71
 3419 02cb 10010000 		.4byte	0x110
 3420 02cf 40       		.byte	0x40
 3421 02d0 0A       		.uleb128 0xa
 3422 02d1 0B090000 		.4byte	.LASF54
 3423 02d5 01       		.byte	0x1
 3424 02d6 73       		.byte	0x73
 3425 02d7 6E030000 		.4byte	0x36e
 3426 02db 44       		.byte	0x44
 3427 02dc 0A       		.uleb128 0xa
 3428 02dd BE010000 		.4byte	.LASF55
 3429 02e1 01       		.byte	0x1
 3430 02e2 74       		.byte	0x74
 3431 02e3 6E030000 		.4byte	0x36e
 3432 02e7 45       		.byte	0x45
 3433 02e8 00       		.byte	0
 3434 02e9 09       		.uleb128 0x9
 3435 02ea 60040000 		.4byte	.LASF56
 3436 02ee 08       		.byte	0x8
 3437 02ef 01       		.byte	0x1
 3438 02f0 43       		.byte	0x43
 3439 02f1 0E030000 		.4byte	0x30e
 3440 02f5 0A       		.uleb128 0xa
 3441 02f6 62070000 		.4byte	.LASF57
 3442 02fa 01       		.byte	0x1
 3443 02fb 45       		.byte	0x45
 3444 02fc 0E030000 		.4byte	0x30e
 3445 0300 00       		.byte	0
 3446 0301 0A       		.uleb128 0xa
 3447 0302 39020000 		.4byte	.LASF58
 3448 0306 01       		.byte	0x1
 3449 0307 46       		.byte	0x46
 3450 0308 0E030000 		.4byte	0x30e
 3451 030c 04       		.byte	0x4
 3452 030d 00       		.byte	0
 3453 030e 06       		.uleb128 0x6
 3454 030f 04       		.byte	0x4
 3455 0310 CB000000 		.4byte	0xcb
 3456 0314 02       		.uleb128 0x2
 3457 0315 C5060000 		.4byte	.LASF59
 3458 0319 01       		.byte	0x1
 3459 031a 47       		.byte	0x47
 3460 031b E9020000 		.4byte	0x2e9
 3461 031f 09       		.uleb128 0x9
 3462 0320 10000000 		.4byte	.LASF60
 3463 0324 08       		.byte	0x8
 3464 0325 01       		.byte	0x1
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 114


 3465 0326 49       		.byte	0x49
 3466 0327 44030000 		.4byte	0x344
 3467 032b 0A       		.uleb128 0xa
 3468 032c ED080000 		.4byte	.LASF61
 3469 0330 01       		.byte	0x1
 3470 0331 4B       		.byte	0x4b
 3471 0332 0F020000 		.4byte	0x20f
 3472 0336 00       		.byte	0
 3473 0337 0A       		.uleb128 0xa
 3474 0338 D5010000 		.4byte	.LASF62
 3475 033c 01       		.byte	0x1
 3476 033d 4C       		.byte	0x4c
 3477 033e 10010000 		.4byte	0x110
 3478 0342 04       		.byte	0x4
 3479 0343 00       		.byte	0
 3480 0344 02       		.uleb128 0x2
 3481 0345 32000000 		.4byte	.LASF63
 3482 0349 01       		.byte	0x1
 3483 034a 4D       		.byte	0x4d
 3484 034b 1F030000 		.4byte	0x31f
 3485 034f 0E       		.uleb128 0xe
 3486 0350 08       		.byte	0x8
 3487 0351 01       		.byte	0x1
 3488 0352 66       		.byte	0x66
 3489 0353 6E030000 		.4byte	0x36e
 3490 0357 0F       		.uleb128 0xf
 3491 0358 C4020000 		.4byte	.LASF64
 3492 035c 01       		.byte	0x1
 3493 035d 68       		.byte	0x68
 3494 035e 14030000 		.4byte	0x314
 3495 0362 0F       		.uleb128 0xf
 3496 0363 53030000 		.4byte	.LASF65
 3497 0367 01       		.byte	0x1
 3498 0368 69       		.byte	0x69
 3499 0369 44030000 		.4byte	0x344
 3500 036d 00       		.byte	0
 3501 036e 0B       		.uleb128 0xb
 3502 036f CB000000 		.4byte	0xcb
 3503 0373 02       		.uleb128 0x2
 3504 0374 E6080000 		.4byte	.LASF66
 3505 0378 01       		.byte	0x1
 3506 0379 83       		.byte	0x83
 3507 037a 66020000 		.4byte	0x266
 3508 037e 02       		.uleb128 0x2
 3509 037f EA010000 		.4byte	.LASF67
 3510 0383 01       		.byte	0x1
 3511 0384 87       		.byte	0x87
 3512 0385 73030000 		.4byte	0x373
 3513 0389 09       		.uleb128 0x9
 3514 038a F1000000 		.4byte	.LASF68
 3515 038e 08       		.byte	0x8
 3516 038f 01       		.byte	0x1
 3517 0390 94       		.byte	0x94
 3518 0391 AE030000 		.4byte	0x3ae
 3519 0395 0A       		.uleb128 0xa
 3520 0396 A9030000 		.4byte	.LASF69
 3521 039a 01       		.byte	0x1
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 115


 3522 039b 96       		.byte	0x96
 3523 039c B9000000 		.4byte	0xb9
 3524 03a0 00       		.byte	0
 3525 03a1 0A       		.uleb128 0xa
 3526 03a2 A1030000 		.4byte	.LASF70
 3527 03a6 01       		.byte	0x1
 3528 03a7 97       		.byte	0x97
 3529 03a8 55020000 		.4byte	0x255
 3530 03ac 04       		.byte	0x4
 3531 03ad 00       		.byte	0
 3532 03ae 02       		.uleb128 0x2
 3533 03af F4040000 		.4byte	.LASF71
 3534 03b3 01       		.byte	0x1
 3535 03b4 98       		.byte	0x98
 3536 03b5 89030000 		.4byte	0x389
 3537 03b9 02       		.uleb128 0x2
 3538 03ba 09020000 		.4byte	.LASF72
 3539 03be 01       		.byte	0x1
 3540 03bf 9D       		.byte	0x9d
 3541 03c0 AE030000 		.4byte	0x3ae
 3542 03c4 10       		.uleb128 0x10
 3543 03c5 2D050000 		.4byte	.LASF144
 3544 03c9 02       		.byte	0x2
 3545 03ca D1       		.byte	0xd1
 3546 03cb EC000000 		.4byte	0xec
 3547 03cf 03       		.byte	0x3
 3548 03d0 EB030000 		.4byte	0x3eb
 3549 03d4 11       		.uleb128 0x11
 3550 03d5 B2020000 		.4byte	.LASF73
 3551 03d9 02       		.byte	0x2
 3552 03da D3       		.byte	0xd3
 3553 03db EC000000 		.4byte	0xec
 3554 03df 11       		.uleb128 0x11
 3555 03e0 6E040000 		.4byte	.LASF74
 3556 03e4 02       		.byte	0x2
 3557 03e5 D3       		.byte	0xd3
 3558 03e6 EC000000 		.4byte	0xec
 3559 03ea 00       		.byte	0
 3560 03eb 12       		.uleb128 0x12
 3561 03ec E4030000 		.4byte	.LASF145
 3562 03f0 02       		.byte	0x2
 3563 03f1 E5       		.byte	0xe5
 3564 03f2 03       		.byte	0x3
 3565 03f3 03040000 		.4byte	0x403
 3566 03f7 13       		.uleb128 0x13
 3567 03f8 F1050000 		.4byte	.LASF146
 3568 03fc 02       		.byte	0x2
 3569 03fd E5       		.byte	0xe5
 3570 03fe EC000000 		.4byte	0xec
 3571 0402 00       		.byte	0
 3572 0403 14       		.uleb128 0x14
 3573 0404 9A080000 		.4byte	.LASF76
 3574 0408 01       		.byte	0x1
 3575 0409 FF       		.byte	0xff
 3576 040a 05010000 		.4byte	0x105
 3577 040e 00000000 		.4byte	.LFB68
 3578 0412 B4000000 		.4byte	.LFE68-.LFB68
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 116


 3579 0416 01       		.uleb128 0x1
 3580 0417 9C       		.byte	0x9c
 3581 0418 48040000 		.4byte	0x448
 3582 041c 15       		.uleb128 0x15
 3583 041d C4020000 		.4byte	.LASF64
 3584 0421 01       		.byte	0x1
 3585 0422 FF       		.byte	0xff
 3586 0423 55020000 		.4byte	0x255
 3587 0427 02       		.uleb128 0x2
 3588 0428 91       		.byte	0x91
 3589 0429 6C       		.sleb128 -20
 3590 042a 15       		.uleb128 0x15
 3591 042b AE050000 		.4byte	.LASF75
 3592 042f 01       		.byte	0x1
 3593 0430 FF       		.byte	0xff
 3594 0431 05010000 		.4byte	0x105
 3595 0435 02       		.uleb128 0x2
 3596 0436 91       		.byte	0x91
 3597 0437 68       		.sleb128 -24
 3598 0438 16       		.uleb128 0x16
 3599 0439 80070000 		.4byte	.LASF80
 3600 043d 01       		.byte	0x1
 3601 043e 0101     		.2byte	0x101
 3602 0440 4E040000 		.4byte	0x44e
 3603 0444 02       		.uleb128 0x2
 3604 0445 91       		.byte	0x91
 3605 0446 74       		.sleb128 -12
 3606 0447 00       		.byte	0
 3607 0448 06       		.uleb128 0x6
 3608 0449 04       		.byte	0x4
 3609 044a 7E030000 		.4byte	0x37e
 3610 044e 07       		.uleb128 0x7
 3611 044f 48040000 		.4byte	0x448
 3612 0453 17       		.uleb128 0x17
 3613 0454 07050000 		.4byte	.LASF77
 3614 0458 01       		.byte	0x1
 3615 0459 7001     		.2byte	0x170
 3616 045b 55020000 		.4byte	0x255
 3617 045f 00000000 		.4byte	.LFB69
 3618 0463 50000000 		.4byte	.LFE69-.LFB69
 3619 0467 01       		.uleb128 0x1
 3620 0468 9C       		.byte	0x9c
 3621 0469 C8040000 		.4byte	0x4c8
 3622 046d 18       		.uleb128 0x18
 3623 046e 62060000 		.4byte	.LASF78
 3624 0472 01       		.byte	0x1
 3625 0473 7001     		.2byte	0x170
 3626 0475 C8040000 		.4byte	0x4c8
 3627 0479 02       		.uleb128 0x2
 3628 047a 91       		.byte	0x91
 3629 047b 64       		.sleb128 -28
 3630 047c 18       		.uleb128 0x18
 3631 047d 19040000 		.4byte	.LASF53
 3632 0481 01       		.byte	0x1
 3633 0482 7001     		.2byte	0x170
 3634 0484 C8040000 		.4byte	0x4c8
 3635 0488 02       		.uleb128 0x2
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 117


 3636 0489 91       		.byte	0x91
 3637 048a 60       		.sleb128 -32
 3638 048b 18       		.uleb128 0x18
 3639 048c 20060000 		.4byte	.LASF79
 3640 0490 01       		.byte	0x1
 3641 0491 7001     		.2byte	0x170
 3642 0493 CD040000 		.4byte	0x4cd
 3643 0497 02       		.uleb128 0x2
 3644 0498 91       		.byte	0x91
 3645 0499 5F       		.sleb128 -33
 3646 049a 16       		.uleb128 0x16
 3647 049b D1000000 		.4byte	.LASF81
 3648 049f 01       		.byte	0x1
 3649 04a0 7201     		.2byte	0x172
 3650 04a2 48040000 		.4byte	0x448
 3651 04a6 02       		.uleb128 0x2
 3652 04a7 91       		.byte	0x91
 3653 04a8 70       		.sleb128 -16
 3654 04a9 16       		.uleb128 0x16
 3655 04aa 12070000 		.4byte	.LASF82
 3656 04ae 01       		.byte	0x1
 3657 04af 7301     		.2byte	0x173
 3658 04b1 25000000 		.4byte	0x25
 3659 04b5 02       		.uleb128 0x2
 3660 04b6 91       		.byte	0x91
 3661 04b7 74       		.sleb128 -12
 3662 04b8 16       		.uleb128 0x16
 3663 04b9 6C050000 		.4byte	.LASF83
 3664 04bd 01       		.byte	0x1
 3665 04be 7401     		.2byte	0x174
 3666 04c0 26010000 		.4byte	0x126
 3667 04c4 02       		.uleb128 0x2
 3668 04c5 91       		.byte	0x91
 3669 04c6 6C       		.sleb128 -20
 3670 04c7 00       		.byte	0
 3671 04c8 07       		.uleb128 0x7
 3672 04c9 10010000 		.4byte	0x110
 3673 04cd 07       		.uleb128 0x7
 3674 04ce D6000000 		.4byte	0xd6
 3675 04d2 19       		.uleb128 0x19
 3676 04d3 71020000 		.4byte	.LASF84
 3677 04d7 01       		.byte	0x1
 3678 04d8 A601     		.2byte	0x1a6
 3679 04da 00000000 		.4byte	.LFB70
 3680 04de 3E000000 		.4byte	.LFE70-.LFB70
 3681 04e2 01       		.uleb128 0x1
 3682 04e3 9C       		.byte	0x9c
 3683 04e4 34050000 		.4byte	0x534
 3684 04e8 18       		.uleb128 0x18
 3685 04e9 62060000 		.4byte	.LASF78
 3686 04ed 01       		.byte	0x1
 3687 04ee A601     		.2byte	0x1a6
 3688 04f0 C8040000 		.4byte	0x4c8
 3689 04f4 02       		.uleb128 0x2
 3690 04f5 91       		.byte	0x91
 3691 04f6 74       		.sleb128 -12
 3692 04f7 18       		.uleb128 0x18
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 118


 3693 04f8 19040000 		.4byte	.LASF53
 3694 04fc 01       		.byte	0x1
 3695 04fd A601     		.2byte	0x1a6
 3696 04ff C8040000 		.4byte	0x4c8
 3697 0503 02       		.uleb128 0x2
 3698 0504 91       		.byte	0x91
 3699 0505 70       		.sleb128 -16
 3700 0506 18       		.uleb128 0x18
 3701 0507 6C050000 		.4byte	.LASF83
 3702 050b 01       		.byte	0x1
 3703 050c A601     		.2byte	0x1a6
 3704 050e 26010000 		.4byte	0x126
 3705 0512 02       		.uleb128 0x2
 3706 0513 91       		.byte	0x91
 3707 0514 6C       		.sleb128 -20
 3708 0515 18       		.uleb128 0x18
 3709 0516 20060000 		.4byte	.LASF79
 3710 051a 01       		.byte	0x1
 3711 051b A601     		.2byte	0x1a6
 3712 051d CD040000 		.4byte	0x4cd
 3713 0521 02       		.uleb128 0x2
 3714 0522 91       		.byte	0x91
 3715 0523 6B       		.sleb128 -21
 3716 0524 18       		.uleb128 0x18
 3717 0525 D1000000 		.4byte	.LASF81
 3718 0529 01       		.byte	0x1
 3719 052a A601     		.2byte	0x1a6
 3720 052c 48040000 		.4byte	0x448
 3721 0530 02       		.uleb128 0x2
 3722 0531 91       		.byte	0x91
 3723 0532 00       		.sleb128 0
 3724 0533 00       		.byte	0
 3725 0534 19       		.uleb128 0x19
 3726 0535 4E050000 		.4byte	.LASF85
 3727 0539 01       		.byte	0x1
 3728 053a D201     		.2byte	0x1d2
 3729 053c 00000000 		.4byte	.LFB71
 3730 0540 34000000 		.4byte	.LFE71-.LFB71
 3731 0544 01       		.uleb128 0x1
 3732 0545 9C       		.byte	0x9c
 3733 0546 5A050000 		.4byte	0x55a
 3734 054a 18       		.uleb128 0x18
 3735 054b D1000000 		.4byte	.LASF81
 3736 054f 01       		.byte	0x1
 3737 0550 D201     		.2byte	0x1d2
 3738 0552 48040000 		.4byte	0x448
 3739 0556 02       		.uleb128 0x2
 3740 0557 91       		.byte	0x91
 3741 0558 74       		.sleb128 -12
 3742 0559 00       		.byte	0
 3743 055a 17       		.uleb128 0x17
 3744 055b 1B050000 		.4byte	.LASF86
 3745 055f 01       		.byte	0x1
 3746 0560 F001     		.2byte	0x1f0
 3747 0562 55020000 		.4byte	0x255
 3748 0566 00000000 		.4byte	.LFB72
 3749 056a 30000000 		.4byte	.LFE72-.LFB72
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 119


 3750 056e 01       		.uleb128 0x1
 3751 056f 9C       		.byte	0x9c
 3752 0570 B1050000 		.4byte	0x5b1
 3753 0574 18       		.uleb128 0x18
 3754 0575 20060000 		.4byte	.LASF79
 3755 0579 01       		.byte	0x1
 3756 057a F001     		.2byte	0x1f0
 3757 057c CD040000 		.4byte	0x4cd
 3758 0580 02       		.uleb128 0x2
 3759 0581 91       		.byte	0x91
 3760 0582 67       		.sleb128 -25
 3761 0583 16       		.uleb128 0x16
 3762 0584 AE050000 		.4byte	.LASF75
 3763 0588 01       		.byte	0x1
 3764 0589 F201     		.2byte	0x1f2
 3765 058b 55020000 		.4byte	0x255
 3766 058f 02       		.uleb128 0x2
 3767 0590 91       		.byte	0x91
 3768 0591 6C       		.sleb128 -20
 3769 0592 16       		.uleb128 0x16
 3770 0593 33040000 		.4byte	.LASF87
 3771 0597 01       		.byte	0x1
 3772 0598 F301     		.2byte	0x1f3
 3773 059a C8040000 		.4byte	0x4c8
 3774 059e 02       		.uleb128 0x2
 3775 059f 91       		.byte	0x91
 3776 05a0 74       		.sleb128 -12
 3777 05a1 16       		.uleb128 0x16
 3778 05a2 97020000 		.4byte	.LASF88
 3779 05a6 01       		.byte	0x1
 3780 05a7 F301     		.2byte	0x1f3
 3781 05a9 C8040000 		.4byte	0x4c8
 3782 05ad 02       		.uleb128 0x2
 3783 05ae 91       		.byte	0x91
 3784 05af 70       		.sleb128 -16
 3785 05b0 00       		.byte	0
 3786 05b1 17       		.uleb128 0x17
 3787 05b2 72080000 		.4byte	.LASF89
 3788 05b6 01       		.byte	0x1
 3789 05b7 4D02     		.2byte	0x24d
 3790 05b9 05010000 		.4byte	0x105
 3791 05bd 00000000 		.4byte	.LFB73
 3792 05c1 4C000000 		.4byte	.LFE73-.LFB73
 3793 05c5 01       		.uleb128 0x1
 3794 05c6 9C       		.byte	0x9c
 3795 05c7 F9050000 		.4byte	0x5f9
 3796 05cb 18       		.uleb128 0x18
 3797 05cc 7C050000 		.4byte	.LASF90
 3798 05d0 01       		.byte	0x1
 3799 05d1 4D02     		.2byte	0x24d
 3800 05d3 55020000 		.4byte	0x255
 3801 05d7 02       		.uleb128 0x2
 3802 05d8 91       		.byte	0x91
 3803 05d9 64       		.sleb128 -28
 3804 05da 16       		.uleb128 0x16
 3805 05db 88070000 		.4byte	.LASF91
 3806 05df 01       		.byte	0x1
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 120


 3807 05e0 4F02     		.2byte	0x24f
 3808 05e2 05010000 		.4byte	0x105
 3809 05e6 02       		.uleb128 0x2
 3810 05e7 91       		.byte	0x91
 3811 05e8 6C       		.sleb128 -20
 3812 05e9 16       		.uleb128 0x16
 3813 05ea 96000000 		.4byte	.LASF92
 3814 05ee 01       		.byte	0x1
 3815 05ef 5002     		.2byte	0x250
 3816 05f1 4E040000 		.4byte	0x44e
 3817 05f5 02       		.uleb128 0x2
 3818 05f6 91       		.byte	0x91
 3819 05f7 68       		.sleb128 -24
 3820 05f8 00       		.byte	0
 3821 05f9 17       		.uleb128 0x17
 3822 05fa 91060000 		.4byte	.LASF93
 3823 05fe 01       		.byte	0x1
 3824 05ff 8402     		.2byte	0x284
 3825 0601 05010000 		.4byte	0x105
 3826 0605 00000000 		.4byte	.LFB74
 3827 0609 50000000 		.4byte	.LFE74-.LFB74
 3828 060d 01       		.uleb128 0x1
 3829 060e 9C       		.byte	0x9c
 3830 060f 50060000 		.4byte	0x650
 3831 0613 18       		.uleb128 0x18
 3832 0614 7C050000 		.4byte	.LASF90
 3833 0618 01       		.byte	0x1
 3834 0619 8402     		.2byte	0x284
 3835 061b 55020000 		.4byte	0x255
 3836 061f 02       		.uleb128 0x2
 3837 0620 91       		.byte	0x91
 3838 0621 64       		.sleb128 -28
 3839 0622 18       		.uleb128 0x18
 3840 0623 69070000 		.4byte	.LASF94
 3841 0627 01       		.byte	0x1
 3842 0628 8402     		.2byte	0x284
 3843 062a 1B010000 		.4byte	0x11b
 3844 062e 02       		.uleb128 0x2
 3845 062f 91       		.byte	0x91
 3846 0630 60       		.sleb128 -32
 3847 0631 16       		.uleb128 0x16
 3848 0632 88070000 		.4byte	.LASF91
 3849 0636 01       		.byte	0x1
 3850 0637 8602     		.2byte	0x286
 3851 0639 05010000 		.4byte	0x105
 3852 063d 02       		.uleb128 0x2
 3853 063e 91       		.byte	0x91
 3854 063f 6C       		.sleb128 -20
 3855 0640 16       		.uleb128 0x16
 3856 0641 96000000 		.4byte	.LASF92
 3857 0645 01       		.byte	0x1
 3858 0646 8702     		.2byte	0x287
 3859 0648 4E040000 		.4byte	0x44e
 3860 064c 02       		.uleb128 0x2
 3861 064d 91       		.byte	0x91
 3862 064e 68       		.sleb128 -24
 3863 064f 00       		.byte	0
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 121


 3864 0650 17       		.uleb128 0x17
 3865 0651 13090000 		.4byte	.LASF95
 3866 0655 01       		.byte	0x1
 3867 0656 CA02     		.2byte	0x2ca
 3868 0658 55020000 		.4byte	0x255
 3869 065c 00000000 		.4byte	.LFB75
 3870 0660 2C000000 		.4byte	.LFE75-.LFB75
 3871 0664 01       		.uleb128 0x1
 3872 0665 9C       		.byte	0x9c
 3873 0666 98060000 		.4byte	0x698
 3874 066a 18       		.uleb128 0x18
 3875 066b B8050000 		.4byte	.LASF96
 3876 066f 01       		.byte	0x1
 3877 0670 CA02     		.2byte	0x2ca
 3878 0672 C8040000 		.4byte	0x4c8
 3879 0676 02       		.uleb128 0x2
 3880 0677 91       		.byte	0x91
 3881 0678 6C       		.sleb128 -20
 3882 0679 18       		.uleb128 0x18
 3883 067a 24040000 		.4byte	.LASF97
 3884 067e 01       		.byte	0x1
 3885 067f CA02     		.2byte	0x2ca
 3886 0681 C8040000 		.4byte	0x4c8
 3887 0685 02       		.uleb128 0x2
 3888 0686 91       		.byte	0x91
 3889 0687 68       		.sleb128 -24
 3890 0688 16       		.uleb128 0x16
 3891 0689 A1030000 		.4byte	.LASF70
 3892 068d 01       		.byte	0x1
 3893 068e CC02     		.2byte	0x2cc
 3894 0690 55020000 		.4byte	0x255
 3895 0694 02       		.uleb128 0x2
 3896 0695 91       		.byte	0x91
 3897 0696 74       		.sleb128 -12
 3898 0697 00       		.byte	0
 3899 0698 17       		.uleb128 0x17
 3900 0699 07040000 		.4byte	.LASF98
 3901 069d 01       		.byte	0x1
 3902 069e E402     		.2byte	0x2e4
 3903 06a0 05010000 		.4byte	0x105
 3904 06a4 00000000 		.4byte	.LFB76
 3905 06a8 54010000 		.4byte	.LFE76-.LFB76
 3906 06ac 01       		.uleb128 0x1
 3907 06ad 9C       		.byte	0x9c
 3908 06ae 2B070000 		.4byte	0x72b
 3909 06b2 18       		.uleb128 0x18
 3910 06b3 C4020000 		.4byte	.LASF64
 3911 06b7 01       		.byte	0x1
 3912 06b8 E402     		.2byte	0x2e4
 3913 06ba 55020000 		.4byte	0x255
 3914 06be 02       		.uleb128 0x2
 3915 06bf 91       		.byte	0x91
 3916 06c0 5C       		.sleb128 -36
 3917 06c1 18       		.uleb128 0x18
 3918 06c2 24070000 		.4byte	.LASF99
 3919 06c6 01       		.byte	0x1
 3920 06c7 E402     		.2byte	0x2e4
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 122


 3921 06c9 2B070000 		.4byte	0x72b
 3922 06cd 02       		.uleb128 0x2
 3923 06ce 91       		.byte	0x91
 3924 06cf 58       		.sleb128 -40
 3925 06d0 18       		.uleb128 0x18
 3926 06d1 69070000 		.4byte	.LASF94
 3927 06d5 01       		.byte	0x1
 3928 06d6 E402     		.2byte	0x2e4
 3929 06d8 1B010000 		.4byte	0x11b
 3930 06dc 02       		.uleb128 0x2
 3931 06dd 91       		.byte	0x91
 3932 06de 54       		.sleb128 -44
 3933 06df 18       		.uleb128 0x18
 3934 06e0 F2010000 		.4byte	.LASF100
 3935 06e4 01       		.byte	0x1
 3936 06e5 E402     		.2byte	0x2e4
 3937 06e7 30070000 		.4byte	0x730
 3938 06eb 02       		.uleb128 0x2
 3939 06ec 91       		.byte	0x91
 3940 06ed 50       		.sleb128 -48
 3941 06ee 16       		.uleb128 0x16
 3942 06ef 83030000 		.4byte	.LASF101
 3943 06f3 01       		.byte	0x1
 3944 06f4 E602     		.2byte	0x2e6
 3945 06f6 05010000 		.4byte	0x105
 3946 06fa 02       		.uleb128 0x2
 3947 06fb 91       		.byte	0x91
 3948 06fc 74       		.sleb128 -12
 3949 06fd 16       		.uleb128 0x16
 3950 06fe A3020000 		.4byte	.LASF102
 3951 0702 01       		.byte	0x1
 3952 0703 E602     		.2byte	0x2e6
 3953 0705 05010000 		.4byte	0x105
 3954 0709 02       		.uleb128 0x2
 3955 070a 91       		.byte	0x91
 3956 070b 6C       		.sleb128 -20
 3957 070c 16       		.uleb128 0x16
 3958 070d 98030000 		.4byte	.LASF103
 3959 0711 01       		.byte	0x1
 3960 0712 E702     		.2byte	0x2e7
 3961 0714 4A020000 		.4byte	0x24a
 3962 0718 02       		.uleb128 0x2
 3963 0719 91       		.byte	0x91
 3964 071a 64       		.sleb128 -28
 3965 071b 16       		.uleb128 0x16
 3966 071c 80070000 		.4byte	.LASF80
 3967 0720 01       		.byte	0x1
 3968 0721 E802     		.2byte	0x2e8
 3969 0723 4E040000 		.4byte	0x44e
 3970 0727 02       		.uleb128 0x2
 3971 0728 91       		.byte	0x91
 3972 0729 70       		.sleb128 -16
 3973 072a 00       		.byte	0
 3974 072b 07       		.uleb128 0x7
 3975 072c C4000000 		.4byte	0xc4
 3976 0730 07       		.uleb128 0x7
 3977 0731 05010000 		.4byte	0x105
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 123


 3978 0735 17       		.uleb128 0x17
 3979 0736 CB030000 		.4byte	.LASF104
 3980 073a 01       		.byte	0x1
 3981 073b B603     		.2byte	0x3b6
 3982 073d 05010000 		.4byte	0x105
 3983 0741 00000000 		.4byte	.LFB77
 3984 0745 B4000000 		.4byte	.LFE77-.LFB77
 3985 0749 01       		.uleb128 0x1
 3986 074a 9C       		.byte	0x9c
 3987 074b 2D080000 		.4byte	0x82d
 3988 074f 18       		.uleb128 0x18
 3989 0750 C4020000 		.4byte	.LASF64
 3990 0754 01       		.byte	0x1
 3991 0755 B603     		.2byte	0x3b6
 3992 0757 55020000 		.4byte	0x255
 3993 075b 02       		.uleb128 0x2
 3994 075c 91       		.byte	0x91
 3995 075d 54       		.sleb128 -44
 3996 075e 18       		.uleb128 0x18
 3997 075f 24070000 		.4byte	.LASF99
 3998 0763 01       		.byte	0x1
 3999 0764 B603     		.2byte	0x3b6
 4000 0766 2B070000 		.4byte	0x72b
 4001 076a 02       		.uleb128 0x2
 4002 076b 91       		.byte	0x91
 4003 076c 50       		.sleb128 -48
 4004 076d 18       		.uleb128 0x18
 4005 076e 7C000000 		.4byte	.LASF105
 4006 0772 01       		.byte	0x1
 4007 0773 B603     		.2byte	0x3b6
 4008 0775 33080000 		.4byte	0x833
 4009 0779 02       		.uleb128 0x2
 4010 077a 91       		.byte	0x91
 4011 077b 4C       		.sleb128 -52
 4012 077c 18       		.uleb128 0x18
 4013 077d F2010000 		.4byte	.LASF100
 4014 0781 01       		.byte	0x1
 4015 0782 B603     		.2byte	0x3b6
 4016 0784 30070000 		.4byte	0x730
 4017 0788 02       		.uleb128 0x2
 4018 0789 91       		.byte	0x91
 4019 078a 48       		.sleb128 -56
 4020 078b 16       		.uleb128 0x16
 4021 078c 88070000 		.4byte	.LASF91
 4022 0790 01       		.byte	0x1
 4023 0791 B803     		.2byte	0x3b8
 4024 0793 05010000 		.4byte	0x105
 4025 0797 02       		.uleb128 0x2
 4026 0798 91       		.byte	0x91
 4027 0799 74       		.sleb128 -12
 4028 079a 16       		.uleb128 0x16
 4029 079b 5A020000 		.4byte	.LASF106
 4030 079f 01       		.byte	0x1
 4031 07a0 B903     		.2byte	0x3b9
 4032 07a2 10010000 		.4byte	0x110
 4033 07a6 02       		.uleb128 0x2
 4034 07a7 91       		.byte	0x91
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 124


 4035 07a8 68       		.sleb128 -24
 4036 07a9 16       		.uleb128 0x16
 4037 07aa 80070000 		.4byte	.LASF80
 4038 07ae 01       		.byte	0x1
 4039 07af BA03     		.2byte	0x3ba
 4040 07b1 4E040000 		.4byte	0x44e
 4041 07b5 02       		.uleb128 0x2
 4042 07b6 91       		.byte	0x91
 4043 07b7 70       		.sleb128 -16
 4044 07b8 1A       		.uleb128 0x1a
 4045 07b9 C4030000 		.4byte	0x3c4
 4046 07bd 12000000 		.4byte	.LBB23
 4047 07c1 1A000000 		.4byte	.LBE23-.LBB23
 4048 07c5 01       		.byte	0x1
 4049 07c6 D503     		.2byte	0x3d5
 4050 07c8 E7070000 		.4byte	0x7e7
 4051 07cc 1B       		.uleb128 0x1b
 4052 07cd 12000000 		.4byte	.LBB24
 4053 07d1 1A000000 		.4byte	.LBE24-.LBB24
 4054 07d5 1C       		.uleb128 0x1c
 4055 07d6 D4030000 		.4byte	0x3d4
 4056 07da 02       		.uleb128 0x2
 4057 07db 91       		.byte	0x91
 4058 07dc 5C       		.sleb128 -36
 4059 07dd 1C       		.uleb128 0x1c
 4060 07de DF030000 		.4byte	0x3df
 4061 07e2 02       		.uleb128 0x2
 4062 07e3 91       		.byte	0x91
 4063 07e4 58       		.sleb128 -40
 4064 07e5 00       		.byte	0
 4065 07e6 00       		.byte	0
 4066 07e7 1D       		.uleb128 0x1d
 4067 07e8 40000000 		.4byte	.LBB25
 4068 07ec 5A000000 		.4byte	.LBE25-.LBB25
 4069 07f0 13080000 		.4byte	0x813
 4070 07f4 16       		.uleb128 0x16
 4071 07f5 BE010000 		.4byte	.LASF55
 4072 07f9 01       		.byte	0x1
 4073 07fa D903     		.2byte	0x3d9
 4074 07fc 38080000 		.4byte	0x838
 4075 0800 02       		.uleb128 0x2
 4076 0801 91       		.byte	0x91
 4077 0802 67       		.sleb128 -25
 4078 0803 16       		.uleb128 0x16
 4079 0804 5E030000 		.4byte	.LASF107
 4080 0808 01       		.byte	0x1
 4081 0809 DA03     		.2byte	0x3da
 4082 080b C8040000 		.4byte	0x4c8
 4083 080f 02       		.uleb128 0x2
 4084 0810 91       		.byte	0x91
 4085 0811 60       		.sleb128 -32
 4086 0812 00       		.byte	0
 4087 0813 1E       		.uleb128 0x1e
 4088 0814 EB030000 		.4byte	0x3eb
 4089 0818 A4000000 		.4byte	.LBB26
 4090 081c 06000000 		.4byte	.LBE26-.LBB26
 4091 0820 01       		.byte	0x1
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 125


 4092 0821 5204     		.2byte	0x452
 4093 0823 1F       		.uleb128 0x1f
 4094 0824 F7030000 		.4byte	0x3f7
 4095 0828 02       		.uleb128 0x2
 4096 0829 91       		.byte	0x91
 4097 082a 6C       		.sleb128 -20
 4098 082b 00       		.byte	0
 4099 082c 00       		.byte	0
 4100 082d 06       		.uleb128 0x6
 4101 082e 04       		.byte	0x4
 4102 082f 05010000 		.4byte	0x105
 4103 0833 07       		.uleb128 0x7
 4104 0834 2D080000 		.4byte	0x82d
 4105 0838 07       		.uleb128 0x7
 4106 0839 CB000000 		.4byte	0xcb
 4107 083d 17       		.uleb128 0x17
 4108 083e 87040000 		.4byte	.LASF108
 4109 0842 01       		.byte	0x1
 4110 0843 5804     		.2byte	0x458
 4111 0845 05010000 		.4byte	0x105
 4112 0849 00000000 		.4byte	.LFB78
 4113 084d A6000000 		.4byte	.LFE78-.LFB78
 4114 0851 01       		.uleb128 0x1
 4115 0852 9C       		.byte	0x9c
 4116 0853 21090000 		.4byte	0x921
 4117 0857 18       		.uleb128 0x18
 4118 0858 C4020000 		.4byte	.LASF64
 4119 085c 01       		.byte	0x1
 4120 085d 5804     		.2byte	0x458
 4121 085f 55020000 		.4byte	0x255
 4122 0863 02       		.uleb128 0x2
 4123 0864 91       		.byte	0x91
 4124 0865 54       		.sleb128 -44
 4125 0866 18       		.uleb128 0x18
 4126 0867 7C000000 		.4byte	.LASF105
 4127 086b 01       		.byte	0x1
 4128 086c 5804     		.2byte	0x458
 4129 086e 33080000 		.4byte	0x833
 4130 0872 02       		.uleb128 0x2
 4131 0873 91       		.byte	0x91
 4132 0874 50       		.sleb128 -48
 4133 0875 16       		.uleb128 0x16
 4134 0876 88070000 		.4byte	.LASF91
 4135 087a 01       		.byte	0x1
 4136 087b 5A04     		.2byte	0x45a
 4137 087d 05010000 		.4byte	0x105
 4138 0881 02       		.uleb128 0x2
 4139 0882 91       		.byte	0x91
 4140 0883 74       		.sleb128 -12
 4141 0884 16       		.uleb128 0x16
 4142 0885 5A020000 		.4byte	.LASF106
 4143 0889 01       		.byte	0x1
 4144 088a 5B04     		.2byte	0x45b
 4145 088c 10010000 		.4byte	0x110
 4146 0890 02       		.uleb128 0x2
 4147 0891 91       		.byte	0x91
 4148 0892 68       		.sleb128 -24
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 126


 4149 0893 16       		.uleb128 0x16
 4150 0894 80070000 		.4byte	.LASF80
 4151 0898 01       		.byte	0x1
 4152 0899 5C04     		.2byte	0x45c
 4153 089b 4E040000 		.4byte	0x44e
 4154 089f 02       		.uleb128 0x2
 4155 08a0 91       		.byte	0x91
 4156 08a1 70       		.sleb128 -16
 4157 08a2 1A       		.uleb128 0x1a
 4158 08a3 C4030000 		.4byte	0x3c4
 4159 08a7 0E000000 		.4byte	.LBB28
 4160 08ab 1A000000 		.4byte	.LBE28-.LBB28
 4161 08af 01       		.byte	0x1
 4162 08b0 7F04     		.2byte	0x47f
 4163 08b2 D1080000 		.4byte	0x8d1
 4164 08b6 1B       		.uleb128 0x1b
 4165 08b7 0E000000 		.4byte	.LBB29
 4166 08bb 1A000000 		.4byte	.LBE29-.LBB29
 4167 08bf 1C       		.uleb128 0x1c
 4168 08c0 D4030000 		.4byte	0x3d4
 4169 08c4 02       		.uleb128 0x2
 4170 08c5 91       		.byte	0x91
 4171 08c6 5C       		.sleb128 -36
 4172 08c7 1C       		.uleb128 0x1c
 4173 08c8 DF030000 		.4byte	0x3df
 4174 08cc 02       		.uleb128 0x2
 4175 08cd 91       		.byte	0x91
 4176 08ce 58       		.sleb128 -40
 4177 08cf 00       		.byte	0
 4178 08d0 00       		.byte	0
 4179 08d1 1D       		.uleb128 0x1d
 4180 08d2 2A000000 		.4byte	.LBB30
 4181 08d6 6C000000 		.4byte	.LBE30-.LBB30
 4182 08da 07090000 		.4byte	0x907
 4183 08de 16       		.uleb128 0x16
 4184 08df 41030000 		.4byte	.LASF51
 4185 08e3 01       		.byte	0x1
 4186 08e4 8104     		.2byte	0x481
 4187 08e6 C8040000 		.4byte	0x4c8
 4188 08ea 02       		.uleb128 0x2
 4189 08eb 91       		.byte	0x91
 4190 08ec 64       		.sleb128 -28
 4191 08ed 1B       		.uleb128 0x1b
 4192 08ee 3A000000 		.4byte	.LBB31
 4193 08f2 52000000 		.4byte	.LBE31-.LBB31
 4194 08f6 16       		.uleb128 0x16
 4195 08f7 BE010000 		.4byte	.LASF55
 4196 08fb 01       		.byte	0x1
 4197 08fc 8804     		.2byte	0x488
 4198 08fe 38080000 		.4byte	0x838
 4199 0902 02       		.uleb128 0x2
 4200 0903 91       		.byte	0x91
 4201 0904 63       		.sleb128 -29
 4202 0905 00       		.byte	0
 4203 0906 00       		.byte	0
 4204 0907 1E       		.uleb128 0x1e
 4205 0908 EB030000 		.4byte	0x3eb
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 127


 4206 090c 96000000 		.4byte	.LBB32
 4207 0910 06000000 		.4byte	.LBE32-.LBB32
 4208 0914 01       		.byte	0x1
 4209 0915 F704     		.2byte	0x4f7
 4210 0917 1F       		.uleb128 0x1f
 4211 0918 F7030000 		.4byte	0x3f7
 4212 091c 02       		.uleb128 0x2
 4213 091d 91       		.byte	0x91
 4214 091e 6C       		.sleb128 -20
 4215 091f 00       		.byte	0
 4216 0920 00       		.byte	0
 4217 0921 17       		.uleb128 0x17
 4218 0922 42000000 		.4byte	.LASF109
 4219 0926 01       		.byte	0x1
 4220 0927 FD04     		.2byte	0x4fd
 4221 0929 05010000 		.4byte	0x105
 4222 092d 00000000 		.4byte	.LFB79
 4223 0931 44010000 		.4byte	.LFE79-.LFB79
 4224 0935 01       		.uleb128 0x1
 4225 0936 9C       		.byte	0x9c
 4226 0937 AF090000 		.4byte	0x9af
 4227 093b 18       		.uleb128 0x18
 4228 093c C4020000 		.4byte	.LASF64
 4229 0940 01       		.byte	0x1
 4230 0941 FD04     		.2byte	0x4fd
 4231 0943 55020000 		.4byte	0x255
 4232 0947 02       		.uleb128 0x2
 4233 0948 91       		.byte	0x91
 4234 0949 5C       		.sleb128 -36
 4235 094a 18       		.uleb128 0x18
 4236 094b 08030000 		.4byte	.LASF110
 4237 094f 01       		.byte	0x1
 4238 0950 FD04     		.2byte	0x4fd
 4239 0952 AF090000 		.4byte	0x9af
 4240 0956 02       		.uleb128 0x2
 4241 0957 91       		.byte	0x91
 4242 0958 58       		.sleb128 -40
 4243 0959 18       		.uleb128 0x18
 4244 095a 69070000 		.4byte	.LASF94
 4245 095e 01       		.byte	0x1
 4246 095f FD04     		.2byte	0x4fd
 4247 0961 1B010000 		.4byte	0x11b
 4248 0965 02       		.uleb128 0x2
 4249 0966 91       		.byte	0x91
 4250 0967 54       		.sleb128 -44
 4251 0968 16       		.uleb128 0x16
 4252 0969 83030000 		.4byte	.LASF101
 4253 096d 01       		.byte	0x1
 4254 096e FF04     		.2byte	0x4ff
 4255 0970 05010000 		.4byte	0x105
 4256 0974 02       		.uleb128 0x2
 4257 0975 91       		.byte	0x91
 4258 0976 74       		.sleb128 -12
 4259 0977 16       		.uleb128 0x16
 4260 0978 98030000 		.4byte	.LASF103
 4261 097c 01       		.byte	0x1
 4262 097d 0005     		.2byte	0x500
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 128


 4263 097f 4A020000 		.4byte	0x24a
 4264 0983 02       		.uleb128 0x2
 4265 0984 91       		.byte	0x91
 4266 0985 64       		.sleb128 -28
 4267 0986 16       		.uleb128 0x16
 4268 0987 80070000 		.4byte	.LASF80
 4269 098b 01       		.byte	0x1
 4270 098c 0105     		.2byte	0x501
 4271 098e 4E040000 		.4byte	0x44e
 4272 0992 02       		.uleb128 0x2
 4273 0993 91       		.byte	0x91
 4274 0994 70       		.sleb128 -16
 4275 0995 1B       		.uleb128 0x1b
 4276 0996 18000000 		.4byte	.LBB34
 4277 099a 6E000000 		.4byte	.LBE34-.LBB34
 4278 099e 16       		.uleb128 0x16
 4279 099f 41030000 		.4byte	.LASF51
 4280 09a3 01       		.byte	0x1
 4281 09a4 1905     		.2byte	0x519
 4282 09a6 C8040000 		.4byte	0x4c8
 4283 09aa 02       		.uleb128 0x2
 4284 09ab 91       		.byte	0x91
 4285 09ac 6C       		.sleb128 -20
 4286 09ad 00       		.byte	0
 4287 09ae 00       		.byte	0
 4288 09af 07       		.uleb128 0x7
 4289 09b0 B0000000 		.4byte	0xb0
 4290 09b4 17       		.uleb128 0x17
 4291 09b5 9E000000 		.4byte	.LASF111
 4292 09b9 01       		.byte	0x1
 4293 09ba 8A05     		.2byte	0x58a
 4294 09bc 05010000 		.4byte	0x105
 4295 09c0 00000000 		.4byte	.LFB80
 4296 09c4 90010000 		.4byte	.LFE80-.LFB80
 4297 09c8 01       		.uleb128 0x1
 4298 09c9 9C       		.byte	0x9c
 4299 09ca 5F0A0000 		.4byte	0xa5f
 4300 09ce 18       		.uleb128 0x18
 4301 09cf C4020000 		.4byte	.LASF64
 4302 09d3 01       		.byte	0x1
 4303 09d4 8A05     		.2byte	0x58a
 4304 09d6 55020000 		.4byte	0x255
 4305 09da 02       		.uleb128 0x2
 4306 09db 91       		.byte	0x91
 4307 09dc 54       		.sleb128 -44
 4308 09dd 18       		.uleb128 0x18
 4309 09de 69070000 		.4byte	.LASF94
 4310 09e2 01       		.byte	0x1
 4311 09e3 8A05     		.2byte	0x58a
 4312 09e5 1B010000 		.4byte	0x11b
 4313 09e9 02       		.uleb128 0x2
 4314 09ea 91       		.byte	0x91
 4315 09eb 50       		.sleb128 -48
 4316 09ec 16       		.uleb128 0x16
 4317 09ed 83030000 		.4byte	.LASF101
 4318 09f1 01       		.byte	0x1
 4319 09f2 8C05     		.2byte	0x58c
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 129


 4320 09f4 05010000 		.4byte	0x105
 4321 09f8 02       		.uleb128 0x2
 4322 09f9 91       		.byte	0x91
 4323 09fa 74       		.sleb128 -12
 4324 09fb 16       		.uleb128 0x16
 4325 09fc 98030000 		.4byte	.LASF103
 4326 0a00 01       		.byte	0x1
 4327 0a01 8D05     		.2byte	0x58d
 4328 0a03 4A020000 		.4byte	0x24a
 4329 0a07 02       		.uleb128 0x2
 4330 0a08 91       		.byte	0x91
 4331 0a09 5C       		.sleb128 -36
 4332 0a0a 16       		.uleb128 0x16
 4333 0a0b 80070000 		.4byte	.LASF80
 4334 0a0f 01       		.byte	0x1
 4335 0a10 8E05     		.2byte	0x58e
 4336 0a12 4E040000 		.4byte	0x44e
 4337 0a16 02       		.uleb128 0x2
 4338 0a17 91       		.byte	0x91
 4339 0a18 6C       		.sleb128 -20
 4340 0a19 16       		.uleb128 0x16
 4341 0a1a 7C060000 		.4byte	.LASF112
 4342 0a1e 01       		.byte	0x1
 4343 0a1f 9105     		.2byte	0x591
 4344 0a21 05010000 		.4byte	0x105
 4345 0a25 02       		.uleb128 0x2
 4346 0a26 91       		.byte	0x91
 4347 0a27 70       		.sleb128 -16
 4348 0a28 1D       		.uleb128 0x1d
 4349 0a29 1A000000 		.4byte	.LBB35
 4350 0a2d 78000000 		.4byte	.LBE35-.LBB35
 4351 0a31 450A0000 		.4byte	0xa45
 4352 0a35 16       		.uleb128 0x16
 4353 0a36 33060000 		.4byte	.LASF113
 4354 0a3a 01       		.byte	0x1
 4355 0a3b AC05     		.2byte	0x5ac
 4356 0a3d C8040000 		.4byte	0x4c8
 4357 0a41 02       		.uleb128 0x2
 4358 0a42 91       		.byte	0x91
 4359 0a43 68       		.sleb128 -24
 4360 0a44 00       		.byte	0
 4361 0a45 1B       		.uleb128 0x1b
 4362 0a46 6A010000 		.4byte	.LBB36
 4363 0a4a 14000000 		.4byte	.LBE36-.LBB36
 4364 0a4e 16       		.uleb128 0x16
 4365 0a4f C5070000 		.4byte	.LASF114
 4366 0a53 01       		.byte	0x1
 4367 0a54 4906     		.2byte	0x649
 4368 0a56 10010000 		.4byte	0x110
 4369 0a5a 02       		.uleb128 0x2
 4370 0a5b 91       		.byte	0x91
 4371 0a5c 64       		.sleb128 -28
 4372 0a5d 00       		.byte	0
 4373 0a5e 00       		.byte	0
 4374 0a5f 17       		.uleb128 0x17
 4375 0a60 78030000 		.4byte	.LASF115
 4376 0a64 01       		.byte	0x1
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 130


 4377 0a65 6406     		.2byte	0x664
 4378 0a67 05010000 		.4byte	0x105
 4379 0a6b 00000000 		.4byte	.LFB81
 4380 0a6f 48010000 		.4byte	.LFE81-.LFB81
 4381 0a73 01       		.uleb128 0x1
 4382 0a74 9C       		.byte	0x9c
 4383 0a75 FC0A0000 		.4byte	0xafc
 4384 0a79 18       		.uleb128 0x18
 4385 0a7a C4020000 		.4byte	.LASF64
 4386 0a7e 01       		.byte	0x1
 4387 0a7f 6406     		.2byte	0x664
 4388 0a81 55020000 		.4byte	0x255
 4389 0a85 02       		.uleb128 0x2
 4390 0a86 91       		.byte	0x91
 4391 0a87 5C       		.sleb128 -36
 4392 0a88 18       		.uleb128 0x18
 4393 0a89 08030000 		.4byte	.LASF110
 4394 0a8d 01       		.byte	0x1
 4395 0a8e 6406     		.2byte	0x664
 4396 0a90 AF090000 		.4byte	0x9af
 4397 0a94 02       		.uleb128 0x2
 4398 0a95 91       		.byte	0x91
 4399 0a96 58       		.sleb128 -40
 4400 0a97 18       		.uleb128 0x18
 4401 0a98 69070000 		.4byte	.LASF94
 4402 0a9c 01       		.byte	0x1
 4403 0a9d 6406     		.2byte	0x664
 4404 0a9f 1B010000 		.4byte	0x11b
 4405 0aa3 02       		.uleb128 0x2
 4406 0aa4 91       		.byte	0x91
 4407 0aa5 54       		.sleb128 -44
 4408 0aa6 16       		.uleb128 0x16
 4409 0aa7 83030000 		.4byte	.LASF101
 4410 0aab 01       		.byte	0x1
 4411 0aac 6606     		.2byte	0x666
 4412 0aae 05010000 		.4byte	0x105
 4413 0ab2 02       		.uleb128 0x2
 4414 0ab3 91       		.byte	0x91
 4415 0ab4 74       		.sleb128 -12
 4416 0ab5 16       		.uleb128 0x16
 4417 0ab6 98030000 		.4byte	.LASF103
 4418 0aba 01       		.byte	0x1
 4419 0abb 6706     		.2byte	0x667
 4420 0abd 4A020000 		.4byte	0x24a
 4421 0ac1 02       		.uleb128 0x2
 4422 0ac2 91       		.byte	0x91
 4423 0ac3 60       		.sleb128 -32
 4424 0ac4 16       		.uleb128 0x16
 4425 0ac5 CD050000 		.4byte	.LASF116
 4426 0ac9 01       		.byte	0x1
 4427 0aca 6806     		.2byte	0x668
 4428 0acc 0E030000 		.4byte	0x30e
 4429 0ad0 02       		.uleb128 0x2
 4430 0ad1 91       		.byte	0x91
 4431 0ad2 68       		.sleb128 -24
 4432 0ad3 16       		.uleb128 0x16
 4433 0ad4 80070000 		.4byte	.LASF80
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 131


 4434 0ad8 01       		.byte	0x1
 4435 0ad9 6906     		.2byte	0x669
 4436 0adb 4E040000 		.4byte	0x44e
 4437 0adf 02       		.uleb128 0x2
 4438 0ae0 91       		.byte	0x91
 4439 0ae1 70       		.sleb128 -16
 4440 0ae2 1B       		.uleb128 0x1b
 4441 0ae3 18000000 		.4byte	.LBB37
 4442 0ae7 72000000 		.4byte	.LBE37-.LBB37
 4443 0aeb 16       		.uleb128 0x16
 4444 0aec 41030000 		.4byte	.LASF51
 4445 0af0 01       		.byte	0x1
 4446 0af1 8106     		.2byte	0x681
 4447 0af3 C8040000 		.4byte	0x4c8
 4448 0af7 02       		.uleb128 0x2
 4449 0af8 91       		.byte	0x91
 4450 0af9 6C       		.sleb128 -20
 4451 0afa 00       		.byte	0
 4452 0afb 00       		.byte	0
 4453 0afc 17       		.uleb128 0x17
 4454 0afd 50000000 		.4byte	.LASF117
 4455 0b01 01       		.byte	0x1
 4456 0b02 F906     		.2byte	0x6f9
 4457 0b04 05010000 		.4byte	0x105
 4458 0b08 00000000 		.4byte	.LFB82
 4459 0b0c AC000000 		.4byte	.LFE82-.LFB82
 4460 0b10 01       		.uleb128 0x1
 4461 0b11 9C       		.byte	0x9c
 4462 0b12 EF0B0000 		.4byte	0xbef
 4463 0b16 18       		.uleb128 0x18
 4464 0b17 C4020000 		.4byte	.LASF64
 4465 0b1b 01       		.byte	0x1
 4466 0b1c F906     		.2byte	0x6f9
 4467 0b1e 55020000 		.4byte	0x255
 4468 0b22 02       		.uleb128 0x2
 4469 0b23 91       		.byte	0x91
 4470 0b24 54       		.sleb128 -44
 4471 0b25 18       		.uleb128 0x18
 4472 0b26 08030000 		.4byte	.LASF110
 4473 0b2a 01       		.byte	0x1
 4474 0b2b F906     		.2byte	0x6f9
 4475 0b2d AF090000 		.4byte	0x9af
 4476 0b31 02       		.uleb128 0x2
 4477 0b32 91       		.byte	0x91
 4478 0b33 50       		.sleb128 -48
 4479 0b34 18       		.uleb128 0x18
 4480 0b35 7C000000 		.4byte	.LASF105
 4481 0b39 01       		.byte	0x1
 4482 0b3a F906     		.2byte	0x6f9
 4483 0b3c 33080000 		.4byte	0x833
 4484 0b40 02       		.uleb128 0x2
 4485 0b41 91       		.byte	0x91
 4486 0b42 4C       		.sleb128 -52
 4487 0b43 16       		.uleb128 0x16
 4488 0b44 88070000 		.4byte	.LASF91
 4489 0b48 01       		.byte	0x1
 4490 0b49 FB06     		.2byte	0x6fb
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 132


 4491 0b4b 05010000 		.4byte	0x105
 4492 0b4f 02       		.uleb128 0x2
 4493 0b50 91       		.byte	0x91
 4494 0b51 74       		.sleb128 -12
 4495 0b52 16       		.uleb128 0x16
 4496 0b53 5A020000 		.4byte	.LASF106
 4497 0b57 01       		.byte	0x1
 4498 0b58 FC06     		.2byte	0x6fc
 4499 0b5a 10010000 		.4byte	0x110
 4500 0b5e 02       		.uleb128 0x2
 4501 0b5f 91       		.byte	0x91
 4502 0b60 68       		.sleb128 -24
 4503 0b61 16       		.uleb128 0x16
 4504 0b62 80070000 		.4byte	.LASF80
 4505 0b66 01       		.byte	0x1
 4506 0b67 FD06     		.2byte	0x6fd
 4507 0b69 4E040000 		.4byte	0x44e
 4508 0b6d 02       		.uleb128 0x2
 4509 0b6e 91       		.byte	0x91
 4510 0b6f 70       		.sleb128 -16
 4511 0b70 1A       		.uleb128 0x1a
 4512 0b71 C4030000 		.4byte	0x3c4
 4513 0b75 10000000 		.4byte	.LBB38
 4514 0b79 1A000000 		.4byte	.LBE38-.LBB38
 4515 0b7d 01       		.byte	0x1
 4516 0b7e 1207     		.2byte	0x712
 4517 0b80 9F0B0000 		.4byte	0xb9f
 4518 0b84 1B       		.uleb128 0x1b
 4519 0b85 10000000 		.4byte	.LBB39
 4520 0b89 1A000000 		.4byte	.LBE39-.LBB39
 4521 0b8d 1C       		.uleb128 0x1c
 4522 0b8e D4030000 		.4byte	0x3d4
 4523 0b92 02       		.uleb128 0x2
 4524 0b93 91       		.byte	0x91
 4525 0b94 5C       		.sleb128 -36
 4526 0b95 1C       		.uleb128 0x1c
 4527 0b96 DF030000 		.4byte	0x3df
 4528 0b9a 02       		.uleb128 0x2
 4529 0b9b 91       		.byte	0x91
 4530 0b9c 58       		.sleb128 -40
 4531 0b9d 00       		.byte	0
 4532 0b9e 00       		.byte	0
 4533 0b9f 1D       		.uleb128 0x1d
 4534 0ba0 2C000000 		.4byte	.LBB40
 4535 0ba4 70000000 		.4byte	.LBE40-.LBB40
 4536 0ba8 D50B0000 		.4byte	0xbd5
 4537 0bac 16       		.uleb128 0x16
 4538 0bad 41030000 		.4byte	.LASF51
 4539 0bb1 01       		.byte	0x1
 4540 0bb2 1407     		.2byte	0x714
 4541 0bb4 C8040000 		.4byte	0x4c8
 4542 0bb8 02       		.uleb128 0x2
 4543 0bb9 91       		.byte	0x91
 4544 0bba 64       		.sleb128 -28
 4545 0bbb 1B       		.uleb128 0x1b
 4546 0bbc 38000000 		.4byte	.LBB41
 4547 0bc0 5A000000 		.4byte	.LBE41-.LBB41
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 133


 4548 0bc4 16       		.uleb128 0x16
 4549 0bc5 0B090000 		.4byte	.LASF54
 4550 0bc9 01       		.byte	0x1
 4551 0bca 1907     		.2byte	0x719
 4552 0bcc 38080000 		.4byte	0x838
 4553 0bd0 02       		.uleb128 0x2
 4554 0bd1 91       		.byte	0x91
 4555 0bd2 63       		.sleb128 -29
 4556 0bd3 00       		.byte	0
 4557 0bd4 00       		.byte	0
 4558 0bd5 1E       		.uleb128 0x1e
 4559 0bd6 EB030000 		.4byte	0x3eb
 4560 0bda 9C000000 		.4byte	.LBB42
 4561 0bde 06000000 		.4byte	.LBE42-.LBB42
 4562 0be2 01       		.byte	0x1
 4563 0be3 4E07     		.2byte	0x74e
 4564 0be5 1F       		.uleb128 0x1f
 4565 0be6 F7030000 		.4byte	0x3f7
 4566 0bea 02       		.uleb128 0x2
 4567 0beb 91       		.byte	0x91
 4568 0bec 6C       		.sleb128 -20
 4569 0bed 00       		.byte	0
 4570 0bee 00       		.byte	0
 4571 0bef 17       		.uleb128 0x17
 4572 0bf0 B3070000 		.4byte	.LASF118
 4573 0bf4 01       		.byte	0x1
 4574 0bf5 5407     		.2byte	0x754
 4575 0bf7 05010000 		.4byte	0x105
 4576 0bfb 00000000 		.4byte	.LFB83
 4577 0bff 64000000 		.4byte	.LFE83-.LFB83
 4578 0c03 01       		.uleb128 0x1
 4579 0c04 9C       		.byte	0x9c
 4580 0c05 AC0C0000 		.4byte	0xcac
 4581 0c09 18       		.uleb128 0x18
 4582 0c0a C4020000 		.4byte	.LASF64
 4583 0c0e 01       		.byte	0x1
 4584 0c0f 5407     		.2byte	0x754
 4585 0c11 55020000 		.4byte	0x255
 4586 0c15 02       		.uleb128 0x2
 4587 0c16 91       		.byte	0x91
 4588 0c17 54       		.sleb128 -44
 4589 0c18 18       		.uleb128 0x18
 4590 0c19 08030000 		.4byte	.LASF110
 4591 0c1d 01       		.byte	0x1
 4592 0c1e 5407     		.2byte	0x754
 4593 0c20 AF090000 		.4byte	0x9af
 4594 0c24 02       		.uleb128 0x2
 4595 0c25 91       		.byte	0x91
 4596 0c26 50       		.sleb128 -48
 4597 0c27 16       		.uleb128 0x16
 4598 0c28 88070000 		.4byte	.LASF91
 4599 0c2c 01       		.byte	0x1
 4600 0c2d 5607     		.2byte	0x756
 4601 0c2f 05010000 		.4byte	0x105
 4602 0c33 02       		.uleb128 0x2
 4603 0c34 91       		.byte	0x91
 4604 0c35 74       		.sleb128 -12
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 134


 4605 0c36 16       		.uleb128 0x16
 4606 0c37 5A020000 		.4byte	.LASF106
 4607 0c3b 01       		.byte	0x1
 4608 0c3c 5707     		.2byte	0x757
 4609 0c3e 10010000 		.4byte	0x110
 4610 0c42 02       		.uleb128 0x2
 4611 0c43 91       		.byte	0x91
 4612 0c44 68       		.sleb128 -24
 4613 0c45 16       		.uleb128 0x16
 4614 0c46 CD050000 		.4byte	.LASF116
 4615 0c4a 01       		.byte	0x1
 4616 0c4b 5807     		.2byte	0x758
 4617 0c4d 0E030000 		.4byte	0x30e
 4618 0c51 02       		.uleb128 0x2
 4619 0c52 91       		.byte	0x91
 4620 0c53 64       		.sleb128 -28
 4621 0c54 16       		.uleb128 0x16
 4622 0c55 80070000 		.4byte	.LASF80
 4623 0c59 01       		.byte	0x1
 4624 0c5a 5907     		.2byte	0x759
 4625 0c5c 4E040000 		.4byte	0x44e
 4626 0c60 02       		.uleb128 0x2
 4627 0c61 91       		.byte	0x91
 4628 0c62 70       		.sleb128 -16
 4629 0c63 1A       		.uleb128 0x1a
 4630 0c64 C4030000 		.4byte	0x3c4
 4631 0c68 0E000000 		.4byte	.LBB44
 4632 0c6c 1A000000 		.4byte	.LBE44-.LBB44
 4633 0c70 01       		.byte	0x1
 4634 0c71 6F07     		.2byte	0x76f
 4635 0c73 920C0000 		.4byte	0xc92
 4636 0c77 1B       		.uleb128 0x1b
 4637 0c78 0E000000 		.4byte	.LBB45
 4638 0c7c 1A000000 		.4byte	.LBE45-.LBB45
 4639 0c80 1C       		.uleb128 0x1c
 4640 0c81 D4030000 		.4byte	0x3d4
 4641 0c85 02       		.uleb128 0x2
 4642 0c86 91       		.byte	0x91
 4643 0c87 60       		.sleb128 -32
 4644 0c88 1C       		.uleb128 0x1c
 4645 0c89 DF030000 		.4byte	0x3df
 4646 0c8d 02       		.uleb128 0x2
 4647 0c8e 91       		.byte	0x91
 4648 0c8f 5C       		.sleb128 -36
 4649 0c90 00       		.byte	0
 4650 0c91 00       		.byte	0
 4651 0c92 1E       		.uleb128 0x1e
 4652 0c93 EB030000 		.4byte	0x3eb
 4653 0c97 54000000 		.4byte	.LBB46
 4654 0c9b 06000000 		.4byte	.LBE46-.LBB46
 4655 0c9f 01       		.byte	0x1
 4656 0ca0 8407     		.2byte	0x784
 4657 0ca2 1F       		.uleb128 0x1f
 4658 0ca3 F7030000 		.4byte	0x3f7
 4659 0ca7 02       		.uleb128 0x2
 4660 0ca8 91       		.byte	0x91
 4661 0ca9 6C       		.sleb128 -20
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 135


 4662 0caa 00       		.byte	0
 4663 0cab 00       		.byte	0
 4664 0cac 17       		.uleb128 0x17
 4665 0cad 4B070000 		.4byte	.LASF119
 4666 0cb1 01       		.byte	0x1
 4667 0cb2 8A07     		.2byte	0x78a
 4668 0cb4 10010000 		.4byte	0x110
 4669 0cb8 00000000 		.4byte	.LFB84
 4670 0cbc 20000000 		.4byte	.LFE84-.LFB84
 4671 0cc0 01       		.uleb128 0x1
 4672 0cc1 9C       		.byte	0x9c
 4673 0cc2 E50C0000 		.4byte	0xce5
 4674 0cc6 18       		.uleb128 0x18
 4675 0cc7 C4020000 		.4byte	.LASF64
 4676 0ccb 01       		.byte	0x1
 4677 0ccc 8A07     		.2byte	0x78a
 4678 0cce E50C0000 		.4byte	0xce5
 4679 0cd2 02       		.uleb128 0x2
 4680 0cd3 91       		.byte	0x91
 4681 0cd4 6C       		.sleb128 -20
 4682 0cd5 16       		.uleb128 0x16
 4683 0cd6 00020000 		.4byte	.LASF120
 4684 0cda 01       		.byte	0x1
 4685 0cdb 8C07     		.2byte	0x78c
 4686 0cdd 10010000 		.4byte	0x110
 4687 0ce1 02       		.uleb128 0x2
 4688 0ce2 91       		.byte	0x91
 4689 0ce3 74       		.sleb128 -12
 4690 0ce4 00       		.byte	0
 4691 0ce5 07       		.uleb128 0x7
 4692 0ce6 55020000 		.4byte	0x255
 4693 0cea 17       		.uleb128 0x17
 4694 0ceb A7010000 		.4byte	.LASF121
 4695 0cef 01       		.byte	0x1
 4696 0cf0 9A07     		.2byte	0x79a
 4697 0cf2 10010000 		.4byte	0x110
 4698 0cf6 00000000 		.4byte	.LFB85
 4699 0cfa 2A000000 		.4byte	.LFE85-.LFB85
 4700 0cfe 01       		.uleb128 0x1
 4701 0cff 9C       		.byte	0x9c
 4702 0d00 320D0000 		.4byte	0xd32
 4703 0d04 18       		.uleb128 0x18
 4704 0d05 C4020000 		.4byte	.LASF64
 4705 0d09 01       		.byte	0x1
 4706 0d0a 9A07     		.2byte	0x79a
 4707 0d0c E50C0000 		.4byte	0xce5
 4708 0d10 02       		.uleb128 0x2
 4709 0d11 91       		.byte	0x91
 4710 0d12 6C       		.sleb128 -20
 4711 0d13 16       		.uleb128 0x16
 4712 0d14 00020000 		.4byte	.LASF120
 4713 0d18 01       		.byte	0x1
 4714 0d19 9C07     		.2byte	0x79c
 4715 0d1b 10010000 		.4byte	0x110
 4716 0d1f 02       		.uleb128 0x2
 4717 0d20 91       		.byte	0x91
 4718 0d21 70       		.sleb128 -16
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 136


 4719 0d22 16       		.uleb128 0x16
 4720 0d23 80070000 		.4byte	.LASF80
 4721 0d27 01       		.byte	0x1
 4722 0d28 9D07     		.2byte	0x79d
 4723 0d2a 4E040000 		.4byte	0x44e
 4724 0d2e 02       		.uleb128 0x2
 4725 0d2f 91       		.byte	0x91
 4726 0d30 74       		.sleb128 -12
 4727 0d31 00       		.byte	0
 4728 0d32 20       		.uleb128 0x20
 4729 0d33 BF040000 		.4byte	.LASF122
 4730 0d37 01       		.byte	0x1
 4731 0d38 AB07     		.2byte	0x7ab
 4732 0d3a 10010000 		.4byte	0x110
 4733 0d3e 00000000 		.4byte	.LFB86
 4734 0d42 1E000000 		.4byte	.LFE86-.LFB86
 4735 0d46 01       		.uleb128 0x1
 4736 0d47 9C       		.byte	0x9c
 4737 0d48 7A0D0000 		.4byte	0xd7a
 4738 0d4c 18       		.uleb128 0x18
 4739 0d4d C4020000 		.4byte	.LASF64
 4740 0d51 01       		.byte	0x1
 4741 0d52 AB07     		.2byte	0x7ab
 4742 0d54 E50C0000 		.4byte	0xce5
 4743 0d58 02       		.uleb128 0x2
 4744 0d59 91       		.byte	0x91
 4745 0d5a 6C       		.sleb128 -20
 4746 0d5b 16       		.uleb128 0x16
 4747 0d5c 00020000 		.4byte	.LASF120
 4748 0d60 01       		.byte	0x1
 4749 0d61 AD07     		.2byte	0x7ad
 4750 0d63 10010000 		.4byte	0x110
 4751 0d67 02       		.uleb128 0x2
 4752 0d68 91       		.byte	0x91
 4753 0d69 70       		.sleb128 -16
 4754 0d6a 16       		.uleb128 0x16
 4755 0d6b 80070000 		.4byte	.LASF80
 4756 0d6f 01       		.byte	0x1
 4757 0d70 AE07     		.2byte	0x7ae
 4758 0d72 4E040000 		.4byte	0x44e
 4759 0d76 02       		.uleb128 0x2
 4760 0d77 91       		.byte	0x91
 4761 0d78 74       		.sleb128 -12
 4762 0d79 00       		.byte	0
 4763 0d7a 21       		.uleb128 0x21
 4764 0d7b 1D020000 		.4byte	.LASF133
 4765 0d7f 01       		.byte	0x1
 4766 0d80 B707     		.2byte	0x7b7
 4767 0d82 00000000 		.4byte	.LFB87
 4768 0d86 20000000 		.4byte	.LFE87-.LFB87
 4769 0d8a 01       		.uleb128 0x1
 4770 0d8b 9C       		.byte	0x9c
 4771 0d8c AF0D0000 		.4byte	0xdaf
 4772 0d90 18       		.uleb128 0x18
 4773 0d91 C4020000 		.4byte	.LASF64
 4774 0d95 01       		.byte	0x1
 4775 0d96 B707     		.2byte	0x7b7
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 137


 4776 0d98 55020000 		.4byte	0x255
 4777 0d9c 02       		.uleb128 0x2
 4778 0d9d 91       		.byte	0x91
 4779 0d9e 6C       		.sleb128 -20
 4780 0d9f 16       		.uleb128 0x16
 4781 0da0 80070000 		.4byte	.LASF80
 4782 0da4 01       		.byte	0x1
 4783 0da5 B907     		.2byte	0x7b9
 4784 0da7 4E040000 		.4byte	0x44e
 4785 0dab 02       		.uleb128 0x2
 4786 0dac 91       		.byte	0x91
 4787 0dad 74       		.sleb128 -12
 4788 0dae 00       		.byte	0
 4789 0daf 22       		.uleb128 0x22
 4790 0db0 11030000 		.4byte	.LASF124
 4791 0db4 01       		.byte	0x1
 4792 0db5 0108     		.2byte	0x801
 4793 0db7 10010000 		.4byte	0x110
 4794 0dbb 00000000 		.4byte	.LFB88
 4795 0dbf 2E000000 		.4byte	.LFE88-.LFB88
 4796 0dc3 01       		.uleb128 0x1
 4797 0dc4 9C       		.byte	0x9c
 4798 0dc5 E80D0000 		.4byte	0xde8
 4799 0dc9 18       		.uleb128 0x18
 4800 0dca 80070000 		.4byte	.LASF80
 4801 0dce 01       		.byte	0x1
 4802 0dcf 0108     		.2byte	0x801
 4803 0dd1 F30D0000 		.4byte	0xdf3
 4804 0dd5 02       		.uleb128 0x2
 4805 0dd6 91       		.byte	0x91
 4806 0dd7 6C       		.sleb128 -20
 4807 0dd8 16       		.uleb128 0x16
 4808 0dd9 00060000 		.4byte	.LASF123
 4809 0ddd 01       		.byte	0x1
 4810 0dde 0308     		.2byte	0x803
 4811 0de0 10010000 		.4byte	0x110
 4812 0de4 02       		.uleb128 0x2
 4813 0de5 91       		.byte	0x91
 4814 0de6 74       		.sleb128 -12
 4815 0de7 00       		.byte	0
 4816 0de8 06       		.uleb128 0x6
 4817 0de9 04       		.byte	0x4
 4818 0dea EE0D0000 		.4byte	0xdee
 4819 0dee 07       		.uleb128 0x7
 4820 0def 7E030000 		.4byte	0x37e
 4821 0df3 07       		.uleb128 0x7
 4822 0df4 E80D0000 		.4byte	0xde8
 4823 0df8 23       		.uleb128 0x23
 4824 0df9 F4030000 		.4byte	.LASF125
 4825 0dfd 01       		.byte	0x1
 4826 0dfe 1A08     		.2byte	0x81a
 4827 0e00 05010000 		.4byte	0x105
 4828 0e04 00000000 		.4byte	.LFB89
 4829 0e08 D4000000 		.4byte	.LFE89-.LFB89
 4830 0e0c 01       		.uleb128 0x1
 4831 0e0d 9C       		.byte	0x9c
 4832 0e0e 5E0E0000 		.4byte	0xe5e
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 138


 4833 0e12 18       		.uleb128 0x18
 4834 0e13 80070000 		.4byte	.LASF80
 4835 0e17 01       		.byte	0x1
 4836 0e18 1A08     		.2byte	0x81a
 4837 0e1a 4E040000 		.4byte	0x44e
 4838 0e1e 02       		.uleb128 0x2
 4839 0e1f 91       		.byte	0x91
 4840 0e20 6C       		.sleb128 -20
 4841 0e21 18       		.uleb128 0x18
 4842 0e22 24070000 		.4byte	.LASF99
 4843 0e26 01       		.byte	0x1
 4844 0e27 1A08     		.2byte	0x81a
 4845 0e29 C4000000 		.4byte	0xc4
 4846 0e2d 02       		.uleb128 0x2
 4847 0e2e 91       		.byte	0x91
 4848 0e2f 68       		.sleb128 -24
 4849 0e30 18       		.uleb128 0x18
 4850 0e31 01090000 		.4byte	.LASF126
 4851 0e35 01       		.byte	0x1
 4852 0e36 1A08     		.2byte	0x81a
 4853 0e38 30070000 		.4byte	0x730
 4854 0e3c 02       		.uleb128 0x2
 4855 0e3d 91       		.byte	0x91
 4856 0e3e 64       		.sleb128 -28
 4857 0e3f 16       		.uleb128 0x16
 4858 0e40 88070000 		.4byte	.LASF91
 4859 0e44 01       		.byte	0x1
 4860 0e45 1C08     		.2byte	0x81c
 4861 0e47 05010000 		.4byte	0x105
 4862 0e4b 02       		.uleb128 0x2
 4863 0e4c 91       		.byte	0x91
 4864 0e4d 74       		.sleb128 -12
 4865 0e4e 16       		.uleb128 0x16
 4866 0e4f 41030000 		.4byte	.LASF51
 4867 0e53 01       		.byte	0x1
 4868 0e54 1D08     		.2byte	0x81d
 4869 0e56 10010000 		.4byte	0x110
 4870 0e5a 02       		.uleb128 0x2
 4871 0e5b 91       		.byte	0x91
 4872 0e5c 70       		.sleb128 -16
 4873 0e5d 00       		.byte	0
 4874 0e5e 19       		.uleb128 0x19
 4875 0e5f F7070000 		.4byte	.LASF127
 4876 0e63 01       		.byte	0x1
 4877 0e64 6908     		.2byte	0x869
 4878 0e66 00000000 		.4byte	.LFB90
 4879 0e6a 4C000000 		.4byte	.LFE90-.LFB90
 4880 0e6e 01       		.uleb128 0x1
 4881 0e6f 9C       		.byte	0x9c
 4882 0e70 930E0000 		.4byte	0xe93
 4883 0e74 18       		.uleb128 0x18
 4884 0e75 80070000 		.4byte	.LASF80
 4885 0e79 01       		.byte	0x1
 4886 0e7a 6908     		.2byte	0x869
 4887 0e7c 4E040000 		.4byte	0x44e
 4888 0e80 02       		.uleb128 0x2
 4889 0e81 91       		.byte	0x91
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 139


 4890 0e82 74       		.sleb128 -12
 4891 0e83 18       		.uleb128 0x18
 4892 0e84 08030000 		.4byte	.LASF110
 4893 0e88 01       		.byte	0x1
 4894 0e89 6908     		.2byte	0x869
 4895 0e8b AF090000 		.4byte	0x9af
 4896 0e8f 02       		.uleb128 0x2
 4897 0e90 91       		.byte	0x91
 4898 0e91 70       		.sleb128 -16
 4899 0e92 00       		.byte	0
 4900 0e93 19       		.uleb128 0x19
 4901 0e94 8B080000 		.4byte	.LASF128
 4902 0e98 01       		.byte	0x1
 4903 0e99 7B08     		.2byte	0x87b
 4904 0e9b 00000000 		.4byte	.LFB91
 4905 0e9f A4000000 		.4byte	.LFE91-.LFB91
 4906 0ea3 01       		.uleb128 0x1
 4907 0ea4 9C       		.byte	0x9c
 4908 0ea5 EF0E0000 		.4byte	0xeef
 4909 0ea9 18       		.uleb128 0x18
 4910 0eaa 80070000 		.4byte	.LASF80
 4911 0eae 01       		.byte	0x1
 4912 0eaf 7B08     		.2byte	0x87b
 4913 0eb1 4E040000 		.4byte	0x44e
 4914 0eb5 02       		.uleb128 0x2
 4915 0eb6 91       		.byte	0x91
 4916 0eb7 6C       		.sleb128 -20
 4917 0eb8 1D       		.uleb128 0x1d
 4918 0eb9 0C000000 		.4byte	.LBB48
 4919 0ebd 42000000 		.4byte	.LBE48-.LBB48
 4920 0ec1 D50E0000 		.4byte	0xed5
 4921 0ec5 16       		.uleb128 0x16
 4922 0ec6 BE010000 		.4byte	.LASF55
 4923 0eca 01       		.byte	0x1
 4924 0ecb 8508     		.2byte	0x885
 4925 0ecd CB000000 		.4byte	0xcb
 4926 0ed1 02       		.uleb128 0x2
 4927 0ed2 91       		.byte	0x91
 4928 0ed3 77       		.sleb128 -9
 4929 0ed4 00       		.byte	0
 4930 0ed5 1B       		.uleb128 0x1b
 4931 0ed6 56000000 		.4byte	.LBB49
 4932 0eda 42000000 		.4byte	.LBE49-.LBB49
 4933 0ede 16       		.uleb128 0x16
 4934 0edf 0B090000 		.4byte	.LASF54
 4935 0ee3 01       		.byte	0x1
 4936 0ee4 D608     		.2byte	0x8d6
 4937 0ee6 CB000000 		.4byte	0xcb
 4938 0eea 02       		.uleb128 0x2
 4939 0eeb 91       		.byte	0x91
 4940 0eec 76       		.sleb128 -10
 4941 0eed 00       		.byte	0
 4942 0eee 00       		.byte	0
 4943 0eef 23       		.uleb128 0x23
 4944 0ef0 F8020000 		.4byte	.LASF129
 4945 0ef4 01       		.byte	0x1
 4946 0ef5 F308     		.2byte	0x8f3
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 140


 4947 0ef7 05010000 		.4byte	0x105
 4948 0efb 00000000 		.4byte	.LFB92
 4949 0eff 2C000000 		.4byte	.LFE92-.LFB92
 4950 0f03 01       		.uleb128 0x1
 4951 0f04 9C       		.byte	0x9c
 4952 0f05 280F0000 		.4byte	0xf28
 4953 0f09 18       		.uleb128 0x18
 4954 0f0a 80070000 		.4byte	.LASF80
 4955 0f0e 01       		.byte	0x1
 4956 0f0f F308     		.2byte	0x8f3
 4957 0f11 E80D0000 		.4byte	0xde8
 4958 0f15 02       		.uleb128 0x2
 4959 0f16 91       		.byte	0x91
 4960 0f17 6C       		.sleb128 -20
 4961 0f18 16       		.uleb128 0x16
 4962 0f19 88070000 		.4byte	.LASF91
 4963 0f1d 01       		.byte	0x1
 4964 0f1e F508     		.2byte	0x8f5
 4965 0f20 05010000 		.4byte	0x105
 4966 0f24 02       		.uleb128 0x2
 4967 0f25 91       		.byte	0x91
 4968 0f26 74       		.sleb128 -12
 4969 0f27 00       		.byte	0
 4970 0f28 20       		.uleb128 0x20
 4971 0f29 AD080000 		.4byte	.LASF130
 4972 0f2d 01       		.byte	0x1
 4973 0f2e 0809     		.2byte	0x908
 4974 0f30 05010000 		.4byte	0x105
 4975 0f34 00000000 		.4byte	.LFB93
 4976 0f38 2A000000 		.4byte	.LFE93-.LFB93
 4977 0f3c 01       		.uleb128 0x1
 4978 0f3d 9C       		.byte	0x9c
 4979 0f3e 700F0000 		.4byte	0xf70
 4980 0f42 18       		.uleb128 0x18
 4981 0f43 C4020000 		.4byte	.LASF64
 4982 0f47 01       		.byte	0x1
 4983 0f48 0809     		.2byte	0x908
 4984 0f4a E50C0000 		.4byte	0xce5
 4985 0f4e 02       		.uleb128 0x2
 4986 0f4f 91       		.byte	0x91
 4987 0f50 6C       		.sleb128 -20
 4988 0f51 16       		.uleb128 0x16
 4989 0f52 88070000 		.4byte	.LASF91
 4990 0f56 01       		.byte	0x1
 4991 0f57 0A09     		.2byte	0x90a
 4992 0f59 05010000 		.4byte	0x105
 4993 0f5d 02       		.uleb128 0x2
 4994 0f5e 91       		.byte	0x91
 4995 0f5f 74       		.sleb128 -12
 4996 0f60 16       		.uleb128 0x16
 4997 0f61 80070000 		.4byte	.LASF80
 4998 0f65 01       		.byte	0x1
 4999 0f66 0B09     		.2byte	0x90b
 5000 0f68 4E040000 		.4byte	0x44e
 5001 0f6c 02       		.uleb128 0x2
 5002 0f6d 91       		.byte	0x91
 5003 0f6e 70       		.sleb128 -16
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 141


 5004 0f6f 00       		.byte	0
 5005 0f70 23       		.uleb128 0x23
 5006 0f71 51040000 		.4byte	.LASF131
 5007 0f75 01       		.byte	0x1
 5008 0f76 1B09     		.2byte	0x91b
 5009 0f78 05010000 		.4byte	0x105
 5010 0f7c 00000000 		.4byte	.LFB94
 5011 0f80 30000000 		.4byte	.LFE94-.LFB94
 5012 0f84 01       		.uleb128 0x1
 5013 0f85 9C       		.byte	0x9c
 5014 0f86 A90F0000 		.4byte	0xfa9
 5015 0f8a 18       		.uleb128 0x18
 5016 0f8b 80070000 		.4byte	.LASF80
 5017 0f8f 01       		.byte	0x1
 5018 0f90 1B09     		.2byte	0x91b
 5019 0f92 E80D0000 		.4byte	0xde8
 5020 0f96 02       		.uleb128 0x2
 5021 0f97 91       		.byte	0x91
 5022 0f98 6C       		.sleb128 -20
 5023 0f99 16       		.uleb128 0x16
 5024 0f9a 88070000 		.4byte	.LASF91
 5025 0f9e 01       		.byte	0x1
 5026 0f9f 1D09     		.2byte	0x91d
 5027 0fa1 05010000 		.4byte	0x105
 5028 0fa5 02       		.uleb128 0x2
 5029 0fa6 91       		.byte	0x91
 5030 0fa7 74       		.sleb128 -12
 5031 0fa8 00       		.byte	0
 5032 0fa9 20       		.uleb128 0x20
 5033 0faa 32070000 		.4byte	.LASF132
 5034 0fae 01       		.byte	0x1
 5035 0faf 3009     		.2byte	0x930
 5036 0fb1 05010000 		.4byte	0x105
 5037 0fb5 00000000 		.4byte	.LFB95
 5038 0fb9 2E000000 		.4byte	.LFE95-.LFB95
 5039 0fbd 01       		.uleb128 0x1
 5040 0fbe 9C       		.byte	0x9c
 5041 0fbf F10F0000 		.4byte	0xff1
 5042 0fc3 18       		.uleb128 0x18
 5043 0fc4 C4020000 		.4byte	.LASF64
 5044 0fc8 01       		.byte	0x1
 5045 0fc9 3009     		.2byte	0x930
 5046 0fcb E50C0000 		.4byte	0xce5
 5047 0fcf 02       		.uleb128 0x2
 5048 0fd0 91       		.byte	0x91
 5049 0fd1 6C       		.sleb128 -20
 5050 0fd2 16       		.uleb128 0x16
 5051 0fd3 88070000 		.4byte	.LASF91
 5052 0fd7 01       		.byte	0x1
 5053 0fd8 3209     		.2byte	0x932
 5054 0fda 05010000 		.4byte	0x105
 5055 0fde 02       		.uleb128 0x2
 5056 0fdf 91       		.byte	0x91
 5057 0fe0 74       		.sleb128 -12
 5058 0fe1 16       		.uleb128 0x16
 5059 0fe2 80070000 		.4byte	.LASF80
 5060 0fe6 01       		.byte	0x1
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 142


 5061 0fe7 3309     		.2byte	0x933
 5062 0fe9 4E040000 		.4byte	0x44e
 5063 0fed 02       		.uleb128 0x2
 5064 0fee 91       		.byte	0x91
 5065 0fef 70       		.sleb128 -16
 5066 0ff0 00       		.byte	0
 5067 0ff1 24       		.uleb128 0x24
 5068 0ff2 93050000 		.4byte	.LASF134
 5069 0ff6 01       		.byte	0x1
 5070 0ff7 580A     		.2byte	0xa58
 5071 0ff9 00000000 		.4byte	.LFB96
 5072 0ffd 50000000 		.4byte	.LFE96-.LFB96
 5073 1001 01       		.uleb128 0x1
 5074 1002 9C       		.byte	0x9c
 5075 1003 34100000 		.4byte	0x1034
 5076 1007 18       		.uleb128 0x18
 5077 1008 C4020000 		.4byte	.LASF64
 5078 100c 01       		.byte	0x1
 5079 100d 580A     		.2byte	0xa58
 5080 100f 55020000 		.4byte	0x255
 5081 1013 02       		.uleb128 0x2
 5082 1014 91       		.byte	0x91
 5083 1015 6C       		.sleb128 -20
 5084 1016 18       		.uleb128 0x18
 5085 1017 A9030000 		.4byte	.LASF69
 5086 101b 01       		.byte	0x1
 5087 101c 580A     		.2byte	0xa58
 5088 101e B9000000 		.4byte	0xb9
 5089 1022 02       		.uleb128 0x2
 5090 1023 91       		.byte	0x91
 5091 1024 68       		.sleb128 -24
 5092 1025 25       		.uleb128 0x25
 5093 1026 757800   		.ascii	"ux\000"
 5094 1029 01       		.byte	0x1
 5095 102a 5A0A     		.2byte	0xa5a
 5096 102c 10010000 		.4byte	0x110
 5097 1030 02       		.uleb128 0x2
 5098 1031 91       		.byte	0x91
 5099 1032 74       		.sleb128 -12
 5100 1033 00       		.byte	0
 5101 1034 20       		.uleb128 0x20
 5102 1035 B6060000 		.4byte	.LASF135
 5103 1039 01       		.byte	0x1
 5104 103a 750A     		.2byte	0xa75
 5105 103c B9000000 		.4byte	0xb9
 5106 1040 00000000 		.4byte	.LFB97
 5107 1044 4C000000 		.4byte	.LFE97-.LFB97
 5108 1048 01       		.uleb128 0x1
 5109 1049 9C       		.byte	0x9c
 5110 104a 7B100000 		.4byte	0x107b
 5111 104e 18       		.uleb128 0x18
 5112 104f C4020000 		.4byte	.LASF64
 5113 1053 01       		.byte	0x1
 5114 1054 750A     		.2byte	0xa75
 5115 1056 55020000 		.4byte	0x255
 5116 105a 02       		.uleb128 0x2
 5117 105b 91       		.byte	0x91
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 143


 5118 105c 6C       		.sleb128 -20
 5119 105d 25       		.uleb128 0x25
 5120 105e 757800   		.ascii	"ux\000"
 5121 1061 01       		.byte	0x1
 5122 1062 770A     		.2byte	0xa77
 5123 1064 10010000 		.4byte	0x110
 5124 1068 02       		.uleb128 0x2
 5125 1069 91       		.byte	0x91
 5126 106a 74       		.sleb128 -12
 5127 106b 16       		.uleb128 0x16
 5128 106c D5060000 		.4byte	.LASF136
 5129 1070 01       		.byte	0x1
 5130 1071 780A     		.2byte	0xa78
 5131 1073 B9000000 		.4byte	0xb9
 5132 1077 02       		.uleb128 0x2
 5133 1078 91       		.byte	0x91
 5134 1079 70       		.sleb128 -16
 5135 107a 00       		.byte	0
 5136 107b 24       		.uleb128 0x24
 5137 107c 44020000 		.4byte	.LASF137
 5138 1080 01       		.byte	0x1
 5139 1081 910A     		.2byte	0xa91
 5140 1083 00000000 		.4byte	.LFB98
 5141 1087 50000000 		.4byte	.LFE98-.LFB98
 5142 108b 01       		.uleb128 0x1
 5143 108c 9C       		.byte	0x9c
 5144 108d AF100000 		.4byte	0x10af
 5145 1091 18       		.uleb128 0x18
 5146 1092 C4020000 		.4byte	.LASF64
 5147 1096 01       		.byte	0x1
 5148 1097 910A     		.2byte	0xa91
 5149 1099 55020000 		.4byte	0x255
 5150 109d 02       		.uleb128 0x2
 5151 109e 91       		.byte	0x91
 5152 109f 6C       		.sleb128 -20
 5153 10a0 25       		.uleb128 0x25
 5154 10a1 757800   		.ascii	"ux\000"
 5155 10a4 01       		.byte	0x1
 5156 10a5 930A     		.2byte	0xa93
 5157 10a7 10010000 		.4byte	0x110
 5158 10ab 02       		.uleb128 0x2
 5159 10ac 91       		.byte	0x91
 5160 10ad 74       		.sleb128 -12
 5161 10ae 00       		.byte	0
 5162 10af 26       		.uleb128 0x26
 5163 10b0 05070000 		.4byte	.LASF138
 5164 10b4 09       		.byte	0x9
 5165 10b5 1207     		.2byte	0x712
 5166 10b7 BB100000 		.4byte	0x10bb
 5167 10bb 0B       		.uleb128 0xb
 5168 10bc E1000000 		.4byte	0xe1
 5169 10c0 27       		.uleb128 0x27
 5170 10c1 B9030000 		.4byte	0x3b9
 5171 10c5 D0100000 		.4byte	0x10d0
 5172 10c9 28       		.uleb128 0x28
 5173 10ca A9000000 		.4byte	0xa9
 5174 10ce 09       		.byte	0x9
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 144


 5175 10cf 00       		.byte	0
 5176 10d0 29       		.uleb128 0x29
 5177 10d1 99040000 		.4byte	.LASF139
 5178 10d5 01       		.byte	0x1
 5179 10d6 A2       		.byte	0xa2
 5180 10d7 C0100000 		.4byte	0x10c0
 5181 10db 05       		.uleb128 0x5
 5182 10dc 03       		.byte	0x3
 5183 10dd 00000000 		.4byte	xQueueRegistry
 5184 10e1 00       		.byte	0
 5185              		.section	.debug_abbrev,"",%progbits
 5186              	.Ldebug_abbrev0:
 5187 0000 01       		.uleb128 0x1
 5188 0001 11       		.uleb128 0x11
 5189 0002 01       		.byte	0x1
 5190 0003 25       		.uleb128 0x25
 5191 0004 0E       		.uleb128 0xe
 5192 0005 13       		.uleb128 0x13
 5193 0006 0B       		.uleb128 0xb
 5194 0007 03       		.uleb128 0x3
 5195 0008 0E       		.uleb128 0xe
 5196 0009 1B       		.uleb128 0x1b
 5197 000a 0E       		.uleb128 0xe
 5198 000b 55       		.uleb128 0x55
 5199 000c 17       		.uleb128 0x17
 5200 000d 11       		.uleb128 0x11
 5201 000e 01       		.uleb128 0x1
 5202 000f 10       		.uleb128 0x10
 5203 0010 17       		.uleb128 0x17
 5204 0011 00       		.byte	0
 5205 0012 00       		.byte	0
 5206 0013 02       		.uleb128 0x2
 5207 0014 16       		.uleb128 0x16
 5208 0015 00       		.byte	0
 5209 0016 03       		.uleb128 0x3
 5210 0017 0E       		.uleb128 0xe
 5211 0018 3A       		.uleb128 0x3a
 5212 0019 0B       		.uleb128 0xb
 5213 001a 3B       		.uleb128 0x3b
 5214 001b 0B       		.uleb128 0xb
 5215 001c 49       		.uleb128 0x49
 5216 001d 13       		.uleb128 0x13
 5217 001e 00       		.byte	0
 5218 001f 00       		.byte	0
 5219 0020 03       		.uleb128 0x3
 5220 0021 24       		.uleb128 0x24
 5221 0022 00       		.byte	0
 5222 0023 0B       		.uleb128 0xb
 5223 0024 0B       		.uleb128 0xb
 5224 0025 3E       		.uleb128 0x3e
 5225 0026 0B       		.uleb128 0xb
 5226 0027 03       		.uleb128 0x3
 5227 0028 0E       		.uleb128 0xe
 5228 0029 00       		.byte	0
 5229 002a 00       		.byte	0
 5230 002b 04       		.uleb128 0x4
 5231 002c 24       		.uleb128 0x24
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 145


 5232 002d 00       		.byte	0
 5233 002e 0B       		.uleb128 0xb
 5234 002f 0B       		.uleb128 0xb
 5235 0030 3E       		.uleb128 0x3e
 5236 0031 0B       		.uleb128 0xb
 5237 0032 03       		.uleb128 0x3
 5238 0033 08       		.uleb128 0x8
 5239 0034 00       		.byte	0
 5240 0035 00       		.byte	0
 5241 0036 05       		.uleb128 0x5
 5242 0037 0F       		.uleb128 0xf
 5243 0038 00       		.byte	0
 5244 0039 0B       		.uleb128 0xb
 5245 003a 0B       		.uleb128 0xb
 5246 003b 00       		.byte	0
 5247 003c 00       		.byte	0
 5248 003d 06       		.uleb128 0x6
 5249 003e 0F       		.uleb128 0xf
 5250 003f 00       		.byte	0
 5251 0040 0B       		.uleb128 0xb
 5252 0041 0B       		.uleb128 0xb
 5253 0042 49       		.uleb128 0x49
 5254 0043 13       		.uleb128 0x13
 5255 0044 00       		.byte	0
 5256 0045 00       		.byte	0
 5257 0046 07       		.uleb128 0x7
 5258 0047 26       		.uleb128 0x26
 5259 0048 00       		.byte	0
 5260 0049 49       		.uleb128 0x49
 5261 004a 13       		.uleb128 0x13
 5262 004b 00       		.byte	0
 5263 004c 00       		.byte	0
 5264 004d 08       		.uleb128 0x8
 5265 004e 26       		.uleb128 0x26
 5266 004f 00       		.byte	0
 5267 0050 00       		.byte	0
 5268 0051 00       		.byte	0
 5269 0052 09       		.uleb128 0x9
 5270 0053 13       		.uleb128 0x13
 5271 0054 01       		.byte	0x1
 5272 0055 03       		.uleb128 0x3
 5273 0056 0E       		.uleb128 0xe
 5274 0057 0B       		.uleb128 0xb
 5275 0058 0B       		.uleb128 0xb
 5276 0059 3A       		.uleb128 0x3a
 5277 005a 0B       		.uleb128 0xb
 5278 005b 3B       		.uleb128 0x3b
 5279 005c 0B       		.uleb128 0xb
 5280 005d 01       		.uleb128 0x1
 5281 005e 13       		.uleb128 0x13
 5282 005f 00       		.byte	0
 5283 0060 00       		.byte	0
 5284 0061 0A       		.uleb128 0xa
 5285 0062 0D       		.uleb128 0xd
 5286 0063 00       		.byte	0
 5287 0064 03       		.uleb128 0x3
 5288 0065 0E       		.uleb128 0xe
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 146


 5289 0066 3A       		.uleb128 0x3a
 5290 0067 0B       		.uleb128 0xb
 5291 0068 3B       		.uleb128 0x3b
 5292 0069 0B       		.uleb128 0xb
 5293 006a 49       		.uleb128 0x49
 5294 006b 13       		.uleb128 0x13
 5295 006c 38       		.uleb128 0x38
 5296 006d 0B       		.uleb128 0xb
 5297 006e 00       		.byte	0
 5298 006f 00       		.byte	0
 5299 0070 0B       		.uleb128 0xb
 5300 0071 35       		.uleb128 0x35
 5301 0072 00       		.byte	0
 5302 0073 49       		.uleb128 0x49
 5303 0074 13       		.uleb128 0x13
 5304 0075 00       		.byte	0
 5305 0076 00       		.byte	0
 5306 0077 0C       		.uleb128 0xc
 5307 0078 13       		.uleb128 0x13
 5308 0079 00       		.byte	0
 5309 007a 03       		.uleb128 0x3
 5310 007b 0E       		.uleb128 0xe
 5311 007c 3C       		.uleb128 0x3c
 5312 007d 19       		.uleb128 0x19
 5313 007e 00       		.byte	0
 5314 007f 00       		.byte	0
 5315 0080 0D       		.uleb128 0xd
 5316 0081 0D       		.uleb128 0xd
 5317 0082 00       		.byte	0
 5318 0083 03       		.uleb128 0x3
 5319 0084 08       		.uleb128 0x8
 5320 0085 3A       		.uleb128 0x3a
 5321 0086 0B       		.uleb128 0xb
 5322 0087 3B       		.uleb128 0x3b
 5323 0088 0B       		.uleb128 0xb
 5324 0089 49       		.uleb128 0x49
 5325 008a 13       		.uleb128 0x13
 5326 008b 38       		.uleb128 0x38
 5327 008c 0B       		.uleb128 0xb
 5328 008d 00       		.byte	0
 5329 008e 00       		.byte	0
 5330 008f 0E       		.uleb128 0xe
 5331 0090 17       		.uleb128 0x17
 5332 0091 01       		.byte	0x1
 5333 0092 0B       		.uleb128 0xb
 5334 0093 0B       		.uleb128 0xb
 5335 0094 3A       		.uleb128 0x3a
 5336 0095 0B       		.uleb128 0xb
 5337 0096 3B       		.uleb128 0x3b
 5338 0097 0B       		.uleb128 0xb
 5339 0098 01       		.uleb128 0x1
 5340 0099 13       		.uleb128 0x13
 5341 009a 00       		.byte	0
 5342 009b 00       		.byte	0
 5343 009c 0F       		.uleb128 0xf
 5344 009d 0D       		.uleb128 0xd
 5345 009e 00       		.byte	0
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 147


 5346 009f 03       		.uleb128 0x3
 5347 00a0 0E       		.uleb128 0xe
 5348 00a1 3A       		.uleb128 0x3a
 5349 00a2 0B       		.uleb128 0xb
 5350 00a3 3B       		.uleb128 0x3b
 5351 00a4 0B       		.uleb128 0xb
 5352 00a5 49       		.uleb128 0x49
 5353 00a6 13       		.uleb128 0x13
 5354 00a7 00       		.byte	0
 5355 00a8 00       		.byte	0
 5356 00a9 10       		.uleb128 0x10
 5357 00aa 2E       		.uleb128 0x2e
 5358 00ab 01       		.byte	0x1
 5359 00ac 03       		.uleb128 0x3
 5360 00ad 0E       		.uleb128 0xe
 5361 00ae 3A       		.uleb128 0x3a
 5362 00af 0B       		.uleb128 0xb
 5363 00b0 3B       		.uleb128 0x3b
 5364 00b1 0B       		.uleb128 0xb
 5365 00b2 27       		.uleb128 0x27
 5366 00b3 19       		.uleb128 0x19
 5367 00b4 49       		.uleb128 0x49
 5368 00b5 13       		.uleb128 0x13
 5369 00b6 20       		.uleb128 0x20
 5370 00b7 0B       		.uleb128 0xb
 5371 00b8 01       		.uleb128 0x1
 5372 00b9 13       		.uleb128 0x13
 5373 00ba 00       		.byte	0
 5374 00bb 00       		.byte	0
 5375 00bc 11       		.uleb128 0x11
 5376 00bd 34       		.uleb128 0x34
 5377 00be 00       		.byte	0
 5378 00bf 03       		.uleb128 0x3
 5379 00c0 0E       		.uleb128 0xe
 5380 00c1 3A       		.uleb128 0x3a
 5381 00c2 0B       		.uleb128 0xb
 5382 00c3 3B       		.uleb128 0x3b
 5383 00c4 0B       		.uleb128 0xb
 5384 00c5 49       		.uleb128 0x49
 5385 00c6 13       		.uleb128 0x13
 5386 00c7 00       		.byte	0
 5387 00c8 00       		.byte	0
 5388 00c9 12       		.uleb128 0x12
 5389 00ca 2E       		.uleb128 0x2e
 5390 00cb 01       		.byte	0x1
 5391 00cc 03       		.uleb128 0x3
 5392 00cd 0E       		.uleb128 0xe
 5393 00ce 3A       		.uleb128 0x3a
 5394 00cf 0B       		.uleb128 0xb
 5395 00d0 3B       		.uleb128 0x3b
 5396 00d1 0B       		.uleb128 0xb
 5397 00d2 27       		.uleb128 0x27
 5398 00d3 19       		.uleb128 0x19
 5399 00d4 20       		.uleb128 0x20
 5400 00d5 0B       		.uleb128 0xb
 5401 00d6 01       		.uleb128 0x1
 5402 00d7 13       		.uleb128 0x13
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 148


 5403 00d8 00       		.byte	0
 5404 00d9 00       		.byte	0
 5405 00da 13       		.uleb128 0x13
 5406 00db 05       		.uleb128 0x5
 5407 00dc 00       		.byte	0
 5408 00dd 03       		.uleb128 0x3
 5409 00de 0E       		.uleb128 0xe
 5410 00df 3A       		.uleb128 0x3a
 5411 00e0 0B       		.uleb128 0xb
 5412 00e1 3B       		.uleb128 0x3b
 5413 00e2 0B       		.uleb128 0xb
 5414 00e3 49       		.uleb128 0x49
 5415 00e4 13       		.uleb128 0x13
 5416 00e5 00       		.byte	0
 5417 00e6 00       		.byte	0
 5418 00e7 14       		.uleb128 0x14
 5419 00e8 2E       		.uleb128 0x2e
 5420 00e9 01       		.byte	0x1
 5421 00ea 3F       		.uleb128 0x3f
 5422 00eb 19       		.uleb128 0x19
 5423 00ec 03       		.uleb128 0x3
 5424 00ed 0E       		.uleb128 0xe
 5425 00ee 3A       		.uleb128 0x3a
 5426 00ef 0B       		.uleb128 0xb
 5427 00f0 3B       		.uleb128 0x3b
 5428 00f1 0B       		.uleb128 0xb
 5429 00f2 27       		.uleb128 0x27
 5430 00f3 19       		.uleb128 0x19
 5431 00f4 49       		.uleb128 0x49
 5432 00f5 13       		.uleb128 0x13
 5433 00f6 11       		.uleb128 0x11
 5434 00f7 01       		.uleb128 0x1
 5435 00f8 12       		.uleb128 0x12
 5436 00f9 06       		.uleb128 0x6
 5437 00fa 40       		.uleb128 0x40
 5438 00fb 18       		.uleb128 0x18
 5439 00fc 9642     		.uleb128 0x2116
 5440 00fe 19       		.uleb128 0x19
 5441 00ff 01       		.uleb128 0x1
 5442 0100 13       		.uleb128 0x13
 5443 0101 00       		.byte	0
 5444 0102 00       		.byte	0
 5445 0103 15       		.uleb128 0x15
 5446 0104 05       		.uleb128 0x5
 5447 0105 00       		.byte	0
 5448 0106 03       		.uleb128 0x3
 5449 0107 0E       		.uleb128 0xe
 5450 0108 3A       		.uleb128 0x3a
 5451 0109 0B       		.uleb128 0xb
 5452 010a 3B       		.uleb128 0x3b
 5453 010b 0B       		.uleb128 0xb
 5454 010c 49       		.uleb128 0x49
 5455 010d 13       		.uleb128 0x13
 5456 010e 02       		.uleb128 0x2
 5457 010f 18       		.uleb128 0x18
 5458 0110 00       		.byte	0
 5459 0111 00       		.byte	0
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 149


 5460 0112 16       		.uleb128 0x16
 5461 0113 34       		.uleb128 0x34
 5462 0114 00       		.byte	0
 5463 0115 03       		.uleb128 0x3
 5464 0116 0E       		.uleb128 0xe
 5465 0117 3A       		.uleb128 0x3a
 5466 0118 0B       		.uleb128 0xb
 5467 0119 3B       		.uleb128 0x3b
 5468 011a 05       		.uleb128 0x5
 5469 011b 49       		.uleb128 0x49
 5470 011c 13       		.uleb128 0x13
 5471 011d 02       		.uleb128 0x2
 5472 011e 18       		.uleb128 0x18
 5473 011f 00       		.byte	0
 5474 0120 00       		.byte	0
 5475 0121 17       		.uleb128 0x17
 5476 0122 2E       		.uleb128 0x2e
 5477 0123 01       		.byte	0x1
 5478 0124 3F       		.uleb128 0x3f
 5479 0125 19       		.uleb128 0x19
 5480 0126 03       		.uleb128 0x3
 5481 0127 0E       		.uleb128 0xe
 5482 0128 3A       		.uleb128 0x3a
 5483 0129 0B       		.uleb128 0xb
 5484 012a 3B       		.uleb128 0x3b
 5485 012b 05       		.uleb128 0x5
 5486 012c 27       		.uleb128 0x27
 5487 012d 19       		.uleb128 0x19
 5488 012e 49       		.uleb128 0x49
 5489 012f 13       		.uleb128 0x13
 5490 0130 11       		.uleb128 0x11
 5491 0131 01       		.uleb128 0x1
 5492 0132 12       		.uleb128 0x12
 5493 0133 06       		.uleb128 0x6
 5494 0134 40       		.uleb128 0x40
 5495 0135 18       		.uleb128 0x18
 5496 0136 9642     		.uleb128 0x2116
 5497 0138 19       		.uleb128 0x19
 5498 0139 01       		.uleb128 0x1
 5499 013a 13       		.uleb128 0x13
 5500 013b 00       		.byte	0
 5501 013c 00       		.byte	0
 5502 013d 18       		.uleb128 0x18
 5503 013e 05       		.uleb128 0x5
 5504 013f 00       		.byte	0
 5505 0140 03       		.uleb128 0x3
 5506 0141 0E       		.uleb128 0xe
 5507 0142 3A       		.uleb128 0x3a
 5508 0143 0B       		.uleb128 0xb
 5509 0144 3B       		.uleb128 0x3b
 5510 0145 05       		.uleb128 0x5
 5511 0146 49       		.uleb128 0x49
 5512 0147 13       		.uleb128 0x13
 5513 0148 02       		.uleb128 0x2
 5514 0149 18       		.uleb128 0x18
 5515 014a 00       		.byte	0
 5516 014b 00       		.byte	0
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 150


 5517 014c 19       		.uleb128 0x19
 5518 014d 2E       		.uleb128 0x2e
 5519 014e 01       		.byte	0x1
 5520 014f 03       		.uleb128 0x3
 5521 0150 0E       		.uleb128 0xe
 5522 0151 3A       		.uleb128 0x3a
 5523 0152 0B       		.uleb128 0xb
 5524 0153 3B       		.uleb128 0x3b
 5525 0154 05       		.uleb128 0x5
 5526 0155 27       		.uleb128 0x27
 5527 0156 19       		.uleb128 0x19
 5528 0157 11       		.uleb128 0x11
 5529 0158 01       		.uleb128 0x1
 5530 0159 12       		.uleb128 0x12
 5531 015a 06       		.uleb128 0x6
 5532 015b 40       		.uleb128 0x40
 5533 015c 18       		.uleb128 0x18
 5534 015d 9642     		.uleb128 0x2116
 5535 015f 19       		.uleb128 0x19
 5536 0160 01       		.uleb128 0x1
 5537 0161 13       		.uleb128 0x13
 5538 0162 00       		.byte	0
 5539 0163 00       		.byte	0
 5540 0164 1A       		.uleb128 0x1a
 5541 0165 1D       		.uleb128 0x1d
 5542 0166 01       		.byte	0x1
 5543 0167 31       		.uleb128 0x31
 5544 0168 13       		.uleb128 0x13
 5545 0169 11       		.uleb128 0x11
 5546 016a 01       		.uleb128 0x1
 5547 016b 12       		.uleb128 0x12
 5548 016c 06       		.uleb128 0x6
 5549 016d 58       		.uleb128 0x58
 5550 016e 0B       		.uleb128 0xb
 5551 016f 59       		.uleb128 0x59
 5552 0170 05       		.uleb128 0x5
 5553 0171 01       		.uleb128 0x1
 5554 0172 13       		.uleb128 0x13
 5555 0173 00       		.byte	0
 5556 0174 00       		.byte	0
 5557 0175 1B       		.uleb128 0x1b
 5558 0176 0B       		.uleb128 0xb
 5559 0177 01       		.byte	0x1
 5560 0178 11       		.uleb128 0x11
 5561 0179 01       		.uleb128 0x1
 5562 017a 12       		.uleb128 0x12
 5563 017b 06       		.uleb128 0x6
 5564 017c 00       		.byte	0
 5565 017d 00       		.byte	0
 5566 017e 1C       		.uleb128 0x1c
 5567 017f 34       		.uleb128 0x34
 5568 0180 00       		.byte	0
 5569 0181 31       		.uleb128 0x31
 5570 0182 13       		.uleb128 0x13
 5571 0183 02       		.uleb128 0x2
 5572 0184 18       		.uleb128 0x18
 5573 0185 00       		.byte	0
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 151


 5574 0186 00       		.byte	0
 5575 0187 1D       		.uleb128 0x1d
 5576 0188 0B       		.uleb128 0xb
 5577 0189 01       		.byte	0x1
 5578 018a 11       		.uleb128 0x11
 5579 018b 01       		.uleb128 0x1
 5580 018c 12       		.uleb128 0x12
 5581 018d 06       		.uleb128 0x6
 5582 018e 01       		.uleb128 0x1
 5583 018f 13       		.uleb128 0x13
 5584 0190 00       		.byte	0
 5585 0191 00       		.byte	0
 5586 0192 1E       		.uleb128 0x1e
 5587 0193 1D       		.uleb128 0x1d
 5588 0194 01       		.byte	0x1
 5589 0195 31       		.uleb128 0x31
 5590 0196 13       		.uleb128 0x13
 5591 0197 11       		.uleb128 0x11
 5592 0198 01       		.uleb128 0x1
 5593 0199 12       		.uleb128 0x12
 5594 019a 06       		.uleb128 0x6
 5595 019b 58       		.uleb128 0x58
 5596 019c 0B       		.uleb128 0xb
 5597 019d 59       		.uleb128 0x59
 5598 019e 05       		.uleb128 0x5
 5599 019f 00       		.byte	0
 5600 01a0 00       		.byte	0
 5601 01a1 1F       		.uleb128 0x1f
 5602 01a2 05       		.uleb128 0x5
 5603 01a3 00       		.byte	0
 5604 01a4 31       		.uleb128 0x31
 5605 01a5 13       		.uleb128 0x13
 5606 01a6 02       		.uleb128 0x2
 5607 01a7 18       		.uleb128 0x18
 5608 01a8 00       		.byte	0
 5609 01a9 00       		.byte	0
 5610 01aa 20       		.uleb128 0x20
 5611 01ab 2E       		.uleb128 0x2e
 5612 01ac 01       		.byte	0x1
 5613 01ad 3F       		.uleb128 0x3f
 5614 01ae 19       		.uleb128 0x19
 5615 01af 03       		.uleb128 0x3
 5616 01b0 0E       		.uleb128 0xe
 5617 01b1 3A       		.uleb128 0x3a
 5618 01b2 0B       		.uleb128 0xb
 5619 01b3 3B       		.uleb128 0x3b
 5620 01b4 05       		.uleb128 0x5
 5621 01b5 27       		.uleb128 0x27
 5622 01b6 19       		.uleb128 0x19
 5623 01b7 49       		.uleb128 0x49
 5624 01b8 13       		.uleb128 0x13
 5625 01b9 11       		.uleb128 0x11
 5626 01ba 01       		.uleb128 0x1
 5627 01bb 12       		.uleb128 0x12
 5628 01bc 06       		.uleb128 0x6
 5629 01bd 40       		.uleb128 0x40
 5630 01be 18       		.uleb128 0x18
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 152


 5631 01bf 9742     		.uleb128 0x2117
 5632 01c1 19       		.uleb128 0x19
 5633 01c2 01       		.uleb128 0x1
 5634 01c3 13       		.uleb128 0x13
 5635 01c4 00       		.byte	0
 5636 01c5 00       		.byte	0
 5637 01c6 21       		.uleb128 0x21
 5638 01c7 2E       		.uleb128 0x2e
 5639 01c8 01       		.byte	0x1
 5640 01c9 3F       		.uleb128 0x3f
 5641 01ca 19       		.uleb128 0x19
 5642 01cb 03       		.uleb128 0x3
 5643 01cc 0E       		.uleb128 0xe
 5644 01cd 3A       		.uleb128 0x3a
 5645 01ce 0B       		.uleb128 0xb
 5646 01cf 3B       		.uleb128 0x3b
 5647 01d0 05       		.uleb128 0x5
 5648 01d1 27       		.uleb128 0x27
 5649 01d2 19       		.uleb128 0x19
 5650 01d3 11       		.uleb128 0x11
 5651 01d4 01       		.uleb128 0x1
 5652 01d5 12       		.uleb128 0x12
 5653 01d6 06       		.uleb128 0x6
 5654 01d7 40       		.uleb128 0x40
 5655 01d8 18       		.uleb128 0x18
 5656 01d9 9642     		.uleb128 0x2116
 5657 01db 19       		.uleb128 0x19
 5658 01dc 01       		.uleb128 0x1
 5659 01dd 13       		.uleb128 0x13
 5660 01de 00       		.byte	0
 5661 01df 00       		.byte	0
 5662 01e0 22       		.uleb128 0x22
 5663 01e1 2E       		.uleb128 0x2e
 5664 01e2 01       		.byte	0x1
 5665 01e3 03       		.uleb128 0x3
 5666 01e4 0E       		.uleb128 0xe
 5667 01e5 3A       		.uleb128 0x3a
 5668 01e6 0B       		.uleb128 0xb
 5669 01e7 3B       		.uleb128 0x3b
 5670 01e8 05       		.uleb128 0x5
 5671 01e9 27       		.uleb128 0x27
 5672 01ea 19       		.uleb128 0x19
 5673 01eb 49       		.uleb128 0x49
 5674 01ec 13       		.uleb128 0x13
 5675 01ed 11       		.uleb128 0x11
 5676 01ee 01       		.uleb128 0x1
 5677 01ef 12       		.uleb128 0x12
 5678 01f0 06       		.uleb128 0x6
 5679 01f1 40       		.uleb128 0x40
 5680 01f2 18       		.uleb128 0x18
 5681 01f3 9742     		.uleb128 0x2117
 5682 01f5 19       		.uleb128 0x19
 5683 01f6 01       		.uleb128 0x1
 5684 01f7 13       		.uleb128 0x13
 5685 01f8 00       		.byte	0
 5686 01f9 00       		.byte	0
 5687 01fa 23       		.uleb128 0x23
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 153


 5688 01fb 2E       		.uleb128 0x2e
 5689 01fc 01       		.byte	0x1
 5690 01fd 03       		.uleb128 0x3
 5691 01fe 0E       		.uleb128 0xe
 5692 01ff 3A       		.uleb128 0x3a
 5693 0200 0B       		.uleb128 0xb
 5694 0201 3B       		.uleb128 0x3b
 5695 0202 05       		.uleb128 0x5
 5696 0203 27       		.uleb128 0x27
 5697 0204 19       		.uleb128 0x19
 5698 0205 49       		.uleb128 0x49
 5699 0206 13       		.uleb128 0x13
 5700 0207 11       		.uleb128 0x11
 5701 0208 01       		.uleb128 0x1
 5702 0209 12       		.uleb128 0x12
 5703 020a 06       		.uleb128 0x6
 5704 020b 40       		.uleb128 0x40
 5705 020c 18       		.uleb128 0x18
 5706 020d 9642     		.uleb128 0x2116
 5707 020f 19       		.uleb128 0x19
 5708 0210 01       		.uleb128 0x1
 5709 0211 13       		.uleb128 0x13
 5710 0212 00       		.byte	0
 5711 0213 00       		.byte	0
 5712 0214 24       		.uleb128 0x24
 5713 0215 2E       		.uleb128 0x2e
 5714 0216 01       		.byte	0x1
 5715 0217 3F       		.uleb128 0x3f
 5716 0218 19       		.uleb128 0x19
 5717 0219 03       		.uleb128 0x3
 5718 021a 0E       		.uleb128 0xe
 5719 021b 3A       		.uleb128 0x3a
 5720 021c 0B       		.uleb128 0xb
 5721 021d 3B       		.uleb128 0x3b
 5722 021e 05       		.uleb128 0x5
 5723 021f 27       		.uleb128 0x27
 5724 0220 19       		.uleb128 0x19
 5725 0221 11       		.uleb128 0x11
 5726 0222 01       		.uleb128 0x1
 5727 0223 12       		.uleb128 0x12
 5728 0224 06       		.uleb128 0x6
 5729 0225 40       		.uleb128 0x40
 5730 0226 18       		.uleb128 0x18
 5731 0227 9742     		.uleb128 0x2117
 5732 0229 19       		.uleb128 0x19
 5733 022a 01       		.uleb128 0x1
 5734 022b 13       		.uleb128 0x13
 5735 022c 00       		.byte	0
 5736 022d 00       		.byte	0
 5737 022e 25       		.uleb128 0x25
 5738 022f 34       		.uleb128 0x34
 5739 0230 00       		.byte	0
 5740 0231 03       		.uleb128 0x3
 5741 0232 08       		.uleb128 0x8
 5742 0233 3A       		.uleb128 0x3a
 5743 0234 0B       		.uleb128 0xb
 5744 0235 3B       		.uleb128 0x3b
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 154


 5745 0236 05       		.uleb128 0x5
 5746 0237 49       		.uleb128 0x49
 5747 0238 13       		.uleb128 0x13
 5748 0239 02       		.uleb128 0x2
 5749 023a 18       		.uleb128 0x18
 5750 023b 00       		.byte	0
 5751 023c 00       		.byte	0
 5752 023d 26       		.uleb128 0x26
 5753 023e 34       		.uleb128 0x34
 5754 023f 00       		.byte	0
 5755 0240 03       		.uleb128 0x3
 5756 0241 0E       		.uleb128 0xe
 5757 0242 3A       		.uleb128 0x3a
 5758 0243 0B       		.uleb128 0xb
 5759 0244 3B       		.uleb128 0x3b
 5760 0245 05       		.uleb128 0x5
 5761 0246 49       		.uleb128 0x49
 5762 0247 13       		.uleb128 0x13
 5763 0248 3F       		.uleb128 0x3f
 5764 0249 19       		.uleb128 0x19
 5765 024a 3C       		.uleb128 0x3c
 5766 024b 19       		.uleb128 0x19
 5767 024c 00       		.byte	0
 5768 024d 00       		.byte	0
 5769 024e 27       		.uleb128 0x27
 5770 024f 01       		.uleb128 0x1
 5771 0250 01       		.byte	0x1
 5772 0251 49       		.uleb128 0x49
 5773 0252 13       		.uleb128 0x13
 5774 0253 01       		.uleb128 0x1
 5775 0254 13       		.uleb128 0x13
 5776 0255 00       		.byte	0
 5777 0256 00       		.byte	0
 5778 0257 28       		.uleb128 0x28
 5779 0258 21       		.uleb128 0x21
 5780 0259 00       		.byte	0
 5781 025a 49       		.uleb128 0x49
 5782 025b 13       		.uleb128 0x13
 5783 025c 2F       		.uleb128 0x2f
 5784 025d 0B       		.uleb128 0xb
 5785 025e 00       		.byte	0
 5786 025f 00       		.byte	0
 5787 0260 29       		.uleb128 0x29
 5788 0261 34       		.uleb128 0x34
 5789 0262 00       		.byte	0
 5790 0263 03       		.uleb128 0x3
 5791 0264 0E       		.uleb128 0xe
 5792 0265 3A       		.uleb128 0x3a
 5793 0266 0B       		.uleb128 0xb
 5794 0267 3B       		.uleb128 0x3b
 5795 0268 0B       		.uleb128 0xb
 5796 0269 49       		.uleb128 0x49
 5797 026a 13       		.uleb128 0x13
 5798 026b 3F       		.uleb128 0x3f
 5799 026c 19       		.uleb128 0x19
 5800 026d 02       		.uleb128 0x2
 5801 026e 18       		.uleb128 0x18
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 155


 5802 026f 00       		.byte	0
 5803 0270 00       		.byte	0
 5804 0271 00       		.byte	0
 5805              		.section	.debug_aranges,"",%progbits
 5806 0000 0C010000 		.4byte	0x10c
 5807 0004 0200     		.2byte	0x2
 5808 0006 00000000 		.4byte	.Ldebug_info0
 5809 000a 04       		.byte	0x4
 5810 000b 00       		.byte	0
 5811 000c 0000     		.2byte	0
 5812 000e 0000     		.2byte	0
 5813 0010 00000000 		.4byte	.LFB68
 5814 0014 B4000000 		.4byte	.LFE68-.LFB68
 5815 0018 00000000 		.4byte	.LFB69
 5816 001c 50000000 		.4byte	.LFE69-.LFB69
 5817 0020 00000000 		.4byte	.LFB70
 5818 0024 3E000000 		.4byte	.LFE70-.LFB70
 5819 0028 00000000 		.4byte	.LFB71
 5820 002c 34000000 		.4byte	.LFE71-.LFB71
 5821 0030 00000000 		.4byte	.LFB72
 5822 0034 30000000 		.4byte	.LFE72-.LFB72
 5823 0038 00000000 		.4byte	.LFB73
 5824 003c 4C000000 		.4byte	.LFE73-.LFB73
 5825 0040 00000000 		.4byte	.LFB74
 5826 0044 50000000 		.4byte	.LFE74-.LFB74
 5827 0048 00000000 		.4byte	.LFB75
 5828 004c 2C000000 		.4byte	.LFE75-.LFB75
 5829 0050 00000000 		.4byte	.LFB76
 5830 0054 54010000 		.4byte	.LFE76-.LFB76
 5831 0058 00000000 		.4byte	.LFB77
 5832 005c B4000000 		.4byte	.LFE77-.LFB77
 5833 0060 00000000 		.4byte	.LFB78
 5834 0064 A6000000 		.4byte	.LFE78-.LFB78
 5835 0068 00000000 		.4byte	.LFB79
 5836 006c 44010000 		.4byte	.LFE79-.LFB79
 5837 0070 00000000 		.4byte	.LFB80
 5838 0074 90010000 		.4byte	.LFE80-.LFB80
 5839 0078 00000000 		.4byte	.LFB81
 5840 007c 48010000 		.4byte	.LFE81-.LFB81
 5841 0080 00000000 		.4byte	.LFB82
 5842 0084 AC000000 		.4byte	.LFE82-.LFB82
 5843 0088 00000000 		.4byte	.LFB83
 5844 008c 64000000 		.4byte	.LFE83-.LFB83
 5845 0090 00000000 		.4byte	.LFB84
 5846 0094 20000000 		.4byte	.LFE84-.LFB84
 5847 0098 00000000 		.4byte	.LFB85
 5848 009c 2A000000 		.4byte	.LFE85-.LFB85
 5849 00a0 00000000 		.4byte	.LFB86
 5850 00a4 1E000000 		.4byte	.LFE86-.LFB86
 5851 00a8 00000000 		.4byte	.LFB87
 5852 00ac 20000000 		.4byte	.LFE87-.LFB87
 5853 00b0 00000000 		.4byte	.LFB88
 5854 00b4 2E000000 		.4byte	.LFE88-.LFB88
 5855 00b8 00000000 		.4byte	.LFB89
 5856 00bc D4000000 		.4byte	.LFE89-.LFB89
 5857 00c0 00000000 		.4byte	.LFB90
 5858 00c4 4C000000 		.4byte	.LFE90-.LFB90
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 156


 5859 00c8 00000000 		.4byte	.LFB91
 5860 00cc A4000000 		.4byte	.LFE91-.LFB91
 5861 00d0 00000000 		.4byte	.LFB92
 5862 00d4 2C000000 		.4byte	.LFE92-.LFB92
 5863 00d8 00000000 		.4byte	.LFB93
 5864 00dc 2A000000 		.4byte	.LFE93-.LFB93
 5865 00e0 00000000 		.4byte	.LFB94
 5866 00e4 30000000 		.4byte	.LFE94-.LFB94
 5867 00e8 00000000 		.4byte	.LFB95
 5868 00ec 2E000000 		.4byte	.LFE95-.LFB95
 5869 00f0 00000000 		.4byte	.LFB96
 5870 00f4 50000000 		.4byte	.LFE96-.LFB96
 5871 00f8 00000000 		.4byte	.LFB97
 5872 00fc 4C000000 		.4byte	.LFE97-.LFB97
 5873 0100 00000000 		.4byte	.LFB98
 5874 0104 50000000 		.4byte	.LFE98-.LFB98
 5875 0108 00000000 		.4byte	0
 5876 010c 00000000 		.4byte	0
 5877              		.section	.debug_ranges,"",%progbits
 5878              	.Ldebug_ranges0:
 5879 0000 00000000 		.4byte	.LFB68
 5880 0004 B4000000 		.4byte	.LFE68
 5881 0008 00000000 		.4byte	.LFB69
 5882 000c 50000000 		.4byte	.LFE69
 5883 0010 00000000 		.4byte	.LFB70
 5884 0014 3E000000 		.4byte	.LFE70
 5885 0018 00000000 		.4byte	.LFB71
 5886 001c 34000000 		.4byte	.LFE71
 5887 0020 00000000 		.4byte	.LFB72
 5888 0024 30000000 		.4byte	.LFE72
 5889 0028 00000000 		.4byte	.LFB73
 5890 002c 4C000000 		.4byte	.LFE73
 5891 0030 00000000 		.4byte	.LFB74
 5892 0034 50000000 		.4byte	.LFE74
 5893 0038 00000000 		.4byte	.LFB75
 5894 003c 2C000000 		.4byte	.LFE75
 5895 0040 00000000 		.4byte	.LFB76
 5896 0044 54010000 		.4byte	.LFE76
 5897 0048 00000000 		.4byte	.LFB77
 5898 004c B4000000 		.4byte	.LFE77
 5899 0050 00000000 		.4byte	.LFB78
 5900 0054 A6000000 		.4byte	.LFE78
 5901 0058 00000000 		.4byte	.LFB79
 5902 005c 44010000 		.4byte	.LFE79
 5903 0060 00000000 		.4byte	.LFB80
 5904 0064 90010000 		.4byte	.LFE80
 5905 0068 00000000 		.4byte	.LFB81
 5906 006c 48010000 		.4byte	.LFE81
 5907 0070 00000000 		.4byte	.LFB82
 5908 0074 AC000000 		.4byte	.LFE82
 5909 0078 00000000 		.4byte	.LFB83
 5910 007c 64000000 		.4byte	.LFE83
 5911 0080 00000000 		.4byte	.LFB84
 5912 0084 20000000 		.4byte	.LFE84
 5913 0088 00000000 		.4byte	.LFB85
 5914 008c 2A000000 		.4byte	.LFE85
 5915 0090 00000000 		.4byte	.LFB86
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 157


 5916 0094 1E000000 		.4byte	.LFE86
 5917 0098 00000000 		.4byte	.LFB87
 5918 009c 20000000 		.4byte	.LFE87
 5919 00a0 00000000 		.4byte	.LFB88
 5920 00a4 2E000000 		.4byte	.LFE88
 5921 00a8 00000000 		.4byte	.LFB89
 5922 00ac D4000000 		.4byte	.LFE89
 5923 00b0 00000000 		.4byte	.LFB90
 5924 00b4 4C000000 		.4byte	.LFE90
 5925 00b8 00000000 		.4byte	.LFB91
 5926 00bc A4000000 		.4byte	.LFE91
 5927 00c0 00000000 		.4byte	.LFB92
 5928 00c4 2C000000 		.4byte	.LFE92
 5929 00c8 00000000 		.4byte	.LFB93
 5930 00cc 2A000000 		.4byte	.LFE93
 5931 00d0 00000000 		.4byte	.LFB94
 5932 00d4 30000000 		.4byte	.LFE94
 5933 00d8 00000000 		.4byte	.LFB95
 5934 00dc 2E000000 		.4byte	.LFE95
 5935 00e0 00000000 		.4byte	.LFB96
 5936 00e4 50000000 		.4byte	.LFE96
 5937 00e8 00000000 		.4byte	.LFB97
 5938 00ec 4C000000 		.4byte	.LFE97
 5939 00f0 00000000 		.4byte	.LFB98
 5940 00f4 50000000 		.4byte	.LFE98
 5941 00f8 00000000 		.4byte	0
 5942 00fc 00000000 		.4byte	0
 5943              		.section	.debug_line,"",%progbits
 5944              	.Ldebug_line0:
 5945 0000 22070000 		.section	.debug_str,"MS",%progbits,1
 5945      02002602 
 5945      00000201 
 5945      FB0E0D00 
 5945      01010101 
 5946              	.LASF33:
 5947 0000 75784E75 		.ascii	"uxNumberOfItems\000"
 5947      6D626572 
 5947      4F664974 
 5947      656D7300 
 5948              	.LASF60:
 5949 0010 53656D61 		.ascii	"SemaphoreData\000"
 5949      70686F72 
 5949      65446174 
 5949      6100
 5950              	.LASF143:
 5951 001e 74736B54 		.ascii	"tskTaskControlBlock\000"
 5951      61736B43 
 5951      6F6E7472 
 5951      6F6C426C 
 5951      6F636B00 
 5952              	.LASF63:
 5953 0032 53656D61 		.ascii	"SemaphoreData_t\000"
 5953      70686F72 
 5953      65446174 
 5953      615F7400 
 5954              	.LASF109:
 5955 0042 78517565 		.ascii	"xQueueReceive\000"
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 158


 5955      75655265 
 5955      63656976 
 5955      6500
 5956              	.LASF117:
 5957 0050 78517565 		.ascii	"xQueueReceiveFromISR\000"
 5957      75655265 
 5957      63656976 
 5957      6546726F 
 5957      6D495352 
 5958              	.LASF50:
 5959 0065 78546173 		.ascii	"xTasksWaitingToReceive\000"
 5959      6B735761 
 5959      6974696E 
 5959      67546F52 
 5959      65636569 
 5960              	.LASF105:
 5961 007c 70784869 		.ascii	"pxHigherPriorityTaskWoken\000"
 5961      67686572 
 5961      5072696F 
 5961      72697479 
 5961      5461736B 
 5962              	.LASF92:
 5963 0096 70784D75 		.ascii	"pxMutex\000"
 5963      74657800 
 5964              	.LASF111:
 5965 009e 78517565 		.ascii	"xQueueSemaphoreTake\000"
 5965      75655365 
 5965      6D617068 
 5965      6F726554 
 5965      616B6500 
 5966              	.LASF0:
 5967 00b2 756E7369 		.ascii	"unsigned int\000"
 5967      676E6564 
 5967      20696E74 
 5967      00
 5968              	.LASF34:
 5969 00bf 7078496E 		.ascii	"pxIndex\000"
 5969      64657800 
 5970              	.LASF41:
 5971 00c7 7854494D 		.ascii	"xTIME_OUT\000"
 5971      455F4F55 
 5971      5400
 5972              	.LASF81:
 5973 00d1 70784E65 		.ascii	"pxNewQueue\000"
 5973      77517565 
 5973      756500
 5974              	.LASF10:
 5975 00dc 5F5F696E 		.ascii	"__int32_t\000"
 5975      7433325F 
 5975      7400
 5976              	.LASF31:
 5977 00e6 784C4953 		.ascii	"xLIST_ITEM\000"
 5977      545F4954 
 5977      454D00
 5978              	.LASF68:
 5979 00f1 51554555 		.ascii	"QUEUE_REGISTRY_ITEM\000"
 5979      455F5245 
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 159


 5979      47495354 
 5979      52595F49 
 5979      54454D00 
 5980              	.LASF140:
 5981 0105 474E5520 		.ascii	"GNU C11 5.4.1 20160609 (release) [ARM/embedded-5-br"
 5981      43313120 
 5981      352E342E 
 5981      31203230 
 5981      31363036 
 5982 0138 616E6368 		.ascii	"anch revision 237715] -mcpu=cortex-m3 -mthumb -g -O"
 5982      20726576 
 5982      6973696F 
 5982      6E203233 
 5982      37373135 
 5983 016b 30202D66 		.ascii	"0 -ffunction-sections -ffat-lto-objects\000"
 5983      66756E63 
 5983      74696F6E 
 5983      2D736563 
 5983      74696F6E 
 5984              	.LASF49:
 5985 0193 78546173 		.ascii	"xTasksWaitingToSend\000"
 5985      6B735761 
 5985      6974696E 
 5985      67546F53 
 5985      656E6400 
 5986              	.LASF121:
 5987 01a7 75785175 		.ascii	"uxQueueSpacesAvailable\000"
 5987      65756553 
 5987      70616365 
 5987      73417661 
 5987      696C6162 
 5988              	.LASF55:
 5989 01be 6354784C 		.ascii	"cTxLock\000"
 5989      6F636B00 
 5990              	.LASF42:
 5991 01c6 784F7665 		.ascii	"xOverflowCount\000"
 5991      72666C6F 
 5991      77436F75 
 5991      6E7400
 5992              	.LASF62:
 5993 01d5 75785265 		.ascii	"uxRecursiveCallCount\000"
 5993      63757273 
 5993      69766543 
 5993      616C6C43 
 5993      6F756E74 
 5994              	.LASF67:
 5995 01ea 51756575 		.ascii	"Queue_t\000"
 5995      655F7400 
 5996              	.LASF100:
 5997 01f2 78436F70 		.ascii	"xCopyPosition\000"
 5997      79506F73 
 5997      6974696F 
 5997      6E00
 5998              	.LASF120:
 5999 0200 75785265 		.ascii	"uxReturn\000"
 5999      7475726E 
 5999      00
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 160


 6000              	.LASF72:
 6001 0209 51756575 		.ascii	"QueueRegistryItem_t\000"
 6001      65526567 
 6001      69737472 
 6001      79497465 
 6001      6D5F7400 
 6002              	.LASF133:
 6003 021d 76517565 		.ascii	"vQueueDelete\000"
 6003      75654465 
 6003      6C657465 
 6003      00
 6004              	.LASF141:
 6005 022a 536F7572 		.ascii	"Source\\queue.c\000"
 6005      63655C71 
 6005      75657565 
 6005      2E6300
 6006              	.LASF58:
 6007 0239 70635265 		.ascii	"pcReadFrom\000"
 6007      61644672 
 6007      6F6D00
 6008              	.LASF137:
 6009 0244 76517565 		.ascii	"vQueueUnregisterQueue\000"
 6009      7565556E 
 6009      72656769 
 6009      73746572 
 6009      51756575 
 6010              	.LASF106:
 6011 025a 75785361 		.ascii	"uxSavedInterruptStatus\000"
 6011      76656449 
 6011      6E746572 
 6011      72757074 
 6011      53746174 
 6012              	.LASF84:
 6013 0271 70727649 		.ascii	"prvInitialiseNewQueue\000"
 6013      6E697469 
 6013      616C6973 
 6013      654E6577 
 6013      51756575 
 6014              	.LASF20:
 6015 0287 75696E74 		.ascii	"uint32_t\000"
 6015      33325F74 
 6015      00
 6016              	.LASF17:
 6017 0290 696E7438 		.ascii	"int8_t\000"
 6017      5F7400
 6018              	.LASF88:
 6019 0297 75784D75 		.ascii	"uxMutexSize\000"
 6019      74657853 
 6019      697A6500 
 6020              	.LASF102:
 6021 02a3 78596965 		.ascii	"xYieldRequired\000"
 6021      6C645265 
 6021      71756972 
 6021      656400
 6022              	.LASF73:
 6023 02b2 756C4F72 		.ascii	"ulOriginalBASEPRI\000"
 6023      6967696E 
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 161


 6023      616C4241 
 6023      53455052 
 6023      4900
 6024              	.LASF64:
 6025 02c4 78517565 		.ascii	"xQueue\000"
 6025      756500
 6026              	.LASF21:
 6027 02cb 666C6F61 		.ascii	"float\000"
 6027      7400
 6028              	.LASF46:
 6029 02d1 51756575 		.ascii	"QueueDefinition\000"
 6029      65446566 
 6029      696E6974 
 6029      696F6E00 
 6030              	.LASF14:
 6031 02e1 6C6F6E67 		.ascii	"long long unsigned int\000"
 6031      206C6F6E 
 6031      6720756E 
 6031      7369676E 
 6031      65642069 
 6032              	.LASF129:
 6033 02f8 70727649 		.ascii	"prvIsQueueEmpty\000"
 6033      73517565 
 6033      7565456D 
 6033      70747900 
 6034              	.LASF110:
 6035 0308 70764275 		.ascii	"pvBuffer\000"
 6035      66666572 
 6035      00
 6036              	.LASF124:
 6037 0311 70727647 		.ascii	"prvGetDisinheritPriorityAfterTimeout\000"
 6037      65744469 
 6037      73696E68 
 6037      65726974 
 6037      5072696F 
 6038              	.LASF28:
 6039 0336 70785072 		.ascii	"pxPrevious\000"
 6039      6576696F 
 6039      757300
 6040              	.LASF51:
 6041 0341 75784D65 		.ascii	"uxMessagesWaiting\000"
 6041      73736167 
 6041      65735761 
 6041      6974696E 
 6041      6700
 6042              	.LASF65:
 6043 0353 7853656D 		.ascii	"xSemaphore\000"
 6043      6170686F 
 6043      726500
 6044              	.LASF107:
 6045 035e 75785072 		.ascii	"uxPreviousMessagesWaiting\000"
 6045      6576696F 
 6045      75734D65 
 6045      73736167 
 6045      65735761 
 6046              	.LASF115:
 6047 0378 78517565 		.ascii	"xQueuePeek\000"
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 162


 6047      75655065 
 6047      656B00
 6048              	.LASF101:
 6049 0383 78456E74 		.ascii	"xEntryTimeSet\000"
 6049      72795469 
 6049      6D655365 
 6049      7400
 6050              	.LASF3:
 6051 0391 73697A65 		.ascii	"size_t\000"
 6051      5F7400
 6052              	.LASF103:
 6053 0398 7854696D 		.ascii	"xTimeOut\000"
 6053      654F7574 
 6053      00
 6054              	.LASF70:
 6055 03a1 7848616E 		.ascii	"xHandle\000"
 6055      646C6500 
 6056              	.LASF69:
 6057 03a9 70635175 		.ascii	"pcQueueName\000"
 6057      6575654E 
 6057      616D6500 
 6058              	.LASF37:
 6059 03b5 784D494E 		.ascii	"xMINI_LIST_ITEM\000"
 6059      495F4C49 
 6059      53545F49 
 6059      54454D00 
 6060              	.LASF32:
 6061 03c5 784C4953 		.ascii	"xLIST\000"
 6061      5400
 6062              	.LASF104:
 6063 03cb 78517565 		.ascii	"xQueueGenericSendFromISR\000"
 6063      75654765 
 6063      6E657269 
 6063      6353656E 
 6063      6446726F 
 6064              	.LASF145:
 6065 03e4 76506F72 		.ascii	"vPortSetBASEPRI\000"
 6065      74536574 
 6065      42415345 
 6065      50524900 
 6066              	.LASF125:
 6067 03f4 70727643 		.ascii	"prvCopyDataToQueue\000"
 6067      6F707944 
 6067      61746154 
 6067      6F517565 
 6067      756500
 6068              	.LASF98:
 6069 0407 78517565 		.ascii	"xQueueGenericSend\000"
 6069      75654765 
 6069      6E657269 
 6069      6353656E 
 6069      6400
 6070              	.LASF53:
 6071 0419 75784974 		.ascii	"uxItemSize\000"
 6071      656D5369 
 6071      7A6500
 6072              	.LASF97:
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 163


 6073 0424 7578496E 		.ascii	"uxInitialCount\000"
 6073      69746961 
 6073      6C436F75 
 6073      6E7400
 6074              	.LASF87:
 6075 0433 75784D75 		.ascii	"uxMutexLength\000"
 6075      7465784C 
 6075      656E6774 
 6075      6800
 6076              	.LASF16:
 6077 0441 63686172 		.ascii	"char\000"
 6077      00
 6078              	.LASF36:
 6079 0446 4C697374 		.ascii	"ListItem_t\000"
 6079      4974656D 
 6079      5F7400
 6080              	.LASF131:
 6081 0451 70727649 		.ascii	"prvIsQueueFull\000"
 6081      73517565 
 6081      75654675 
 6081      6C6C00
 6082              	.LASF56:
 6083 0460 51756575 		.ascii	"QueuePointers\000"
 6083      65506F69 
 6083      6E746572 
 6083      7300
 6084              	.LASF74:
 6085 046e 756C4E65 		.ascii	"ulNewBASEPRI\000"
 6085      77424153 
 6085      45505249 
 6085      00
 6086              	.LASF24:
 6087 047b 55426173 		.ascii	"UBaseType_t\000"
 6087      65547970 
 6087      655F7400 
 6088              	.LASF108:
 6089 0487 78517565 		.ascii	"xQueueGiveFromISR\000"
 6089      75654769 
 6089      76654672 
 6089      6F6D4953 
 6089      5200
 6090              	.LASF139:
 6091 0499 78517565 		.ascii	"xQueueRegistry\000"
 6091      75655265 
 6091      67697374 
 6091      727900
 6092              	.LASF45:
 6093 04a8 51756575 		.ascii	"QueueHandle_t\000"
 6093      6548616E 
 6093      646C655F 
 6093      7400
 6094              	.LASF35:
 6095 04b6 784C6973 		.ascii	"xListEnd\000"
 6095      74456E64 
 6095      00
 6096              	.LASF122:
 6097 04bf 75785175 		.ascii	"uxQueueMessagesWaitingFromISR\000"
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 164


 6097      6575654D 
 6097      65737361 
 6097      67657357 
 6097      61697469 
 6098              	.LASF38:
 6099 04dd 4D696E69 		.ascii	"MiniListItem_t\000"
 6099      4C697374 
 6099      4974656D 
 6099      5F7400
 6100              	.LASF18:
 6101 04ec 75696E74 		.ascii	"uint8_t\000"
 6101      385F7400 
 6102              	.LASF71:
 6103 04f4 78517565 		.ascii	"xQueueRegistryItem\000"
 6103      75655265 
 6103      67697374 
 6103      72794974 
 6103      656D00
 6104              	.LASF77:
 6105 0507 78517565 		.ascii	"xQueueGenericCreate\000"
 6105      75654765 
 6105      6E657269 
 6105      63437265 
 6105      61746500 
 6106              	.LASF86:
 6107 051b 78517565 		.ascii	"xQueueCreateMutex\000"
 6107      75654372 
 6107      65617465 
 6107      4D757465 
 6107      7800
 6108              	.LASF144:
 6109 052d 756C506F 		.ascii	"ulPortRaiseBASEPRI\000"
 6109      72745261 
 6109      69736542 
 6109      41534550 
 6109      524900
 6110              	.LASF1:
 6111 0540 6C6F6E67 		.ascii	"long long int\000"
 6111      206C6F6E 
 6111      6720696E 
 6111      7400
 6112              	.LASF85:
 6113 054e 70727649 		.ascii	"prvInitialiseMutex\000"
 6113      6E697469 
 6113      616C6973 
 6113      654D7574 
 6113      657800
 6114              	.LASF23:
 6115 0561 42617365 		.ascii	"BaseType_t\000"
 6115      54797065 
 6115      5F7400
 6116              	.LASF83:
 6117 056c 70756351 		.ascii	"pucQueueStorage\000"
 6117      75657565 
 6117      53746F72 
 6117      61676500 
 6118              	.LASF90:
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 165


 6119 057c 784D7574 		.ascii	"xMutex\000"
 6119      657800
 6120              	.LASF43:
 6121 0583 7854696D 		.ascii	"xTimeOnEntering\000"
 6121      654F6E45 
 6121      6E746572 
 6121      696E6700 
 6122              	.LASF134:
 6123 0593 76517565 		.ascii	"vQueueAddToRegistry\000"
 6123      75654164 
 6123      64546F52 
 6123      65676973 
 6123      74727900 
 6124              	.LASF27:
 6125 05a7 70784E65 		.ascii	"pxNext\000"
 6125      787400
 6126              	.LASF75:
 6127 05ae 784E6577 		.ascii	"xNewQueue\000"
 6127      51756575 
 6127      6500
 6128              	.LASF96:
 6129 05b8 75784D61 		.ascii	"uxMaxCount\000"
 6129      78436F75 
 6129      6E7400
 6130              	.LASF44:
 6131 05c3 54696D65 		.ascii	"TimeOut_t\000"
 6131      4F75745F 
 6131      7400
 6132              	.LASF116:
 6133 05cd 70634F72 		.ascii	"pcOriginalReadPosition\000"
 6133      6967696E 
 6133      616C5265 
 6133      6164506F 
 6133      73697469 
 6134              	.LASF40:
 6135 05e4 5461736B 		.ascii	"TaskHandle_t\000"
 6135      48616E64 
 6135      6C655F74 
 6135      00
 6136              	.LASF146:
 6137 05f1 756C4E65 		.ascii	"ulNewMaskValue\000"
 6137      774D6173 
 6137      6B56616C 
 6137      756500
 6138              	.LASF123:
 6139 0600 75784869 		.ascii	"uxHighestPriorityOfWaitingTasks\000"
 6139      67686573 
 6139      74507269 
 6139      6F726974 
 6139      794F6657 
 6140              	.LASF79:
 6141 0620 75635175 		.ascii	"ucQueueType\000"
 6141      65756554 
 6141      79706500 
 6142              	.LASF39:
 6143 062c 4C697374 		.ascii	"List_t\000"
 6143      5F7400
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 166


 6144              	.LASF113:
 6145 0633 75785365 		.ascii	"uxSemaphoreCount\000"
 6145      6D617068 
 6145      6F726543 
 6145      6F756E74 
 6145      00
 6146              	.LASF48:
 6147 0644 70635772 		.ascii	"pcWriteTo\000"
 6147      69746554 
 6147      6F00
 6148              	.LASF25:
 6149 064e 5469636B 		.ascii	"TickType_t\000"
 6149      54797065 
 6149      5F7400
 6150              	.LASF4:
 6151 0659 5F5F696E 		.ascii	"__int8_t\000"
 6151      74385F74 
 6151      00
 6152              	.LASF78:
 6153 0662 75785175 		.ascii	"uxQueueLength\000"
 6153      6575654C 
 6153      656E6774 
 6153      6800
 6154              	.LASF2:
 6155 0670 6C6F6E67 		.ascii	"long double\000"
 6155      20646F75 
 6155      626C6500 
 6156              	.LASF112:
 6157 067c 78496E68 		.ascii	"xInheritanceOccurred\000"
 6157      65726974 
 6157      616E6365 
 6157      4F636375 
 6157      72726564 
 6158              	.LASF93:
 6159 0691 78517565 		.ascii	"xQueueTakeMutexRecursive\000"
 6159      75655461 
 6159      6B654D75 
 6159      74657852 
 6159      65637572 
 6160              	.LASF30:
 6161 06aa 7076436F 		.ascii	"pvContainer\000"
 6161      6E746169 
 6161      6E657200 
 6162              	.LASF135:
 6163 06b6 70635175 		.ascii	"pcQueueGetName\000"
 6163      65756547 
 6163      65744E61 
 6163      6D6500
 6164              	.LASF59:
 6165 06c5 51756575 		.ascii	"QueuePointers_t\000"
 6165      65506F69 
 6165      6E746572 
 6165      735F7400 
 6166              	.LASF136:
 6167 06d5 70635265 		.ascii	"pcReturn\000"
 6167      7475726E 
 6167      00
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 167


 6168              	.LASF52:
 6169 06de 75784C65 		.ascii	"uxLength\000"
 6169      6E677468 
 6169      00
 6170              	.LASF8:
 6171 06e7 73686F72 		.ascii	"short int\000"
 6171      7420696E 
 6171      7400
 6172              	.LASF26:
 6173 06f1 78497465 		.ascii	"xItemValue\000"
 6173      6D56616C 
 6173      756500
 6174              	.LASF11:
 6175 06fc 6C6F6E67 		.ascii	"long int\000"
 6175      20696E74 
 6175      00
 6176              	.LASF138:
 6177 0705 49544D5F 		.ascii	"ITM_RxBuffer\000"
 6177      52784275 
 6177      66666572 
 6177      00
 6178              	.LASF82:
 6179 0712 78517565 		.ascii	"xQueueSizeInBytes\000"
 6179      75655369 
 6179      7A65496E 
 6179      42797465 
 6179      7300
 6180              	.LASF99:
 6181 0724 70764974 		.ascii	"pvItemToQueue\000"
 6181      656D546F 
 6181      51756575 
 6181      6500
 6182              	.LASF132:
 6183 0732 78517565 		.ascii	"xQueueIsQueueFullFromISR\000"
 6183      75654973 
 6183      51756575 
 6183      6546756C 
 6183      6C46726F 
 6184              	.LASF119:
 6185 074b 75785175 		.ascii	"uxQueueMessagesWaiting\000"
 6185      6575654D 
 6185      65737361 
 6185      67657357 
 6185      61697469 
 6186              	.LASF57:
 6187 0762 70635461 		.ascii	"pcTail\000"
 6187      696C00
 6188              	.LASF94:
 6189 0769 78546963 		.ascii	"xTicksToWait\000"
 6189      6B73546F 
 6189      57616974 
 6189      00
 6190              	.LASF6:
 6191 0776 5F5F7569 		.ascii	"__uint8_t\000"
 6191      6E74385F 
 6191      7400
 6192              	.LASF80:
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 168


 6193 0780 70785175 		.ascii	"pxQueue\000"
 6193      65756500 
 6194              	.LASF91:
 6195 0788 78526574 		.ascii	"xReturn\000"
 6195      75726E00 
 6196              	.LASF15:
 6197 0790 73697A65 		.ascii	"sizetype\000"
 6197      74797065 
 6197      00
 6198              	.LASF13:
 6199 0799 6C6F6E67 		.ascii	"long unsigned int\000"
 6199      20756E73 
 6199      69676E65 
 6199      6420696E 
 6199      7400
 6200              	.LASF19:
 6201 07ab 696E7433 		.ascii	"int32_t\000"
 6201      325F7400 
 6202              	.LASF118:
 6203 07b3 78517565 		.ascii	"xQueuePeekFromISR\000"
 6203      75655065 
 6203      656B4672 
 6203      6F6D4953 
 6203      5200
 6204              	.LASF114:
 6205 07c5 75784869 		.ascii	"uxHighestWaitingPriority\000"
 6205      67686573 
 6205      74576169 
 6205      74696E67 
 6205      5072696F 
 6206              	.LASF7:
 6207 07de 756E7369 		.ascii	"unsigned char\000"
 6207      676E6564 
 6207      20636861 
 6207      7200
 6208              	.LASF12:
 6209 07ec 5F5F7569 		.ascii	"__uint32_t\000"
 6209      6E743332 
 6209      5F7400
 6210              	.LASF127:
 6211 07f7 70727643 		.ascii	"prvCopyDataFromQueue\000"
 6211      6F707944 
 6211      61746146 
 6211      726F6D51 
 6211      75657565 
 6212              	.LASF142:
 6213 080c 433A5C55 		.ascii	"C:\\Users\\Emil\\Documents\\GitHub\\P4_Vertical_far"
 6213      73657273 
 6213      5C456D69 
 6213      6C5C446F 
 6213      63756D65 
 6214 083a 6D5C5254 		.ascii	"m\\RTOS_TEMPLATE-master\\PlanteModul.cydsn\000"
 6214      4F535F54 
 6214      454D504C 
 6214      4154452D 
 6214      6D617374 
 6215              	.LASF29:
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 169


 6216 0863 70764F77 		.ascii	"pvOwner\000"
 6216      6E657200 
 6217              	.LASF47:
 6218 086b 70634865 		.ascii	"pcHead\000"
 6218      616400
 6219              	.LASF89:
 6220 0872 78517565 		.ascii	"xQueueGiveMutexRecursive\000"
 6220      75654769 
 6220      76654D75 
 6220      74657852 
 6220      65637572 
 6221              	.LASF128:
 6222 088b 70727655 		.ascii	"prvUnlockQueue\000"
 6222      6E6C6F63 
 6222      6B517565 
 6222      756500
 6223              	.LASF76:
 6224 089a 78517565 		.ascii	"xQueueGenericReset\000"
 6224      75654765 
 6224      6E657269 
 6224      63526573 
 6224      657400
 6225              	.LASF130:
 6226 08ad 78517565 		.ascii	"xQueueIsQueueEmptyFromISR\000"
 6226      75654973 
 6226      51756575 
 6226      65456D70 
 6226      74794672 
 6227              	.LASF5:
 6228 08c7 7369676E 		.ascii	"signed char\000"
 6228      65642063 
 6228      68617200 
 6229              	.LASF9:
 6230 08d3 73686F72 		.ascii	"short unsigned int\000"
 6230      7420756E 
 6230      7369676E 
 6230      65642069 
 6230      6E7400
 6231              	.LASF66:
 6232 08e6 78515545 		.ascii	"xQUEUE\000"
 6232      554500
 6233              	.LASF61:
 6234 08ed 784D7574 		.ascii	"xMutexHolder\000"
 6234      6578486F 
 6234      6C646572 
 6234      00
 6235              	.LASF22:
 6236 08fa 646F7562 		.ascii	"double\000"
 6236      6C6500
 6237              	.LASF126:
 6238 0901 78506F73 		.ascii	"xPosition\000"
 6238      6974696F 
 6238      6E00
 6239              	.LASF54:
 6240 090b 6352784C 		.ascii	"cRxLock\000"
 6240      6F636B00 
 6241              	.LASF95:
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccX3pjTY.s 			page 170


 6242 0913 78517565 		.ascii	"xQueueCreateCountingSemaphore\000"
 6242      75654372 
 6242      65617465 
 6242      436F756E 
 6242      74696E67 
 6243              		.ident	"GCC: (GNU Tools for ARM Embedded Processors) 5.4.1 20160609 (release) [ARM/embedded-5-bran
