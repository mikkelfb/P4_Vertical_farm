ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 1


   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.syntax unified
  15              		.file	"queue.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.comm	DS18x8_Sensor,32,4
  20              		.comm	DS18x8_DataReady,1,1
  21              		.comm	xQueueRegistry,80,4
  22              		.section	.text.xQueueGenericReset,"ax",%progbits
  23              		.align	2
  24              		.global	xQueueGenericReset
  25              		.thumb
  26              		.thumb_func
  27              		.type	xQueueGenericReset, %function
  28              	xQueueGenericReset:
  29              	.LFB68:
  30              		.file 1 "Source\\queue.c"
   1:Source/queue.c **** /*
   2:Source/queue.c ****  * FreeRTOS Kernel V10.3.1
   3:Source/queue.c ****  * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:Source/queue.c ****  *
   5:Source/queue.c ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   6:Source/queue.c ****  * this software and associated documentation files (the "Software"), to deal in
   7:Source/queue.c ****  * the Software without restriction, including without limitation the rights to
   8:Source/queue.c ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   9:Source/queue.c ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  10:Source/queue.c ****  * subject to the following conditions:
  11:Source/queue.c ****  *
  12:Source/queue.c ****  * The above copyright notice and this permission notice shall be included in all
  13:Source/queue.c ****  * copies or substantial portions of the Software.
  14:Source/queue.c ****  *
  15:Source/queue.c ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:Source/queue.c ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  17:Source/queue.c ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  18:Source/queue.c ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  19:Source/queue.c ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  20:Source/queue.c ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  21:Source/queue.c ****  *
  22:Source/queue.c ****  * http://www.FreeRTOS.org
  23:Source/queue.c ****  * http://aws.amazon.com/freertos
  24:Source/queue.c ****  *
  25:Source/queue.c ****  * 1 tab == 4 spaces!
  26:Source/queue.c ****  */
  27:Source/queue.c **** 
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 2


  28:Source/queue.c **** #include <stdlib.h>
  29:Source/queue.c **** #include <string.h>
  30:Source/queue.c **** 
  31:Source/queue.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  32:Source/queue.c **** all the API functions to use the MPU wrappers.  That should only be done when
  33:Source/queue.c **** task.h is included from an application file. */
  34:Source/queue.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  35:Source/queue.c **** 
  36:Source/queue.c **** #include "FreeRTOS.h"
  37:Source/queue.c **** #include "task.h"
  38:Source/queue.c **** #include "queue.h"
  39:Source/queue.c **** 
  40:Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
  41:Source/queue.c **** 	#include "croutine.h"
  42:Source/queue.c **** #endif
  43:Source/queue.c **** 
  44:Source/queue.c **** /* Lint e9021, e961 and e750 are suppressed as a MISRA exception justified
  45:Source/queue.c **** because the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined
  46:Source/queue.c **** for the header files above, but not in this file, in order to generate the
  47:Source/queue.c **** correct privileged Vs unprivileged linkage and placement. */
  48:Source/queue.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750 !e9021. */
  49:Source/queue.c **** 
  50:Source/queue.c **** 
  51:Source/queue.c **** /* Constants used with the cRxLock and cTxLock structure members. */
  52:Source/queue.c **** #define queueUNLOCKED					( ( int8_t ) -1 )
  53:Source/queue.c **** #define queueLOCKED_UNMODIFIED			( ( int8_t ) 0 )
  54:Source/queue.c **** 
  55:Source/queue.c **** /* When the Queue_t structure is used to represent a base queue its pcHead and
  56:Source/queue.c **** pcTail members are used as pointers into the queue storage area.  When the
  57:Source/queue.c **** Queue_t structure is used to represent a mutex pcHead and pcTail pointers are
  58:Source/queue.c **** not necessary, and the pcHead pointer is set to NULL to indicate that the
  59:Source/queue.c **** structure instead holds a pointer to the mutex holder (if any).  Map alternative
  60:Source/queue.c **** names to the pcHead and structure member to ensure the readability of the code
  61:Source/queue.c **** is maintained.  The QueuePointers_t and SemaphoreData_t types are used to form
  62:Source/queue.c **** a union as their usage is mutually exclusive dependent on what the queue is
  63:Source/queue.c **** being used for. */
  64:Source/queue.c **** #define uxQueueType						pcHead
  65:Source/queue.c **** #define queueQUEUE_IS_MUTEX				NULL
  66:Source/queue.c **** 
  67:Source/queue.c **** typedef struct QueuePointers
  68:Source/queue.c **** {
  69:Source/queue.c **** 	int8_t *pcTail;					/*< Points to the byte at the end of the queue storage area.  Once more byte i
  70:Source/queue.c **** 	int8_t *pcReadFrom;				/*< Points to the last place that a queued item was read from when the stru
  71:Source/queue.c **** } QueuePointers_t;
  72:Source/queue.c **** 
  73:Source/queue.c **** typedef struct SemaphoreData
  74:Source/queue.c **** {
  75:Source/queue.c **** 	TaskHandle_t xMutexHolder;		 /*< The handle of the task that holds the mutex. */
  76:Source/queue.c **** 	UBaseType_t uxRecursiveCallCount;/*< Maintains a count of the number of times a recursive mutex ha
  77:Source/queue.c **** } SemaphoreData_t;
  78:Source/queue.c **** 
  79:Source/queue.c **** /* Semaphores do not actually store or copy data, so have an item size of
  80:Source/queue.c **** zero. */
  81:Source/queue.c **** #define queueSEMAPHORE_QUEUE_ITEM_LENGTH ( ( UBaseType_t ) 0 )
  82:Source/queue.c **** #define queueMUTEX_GIVE_BLOCK_TIME		 ( ( TickType_t ) 0U )
  83:Source/queue.c **** 
  84:Source/queue.c **** #if( configUSE_PREEMPTION == 0 )
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 3


  85:Source/queue.c **** 	/* If the cooperative scheduler is being used then a yield should not be
  86:Source/queue.c **** 	performed just because a higher priority task has been woken. */
  87:Source/queue.c **** 	#define queueYIELD_IF_USING_PREEMPTION()
  88:Source/queue.c **** #else
  89:Source/queue.c **** 	#define queueYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
  90:Source/queue.c **** #endif
  91:Source/queue.c **** 
  92:Source/queue.c **** /*
  93:Source/queue.c ****  * Definition of the queue used by the scheduler.
  94:Source/queue.c ****  * Items are queued by copy, not reference.  See the following link for the
  95:Source/queue.c ****  * rationale: https://www.freertos.org/Embedded-RTOS-Queues.html
  96:Source/queue.c ****  */
  97:Source/queue.c **** typedef struct QueueDefinition 		/* The old naming convention is used to prevent breaking kernel aw
  98:Source/queue.c **** {
  99:Source/queue.c **** 	int8_t *pcHead;					/*< Points to the beginning of the queue storage area. */
 100:Source/queue.c **** 	int8_t *pcWriteTo;				/*< Points to the free next place in the storage area. */
 101:Source/queue.c **** 
 102:Source/queue.c **** 	union
 103:Source/queue.c **** 	{
 104:Source/queue.c **** 		QueuePointers_t xQueue;		/*< Data required exclusively when this structure is used as a queue. */
 105:Source/queue.c **** 		SemaphoreData_t xSemaphore; /*< Data required exclusively when this structure is used as a semaph
 106:Source/queue.c **** 	} u;
 107:Source/queue.c **** 
 108:Source/queue.c **** 	List_t xTasksWaitingToSend;		/*< List of tasks that are blocked waiting to post onto this queue.  
 109:Source/queue.c **** 	List_t xTasksWaitingToReceive;	/*< List of tasks that are blocked waiting to read from this queue.
 110:Source/queue.c **** 
 111:Source/queue.c **** 	volatile UBaseType_t uxMessagesWaiting;/*< The number of items currently in the queue. */
 112:Source/queue.c **** 	UBaseType_t uxLength;			/*< The length of the queue defined as the number of items it will hold, n
 113:Source/queue.c **** 	UBaseType_t uxItemSize;			/*< The size of each items that the queue will hold. */
 114:Source/queue.c **** 
 115:Source/queue.c **** 	volatile int8_t cRxLock;		/*< Stores the number of items received from the queue (removed from the
 116:Source/queue.c **** 	volatile int8_t cTxLock;		/*< Stores the number of items transmitted to the queue (added to the qu
 117:Source/queue.c **** 
 118:Source/queue.c **** 	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 119:Source/queue.c **** 		uint8_t ucStaticallyAllocated;	/*< Set to pdTRUE if the memory used by the queue was statically a
 120:Source/queue.c **** 	#endif
 121:Source/queue.c **** 
 122:Source/queue.c **** 	#if ( configUSE_QUEUE_SETS == 1 )
 123:Source/queue.c **** 		struct QueueDefinition *pxQueueSetContainer;
 124:Source/queue.c **** 	#endif
 125:Source/queue.c **** 
 126:Source/queue.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 127:Source/queue.c **** 		UBaseType_t uxQueueNumber;
 128:Source/queue.c **** 		uint8_t ucQueueType;
 129:Source/queue.c **** 	#endif
 130:Source/queue.c **** 
 131:Source/queue.c **** } xQUEUE;
 132:Source/queue.c **** 
 133:Source/queue.c **** /* The old xQUEUE name is maintained above then typedefed to the new Queue_t
 134:Source/queue.c **** name below to enable the use of older kernel aware debuggers. */
 135:Source/queue.c **** typedef xQUEUE Queue_t;
 136:Source/queue.c **** 
 137:Source/queue.c **** /*-----------------------------------------------------------*/
 138:Source/queue.c **** 
 139:Source/queue.c **** /*
 140:Source/queue.c ****  * The queue registry is just a means for kernel aware debuggers to locate
 141:Source/queue.c ****  * queue structures.  It has no other purpose so is an optional component.
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 4


 142:Source/queue.c ****  */
 143:Source/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
 144:Source/queue.c **** 
 145:Source/queue.c **** 	/* The type stored within the queue registry array.  This allows a name
 146:Source/queue.c **** 	to be assigned to each queue making kernel aware debugging a little
 147:Source/queue.c **** 	more user friendly. */
 148:Source/queue.c **** 	typedef struct QUEUE_REGISTRY_ITEM
 149:Source/queue.c **** 	{
 150:Source/queue.c **** 		const char *pcQueueName; /*lint !e971 Unqualified char types are allowed for strings and single c
 151:Source/queue.c **** 		QueueHandle_t xHandle;
 152:Source/queue.c **** 	} xQueueRegistryItem;
 153:Source/queue.c **** 
 154:Source/queue.c **** 	/* The old xQueueRegistryItem name is maintained above then typedefed to the
 155:Source/queue.c **** 	new xQueueRegistryItem name below to enable the use of older kernel aware
 156:Source/queue.c **** 	debuggers. */
 157:Source/queue.c **** 	typedef xQueueRegistryItem QueueRegistryItem_t;
 158:Source/queue.c **** 
 159:Source/queue.c **** 	/* The queue registry is simply an array of QueueRegistryItem_t structures.
 160:Source/queue.c **** 	The pcQueueName member of a structure being NULL is indicative of the
 161:Source/queue.c **** 	array position being vacant. */
 162:Source/queue.c **** 	PRIVILEGED_DATA QueueRegistryItem_t xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];
 163:Source/queue.c **** 
 164:Source/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
 165:Source/queue.c **** 
 166:Source/queue.c **** /*
 167:Source/queue.c ****  * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not
 168:Source/queue.c ****  * prevent an ISR from adding or removing items to the queue, but does prevent
 169:Source/queue.c ****  * an ISR from removing tasks from the queue event lists.  If an ISR finds a
 170:Source/queue.c ****  * queue is locked it will instead increment the appropriate queue lock count
 171:Source/queue.c ****  * to indicate that a task may require unblocking.  When the queue in unlocked
 172:Source/queue.c ****  * these lock counts are inspected, and the appropriate action taken.
 173:Source/queue.c ****  */
 174:Source/queue.c **** static void prvUnlockQueue( Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;
 175:Source/queue.c **** 
 176:Source/queue.c **** /*
 177:Source/queue.c ****  * Uses a critical section to determine if there is any data in a queue.
 178:Source/queue.c ****  *
 179:Source/queue.c ****  * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
 180:Source/queue.c ****  */
 181:Source/queue.c **** static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
 182:Source/queue.c **** 
 183:Source/queue.c **** /*
 184:Source/queue.c ****  * Uses a critical section to determine if there is any space in a queue.
 185:Source/queue.c ****  *
 186:Source/queue.c ****  * @return pdTRUE if there is no space, otherwise pdFALSE;
 187:Source/queue.c ****  */
 188:Source/queue.c **** static BaseType_t prvIsQueueFull( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
 189:Source/queue.c **** 
 190:Source/queue.c **** /*
 191:Source/queue.c ****  * Copies an item into the queue, either at the front of the queue or the
 192:Source/queue.c ****  * back of the queue.
 193:Source/queue.c ****  */
 194:Source/queue.c **** static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const Bas
 195:Source/queue.c **** 
 196:Source/queue.c **** /*
 197:Source/queue.c ****  * Copies an item out of a queue.
 198:Source/queue.c ****  */
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 5


 199:Source/queue.c **** static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer ) PRIVILEGED_FUNCT
 200:Source/queue.c **** 
 201:Source/queue.c **** #if ( configUSE_QUEUE_SETS == 1 )
 202:Source/queue.c **** 	/*
 203:Source/queue.c **** 	 * Checks to see if a queue is a member of a queue set, and if so, notifies
 204:Source/queue.c **** 	 * the queue set that the queue contains data.
 205:Source/queue.c **** 	 */
 206:Source/queue.c **** 	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;
 207:Source/queue.c **** #endif
 208:Source/queue.c **** 
 209:Source/queue.c **** /*
 210:Source/queue.c ****  * Called after a Queue_t structure has been allocated either statically or
 211:Source/queue.c ****  * dynamically to fill in the structure's members.
 212:Source/queue.c ****  */
 213:Source/queue.c **** static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, u
 214:Source/queue.c **** 
 215:Source/queue.c **** /*
 216:Source/queue.c ****  * Mutexes are a special type of queue.  When a mutex is created, first the
 217:Source/queue.c ****  * queue is created, then prvInitialiseMutex() is called to configure the queue
 218:Source/queue.c ****  * as a mutex.
 219:Source/queue.c ****  */
 220:Source/queue.c **** #if( configUSE_MUTEXES == 1 )
 221:Source/queue.c **** 	static void prvInitialiseMutex( Queue_t *pxNewQueue ) PRIVILEGED_FUNCTION;
 222:Source/queue.c **** #endif
 223:Source/queue.c **** 
 224:Source/queue.c **** #if( configUSE_MUTEXES == 1 )
 225:Source/queue.c **** 	/*
 226:Source/queue.c **** 	 * If a task waiting for a mutex causes the mutex holder to inherit a
 227:Source/queue.c **** 	 * priority, but the waiting task times out, then the holder should
 228:Source/queue.c **** 	 * disinherit the priority - but only down to the highest priority of any
 229:Source/queue.c **** 	 * other tasks that are waiting for the same mutex.  This function returns
 230:Source/queue.c **** 	 * that priority.
 231:Source/queue.c **** 	 */
 232:Source/queue.c **** 	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue ) PRIVILEGE
 233:Source/queue.c **** #endif
 234:Source/queue.c **** /*-----------------------------------------------------------*/
 235:Source/queue.c **** 
 236:Source/queue.c **** /*
 237:Source/queue.c ****  * Macro to mark a queue as locked.  Locking a queue prevents an ISR from
 238:Source/queue.c ****  * accessing the queue event lists.
 239:Source/queue.c ****  */
 240:Source/queue.c **** #define prvLockQueue( pxQueue )								\
 241:Source/queue.c **** 	taskENTER_CRITICAL();									\
 242:Source/queue.c **** 	{														\
 243:Source/queue.c **** 		if( ( pxQueue )->cRxLock == queueUNLOCKED )			\
 244:Source/queue.c **** 		{													\
 245:Source/queue.c **** 			( pxQueue )->cRxLock = queueLOCKED_UNMODIFIED;	\
 246:Source/queue.c **** 		}													\
 247:Source/queue.c **** 		if( ( pxQueue )->cTxLock == queueUNLOCKED )			\
 248:Source/queue.c **** 		{													\
 249:Source/queue.c **** 			( pxQueue )->cTxLock = queueLOCKED_UNMODIFIED;	\
 250:Source/queue.c **** 		}													\
 251:Source/queue.c **** 	}														\
 252:Source/queue.c **** 	taskEXIT_CRITICAL()
 253:Source/queue.c **** /*-----------------------------------------------------------*/
 254:Source/queue.c **** 
 255:Source/queue.c **** BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 6


 256:Source/queue.c **** {
  31              		.loc 1 256 0
  32              		.cfi_startproc
  33              		@ args = 0, pretend = 0, frame = 16
  34              		@ frame_needed = 1, uses_anonymous_args = 0
  35 0000 80B5     		push	{r7, lr}
  36              		.cfi_def_cfa_offset 8
  37              		.cfi_offset 7, -8
  38              		.cfi_offset 14, -4
  39 0002 84B0     		sub	sp, sp, #16
  40              		.cfi_def_cfa_offset 24
  41 0004 00AF     		add	r7, sp, #0
  42              		.cfi_def_cfa_register 7
  43 0006 7860     		str	r0, [r7, #4]
  44 0008 3960     		str	r1, [r7]
 257:Source/queue.c **** Queue_t * const pxQueue = xQueue;
  45              		.loc 1 257 0
  46 000a 7B68     		ldr	r3, [r7, #4]
  47 000c FB60     		str	r3, [r7, #12]
 258:Source/queue.c **** 
 259:Source/queue.c **** 	configASSERT( pxQueue );
 260:Source/queue.c **** 
 261:Source/queue.c **** 	taskENTER_CRITICAL();
  48              		.loc 1 261 0
  49 000e FFF7FEFF 		bl	vPortEnterCritical
 262:Source/queue.c **** 	{
 263:Source/queue.c **** 		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint 
  50              		.loc 1 263 0
  51 0012 FB68     		ldr	r3, [r7, #12]
  52 0014 1A68     		ldr	r2, [r3]
  53 0016 FB68     		ldr	r3, [r7, #12]
  54 0018 DB6B     		ldr	r3, [r3, #60]
  55 001a F968     		ldr	r1, [r7, #12]
  56 001c 096C     		ldr	r1, [r1, #64]
  57 001e 01FB03F3 		mul	r3, r1, r3
  58 0022 1A44     		add	r2, r2, r3
  59 0024 FB68     		ldr	r3, [r7, #12]
  60 0026 9A60     		str	r2, [r3, #8]
 264:Source/queue.c **** 		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
  61              		.loc 1 264 0
  62 0028 FB68     		ldr	r3, [r7, #12]
  63 002a 0022     		movs	r2, #0
  64 002c 9A63     		str	r2, [r3, #56]
 265:Source/queue.c **** 		pxQueue->pcWriteTo = pxQueue->pcHead;
  65              		.loc 1 265 0
  66 002e FB68     		ldr	r3, [r7, #12]
  67 0030 1A68     		ldr	r2, [r3]
  68 0032 FB68     		ldr	r3, [r7, #12]
  69 0034 5A60     		str	r2, [r3, #4]
 266:Source/queue.c **** 		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSi
  70              		.loc 1 266 0
  71 0036 FB68     		ldr	r3, [r7, #12]
  72 0038 1A68     		ldr	r2, [r3]
  73 003a FB68     		ldr	r3, [r7, #12]
  74 003c DB6B     		ldr	r3, [r3, #60]
  75 003e 013B     		subs	r3, r3, #1
  76 0040 F968     		ldr	r1, [r7, #12]
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 7


  77 0042 096C     		ldr	r1, [r1, #64]
  78 0044 01FB03F3 		mul	r3, r1, r3
  79 0048 1A44     		add	r2, r2, r3
  80 004a FB68     		ldr	r3, [r7, #12]
  81 004c DA60     		str	r2, [r3, #12]
 267:Source/queue.c **** 		pxQueue->cRxLock = queueUNLOCKED;
  82              		.loc 1 267 0
  83 004e FB68     		ldr	r3, [r7, #12]
  84 0050 FF22     		movs	r2, #255
  85 0052 83F84420 		strb	r2, [r3, #68]
 268:Source/queue.c **** 		pxQueue->cTxLock = queueUNLOCKED;
  86              		.loc 1 268 0
  87 0056 FB68     		ldr	r3, [r7, #12]
  88 0058 FF22     		movs	r2, #255
  89 005a 83F84520 		strb	r2, [r3, #69]
 269:Source/queue.c **** 
 270:Source/queue.c **** 		if( xNewQueue == pdFALSE )
  90              		.loc 1 270 0
  91 005e 3B68     		ldr	r3, [r7]
  92 0060 002B     		cmp	r3, #0
  93 0062 14D1     		bne	.L2
 271:Source/queue.c **** 		{
 272:Source/queue.c **** 			/* If there are tasks blocked waiting to read from the queue, then
 273:Source/queue.c **** 			the tasks will remain blocked as after this function exits the queue
 274:Source/queue.c **** 			will still be empty.  If there are tasks blocked waiting to write to
 275:Source/queue.c **** 			the queue, then one should be unblocked as after this function exits
 276:Source/queue.c **** 			it will be possible to write to it. */
 277:Source/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  94              		.loc 1 277 0
  95 0064 FB68     		ldr	r3, [r7, #12]
  96 0066 1B69     		ldr	r3, [r3, #16]
  97 0068 002B     		cmp	r3, #0
  98 006a 1AD0     		beq	.L3
 278:Source/queue.c **** 			{
 279:Source/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
  99              		.loc 1 279 0
 100 006c FB68     		ldr	r3, [r7, #12]
 101 006e 1033     		adds	r3, r3, #16
 102 0070 1846     		mov	r0, r3
 103 0072 FFF7FEFF 		bl	xTaskRemoveFromEventList
 104 0076 0346     		mov	r3, r0
 105 0078 002B     		cmp	r3, #0
 106 007a 12D0     		beq	.L3
 280:Source/queue.c **** 				{
 281:Source/queue.c **** 					queueYIELD_IF_USING_PREEMPTION();
 107              		.loc 1 281 0
 108 007c 0C4B     		ldr	r3, .L5
 109 007e 4FF08052 		mov	r2, #268435456
 110 0082 1A60     		str	r2, [r3]
 111              		.syntax unified
 112              	@ 281 "Source\queue.c" 1
 113 0084 BFF34F8F 		dsb
 114              	@ 0 "" 2
 115              	@ 281 "Source\queue.c" 1
 116 0088 BFF36F8F 		isb
 117              	@ 0 "" 2
 118              		.thumb
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 8


 119              		.syntax unified
 120 008c 09E0     		b	.L3
 121              	.L2:
 282:Source/queue.c **** 				}
 283:Source/queue.c **** 				else
 284:Source/queue.c **** 				{
 285:Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
 286:Source/queue.c **** 				}
 287:Source/queue.c **** 			}
 288:Source/queue.c **** 			else
 289:Source/queue.c **** 			{
 290:Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
 291:Source/queue.c **** 			}
 292:Source/queue.c **** 		}
 293:Source/queue.c **** 		else
 294:Source/queue.c **** 		{
 295:Source/queue.c **** 			/* Ensure the event queues start in the correct state. */
 296:Source/queue.c **** 			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 122              		.loc 1 296 0
 123 008e FB68     		ldr	r3, [r7, #12]
 124 0090 1033     		adds	r3, r3, #16
 125 0092 1846     		mov	r0, r3
 126 0094 FFF7FEFF 		bl	vListInitialise
 297:Source/queue.c **** 			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 127              		.loc 1 297 0
 128 0098 FB68     		ldr	r3, [r7, #12]
 129 009a 2433     		adds	r3, r3, #36
 130 009c 1846     		mov	r0, r3
 131 009e FFF7FEFF 		bl	vListInitialise
 132              	.L3:
 298:Source/queue.c **** 		}
 299:Source/queue.c **** 	}
 300:Source/queue.c **** 	taskEXIT_CRITICAL();
 133              		.loc 1 300 0
 134 00a2 FFF7FEFF 		bl	vPortExitCritical
 301:Source/queue.c **** 
 302:Source/queue.c **** 	/* A value is returned for calling semantic consistency with previous
 303:Source/queue.c **** 	versions. */
 304:Source/queue.c **** 	return pdPASS;
 135              		.loc 1 304 0
 136 00a6 0123     		movs	r3, #1
 305:Source/queue.c **** }
 137              		.loc 1 305 0
 138 00a8 1846     		mov	r0, r3
 139 00aa 1037     		adds	r7, r7, #16
 140              		.cfi_def_cfa_offset 8
 141 00ac BD46     		mov	sp, r7
 142              		.cfi_def_cfa_register 13
 143              		@ sp needed
 144 00ae 80BD     		pop	{r7, pc}
 145              	.L6:
 146              		.align	2
 147              	.L5:
 148 00b0 04ED00E0 		.word	-536810236
 149              		.cfi_endproc
 150              	.LFE68:
 151              		.size	xQueueGenericReset, .-xQueueGenericReset
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 9


 152              		.section	.text.xQueueGenericCreate,"ax",%progbits
 153              		.align	2
 154              		.global	xQueueGenericCreate
 155              		.thumb
 156              		.thumb_func
 157              		.type	xQueueGenericCreate, %function
 158              	xQueueGenericCreate:
 159              	.LFB69:
 306:Source/queue.c **** /*-----------------------------------------------------------*/
 307:Source/queue.c **** 
 308:Source/queue.c **** #if( configSUPPORT_STATIC_ALLOCATION == 1 )
 309:Source/queue.c **** 
 310:Source/queue.c **** 	QueueHandle_t xQueueGenericCreateStatic( const UBaseType_t uxQueueLength, const UBaseType_t uxItem
 311:Source/queue.c **** 	{
 312:Source/queue.c **** 	Queue_t *pxNewQueue;
 313:Source/queue.c **** 
 314:Source/queue.c **** 		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 315:Source/queue.c **** 
 316:Source/queue.c **** 		/* The StaticQueue_t structure and the queue storage area must be
 317:Source/queue.c **** 		supplied. */
 318:Source/queue.c **** 		configASSERT( pxStaticQueue != NULL );
 319:Source/queue.c **** 
 320:Source/queue.c **** 		/* A queue storage area should be provided if the item size is not 0, and
 321:Source/queue.c **** 		should not be provided if the item size is 0. */
 322:Source/queue.c **** 		configASSERT( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) );
 323:Source/queue.c **** 		configASSERT( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) );
 324:Source/queue.c **** 
 325:Source/queue.c **** 		#if( configASSERT_DEFINED == 1 )
 326:Source/queue.c **** 		{
 327:Source/queue.c **** 			/* Sanity check that the size of the structure used to declare a
 328:Source/queue.c **** 			variable of type StaticQueue_t or StaticSemaphore_t equals the size of
 329:Source/queue.c **** 			the real queue and semaphore structures. */
 330:Source/queue.c **** 			volatile size_t xSize = sizeof( StaticQueue_t );
 331:Source/queue.c **** 			configASSERT( xSize == sizeof( Queue_t ) );
 332:Source/queue.c **** 			( void ) xSize; /* Keeps lint quiet when configASSERT() is not defined. */
 333:Source/queue.c **** 		}
 334:Source/queue.c **** 		#endif /* configASSERT_DEFINED */
 335:Source/queue.c **** 
 336:Source/queue.c **** 		/* The address of a statically allocated queue was passed in, use it.
 337:Source/queue.c **** 		The address of a statically allocated storage area was also passed in
 338:Source/queue.c **** 		but is already set. */
 339:Source/queue.c **** 		pxNewQueue = ( Queue_t * ) pxStaticQueue; /*lint !e740 !e9087 Unusual cast is ok as the structure
 340:Source/queue.c **** 
 341:Source/queue.c **** 		if( pxNewQueue != NULL )
 342:Source/queue.c **** 		{
 343:Source/queue.c **** 			#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 344:Source/queue.c **** 			{
 345:Source/queue.c **** 				/* Queues can be allocated wither statically or dynamically, so
 346:Source/queue.c **** 				note this queue was allocated statically in case the queue is
 347:Source/queue.c **** 				later deleted. */
 348:Source/queue.c **** 				pxNewQueue->ucStaticallyAllocated = pdTRUE;
 349:Source/queue.c **** 			}
 350:Source/queue.c **** 			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
 351:Source/queue.c **** 
 352:Source/queue.c **** 			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
 353:Source/queue.c **** 		}
 354:Source/queue.c **** 		else
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 10


 355:Source/queue.c **** 		{
 356:Source/queue.c **** 			traceQUEUE_CREATE_FAILED( ucQueueType );
 357:Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
 358:Source/queue.c **** 		}
 359:Source/queue.c **** 
 360:Source/queue.c **** 		return pxNewQueue;
 361:Source/queue.c **** 	}
 362:Source/queue.c **** 
 363:Source/queue.c **** #endif /* configSUPPORT_STATIC_ALLOCATION */
 364:Source/queue.c **** /*-----------------------------------------------------------*/
 365:Source/queue.c **** 
 366:Source/queue.c **** #if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 367:Source/queue.c **** 
 368:Source/queue.c **** 	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, 
 369:Source/queue.c **** 	{
 160              		.loc 1 369 0
 161              		.cfi_startproc
 162              		@ args = 0, pretend = 0, frame = 32
 163              		@ frame_needed = 1, uses_anonymous_args = 0
 164 0000 80B5     		push	{r7, lr}
 165              		.cfi_def_cfa_offset 8
 166              		.cfi_offset 7, -8
 167              		.cfi_offset 14, -4
 168 0002 8AB0     		sub	sp, sp, #40
 169              		.cfi_def_cfa_offset 48
 170 0004 02AF     		add	r7, sp, #8
 171              		.cfi_def_cfa 7, 40
 172 0006 F860     		str	r0, [r7, #12]
 173 0008 B960     		str	r1, [r7, #8]
 174 000a 1346     		mov	r3, r2
 175 000c FB71     		strb	r3, [r7, #7]
 370:Source/queue.c **** 	Queue_t *pxNewQueue;
 371:Source/queue.c **** 	size_t xQueueSizeInBytes;
 372:Source/queue.c **** 	uint8_t *pucQueueStorage;
 373:Source/queue.c **** 
 374:Source/queue.c **** 		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 375:Source/queue.c **** 
 376:Source/queue.c **** 		/* Allocate enough space to hold the maximum number of items that
 377:Source/queue.c **** 		can be in the queue at any time.  It is valid for uxItemSize to be
 378:Source/queue.c **** 		zero in the case the queue is used as a semaphore. */
 379:Source/queue.c **** 		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as th
 176              		.loc 1 379 0
 177 000e FB68     		ldr	r3, [r7, #12]
 178 0010 BA68     		ldr	r2, [r7, #8]
 179 0012 02FB03F3 		mul	r3, r2, r3
 180 0016 FB61     		str	r3, [r7, #28]
 380:Source/queue.c **** 
 381:Source/queue.c **** 		/* Allocate the queue and storage area.  Justification for MISRA
 382:Source/queue.c **** 		deviation as follows:  pvPortMalloc() always ensures returned memory
 383:Source/queue.c **** 		blocks are aligned per the requirements of the MCU stack.  In this case
 384:Source/queue.c **** 		pvPortMalloc() must return a pointer that is guaranteed to meet the
 385:Source/queue.c **** 		alignment requirements of the Queue_t structure - which in this case
 386:Source/queue.c **** 		is an int8_t *.  Therefore, whenever the stack alignment requirements
 387:Source/queue.c **** 		are greater than or equal to the pointer to char requirements the cast
 388:Source/queue.c **** 		is safe.  In other cases alignment requirements are not strict (one or
 389:Source/queue.c **** 		two bytes). */
 390:Source/queue.c **** 		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 11


 181              		.loc 1 390 0
 182 0018 FB69     		ldr	r3, [r7, #28]
 183 001a 4833     		adds	r3, r3, #72
 184 001c 1846     		mov	r0, r3
 185 001e FFF7FEFF 		bl	pvPortMalloc
 186 0022 B861     		str	r0, [r7, #24]
 391:Source/queue.c **** 
 392:Source/queue.c **** 		if( pxNewQueue != NULL )
 187              		.loc 1 392 0
 188 0024 BB69     		ldr	r3, [r7, #24]
 189 0026 002B     		cmp	r3, #0
 190 0028 0DD0     		beq	.L8
 393:Source/queue.c **** 		{
 394:Source/queue.c **** 			/* Jump past the queue structure to find the location of the queue
 395:Source/queue.c **** 			storage area. */
 396:Source/queue.c **** 			pucQueueStorage = ( uint8_t * ) pxNewQueue;
 191              		.loc 1 396 0
 192 002a BB69     		ldr	r3, [r7, #24]
 193 002c 7B61     		str	r3, [r7, #20]
 397:Source/queue.c **** 			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, es
 194              		.loc 1 397 0
 195 002e 7B69     		ldr	r3, [r7, #20]
 196 0030 4833     		adds	r3, r3, #72
 197 0032 7B61     		str	r3, [r7, #20]
 398:Source/queue.c **** 
 399:Source/queue.c **** 			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
 400:Source/queue.c **** 			{
 401:Source/queue.c **** 				/* Queues can be created either statically or dynamically, so
 402:Source/queue.c **** 				note this task was created dynamically in case it is later
 403:Source/queue.c **** 				deleted. */
 404:Source/queue.c **** 				pxNewQueue->ucStaticallyAllocated = pdFALSE;
 405:Source/queue.c **** 			}
 406:Source/queue.c **** 			#endif /* configSUPPORT_STATIC_ALLOCATION */
 407:Source/queue.c **** 
 408:Source/queue.c **** 			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
 198              		.loc 1 408 0
 199 0034 FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 200 0036 BB69     		ldr	r3, [r7, #24]
 201 0038 0093     		str	r3, [sp]
 202 003a 1346     		mov	r3, r2
 203 003c 7A69     		ldr	r2, [r7, #20]
 204 003e B968     		ldr	r1, [r7, #8]
 205 0040 F868     		ldr	r0, [r7, #12]
 206 0042 FFF7FEFF 		bl	prvInitialiseNewQueue
 207              	.L8:
 409:Source/queue.c **** 		}
 410:Source/queue.c **** 		else
 411:Source/queue.c **** 		{
 412:Source/queue.c **** 			traceQUEUE_CREATE_FAILED( ucQueueType );
 413:Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
 414:Source/queue.c **** 		}
 415:Source/queue.c **** 
 416:Source/queue.c **** 		return pxNewQueue;
 208              		.loc 1 416 0
 209 0046 BB69     		ldr	r3, [r7, #24]
 417:Source/queue.c **** 	}
 210              		.loc 1 417 0
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 12


 211 0048 1846     		mov	r0, r3
 212 004a 2037     		adds	r7, r7, #32
 213              		.cfi_def_cfa_offset 8
 214 004c BD46     		mov	sp, r7
 215              		.cfi_def_cfa_register 13
 216              		@ sp needed
 217 004e 80BD     		pop	{r7, pc}
 218              		.cfi_endproc
 219              	.LFE69:
 220              		.size	xQueueGenericCreate, .-xQueueGenericCreate
 221              		.section	.text.prvInitialiseNewQueue,"ax",%progbits
 222              		.align	2
 223              		.thumb
 224              		.thumb_func
 225              		.type	prvInitialiseNewQueue, %function
 226              	prvInitialiseNewQueue:
 227              	.LFB70:
 418:Source/queue.c **** 
 419:Source/queue.c **** #endif /* configSUPPORT_STATIC_ALLOCATION */
 420:Source/queue.c **** /*-----------------------------------------------------------*/
 421:Source/queue.c **** 
 422:Source/queue.c **** static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, u
 423:Source/queue.c **** {
 228              		.loc 1 423 0
 229              		.cfi_startproc
 230              		@ args = 4, pretend = 0, frame = 16
 231              		@ frame_needed = 1, uses_anonymous_args = 0
 232 0000 80B5     		push	{r7, lr}
 233              		.cfi_def_cfa_offset 8
 234              		.cfi_offset 7, -8
 235              		.cfi_offset 14, -4
 236 0002 84B0     		sub	sp, sp, #16
 237              		.cfi_def_cfa_offset 24
 238 0004 00AF     		add	r7, sp, #0
 239              		.cfi_def_cfa_register 7
 240 0006 F860     		str	r0, [r7, #12]
 241 0008 B960     		str	r1, [r7, #8]
 242 000a 7A60     		str	r2, [r7, #4]
 243 000c FB70     		strb	r3, [r7, #3]
 424:Source/queue.c **** 	/* Remove compiler warnings about unused parameters should
 425:Source/queue.c **** 	configUSE_TRACE_FACILITY not be set to 1. */
 426:Source/queue.c **** 	( void ) ucQueueType;
 427:Source/queue.c **** 
 428:Source/queue.c **** 	if( uxItemSize == ( UBaseType_t ) 0 )
 244              		.loc 1 428 0
 245 000e BB68     		ldr	r3, [r7, #8]
 246 0010 002B     		cmp	r3, #0
 247 0012 03D1     		bne	.L11
 429:Source/queue.c **** 	{
 430:Source/queue.c **** 		/* No RAM was allocated for the queue storage area, but PC head cannot
 431:Source/queue.c **** 		be set to NULL because NULL is used as a key to say the queue is used as
 432:Source/queue.c **** 		a mutex.  Therefore just set pcHead to point to the queue as a benign
 433:Source/queue.c **** 		value that is known to be within the memory map. */
 434:Source/queue.c **** 		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 248              		.loc 1 434 0
 249 0014 BB69     		ldr	r3, [r7, #24]
 250 0016 BA69     		ldr	r2, [r7, #24]
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 13


 251 0018 1A60     		str	r2, [r3]
 252 001a 02E0     		b	.L12
 253              	.L11:
 435:Source/queue.c **** 	}
 436:Source/queue.c **** 	else
 437:Source/queue.c **** 	{
 438:Source/queue.c **** 		/* Set the head to the start of the queue storage area. */
 439:Source/queue.c **** 		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 254              		.loc 1 439 0
 255 001c BB69     		ldr	r3, [r7, #24]
 256 001e 7A68     		ldr	r2, [r7, #4]
 257 0020 1A60     		str	r2, [r3]
 258              	.L12:
 440:Source/queue.c **** 	}
 441:Source/queue.c **** 
 442:Source/queue.c **** 	/* Initialise the queue members as described where the queue type is
 443:Source/queue.c **** 	defined. */
 444:Source/queue.c **** 	pxNewQueue->uxLength = uxQueueLength;
 259              		.loc 1 444 0
 260 0022 BB69     		ldr	r3, [r7, #24]
 261 0024 FA68     		ldr	r2, [r7, #12]
 262 0026 DA63     		str	r2, [r3, #60]
 445:Source/queue.c **** 	pxNewQueue->uxItemSize = uxItemSize;
 263              		.loc 1 445 0
 264 0028 BB69     		ldr	r3, [r7, #24]
 265 002a BA68     		ldr	r2, [r7, #8]
 266 002c 1A64     		str	r2, [r3, #64]
 446:Source/queue.c **** 	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 267              		.loc 1 446 0
 268 002e 0121     		movs	r1, #1
 269 0030 B869     		ldr	r0, [r7, #24]
 270 0032 FFF7FEFF 		bl	xQueueGenericReset
 447:Source/queue.c **** 
 448:Source/queue.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 449:Source/queue.c **** 	{
 450:Source/queue.c **** 		pxNewQueue->ucQueueType = ucQueueType;
 451:Source/queue.c **** 	}
 452:Source/queue.c **** 	#endif /* configUSE_TRACE_FACILITY */
 453:Source/queue.c **** 
 454:Source/queue.c **** 	#if( configUSE_QUEUE_SETS == 1 )
 455:Source/queue.c **** 	{
 456:Source/queue.c **** 		pxNewQueue->pxQueueSetContainer = NULL;
 457:Source/queue.c **** 	}
 458:Source/queue.c **** 	#endif /* configUSE_QUEUE_SETS */
 459:Source/queue.c **** 
 460:Source/queue.c **** 	traceQUEUE_CREATE( pxNewQueue );
 461:Source/queue.c **** }
 271              		.loc 1 461 0
 272 0036 00BF     		nop
 273 0038 1037     		adds	r7, r7, #16
 274              		.cfi_def_cfa_offset 8
 275 003a BD46     		mov	sp, r7
 276              		.cfi_def_cfa_register 13
 277              		@ sp needed
 278 003c 80BD     		pop	{r7, pc}
 279              		.cfi_endproc
 280              	.LFE70:
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 14


 281              		.size	prvInitialiseNewQueue, .-prvInitialiseNewQueue
 282 003e 00BF     		.section	.text.prvInitialiseMutex,"ax",%progbits
 283              		.align	2
 284              		.thumb
 285              		.thumb_func
 286              		.type	prvInitialiseMutex, %function
 287              	prvInitialiseMutex:
 288              	.LFB71:
 462:Source/queue.c **** /*-----------------------------------------------------------*/
 463:Source/queue.c **** 
 464:Source/queue.c **** #if( configUSE_MUTEXES == 1 )
 465:Source/queue.c **** 
 466:Source/queue.c **** 	static void prvInitialiseMutex( Queue_t *pxNewQueue )
 467:Source/queue.c **** 	{
 289              		.loc 1 467 0
 290              		.cfi_startproc
 291              		@ args = 0, pretend = 0, frame = 8
 292              		@ frame_needed = 1, uses_anonymous_args = 0
 293 0000 80B5     		push	{r7, lr}
 294              		.cfi_def_cfa_offset 8
 295              		.cfi_offset 7, -8
 296              		.cfi_offset 14, -4
 297 0002 82B0     		sub	sp, sp, #8
 298              		.cfi_def_cfa_offset 16
 299 0004 00AF     		add	r7, sp, #0
 300              		.cfi_def_cfa_register 7
 301 0006 7860     		str	r0, [r7, #4]
 468:Source/queue.c **** 		if( pxNewQueue != NULL )
 302              		.loc 1 468 0
 303 0008 7B68     		ldr	r3, [r7, #4]
 304 000a 002B     		cmp	r3, #0
 305 000c 0ED0     		beq	.L15
 469:Source/queue.c **** 		{
 470:Source/queue.c **** 			/* The queue create function will set all the queue structure members
 471:Source/queue.c **** 			correctly for a generic queue, but this function is creating a
 472:Source/queue.c **** 			mutex.  Overwrite those members that need to be set differently -
 473:Source/queue.c **** 			in particular the information required for priority inheritance. */
 474:Source/queue.c **** 			pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
 306              		.loc 1 474 0
 307 000e 7B68     		ldr	r3, [r7, #4]
 308 0010 0022     		movs	r2, #0
 309 0012 9A60     		str	r2, [r3, #8]
 475:Source/queue.c **** 			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 310              		.loc 1 475 0
 311 0014 7B68     		ldr	r3, [r7, #4]
 312 0016 0022     		movs	r2, #0
 313 0018 1A60     		str	r2, [r3]
 476:Source/queue.c **** 
 477:Source/queue.c **** 			/* In case this is a recursive mutex. */
 478:Source/queue.c **** 			pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
 314              		.loc 1 478 0
 315 001a 7B68     		ldr	r3, [r7, #4]
 316 001c 0022     		movs	r2, #0
 317 001e DA60     		str	r2, [r3, #12]
 479:Source/queue.c **** 
 480:Source/queue.c **** 			traceCREATE_MUTEX( pxNewQueue );
 481:Source/queue.c **** 
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 15


 482:Source/queue.c **** 			/* Start with the semaphore in the expected state. */
 483:Source/queue.c **** 			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 318              		.loc 1 483 0
 319 0020 0023     		movs	r3, #0
 320 0022 0022     		movs	r2, #0
 321 0024 0021     		movs	r1, #0
 322 0026 7868     		ldr	r0, [r7, #4]
 323 0028 FFF7FEFF 		bl	xQueueGenericSend
 324              	.L15:
 484:Source/queue.c **** 		}
 485:Source/queue.c **** 		else
 486:Source/queue.c **** 		{
 487:Source/queue.c **** 			traceCREATE_MUTEX_FAILED();
 488:Source/queue.c **** 		}
 489:Source/queue.c **** 	}
 325              		.loc 1 489 0
 326 002c 00BF     		nop
 327 002e 0837     		adds	r7, r7, #8
 328              		.cfi_def_cfa_offset 8
 329 0030 BD46     		mov	sp, r7
 330              		.cfi_def_cfa_register 13
 331              		@ sp needed
 332 0032 80BD     		pop	{r7, pc}
 333              		.cfi_endproc
 334              	.LFE71:
 335              		.size	prvInitialiseMutex, .-prvInitialiseMutex
 336              		.section	.text.xQueueCreateMutex,"ax",%progbits
 337              		.align	2
 338              		.global	xQueueCreateMutex
 339              		.thumb
 340              		.thumb_func
 341              		.type	xQueueCreateMutex, %function
 342              	xQueueCreateMutex:
 343              	.LFB72:
 490:Source/queue.c **** 
 491:Source/queue.c **** #endif /* configUSE_MUTEXES */
 492:Source/queue.c **** /*-----------------------------------------------------------*/
 493:Source/queue.c **** 
 494:Source/queue.c **** #if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 495:Source/queue.c **** 
 496:Source/queue.c **** 	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
 497:Source/queue.c **** 	{
 344              		.loc 1 497 0
 345              		.cfi_startproc
 346              		@ args = 0, pretend = 0, frame = 24
 347              		@ frame_needed = 1, uses_anonymous_args = 0
 348 0000 80B5     		push	{r7, lr}
 349              		.cfi_def_cfa_offset 8
 350              		.cfi_offset 7, -8
 351              		.cfi_offset 14, -4
 352 0002 86B0     		sub	sp, sp, #24
 353              		.cfi_def_cfa_offset 32
 354 0004 00AF     		add	r7, sp, #0
 355              		.cfi_def_cfa_register 7
 356 0006 0346     		mov	r3, r0
 357 0008 FB71     		strb	r3, [r7, #7]
 498:Source/queue.c **** 	QueueHandle_t xNewQueue;
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 16


 499:Source/queue.c **** 	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
 358              		.loc 1 499 0
 359 000a 0123     		movs	r3, #1
 360 000c 7B61     		str	r3, [r7, #20]
 361 000e 0023     		movs	r3, #0
 362 0010 3B61     		str	r3, [r7, #16]
 500:Source/queue.c **** 
 501:Source/queue.c **** 		xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
 363              		.loc 1 501 0
 364 0012 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 365 0014 1A46     		mov	r2, r3
 366 0016 3969     		ldr	r1, [r7, #16]
 367 0018 7869     		ldr	r0, [r7, #20]
 368 001a FFF7FEFF 		bl	xQueueGenericCreate
 369 001e F860     		str	r0, [r7, #12]
 502:Source/queue.c **** 		prvInitialiseMutex( ( Queue_t * ) xNewQueue );
 370              		.loc 1 502 0
 371 0020 F868     		ldr	r0, [r7, #12]
 372 0022 FFF7FEFF 		bl	prvInitialiseMutex
 503:Source/queue.c **** 
 504:Source/queue.c **** 		return xNewQueue;
 373              		.loc 1 504 0
 374 0026 FB68     		ldr	r3, [r7, #12]
 505:Source/queue.c **** 	}
 375              		.loc 1 505 0
 376 0028 1846     		mov	r0, r3
 377 002a 1837     		adds	r7, r7, #24
 378              		.cfi_def_cfa_offset 8
 379 002c BD46     		mov	sp, r7
 380              		.cfi_def_cfa_register 13
 381              		@ sp needed
 382 002e 80BD     		pop	{r7, pc}
 383              		.cfi_endproc
 384              	.LFE72:
 385              		.size	xQueueCreateMutex, .-xQueueCreateMutex
 386              		.section	.text.xQueueGiveMutexRecursive,"ax",%progbits
 387              		.align	2
 388              		.global	xQueueGiveMutexRecursive
 389              		.thumb
 390              		.thumb_func
 391              		.type	xQueueGiveMutexRecursive, %function
 392              	xQueueGiveMutexRecursive:
 393              	.LFB73:
 506:Source/queue.c **** 
 507:Source/queue.c **** #endif /* configUSE_MUTEXES */
 508:Source/queue.c **** /*-----------------------------------------------------------*/
 509:Source/queue.c **** 
 510:Source/queue.c **** #if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
 511:Source/queue.c **** 
 512:Source/queue.c **** 	QueueHandle_t xQueueCreateMutexStatic( const uint8_t ucQueueType, StaticQueue_t *pxStaticQueue )
 513:Source/queue.c **** 	{
 514:Source/queue.c **** 	QueueHandle_t xNewQueue;
 515:Source/queue.c **** 	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
 516:Source/queue.c **** 
 517:Source/queue.c **** 		/* Prevent compiler warnings about unused parameters if
 518:Source/queue.c **** 		configUSE_TRACE_FACILITY does not equal 1. */
 519:Source/queue.c **** 		( void ) ucQueueType;
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 17


 520:Source/queue.c **** 
 521:Source/queue.c **** 		xNewQueue = xQueueGenericCreateStatic( uxMutexLength, uxMutexSize, NULL, pxStaticQueue, ucQueueTy
 522:Source/queue.c **** 		prvInitialiseMutex( ( Queue_t * ) xNewQueue );
 523:Source/queue.c **** 
 524:Source/queue.c **** 		return xNewQueue;
 525:Source/queue.c **** 	}
 526:Source/queue.c **** 
 527:Source/queue.c **** #endif /* configUSE_MUTEXES */
 528:Source/queue.c **** /*-----------------------------------------------------------*/
 529:Source/queue.c **** 
 530:Source/queue.c **** #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
 531:Source/queue.c **** 
 532:Source/queue.c **** 	TaskHandle_t xQueueGetMutexHolder( QueueHandle_t xSemaphore )
 533:Source/queue.c **** 	{
 534:Source/queue.c **** 	TaskHandle_t pxReturn;
 535:Source/queue.c **** 	Queue_t * const pxSemaphore = ( Queue_t * ) xSemaphore;
 536:Source/queue.c **** 
 537:Source/queue.c **** 		/* This function is called by xSemaphoreGetMutexHolder(), and should not
 538:Source/queue.c **** 		be called directly.  Note:  This is a good way of determining if the
 539:Source/queue.c **** 		calling task is the mutex holder, but not a good way of determining the
 540:Source/queue.c **** 		identity of the mutex holder, as the holder may change between the
 541:Source/queue.c **** 		following critical section exiting and the function returning. */
 542:Source/queue.c **** 		taskENTER_CRITICAL();
 543:Source/queue.c **** 		{
 544:Source/queue.c **** 			if( pxSemaphore->uxQueueType == queueQUEUE_IS_MUTEX )
 545:Source/queue.c **** 			{
 546:Source/queue.c **** 				pxReturn = pxSemaphore->u.xSemaphore.xMutexHolder;
 547:Source/queue.c **** 			}
 548:Source/queue.c **** 			else
 549:Source/queue.c **** 			{
 550:Source/queue.c **** 				pxReturn = NULL;
 551:Source/queue.c **** 			}
 552:Source/queue.c **** 		}
 553:Source/queue.c **** 		taskEXIT_CRITICAL();
 554:Source/queue.c **** 
 555:Source/queue.c **** 		return pxReturn;
 556:Source/queue.c **** 	} /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
 557:Source/queue.c **** 
 558:Source/queue.c **** #endif
 559:Source/queue.c **** /*-----------------------------------------------------------*/
 560:Source/queue.c **** 
 561:Source/queue.c **** #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
 562:Source/queue.c **** 
 563:Source/queue.c **** 	TaskHandle_t xQueueGetMutexHolderFromISR( QueueHandle_t xSemaphore )
 564:Source/queue.c **** 	{
 565:Source/queue.c **** 	TaskHandle_t pxReturn;
 566:Source/queue.c **** 
 567:Source/queue.c **** 		configASSERT( xSemaphore );
 568:Source/queue.c **** 
 569:Source/queue.c **** 		/* Mutexes cannot be used in interrupt service routines, so the mutex
 570:Source/queue.c **** 		holder should not change in an ISR, and therefore a critical section is
 571:Source/queue.c **** 		not required here. */
 572:Source/queue.c **** 		if( ( ( Queue_t * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
 573:Source/queue.c **** 		{
 574:Source/queue.c **** 			pxReturn = ( ( Queue_t * ) xSemaphore )->u.xSemaphore.xMutexHolder;
 575:Source/queue.c **** 		}
 576:Source/queue.c **** 		else
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 18


 577:Source/queue.c **** 		{
 578:Source/queue.c **** 			pxReturn = NULL;
 579:Source/queue.c **** 		}
 580:Source/queue.c **** 
 581:Source/queue.c **** 		return pxReturn;
 582:Source/queue.c **** 	} /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
 583:Source/queue.c **** 
 584:Source/queue.c **** #endif
 585:Source/queue.c **** /*-----------------------------------------------------------*/
 586:Source/queue.c **** 
 587:Source/queue.c **** #if ( configUSE_RECURSIVE_MUTEXES == 1 )
 588:Source/queue.c **** 
 589:Source/queue.c **** 	BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
 590:Source/queue.c **** 	{
 394              		.loc 1 590 0
 395              		.cfi_startproc
 396              		@ args = 0, pretend = 0, frame = 16
 397              		@ frame_needed = 1, uses_anonymous_args = 0
 398 0000 90B5     		push	{r4, r7, lr}
 399              		.cfi_def_cfa_offset 12
 400              		.cfi_offset 4, -12
 401              		.cfi_offset 7, -8
 402              		.cfi_offset 14, -4
 403 0002 85B0     		sub	sp, sp, #20
 404              		.cfi_def_cfa_offset 32
 405 0004 00AF     		add	r7, sp, #0
 406              		.cfi_def_cfa_register 7
 407 0006 7860     		str	r0, [r7, #4]
 591:Source/queue.c **** 	BaseType_t xReturn;
 592:Source/queue.c **** 	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 408              		.loc 1 592 0
 409 0008 7B68     		ldr	r3, [r7, #4]
 410 000a BB60     		str	r3, [r7, #8]
 593:Source/queue.c **** 
 594:Source/queue.c **** 		configASSERT( pxMutex );
 595:Source/queue.c **** 
 596:Source/queue.c **** 		/* If this is the task that holds the mutex then xMutexHolder will not
 597:Source/queue.c **** 		change outside of this task.  If this task does not hold the mutex then
 598:Source/queue.c **** 		pxMutexHolder can never coincidentally equal the tasks handle, and as
 599:Source/queue.c **** 		this is the only condition we are interested in it does not matter if
 600:Source/queue.c **** 		pxMutexHolder is accessed simultaneously by another task.  Therefore no
 601:Source/queue.c **** 		mutual exclusion is required to test the pxMutexHolder variable. */
 602:Source/queue.c **** 		if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
 411              		.loc 1 602 0
 412 000c BB68     		ldr	r3, [r7, #8]
 413 000e 9C68     		ldr	r4, [r3, #8]
 414 0010 FFF7FEFF 		bl	xTaskGetCurrentTaskHandle
 415 0014 0346     		mov	r3, r0
 416 0016 9C42     		cmp	r4, r3
 417 0018 11D1     		bne	.L19
 603:Source/queue.c **** 		{
 604:Source/queue.c **** 			traceGIVE_MUTEX_RECURSIVE( pxMutex );
 605:Source/queue.c **** 
 606:Source/queue.c **** 			/* uxRecursiveCallCount cannot be zero if xMutexHolder is equal to
 607:Source/queue.c **** 			the task handle, therefore no underflow check is required.  Also,
 608:Source/queue.c **** 			uxRecursiveCallCount is only modified by the mutex holder, and as
 609:Source/queue.c **** 			there can only be one, no mutual exclusion is required to modify the
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 19


 610:Source/queue.c **** 			uxRecursiveCallCount member. */
 611:Source/queue.c **** 			( pxMutex->u.xSemaphore.uxRecursiveCallCount )--;
 418              		.loc 1 611 0
 419 001a BB68     		ldr	r3, [r7, #8]
 420 001c DB68     		ldr	r3, [r3, #12]
 421 001e 5A1E     		subs	r2, r3, #1
 422 0020 BB68     		ldr	r3, [r7, #8]
 423 0022 DA60     		str	r2, [r3, #12]
 612:Source/queue.c **** 
 613:Source/queue.c **** 			/* Has the recursive call count unwound to 0? */
 614:Source/queue.c **** 			if( pxMutex->u.xSemaphore.uxRecursiveCallCount == ( UBaseType_t ) 0 )
 424              		.loc 1 614 0
 425 0024 BB68     		ldr	r3, [r7, #8]
 426 0026 DB68     		ldr	r3, [r3, #12]
 427 0028 002B     		cmp	r3, #0
 428 002a 05D1     		bne	.L20
 615:Source/queue.c **** 			{
 616:Source/queue.c **** 				/* Return the mutex.  This will automatically unblock any other
 617:Source/queue.c **** 				task that might be waiting to access the mutex. */
 618:Source/queue.c **** 				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
 429              		.loc 1 618 0
 430 002c 0023     		movs	r3, #0
 431 002e 0022     		movs	r2, #0
 432 0030 0021     		movs	r1, #0
 433 0032 B868     		ldr	r0, [r7, #8]
 434 0034 FFF7FEFF 		bl	xQueueGenericSend
 435              	.L20:
 619:Source/queue.c **** 			}
 620:Source/queue.c **** 			else
 621:Source/queue.c **** 			{
 622:Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
 623:Source/queue.c **** 			}
 624:Source/queue.c **** 
 625:Source/queue.c **** 			xReturn = pdPASS;
 436              		.loc 1 625 0
 437 0038 0123     		movs	r3, #1
 438 003a FB60     		str	r3, [r7, #12]
 439 003c 01E0     		b	.L21
 440              	.L19:
 626:Source/queue.c **** 		}
 627:Source/queue.c **** 		else
 628:Source/queue.c **** 		{
 629:Source/queue.c **** 			/* The mutex cannot be given because the calling task is not the
 630:Source/queue.c **** 			holder. */
 631:Source/queue.c **** 			xReturn = pdFAIL;
 441              		.loc 1 631 0
 442 003e 0023     		movs	r3, #0
 443 0040 FB60     		str	r3, [r7, #12]
 444              	.L21:
 632:Source/queue.c **** 
 633:Source/queue.c **** 			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
 634:Source/queue.c **** 		}
 635:Source/queue.c **** 
 636:Source/queue.c **** 		return xReturn;
 445              		.loc 1 636 0
 446 0042 FB68     		ldr	r3, [r7, #12]
 637:Source/queue.c **** 	}
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 20


 447              		.loc 1 637 0
 448 0044 1846     		mov	r0, r3
 449 0046 1437     		adds	r7, r7, #20
 450              		.cfi_def_cfa_offset 12
 451 0048 BD46     		mov	sp, r7
 452              		.cfi_def_cfa_register 13
 453              		@ sp needed
 454 004a 90BD     		pop	{r4, r7, pc}
 455              		.cfi_endproc
 456              	.LFE73:
 457              		.size	xQueueGiveMutexRecursive, .-xQueueGiveMutexRecursive
 458              		.section	.text.xQueueTakeMutexRecursive,"ax",%progbits
 459              		.align	2
 460              		.global	xQueueTakeMutexRecursive
 461              		.thumb
 462              		.thumb_func
 463              		.type	xQueueTakeMutexRecursive, %function
 464              	xQueueTakeMutexRecursive:
 465              	.LFB74:
 638:Source/queue.c **** 
 639:Source/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 640:Source/queue.c **** /*-----------------------------------------------------------*/
 641:Source/queue.c **** 
 642:Source/queue.c **** #if ( configUSE_RECURSIVE_MUTEXES == 1 )
 643:Source/queue.c **** 
 644:Source/queue.c **** 	BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )
 645:Source/queue.c **** 	{
 466              		.loc 1 645 0
 467              		.cfi_startproc
 468              		@ args = 0, pretend = 0, frame = 16
 469              		@ frame_needed = 1, uses_anonymous_args = 0
 470 0000 90B5     		push	{r4, r7, lr}
 471              		.cfi_def_cfa_offset 12
 472              		.cfi_offset 4, -12
 473              		.cfi_offset 7, -8
 474              		.cfi_offset 14, -4
 475 0002 85B0     		sub	sp, sp, #20
 476              		.cfi_def_cfa_offset 32
 477 0004 00AF     		add	r7, sp, #0
 478              		.cfi_def_cfa_register 7
 479 0006 7860     		str	r0, [r7, #4]
 480 0008 3960     		str	r1, [r7]
 646:Source/queue.c **** 	BaseType_t xReturn;
 647:Source/queue.c **** 	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 481              		.loc 1 647 0
 482 000a 7B68     		ldr	r3, [r7, #4]
 483 000c BB60     		str	r3, [r7, #8]
 648:Source/queue.c **** 
 649:Source/queue.c **** 		configASSERT( pxMutex );
 650:Source/queue.c **** 
 651:Source/queue.c **** 		/* Comments regarding mutual exclusion as per those within
 652:Source/queue.c **** 		xQueueGiveMutexRecursive(). */
 653:Source/queue.c **** 
 654:Source/queue.c **** 		traceTAKE_MUTEX_RECURSIVE( pxMutex );
 655:Source/queue.c **** 
 656:Source/queue.c **** 		if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
 484              		.loc 1 656 0
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 21


 485 000e BB68     		ldr	r3, [r7, #8]
 486 0010 9C68     		ldr	r4, [r3, #8]
 487 0012 FFF7FEFF 		bl	xTaskGetCurrentTaskHandle
 488 0016 0346     		mov	r3, r0
 489 0018 9C42     		cmp	r4, r3
 490 001a 07D1     		bne	.L24
 657:Source/queue.c **** 		{
 658:Source/queue.c **** 			( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
 491              		.loc 1 658 0
 492 001c BB68     		ldr	r3, [r7, #8]
 493 001e DB68     		ldr	r3, [r3, #12]
 494 0020 5A1C     		adds	r2, r3, #1
 495 0022 BB68     		ldr	r3, [r7, #8]
 496 0024 DA60     		str	r2, [r3, #12]
 659:Source/queue.c **** 			xReturn = pdPASS;
 497              		.loc 1 659 0
 498 0026 0123     		movs	r3, #1
 499 0028 FB60     		str	r3, [r7, #12]
 500 002a 0CE0     		b	.L25
 501              	.L24:
 660:Source/queue.c **** 		}
 661:Source/queue.c **** 		else
 662:Source/queue.c **** 		{
 663:Source/queue.c **** 			xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
 502              		.loc 1 663 0
 503 002c 3968     		ldr	r1, [r7]
 504 002e B868     		ldr	r0, [r7, #8]
 505 0030 FFF7FEFF 		bl	xQueueSemaphoreTake
 506 0034 F860     		str	r0, [r7, #12]
 664:Source/queue.c **** 
 665:Source/queue.c **** 			/* pdPASS will only be returned if the mutex was successfully
 666:Source/queue.c **** 			obtained.  The calling task may have entered the Blocked state
 667:Source/queue.c **** 			before reaching here. */
 668:Source/queue.c **** 			if( xReturn != pdFAIL )
 507              		.loc 1 668 0
 508 0036 FB68     		ldr	r3, [r7, #12]
 509 0038 002B     		cmp	r3, #0
 510 003a 04D0     		beq	.L25
 669:Source/queue.c **** 			{
 670:Source/queue.c **** 				( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
 511              		.loc 1 670 0
 512 003c BB68     		ldr	r3, [r7, #8]
 513 003e DB68     		ldr	r3, [r3, #12]
 514 0040 5A1C     		adds	r2, r3, #1
 515 0042 BB68     		ldr	r3, [r7, #8]
 516 0044 DA60     		str	r2, [r3, #12]
 517              	.L25:
 671:Source/queue.c **** 			}
 672:Source/queue.c **** 			else
 673:Source/queue.c **** 			{
 674:Source/queue.c **** 				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
 675:Source/queue.c **** 			}
 676:Source/queue.c **** 		}
 677:Source/queue.c **** 
 678:Source/queue.c **** 		return xReturn;
 518              		.loc 1 678 0
 519 0046 FB68     		ldr	r3, [r7, #12]
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 22


 679:Source/queue.c **** 	}
 520              		.loc 1 679 0
 521 0048 1846     		mov	r0, r3
 522 004a 1437     		adds	r7, r7, #20
 523              		.cfi_def_cfa_offset 12
 524 004c BD46     		mov	sp, r7
 525              		.cfi_def_cfa_register 13
 526              		@ sp needed
 527 004e 90BD     		pop	{r4, r7, pc}
 528              		.cfi_endproc
 529              	.LFE74:
 530              		.size	xQueueTakeMutexRecursive, .-xQueueTakeMutexRecursive
 531              		.section	.text.xQueueCreateCountingSemaphore,"ax",%progbits
 532              		.align	2
 533              		.global	xQueueCreateCountingSemaphore
 534              		.thumb
 535              		.thumb_func
 536              		.type	xQueueCreateCountingSemaphore, %function
 537              	xQueueCreateCountingSemaphore:
 538              	.LFB75:
 680:Source/queue.c **** 
 681:Source/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 682:Source/queue.c **** /*-----------------------------------------------------------*/
 683:Source/queue.c **** 
 684:Source/queue.c **** #if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
 685:Source/queue.c **** 
 686:Source/queue.c **** 	QueueHandle_t xQueueCreateCountingSemaphoreStatic( const UBaseType_t uxMaxCount, const UBaseType_t
 687:Source/queue.c **** 	{
 688:Source/queue.c **** 	QueueHandle_t xHandle;
 689:Source/queue.c **** 
 690:Source/queue.c **** 		configASSERT( uxMaxCount != 0 );
 691:Source/queue.c **** 		configASSERT( uxInitialCount <= uxMaxCount );
 692:Source/queue.c **** 
 693:Source/queue.c **** 		xHandle = xQueueGenericCreateStatic( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, NULL, pxStatic
 694:Source/queue.c **** 
 695:Source/queue.c **** 		if( xHandle != NULL )
 696:Source/queue.c **** 		{
 697:Source/queue.c **** 			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 698:Source/queue.c **** 
 699:Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE();
 700:Source/queue.c **** 		}
 701:Source/queue.c **** 		else
 702:Source/queue.c **** 		{
 703:Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE_FAILED();
 704:Source/queue.c **** 		}
 705:Source/queue.c **** 
 706:Source/queue.c **** 		return xHandle;
 707:Source/queue.c **** 	}
 708:Source/queue.c **** 
 709:Source/queue.c **** #endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) *
 710:Source/queue.c **** /*-----------------------------------------------------------*/
 711:Source/queue.c **** 
 712:Source/queue.c **** #if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 713:Source/queue.c **** 
 714:Source/queue.c **** 	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxIni
 715:Source/queue.c **** 	{
 539              		.loc 1 715 0
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 23


 540              		.cfi_startproc
 541              		@ args = 0, pretend = 0, frame = 16
 542              		@ frame_needed = 1, uses_anonymous_args = 0
 543 0000 80B5     		push	{r7, lr}
 544              		.cfi_def_cfa_offset 8
 545              		.cfi_offset 7, -8
 546              		.cfi_offset 14, -4
 547 0002 84B0     		sub	sp, sp, #16
 548              		.cfi_def_cfa_offset 24
 549 0004 00AF     		add	r7, sp, #0
 550              		.cfi_def_cfa_register 7
 551 0006 7860     		str	r0, [r7, #4]
 552 0008 3960     		str	r1, [r7]
 716:Source/queue.c **** 	QueueHandle_t xHandle;
 717:Source/queue.c **** 
 718:Source/queue.c **** 		configASSERT( uxMaxCount != 0 );
 719:Source/queue.c **** 		configASSERT( uxInitialCount <= uxMaxCount );
 720:Source/queue.c **** 
 721:Source/queue.c **** 		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUN
 553              		.loc 1 721 0
 554 000a 0222     		movs	r2, #2
 555 000c 0021     		movs	r1, #0
 556 000e 7868     		ldr	r0, [r7, #4]
 557 0010 FFF7FEFF 		bl	xQueueGenericCreate
 558 0014 F860     		str	r0, [r7, #12]
 722:Source/queue.c **** 
 723:Source/queue.c **** 		if( xHandle != NULL )
 559              		.loc 1 723 0
 560 0016 FB68     		ldr	r3, [r7, #12]
 561 0018 002B     		cmp	r3, #0
 562 001a 02D0     		beq	.L28
 724:Source/queue.c **** 		{
 725:Source/queue.c **** 			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 563              		.loc 1 725 0
 564 001c FB68     		ldr	r3, [r7, #12]
 565 001e 3A68     		ldr	r2, [r7]
 566 0020 9A63     		str	r2, [r3, #56]
 567              	.L28:
 726:Source/queue.c **** 
 727:Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE();
 728:Source/queue.c **** 		}
 729:Source/queue.c **** 		else
 730:Source/queue.c **** 		{
 731:Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE_FAILED();
 732:Source/queue.c **** 		}
 733:Source/queue.c **** 
 734:Source/queue.c **** 		return xHandle;
 568              		.loc 1 734 0
 569 0022 FB68     		ldr	r3, [r7, #12]
 735:Source/queue.c **** 	}
 570              		.loc 1 735 0
 571 0024 1846     		mov	r0, r3
 572 0026 1037     		adds	r7, r7, #16
 573              		.cfi_def_cfa_offset 8
 574 0028 BD46     		mov	sp, r7
 575              		.cfi_def_cfa_register 13
 576              		@ sp needed
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 24


 577 002a 80BD     		pop	{r7, pc}
 578              		.cfi_endproc
 579              	.LFE75:
 580              		.size	xQueueCreateCountingSemaphore, .-xQueueCreateCountingSemaphore
 581              		.section	.text.xQueueGenericSend,"ax",%progbits
 582              		.align	2
 583              		.global	xQueueGenericSend
 584              		.thumb
 585              		.thumb_func
 586              		.type	xQueueGenericSend, %function
 587              	xQueueGenericSend:
 588              	.LFB76:
 736:Source/queue.c **** 
 737:Source/queue.c **** #endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) *
 738:Source/queue.c **** /*-----------------------------------------------------------*/
 739:Source/queue.c **** 
 740:Source/queue.c **** BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xT
 741:Source/queue.c **** {
 589              		.loc 1 741 0
 590              		.cfi_startproc
 591              		@ args = 0, pretend = 0, frame = 40
 592              		@ frame_needed = 1, uses_anonymous_args = 0
 593 0000 80B5     		push	{r7, lr}
 594              		.cfi_def_cfa_offset 8
 595              		.cfi_offset 7, -8
 596              		.cfi_offset 14, -4
 597 0002 8AB0     		sub	sp, sp, #40
 598              		.cfi_def_cfa_offset 48
 599 0004 00AF     		add	r7, sp, #0
 600              		.cfi_def_cfa_register 7
 601 0006 F860     		str	r0, [r7, #12]
 602 0008 B960     		str	r1, [r7, #8]
 603 000a 7A60     		str	r2, [r7, #4]
 604 000c 3B60     		str	r3, [r7]
 742:Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 605              		.loc 1 742 0
 606 000e 0023     		movs	r3, #0
 607 0010 7B62     		str	r3, [r7, #36]
 743:Source/queue.c **** TimeOut_t xTimeOut;
 744:Source/queue.c **** Queue_t * const pxQueue = xQueue;
 608              		.loc 1 744 0
 609 0012 FB68     		ldr	r3, [r7, #12]
 610 0014 3B62     		str	r3, [r7, #32]
 611              	.L45:
 745:Source/queue.c **** 
 746:Source/queue.c **** 	configASSERT( pxQueue );
 747:Source/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 748:Source/queue.c **** 	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 749:Source/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
 750:Source/queue.c **** 	{
 751:Source/queue.c **** 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 )
 752:Source/queue.c **** 	}
 753:Source/queue.c **** 	#endif
 754:Source/queue.c **** 
 755:Source/queue.c **** 
 756:Source/queue.c **** 	/*lint -save -e904 This function relaxes the coding standard somewhat to
 757:Source/queue.c **** 	allow return statements within the function itself.  This is done in the
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 25


 758:Source/queue.c **** 	interest of execution time efficiency. */
 759:Source/queue.c **** 	for( ;; )
 760:Source/queue.c **** 	{
 761:Source/queue.c **** 		taskENTER_CRITICAL();
 612              		.loc 1 761 0
 613 0016 FFF7FEFF 		bl	vPortEnterCritical
 762:Source/queue.c **** 		{
 763:Source/queue.c **** 			/* Is there room on the queue now?  The running task must be the
 764:Source/queue.c **** 			highest priority task wanting to access the queue.  If the head item
 765:Source/queue.c **** 			in the queue is to be overwritten then it does not matter if the
 766:Source/queue.c **** 			queue is full. */
 767:Source/queue.c **** 			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 614              		.loc 1 767 0
 615 001a 3B6A     		ldr	r3, [r7, #32]
 616 001c 9A6B     		ldr	r2, [r3, #56]
 617 001e 3B6A     		ldr	r3, [r7, #32]
 618 0020 DB6B     		ldr	r3, [r3, #60]
 619 0022 9A42     		cmp	r2, r3
 620 0024 02D3     		bcc	.L31
 621              		.loc 1 767 0 is_stmt 0 discriminator 1
 622 0026 3B68     		ldr	r3, [r7]
 623 0028 022B     		cmp	r3, #2
 624 002a 29D1     		bne	.L32
 625              	.L31:
 768:Source/queue.c **** 			{
 769:Source/queue.c **** 				traceQUEUE_SEND( pxQueue );
 770:Source/queue.c **** 
 771:Source/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
 772:Source/queue.c **** 				{
 773:Source/queue.c **** 				const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
 774:Source/queue.c **** 
 775:Source/queue.c **** 					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 776:Source/queue.c **** 
 777:Source/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
 778:Source/queue.c **** 					{
 779:Source/queue.c **** 						if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting != ( UBaseType_t ) 0 )
 780:Source/queue.c **** 						{
 781:Source/queue.c **** 							/* Do not notify the queue set as an existing item
 782:Source/queue.c **** 							was overwritten in the queue so the number of items
 783:Source/queue.c **** 							in the queue has not changed. */
 784:Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 785:Source/queue.c **** 						}
 786:Source/queue.c **** 						else if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
 787:Source/queue.c **** 						{
 788:Source/queue.c **** 							/* The queue is a member of a queue set, and posting
 789:Source/queue.c **** 							to the queue set caused a higher priority task to
 790:Source/queue.c **** 							unblock. A context switch is required. */
 791:Source/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 792:Source/queue.c **** 						}
 793:Source/queue.c **** 						else
 794:Source/queue.c **** 						{
 795:Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 796:Source/queue.c **** 						}
 797:Source/queue.c **** 					}
 798:Source/queue.c **** 					else
 799:Source/queue.c **** 					{
 800:Source/queue.c **** 						/* If there was a task waiting for data to arrive on the
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 26


 801:Source/queue.c **** 						queue then unblock it now. */
 802:Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 803:Source/queue.c **** 						{
 804:Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 805:Source/queue.c **** 							{
 806:Source/queue.c **** 								/* The unblocked task has a priority higher than
 807:Source/queue.c **** 								our own so yield immediately.  Yes it is ok to
 808:Source/queue.c **** 								do this from within the critical section - the
 809:Source/queue.c **** 								kernel takes care of that. */
 810:Source/queue.c **** 								queueYIELD_IF_USING_PREEMPTION();
 811:Source/queue.c **** 							}
 812:Source/queue.c **** 							else
 813:Source/queue.c **** 							{
 814:Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
 815:Source/queue.c **** 							}
 816:Source/queue.c **** 						}
 817:Source/queue.c **** 						else if( xYieldRequired != pdFALSE )
 818:Source/queue.c **** 						{
 819:Source/queue.c **** 							/* This path is a special case that will only get
 820:Source/queue.c **** 							executed if the task was holding multiple mutexes
 821:Source/queue.c **** 							and the mutexes were given back in an order that is
 822:Source/queue.c **** 							different to that in which they were taken. */
 823:Source/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 824:Source/queue.c **** 						}
 825:Source/queue.c **** 						else
 826:Source/queue.c **** 						{
 827:Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 828:Source/queue.c **** 						}
 829:Source/queue.c **** 					}
 830:Source/queue.c **** 				}
 831:Source/queue.c **** 				#else /* configUSE_QUEUE_SETS */
 832:Source/queue.c **** 				{
 833:Source/queue.c **** 					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 626              		.loc 1 833 0 is_stmt 1
 627 002c 3A68     		ldr	r2, [r7]
 628 002e B968     		ldr	r1, [r7, #8]
 629 0030 386A     		ldr	r0, [r7, #32]
 630 0032 FFF7FEFF 		bl	prvCopyDataToQueue
 631 0036 F861     		str	r0, [r7, #28]
 834:Source/queue.c **** 
 835:Source/queue.c **** 					/* If there was a task waiting for data to arrive on the
 836:Source/queue.c **** 					queue then unblock it now. */
 837:Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 632              		.loc 1 837 0
 633 0038 3B6A     		ldr	r3, [r7, #32]
 634 003a 5B6A     		ldr	r3, [r3, #36]
 635 003c 002B     		cmp	r3, #0
 636 003e 10D0     		beq	.L33
 838:Source/queue.c **** 					{
 839:Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 637              		.loc 1 839 0
 638 0040 3B6A     		ldr	r3, [r7, #32]
 639 0042 2433     		adds	r3, r3, #36
 640 0044 1846     		mov	r0, r3
 641 0046 FFF7FEFF 		bl	xTaskRemoveFromEventList
 642 004a 0346     		mov	r3, r0
 643 004c 002B     		cmp	r3, #0
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 27


 644 004e 13D0     		beq	.L34
 840:Source/queue.c **** 						{
 841:Source/queue.c **** 							/* The unblocked task has a priority higher than
 842:Source/queue.c **** 							our own so yield immediately.  Yes it is ok to do
 843:Source/queue.c **** 							this from within the critical section - the kernel
 844:Source/queue.c **** 							takes care of that. */
 845:Source/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 645              		.loc 1 845 0
 646 0050 3F4B     		ldr	r3, .L47
 647 0052 4FF08052 		mov	r2, #268435456
 648 0056 1A60     		str	r2, [r3]
 649              		.syntax unified
 650              	@ 845 "Source\queue.c" 1
 651 0058 BFF34F8F 		dsb
 652              	@ 0 "" 2
 653              	@ 845 "Source\queue.c" 1
 654 005c BFF36F8F 		isb
 655              	@ 0 "" 2
 656              		.thumb
 657              		.syntax unified
 658 0060 0AE0     		b	.L34
 659              	.L33:
 846:Source/queue.c **** 						}
 847:Source/queue.c **** 						else
 848:Source/queue.c **** 						{
 849:Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 850:Source/queue.c **** 						}
 851:Source/queue.c **** 					}
 852:Source/queue.c **** 					else if( xYieldRequired != pdFALSE )
 660              		.loc 1 852 0
 661 0062 FB69     		ldr	r3, [r7, #28]
 662 0064 002B     		cmp	r3, #0
 663 0066 07D0     		beq	.L34
 853:Source/queue.c **** 					{
 854:Source/queue.c **** 						/* This path is a special case that will only get
 855:Source/queue.c **** 						executed if the task was holding multiple mutexes and
 856:Source/queue.c **** 						the mutexes were given back in an order that is
 857:Source/queue.c **** 						different to that in which they were taken. */
 858:Source/queue.c **** 						queueYIELD_IF_USING_PREEMPTION();
 664              		.loc 1 858 0
 665 0068 394B     		ldr	r3, .L47
 666 006a 4FF08052 		mov	r2, #268435456
 667 006e 1A60     		str	r2, [r3]
 668              		.syntax unified
 669              	@ 858 "Source\queue.c" 1
 670 0070 BFF34F8F 		dsb
 671              	@ 0 "" 2
 672              	@ 858 "Source\queue.c" 1
 673 0074 BFF36F8F 		isb
 674              	@ 0 "" 2
 675              		.thumb
 676              		.syntax unified
 677              	.L34:
 859:Source/queue.c **** 					}
 860:Source/queue.c **** 					else
 861:Source/queue.c **** 					{
 862:Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 28


 863:Source/queue.c **** 					}
 864:Source/queue.c **** 				}
 865:Source/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
 866:Source/queue.c **** 
 867:Source/queue.c **** 				taskEXIT_CRITICAL();
 678              		.loc 1 867 0
 679 0078 FFF7FEFF 		bl	vPortExitCritical
 868:Source/queue.c **** 				return pdPASS;
 680              		.loc 1 868 0
 681 007c 0123     		movs	r3, #1
 682 007e 63E0     		b	.L46
 683              	.L32:
 869:Source/queue.c **** 			}
 870:Source/queue.c **** 			else
 871:Source/queue.c **** 			{
 872:Source/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
 684              		.loc 1 872 0
 685 0080 7B68     		ldr	r3, [r7, #4]
 686 0082 002B     		cmp	r3, #0
 687 0084 03D1     		bne	.L36
 873:Source/queue.c **** 				{
 874:Source/queue.c **** 					/* The queue was full and no block time is specified (or
 875:Source/queue.c **** 					the block time has expired) so leave now. */
 876:Source/queue.c **** 					taskEXIT_CRITICAL();
 688              		.loc 1 876 0
 689 0086 FFF7FEFF 		bl	vPortExitCritical
 877:Source/queue.c **** 
 878:Source/queue.c **** 					/* Return to the original privilege level before exiting
 879:Source/queue.c **** 					the function. */
 880:Source/queue.c **** 					traceQUEUE_SEND_FAILED( pxQueue );
 881:Source/queue.c **** 					return errQUEUE_FULL;
 690              		.loc 1 881 0
 691 008a 0023     		movs	r3, #0
 692 008c 5CE0     		b	.L46
 693              	.L36:
 882:Source/queue.c **** 				}
 883:Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 694              		.loc 1 883 0
 695 008e 7B6A     		ldr	r3, [r7, #36]
 696 0090 002B     		cmp	r3, #0
 697 0092 06D1     		bne	.L37
 884:Source/queue.c **** 				{
 885:Source/queue.c **** 					/* The queue was full and a block time was specified so
 886:Source/queue.c **** 					configure the timeout structure. */
 887:Source/queue.c **** 					vTaskInternalSetTimeOutState( &xTimeOut );
 698              		.loc 1 887 0
 699 0094 07F11403 		add	r3, r7, #20
 700 0098 1846     		mov	r0, r3
 701 009a FFF7FEFF 		bl	vTaskInternalSetTimeOutState
 888:Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 702              		.loc 1 888 0
 703 009e 0123     		movs	r3, #1
 704 00a0 7B62     		str	r3, [r7, #36]
 705              	.L37:
 889:Source/queue.c **** 				}
 890:Source/queue.c **** 				else
 891:Source/queue.c **** 				{
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 29


 892:Source/queue.c **** 					/* Entry time was already set. */
 893:Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
 894:Source/queue.c **** 				}
 895:Source/queue.c **** 			}
 896:Source/queue.c **** 		}
 897:Source/queue.c **** 		taskEXIT_CRITICAL();
 706              		.loc 1 897 0
 707 00a2 FFF7FEFF 		bl	vPortExitCritical
 898:Source/queue.c **** 
 899:Source/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
 900:Source/queue.c **** 		now the critical section has been exited. */
 901:Source/queue.c **** 
 902:Source/queue.c **** 		vTaskSuspendAll();
 708              		.loc 1 902 0
 709 00a6 FFF7FEFF 		bl	vTaskSuspendAll
 903:Source/queue.c **** 		prvLockQueue( pxQueue );
 710              		.loc 1 903 0
 711 00aa FFF7FEFF 		bl	vPortEnterCritical
 712 00ae 3B6A     		ldr	r3, [r7, #32]
 713 00b0 93F84430 		ldrb	r3, [r3, #68]
 714 00b4 5BB2     		sxtb	r3, r3
 715 00b6 B3F1FF3F 		cmp	r3, #-1
 716 00ba 03D1     		bne	.L38
 717              		.loc 1 903 0 is_stmt 0 discriminator 1
 718 00bc 3B6A     		ldr	r3, [r7, #32]
 719 00be 0022     		movs	r2, #0
 720 00c0 83F84420 		strb	r2, [r3, #68]
 721              	.L38:
 722              		.loc 1 903 0 discriminator 3
 723 00c4 3B6A     		ldr	r3, [r7, #32]
 724 00c6 93F84530 		ldrb	r3, [r3, #69]
 725 00ca 5BB2     		sxtb	r3, r3
 726 00cc B3F1FF3F 		cmp	r3, #-1
 727 00d0 03D1     		bne	.L39
 728              		.loc 1 903 0 discriminator 4
 729 00d2 3B6A     		ldr	r3, [r7, #32]
 730 00d4 0022     		movs	r2, #0
 731 00d6 83F84520 		strb	r2, [r3, #69]
 732              	.L39:
 733              		.loc 1 903 0 discriminator 6
 734 00da FFF7FEFF 		bl	vPortExitCritical
 904:Source/queue.c **** 
 905:Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
 906:Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 735              		.loc 1 906 0 is_stmt 1 discriminator 6
 736 00de 3A1D     		adds	r2, r7, #4
 737 00e0 07F11403 		add	r3, r7, #20
 738 00e4 1146     		mov	r1, r2
 739 00e6 1846     		mov	r0, r3
 740 00e8 FFF7FEFF 		bl	xTaskCheckForTimeOut
 741 00ec 0346     		mov	r3, r0
 742 00ee 002B     		cmp	r3, #0
 743 00f0 24D1     		bne	.L40
 907:Source/queue.c **** 		{
 908:Source/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 744              		.loc 1 908 0
 745 00f2 386A     		ldr	r0, [r7, #32]
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 30


 746 00f4 FFF7FEFF 		bl	prvIsQueueFull
 747 00f8 0346     		mov	r3, r0
 748 00fa 002B     		cmp	r3, #0
 749 00fc 18D0     		beq	.L41
 909:Source/queue.c **** 			{
 910:Source/queue.c **** 				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
 911:Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 750              		.loc 1 911 0
 751 00fe 3B6A     		ldr	r3, [r7, #32]
 752 0100 1033     		adds	r3, r3, #16
 753 0102 7A68     		ldr	r2, [r7, #4]
 754 0104 1146     		mov	r1, r2
 755 0106 1846     		mov	r0, r3
 756 0108 FFF7FEFF 		bl	vTaskPlaceOnEventList
 912:Source/queue.c **** 
 913:Source/queue.c **** 				/* Unlocking the queue means queue events can effect the
 914:Source/queue.c **** 				event list.  It is possible that interrupts occurring now
 915:Source/queue.c **** 				remove this task from the event list again - but as the
 916:Source/queue.c **** 				scheduler is suspended the task will go onto the pending
 917:Source/queue.c **** 				ready last instead of the actual ready list. */
 918:Source/queue.c **** 				prvUnlockQueue( pxQueue );
 757              		.loc 1 918 0
 758 010c 386A     		ldr	r0, [r7, #32]
 759 010e FFF7FEFF 		bl	prvUnlockQueue
 919:Source/queue.c **** 
 920:Source/queue.c **** 				/* Resuming the scheduler will move tasks from the pending
 921:Source/queue.c **** 				ready list into the ready list - so it is feasible that this
 922:Source/queue.c **** 				task is already in a ready list before it yields - in which
 923:Source/queue.c **** 				case the yield will not cause a context switch unless there
 924:Source/queue.c **** 				is also a higher priority task in the pending ready list. */
 925:Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 760              		.loc 1 925 0
 761 0112 FFF7FEFF 		bl	xTaskResumeAll
 762 0116 0346     		mov	r3, r0
 763 0118 002B     		cmp	r3, #0
 764 011a 7FF47CAF 		bne	.L45
 926:Source/queue.c **** 				{
 927:Source/queue.c **** 					portYIELD_WITHIN_API();
 765              		.loc 1 927 0
 766 011e 0C4B     		ldr	r3, .L47
 767 0120 4FF08052 		mov	r2, #268435456
 768 0124 1A60     		str	r2, [r3]
 769              		.syntax unified
 770              	@ 927 "Source\queue.c" 1
 771 0126 BFF34F8F 		dsb
 772              	@ 0 "" 2
 773              	@ 927 "Source\queue.c" 1
 774 012a BFF36F8F 		isb
 775              	@ 0 "" 2
 776              		.thumb
 777              		.syntax unified
 778 012e 72E7     		b	.L45
 779              	.L41:
 928:Source/queue.c **** 				}
 929:Source/queue.c **** 			}
 930:Source/queue.c **** 			else
 931:Source/queue.c **** 			{
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 31


 932:Source/queue.c **** 				/* Try again. */
 933:Source/queue.c **** 				prvUnlockQueue( pxQueue );
 780              		.loc 1 933 0
 781 0130 386A     		ldr	r0, [r7, #32]
 782 0132 FFF7FEFF 		bl	prvUnlockQueue
 934:Source/queue.c **** 				( void ) xTaskResumeAll();
 783              		.loc 1 934 0
 784 0136 FFF7FEFF 		bl	xTaskResumeAll
 785 013a 6CE7     		b	.L45
 786              	.L40:
 935:Source/queue.c **** 			}
 936:Source/queue.c **** 		}
 937:Source/queue.c **** 		else
 938:Source/queue.c **** 		{
 939:Source/queue.c **** 			/* The timeout has expired. */
 940:Source/queue.c **** 			prvUnlockQueue( pxQueue );
 787              		.loc 1 940 0
 788 013c 386A     		ldr	r0, [r7, #32]
 789 013e FFF7FEFF 		bl	prvUnlockQueue
 941:Source/queue.c **** 			( void ) xTaskResumeAll();
 790              		.loc 1 941 0
 791 0142 FFF7FEFF 		bl	xTaskResumeAll
 942:Source/queue.c **** 
 943:Source/queue.c **** 			traceQUEUE_SEND_FAILED( pxQueue );
 944:Source/queue.c **** 			return errQUEUE_FULL;
 792              		.loc 1 944 0
 793 0146 0023     		movs	r3, #0
 794              	.L46:
 945:Source/queue.c **** 		}
 946:Source/queue.c **** 	} /*lint -restore */
 947:Source/queue.c **** }
 795              		.loc 1 947 0 discriminator 3
 796 0148 1846     		mov	r0, r3
 797 014a 2837     		adds	r7, r7, #40
 798              		.cfi_def_cfa_offset 8
 799 014c BD46     		mov	sp, r7
 800              		.cfi_def_cfa_register 13
 801              		@ sp needed
 802 014e 80BD     		pop	{r7, pc}
 803              	.L48:
 804              		.align	2
 805              	.L47:
 806 0150 04ED00E0 		.word	-536810236
 807              		.cfi_endproc
 808              	.LFE76:
 809              		.size	xQueueGenericSend, .-xQueueGenericSend
 810              		.section	.text.xQueueGenericSendFromISR,"ax",%progbits
 811              		.align	2
 812              		.global	xQueueGenericSendFromISR
 813              		.thumb
 814              		.thumb_func
 815              		.type	xQueueGenericSendFromISR, %function
 816              	xQueueGenericSendFromISR:
 817              	.LFB77:
 948:Source/queue.c **** /*-----------------------------------------------------------*/
 949:Source/queue.c **** 
 950:Source/queue.c **** BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseTy
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 32


 951:Source/queue.c **** {
 818              		.loc 1 951 0
 819              		.cfi_startproc
 820              		@ args = 0, pretend = 0, frame = 48
 821              		@ frame_needed = 1, uses_anonymous_args = 0
 822 0000 80B5     		push	{r7, lr}
 823              		.cfi_def_cfa_offset 8
 824              		.cfi_offset 7, -8
 825              		.cfi_offset 14, -4
 826 0002 8CB0     		sub	sp, sp, #48
 827              		.cfi_def_cfa_offset 56
 828 0004 00AF     		add	r7, sp, #0
 829              		.cfi_def_cfa_register 7
 830 0006 F860     		str	r0, [r7, #12]
 831 0008 B960     		str	r1, [r7, #8]
 832 000a 7A60     		str	r2, [r7, #4]
 833 000c 3B60     		str	r3, [r7]
 952:Source/queue.c **** BaseType_t xReturn;
 953:Source/queue.c **** UBaseType_t uxSavedInterruptStatus;
 954:Source/queue.c **** Queue_t * const pxQueue = xQueue;
 834              		.loc 1 954 0
 835 000e FB68     		ldr	r3, [r7, #12]
 836 0010 BB62     		str	r3, [r7, #40]
 837              	.LBB23:
 838              	.LBB24:
 839              		.file 2 ".\\Source\\portable\\GCC\\ARM_CM3/portmacro.h"
   1:.\Source\portable\GCC\ARM_CM3/portmacro.h **** /*
   2:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * FreeRTOS Kernel V10.3.1
   3:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  *
   5:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   6:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * this software and associated documentation files (the "Software"), to deal in
   7:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * the Software without restriction, including without limitation the rights to
   8:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   9:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  10:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * subject to the following conditions:
  11:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  *
  12:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * The above copyright notice and this permission notice shall be included in all
  13:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * copies or substantial portions of the Software.
  14:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  *
  15:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  17:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  18:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  19:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  20:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  21:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  *
  22:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * http://www.FreeRTOS.org
  23:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * http://aws.amazon.com/freertos
  24:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  *
  25:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * 1 tab == 4 spaces!
  26:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  */
  27:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  28:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  29:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #ifndef PORTMACRO_H
  30:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define PORTMACRO_H
  31:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 33


  32:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #ifdef __cplusplus
  33:.\Source\portable\GCC\ARM_CM3/portmacro.h **** extern "C" {
  34:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #endif
  35:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  36:.\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------
  37:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * Port specific definitions.
  38:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  *
  39:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * The settings in this file configure FreeRTOS correctly for the
  40:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * given hardware and compiler.
  41:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  *
  42:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * These settings should not be altered.
  43:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  *-----------------------------------------------------------
  44:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  */
  45:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  46:.\Source\portable\GCC\ARM_CM3/portmacro.h **** /* Type definitions. */
  47:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portCHAR		char
  48:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portFLOAT		float
  49:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portDOUBLE		double
  50:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portLONG		long
  51:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portSHORT		short
  52:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portSTACK_TYPE	uint32_t
  53:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portBASE_TYPE	long
  54:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  55:.\Source\portable\GCC\ARM_CM3/portmacro.h **** typedef portSTACK_TYPE StackType_t;
  56:.\Source\portable\GCC\ARM_CM3/portmacro.h **** typedef long BaseType_t;
  57:.\Source\portable\GCC\ARM_CM3/portmacro.h **** typedef unsigned long UBaseType_t;
  58:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  59:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #if( configUSE_16_BIT_TICKS == 1 )
  60:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	typedef uint16_t TickType_t;
  61:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#define portMAX_DELAY ( TickType_t ) 0xffff
  62:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #else
  63:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	typedef uint32_t TickType_t;
  64:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#define portMAX_DELAY ( TickType_t ) 0xffffffffUL
  65:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  66:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	/* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
  67:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	not need to be guarded with a critical section. */
  68:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#define portTICK_TYPE_IS_ATOMIC 1
  69:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #endif
  70:.\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
  71:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  72:.\Source\portable\GCC\ARM_CM3/portmacro.h **** /* Architecture specifics. */
  73:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portSTACK_GROWTH			( -1 )
  74:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portTICK_PERIOD_MS			( ( TickType_t ) 1000 / configTICK_RATE_HZ )
  75:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portBYTE_ALIGNMENT			8
  76:.\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
  77:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  78:.\Source\portable\GCC\ARM_CM3/portmacro.h **** /* Scheduler utilities. */
  79:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portYIELD() 															\
  80:.\Source\portable\GCC\ARM_CM3/portmacro.h **** {																				\
  81:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	/* Set a PendSV to request a context switch. */								\
  82:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;								\
  83:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 																				\
  84:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	/* Barriers are normally not required but do ensure the code is completely	\
  85:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	within the specified behaviour for the architecture. */						\
  86:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	__asm volatile( "dsb" ::: "memory" );										\
  87:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	__asm volatile( "isb" );													\
  88:.\Source\portable\GCC\ARM_CM3/portmacro.h **** }
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 34


  89:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  90:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portNVIC_INT_CTRL_REG		( * ( ( volatile uint32_t * ) 0xe000ed04 ) )
  91:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portNVIC_PENDSVSET_BIT		( 1UL << 28UL )
  92:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portEND_SWITCHING_ISR( xSwitchRequired ) if( xSwitchRequired != pdFALSE ) portYIELD()
  93:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portYIELD_FROM_ISR( x ) portEND_SWITCHING_ISR( x )
  94:.\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
  95:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  96:.\Source\portable\GCC\ARM_CM3/portmacro.h **** /* Critical section management. */
  97:.\Source\portable\GCC\ARM_CM3/portmacro.h **** extern void vPortEnterCritical( void );
  98:.\Source\portable\GCC\ARM_CM3/portmacro.h **** extern void vPortExitCritical( void );
  99:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portSET_INTERRUPT_MASK_FROM_ISR()		ulPortRaiseBASEPRI()
 100:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portCLEAR_INTERRUPT_MASK_FROM_ISR(x)	vPortSetBASEPRI(x)
 101:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portDISABLE_INTERRUPTS()				vPortRaiseBASEPRI()
 102:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portENABLE_INTERRUPTS()					vPortSetBASEPRI(0)
 103:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portENTER_CRITICAL()					vPortEnterCritical()
 104:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portEXIT_CRITICAL()						vPortExitCritical()
 105:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 106:.\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 107:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 108:.\Source\portable\GCC\ARM_CM3/portmacro.h **** /* Task function macros as described on the FreeRTOS.org WEB site.  These are
 109:.\Source\portable\GCC\ARM_CM3/portmacro.h **** not necessary for to use this port.  They are defined so the common demo files
 110:.\Source\portable\GCC\ARM_CM3/portmacro.h **** (which build with all the ports) will build. */
 111:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portTASK_FUNCTION_PROTO( vFunction, pvParameters ) void vFunction( void *pvParameters )
 112:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portTASK_FUNCTION( vFunction, pvParameters ) void vFunction( void *pvParameters )
 113:.\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 114:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 115:.\Source\portable\GCC\ARM_CM3/portmacro.h **** /* Tickless idle/low power functionality. */
 116:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #ifndef portSUPPRESS_TICKS_AND_SLEEP
 117:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	extern void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime );
 118:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime ) vPortSuppressTicksAndSleep( xExpectedIdl
 119:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #endif
 120:.\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 121:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 122:.\Source\portable\GCC\ARM_CM3/portmacro.h **** /* Architecture specific optimisations. */
 123:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
 124:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#define configUSE_PORT_OPTIMISED_TASK_SELECTION 1
 125:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #endif
 126:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 127:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #if configUSE_PORT_OPTIMISED_TASK_SELECTION == 1
 128:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 129:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	/* Generic helper function. */
 130:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	__attribute__( ( always_inline ) ) static inline uint8_t ucPortCountLeadingZeros( uint32_t ulBitma
 131:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	{
 132:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	uint8_t ucReturn;
 133:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 134:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
 135:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 		return ucReturn;
 136:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	}
 137:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 138:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	/* Check the configuration. */
 139:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#if( configMAX_PRIORITIES > 32 )
 140:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 		#error configUSE_PORT_OPTIMISED_TASK_SELECTION can only be set to 1 when configMAX_PRIORITIES is 
 141:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#endif
 142:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 143:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	/* Store/clear the ready priorities in a bit map. */
 144:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#define portRECORD_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) |= ( 1UL 
 145:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#define portRESET_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) &= ~( 1UL 
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 35


 146:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 147:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	/*-----------------------------------------------------------*/
 148:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 149:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#define portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities ) uxTopPriority = ( 31UL - ( ui
 150:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 151:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 152:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 153:.\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 154:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 155:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #ifdef configASSERT
 156:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	void vPortValidateInterruptPriority( void );
 157:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#define portASSERT_IF_INTERRUPT_PRIORITY_INVALID() 	vPortValidateInterruptPriority()
 158:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #endif
 159:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 160:.\Source\portable\GCC\ARM_CM3/portmacro.h **** /* portNOP() is not required by this port. */
 161:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portNOP()
 162:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 163:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portINLINE	__inline
 164:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 165:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #ifndef portFORCE_INLINE
 166:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#define portFORCE_INLINE inline __attribute__(( always_inline))
 167:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #endif
 168:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 169:.\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 170:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 171:.\Source\portable\GCC\ARM_CM3/portmacro.h **** portFORCE_INLINE static BaseType_t xPortIsInsideInterrupt( void )
 172:.\Source\portable\GCC\ARM_CM3/portmacro.h **** {
 173:.\Source\portable\GCC\ARM_CM3/portmacro.h **** uint32_t ulCurrentInterrupt;
 174:.\Source\portable\GCC\ARM_CM3/portmacro.h **** BaseType_t xReturn;
 175:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 176:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	/* Obtain the number of the currently executing interrupt. */
 177:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
 178:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 179:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	if( ulCurrentInterrupt == 0 )
 180:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	{
 181:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 		xReturn = pdFALSE;
 182:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	}
 183:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	else
 184:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	{
 185:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 		xReturn = pdTRUE;
 186:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	}
 187:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 188:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	return xReturn;
 189:.\Source\portable\GCC\ARM_CM3/portmacro.h **** }
 190:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 191:.\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 192:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 193:.\Source\portable\GCC\ARM_CM3/portmacro.h **** portFORCE_INLINE static void vPortRaiseBASEPRI( void )
 194:.\Source\portable\GCC\ARM_CM3/portmacro.h **** {
 195:.\Source\portable\GCC\ARM_CM3/portmacro.h **** uint32_t ulNewBASEPRI;
 196:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 197:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	__asm volatile
 198:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	(
 199:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 		"	mov %0, %1												\n" \
 200:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 		"	msr basepri, %0											\n" \
 201:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 		"	isb														\n" \
 202:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 		"	dsb														\n" \
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 36


 203:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 		:"=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
 204:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	);
 205:.\Source\portable\GCC\ARM_CM3/portmacro.h **** }
 206:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 207:.\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 208:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 209:.\Source\portable\GCC\ARM_CM3/portmacro.h **** portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
 210:.\Source\portable\GCC\ARM_CM3/portmacro.h **** {
 211:.\Source\portable\GCC\ARM_CM3/portmacro.h **** uint32_t ulOriginalBASEPRI, ulNewBASEPRI;
 212:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 213:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	__asm volatile
 840              		.loc 2 213 0
 841              		.syntax unified
 842              	@ 213 ".\Source\portable\GCC\ARM_CM3/portmacro.h" 1
 843 0012 EFF31182 			mrs r2, basepri											
 844 0016 4FF0A003 		mov r3, #160												
 845 001a 83F31188 		msr basepri, r3											
 846 001e BFF36F8F 		isb														
 847 0022 BFF34F8F 		dsb														
 848              	
 849              	@ 0 "" 2
 850              		.thumb
 851              		.syntax unified
 852 0026 7A61     		str	r2, [r7, #20]
 853 0028 3B61     		str	r3, [r7, #16]
 214:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	(
 215:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 		"	mrs %0, basepri											\n" \
 216:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 		"	mov %1, %2												\n" \
 217:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 		"	msr basepri, %1											\n" \
 218:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 		"	isb														\n" \
 219:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 		"	dsb														\n" \
 220:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "
 221:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	);
 222:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 223:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	/* This return will not be reached but is necessary to prevent compiler
 224:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	warnings. */
 225:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	return ulOriginalBASEPRI;
 854              		.loc 2 225 0
 855 002a 7B69     		ldr	r3, [r7, #20]
 856              	.LBE24:
 857              	.LBE23:
 955:Source/queue.c **** 
 956:Source/queue.c **** 	configASSERT( pxQueue );
 957:Source/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 958:Source/queue.c **** 	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 959:Source/queue.c **** 
 960:Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
 961:Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
 962:Source/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
 963:Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
 964:Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
 965:Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
 966:Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
 967:Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
 968:Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
 969:Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
 970:Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 37


 971:Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
 972:Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
 973:Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
 974:Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 975:Source/queue.c **** 
 976:Source/queue.c **** 	/* Similar to xQueueGenericSend, except without blocking if there is no room
 977:Source/queue.c **** 	in the queue.  Also don't directly wake a task that was blocked on a queue
 978:Source/queue.c **** 	read, instead return a flag to say whether a context switch is required or
 979:Source/queue.c **** 	not (i.e. has a task with a higher priority than us been woken by this
 980:Source/queue.c **** 	post). */
 981:Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 858              		.loc 1 981 0
 859 002c 3B62     		str	r3, [r7, #32]
 982:Source/queue.c **** 	{
 983:Source/queue.c **** 		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 860              		.loc 1 983 0
 861 002e BB6A     		ldr	r3, [r7, #40]
 862 0030 9A6B     		ldr	r2, [r3, #56]
 863 0032 BB6A     		ldr	r3, [r7, #40]
 864 0034 DB6B     		ldr	r3, [r3, #60]
 865 0036 9A42     		cmp	r2, r3
 866 0038 02D3     		bcc	.L51
 867              		.loc 1 983 0 is_stmt 0 discriminator 1
 868 003a 3B68     		ldr	r3, [r7]
 869 003c 022B     		cmp	r3, #2
 870 003e 2DD1     		bne	.L52
 871              	.L51:
 872              	.LBB25:
 984:Source/queue.c **** 		{
 985:Source/queue.c **** 			const int8_t cTxLock = pxQueue->cTxLock;
 873              		.loc 1 985 0 is_stmt 1
 874 0040 BB6A     		ldr	r3, [r7, #40]
 875 0042 93F84530 		ldrb	r3, [r3, #69]
 876 0046 FB77     		strb	r3, [r7, #31]
 986:Source/queue.c **** 			const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
 877              		.loc 1 986 0
 878 0048 BB6A     		ldr	r3, [r7, #40]
 879 004a 9B6B     		ldr	r3, [r3, #56]
 880 004c BB61     		str	r3, [r7, #24]
 987:Source/queue.c **** 
 988:Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR( pxQueue );
 989:Source/queue.c **** 
 990:Source/queue.c **** 			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
 991:Source/queue.c **** 			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
 992:Source/queue.c **** 			in a task disinheriting a priority and prvCopyDataToQueue() can be
 993:Source/queue.c **** 			called here even though the disinherit function does not check if
 994:Source/queue.c **** 			the scheduler is suspended before accessing the ready lists. */
 995:Source/queue.c **** 			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 881              		.loc 1 995 0
 882 004e 3A68     		ldr	r2, [r7]
 883 0050 B968     		ldr	r1, [r7, #8]
 884 0052 B86A     		ldr	r0, [r7, #40]
 885 0054 FFF7FEFF 		bl	prvCopyDataToQueue
 996:Source/queue.c **** 
 997:Source/queue.c **** 			/* The event list is not altered if the queue is locked.  This will
 998:Source/queue.c **** 			be done when the queue is unlocked later. */
 999:Source/queue.c **** 			if( cTxLock == queueUNLOCKED )
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 38


 886              		.loc 1 999 0
 887 0058 97F91F30 		ldrsb	r3, [r7, #31]
 888 005c B3F1FF3F 		cmp	r3, #-1
 889 0060 12D1     		bne	.L53
1000:Source/queue.c **** 			{
1001:Source/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
1002:Source/queue.c **** 				{
1003:Source/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
1004:Source/queue.c **** 					{
1005:Source/queue.c **** 						if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting != ( UBaseType_t ) 0 )
1006:Source/queue.c **** 						{
1007:Source/queue.c **** 							/* Do not notify the queue set as an existing item
1008:Source/queue.c **** 							was overwritten in the queue so the number of items
1009:Source/queue.c **** 							in the queue has not changed. */
1010:Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1011:Source/queue.c **** 						}
1012:Source/queue.c **** 						else if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
1013:Source/queue.c **** 						{
1014:Source/queue.c **** 							/* The queue is a member of a queue set, and posting
1015:Source/queue.c **** 							to the queue set caused a higher priority task to
1016:Source/queue.c **** 							unblock.  A context switch is required. */
1017:Source/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
1018:Source/queue.c **** 							{
1019:Source/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
1020:Source/queue.c **** 							}
1021:Source/queue.c **** 							else
1022:Source/queue.c **** 							{
1023:Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1024:Source/queue.c **** 							}
1025:Source/queue.c **** 						}
1026:Source/queue.c **** 						else
1027:Source/queue.c **** 						{
1028:Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1029:Source/queue.c **** 						}
1030:Source/queue.c **** 					}
1031:Source/queue.c **** 					else
1032:Source/queue.c **** 					{
1033:Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1034:Source/queue.c **** 						{
1035:Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1036:Source/queue.c **** 							{
1037:Source/queue.c **** 								/* The task waiting has a higher priority so
1038:Source/queue.c **** 								record that a context switch is required. */
1039:Source/queue.c **** 								if( pxHigherPriorityTaskWoken != NULL )
1040:Source/queue.c **** 								{
1041:Source/queue.c **** 									*pxHigherPriorityTaskWoken = pdTRUE;
1042:Source/queue.c **** 								}
1043:Source/queue.c **** 								else
1044:Source/queue.c **** 								{
1045:Source/queue.c **** 									mtCOVERAGE_TEST_MARKER();
1046:Source/queue.c **** 								}
1047:Source/queue.c **** 							}
1048:Source/queue.c **** 							else
1049:Source/queue.c **** 							{
1050:Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1051:Source/queue.c **** 							}
1052:Source/queue.c **** 						}
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 39


1053:Source/queue.c **** 						else
1054:Source/queue.c **** 						{
1055:Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1056:Source/queue.c **** 						}
1057:Source/queue.c **** 					}
1058:Source/queue.c **** 				}
1059:Source/queue.c **** 				#else /* configUSE_QUEUE_SETS */
1060:Source/queue.c **** 				{
1061:Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 890              		.loc 1 1061 0
 891 0062 BB6A     		ldr	r3, [r7, #40]
 892 0064 5B6A     		ldr	r3, [r3, #36]
 893 0066 002B     		cmp	r3, #0
 894 0068 15D0     		beq	.L54
1062:Source/queue.c **** 					{
1063:Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 895              		.loc 1 1063 0
 896 006a BB6A     		ldr	r3, [r7, #40]
 897 006c 2433     		adds	r3, r3, #36
 898 006e 1846     		mov	r0, r3
 899 0070 FFF7FEFF 		bl	xTaskRemoveFromEventList
 900 0074 0346     		mov	r3, r0
 901 0076 002B     		cmp	r3, #0
 902 0078 0DD0     		beq	.L54
1064:Source/queue.c **** 						{
1065:Source/queue.c **** 							/* The task waiting has a higher priority so record that a
1066:Source/queue.c **** 							context	switch is required. */
1067:Source/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
 903              		.loc 1 1067 0
 904 007a 7B68     		ldr	r3, [r7, #4]
 905 007c 002B     		cmp	r3, #0
 906 007e 0AD0     		beq	.L54
1068:Source/queue.c **** 							{
1069:Source/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
 907              		.loc 1 1069 0
 908 0080 7B68     		ldr	r3, [r7, #4]
 909 0082 0122     		movs	r2, #1
 910 0084 1A60     		str	r2, [r3]
 911 0086 06E0     		b	.L54
 912              	.L53:
1070:Source/queue.c **** 							}
1071:Source/queue.c **** 							else
1072:Source/queue.c **** 							{
1073:Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1074:Source/queue.c **** 							}
1075:Source/queue.c **** 						}
1076:Source/queue.c **** 						else
1077:Source/queue.c **** 						{
1078:Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1079:Source/queue.c **** 						}
1080:Source/queue.c **** 					}
1081:Source/queue.c **** 					else
1082:Source/queue.c **** 					{
1083:Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1084:Source/queue.c **** 					}
1085:Source/queue.c **** 					
1086:Source/queue.c **** 					/* Not used in this path. */
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 40


1087:Source/queue.c **** 					( void ) uxPreviousMessagesWaiting;
1088:Source/queue.c **** 				}
1089:Source/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
1090:Source/queue.c **** 			}
1091:Source/queue.c **** 			else
1092:Source/queue.c **** 			{
1093:Source/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1094:Source/queue.c **** 				knows that data was posted while it was locked. */
1095:Source/queue.c **** 				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 913              		.loc 1 1095 0
 914 0088 FB7F     		ldrb	r3, [r7, #31]	@ zero_extendqisi2
 915 008a 0133     		adds	r3, r3, #1
 916 008c DBB2     		uxtb	r3, r3
 917 008e 5AB2     		sxtb	r2, r3
 918 0090 BB6A     		ldr	r3, [r7, #40]
 919 0092 83F84520 		strb	r2, [r3, #69]
 920              	.L54:
1096:Source/queue.c **** 			}
1097:Source/queue.c **** 
1098:Source/queue.c **** 			xReturn = pdPASS;
 921              		.loc 1 1098 0
 922 0096 0123     		movs	r3, #1
 923 0098 FB62     		str	r3, [r7, #44]
 924              	.LBE25:
 984:Source/queue.c **** 			const int8_t cTxLock = pxQueue->cTxLock;
 925              		.loc 1 984 0
 926 009a 01E0     		b	.L55
 927              	.L52:
1099:Source/queue.c **** 		}
1100:Source/queue.c **** 		else
1101:Source/queue.c **** 		{
1102:Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1103:Source/queue.c **** 			xReturn = errQUEUE_FULL;
 928              		.loc 1 1103 0
 929 009c 0023     		movs	r3, #0
 930 009e FB62     		str	r3, [r7, #44]
 931              	.L55:
 932 00a0 3B6A     		ldr	r3, [r7, #32]
 933 00a2 7B62     		str	r3, [r7, #36]
 934              	.LBB26:
 935              	.LBB27:
 226:.\Source\portable\GCC\ARM_CM3/portmacro.h **** }
 227:.\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 228:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 229:.\Source\portable\GCC\ARM_CM3/portmacro.h **** portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
 230:.\Source\portable\GCC\ARM_CM3/portmacro.h **** {
 231:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	__asm volatile
 936              		.loc 2 231 0
 937 00a4 7B6A     		ldr	r3, [r7, #36]
 938              		.syntax unified
 939              	@ 231 ".\Source\portable\GCC\ARM_CM3/portmacro.h" 1
 940 00a6 83F31188 			msr basepri, r3	
 941              	@ 0 "" 2
 942              		.thumb
 943              		.syntax unified
 944              	.LBE27:
 945              	.LBE26:
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 41


1104:Source/queue.c **** 		}
1105:Source/queue.c **** 	}
1106:Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1107:Source/queue.c **** 
1108:Source/queue.c **** 	return xReturn;
 946              		.loc 1 1108 0
 947 00aa FB6A     		ldr	r3, [r7, #44]
1109:Source/queue.c **** }
 948              		.loc 1 1109 0
 949 00ac 1846     		mov	r0, r3
 950 00ae 3037     		adds	r7, r7, #48
 951              		.cfi_def_cfa_offset 8
 952 00b0 BD46     		mov	sp, r7
 953              		.cfi_def_cfa_register 13
 954              		@ sp needed
 955 00b2 80BD     		pop	{r7, pc}
 956              		.cfi_endproc
 957              	.LFE77:
 958              		.size	xQueueGenericSendFromISR, .-xQueueGenericSendFromISR
 959              		.section	.text.xQueueGiveFromISR,"ax",%progbits
 960              		.align	2
 961              		.global	xQueueGiveFromISR
 962              		.thumb
 963              		.thumb_func
 964              		.type	xQueueGiveFromISR, %function
 965              	xQueueGiveFromISR:
 966              	.LFB78:
1110:Source/queue.c **** /*-----------------------------------------------------------*/
1111:Source/queue.c **** 
1112:Source/queue.c **** BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
1113:Source/queue.c **** {
 967              		.loc 1 1113 0
 968              		.cfi_startproc
 969              		@ args = 0, pretend = 0, frame = 40
 970              		@ frame_needed = 1, uses_anonymous_args = 0
 971 0000 80B5     		push	{r7, lr}
 972              		.cfi_def_cfa_offset 8
 973              		.cfi_offset 7, -8
 974              		.cfi_offset 14, -4
 975 0002 8AB0     		sub	sp, sp, #40
 976              		.cfi_def_cfa_offset 48
 977 0004 00AF     		add	r7, sp, #0
 978              		.cfi_def_cfa_register 7
 979 0006 7860     		str	r0, [r7, #4]
 980 0008 3960     		str	r1, [r7]
1114:Source/queue.c **** BaseType_t xReturn;
1115:Source/queue.c **** UBaseType_t uxSavedInterruptStatus;
1116:Source/queue.c **** Queue_t * const pxQueue = xQueue;
 981              		.loc 1 1116 0
 982 000a 7B68     		ldr	r3, [r7, #4]
 983 000c 3B62     		str	r3, [r7, #32]
 984              	.LBB28:
 985              	.LBB29:
 213:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	(
 986              		.loc 2 213 0
 987              		.syntax unified
 988              	@ 213 ".\Source\portable\GCC\ARM_CM3/portmacro.h" 1
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 42


 989 000e EFF31182 			mrs r2, basepri											
 990 0012 4FF0A003 		mov r3, #160												
 991 0016 83F31188 		msr basepri, r3											
 992 001a BFF36F8F 		isb														
 993 001e BFF34F8F 		dsb														
 994              	
 995              	@ 0 "" 2
 996              		.thumb
 997              		.syntax unified
 998 0022 FA60     		str	r2, [r7, #12]
 999 0024 BB60     		str	r3, [r7, #8]
 225:.\Source\portable\GCC\ARM_CM3/portmacro.h **** }
 1000              		.loc 2 225 0
 1001 0026 FB68     		ldr	r3, [r7, #12]
 1002              	.LBE29:
 1003              	.LBE28:
1117:Source/queue.c **** 
1118:Source/queue.c **** 	/* Similar to xQueueGenericSendFromISR() but used with semaphores where the
1119:Source/queue.c **** 	item size is 0.  Don't directly wake a task that was blocked on a queue
1120:Source/queue.c **** 	read, instead return a flag to say whether a context switch is required or
1121:Source/queue.c **** 	not (i.e. has a task with a higher priority than us been woken by this
1122:Source/queue.c **** 	post). */
1123:Source/queue.c **** 
1124:Source/queue.c **** 	configASSERT( pxQueue );
1125:Source/queue.c **** 
1126:Source/queue.c **** 	/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
1127:Source/queue.c **** 	if the item size is not 0. */
1128:Source/queue.c **** 	configASSERT( pxQueue->uxItemSize == 0 );
1129:Source/queue.c **** 
1130:Source/queue.c **** 	/* Normally a mutex would not be given from an interrupt, especially if
1131:Source/queue.c **** 	there is a mutex holder, as priority inheritance makes no sense for an
1132:Source/queue.c **** 	interrupts, only tasks. */
1133:Source/queue.c **** 	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMutex
1134:Source/queue.c **** 
1135:Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1136:Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1137:Source/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
1138:Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1139:Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1140:Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1141:Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1142:Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
1143:Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1144:Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1145:Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1146:Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1147:Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1148:Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1149:Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1150:Source/queue.c **** 
1151:Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1004              		.loc 1 1151 0
 1005 0028 BB61     		str	r3, [r7, #24]
 1006              	.LBB30:
1152:Source/queue.c **** 	{
1153:Source/queue.c **** 		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 1007              		.loc 1 1153 0
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 43


 1008 002a 3B6A     		ldr	r3, [r7, #32]
 1009 002c 9B6B     		ldr	r3, [r3, #56]
 1010 002e 7B61     		str	r3, [r7, #20]
1154:Source/queue.c **** 
1155:Source/queue.c **** 		/* When the queue is used to implement a semaphore no data is ever
1156:Source/queue.c **** 		moved through the queue but it is still valid to see if the queue 'has
1157:Source/queue.c **** 		space'. */
1158:Source/queue.c **** 		if( uxMessagesWaiting < pxQueue->uxLength )
 1011              		.loc 1 1158 0
 1012 0030 3B6A     		ldr	r3, [r7, #32]
 1013 0032 DA6B     		ldr	r2, [r3, #60]
 1014 0034 7B69     		ldr	r3, [r7, #20]
 1015 0036 9A42     		cmp	r2, r3
 1016 0038 29D9     		bls	.L59
 1017              	.LBB31:
1159:Source/queue.c **** 		{
1160:Source/queue.c **** 			const int8_t cTxLock = pxQueue->cTxLock;
 1018              		.loc 1 1160 0
 1019 003a 3B6A     		ldr	r3, [r7, #32]
 1020 003c 93F84530 		ldrb	r3, [r3, #69]
 1021 0040 FB74     		strb	r3, [r7, #19]
1161:Source/queue.c **** 
1162:Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR( pxQueue );
1163:Source/queue.c **** 
1164:Source/queue.c **** 			/* A task can only have an inherited priority if it is a mutex
1165:Source/queue.c **** 			holder - and if there is a mutex holder then the mutex cannot be
1166:Source/queue.c **** 			given from an ISR.  As this is the ISR version of the function it
1167:Source/queue.c **** 			can be assumed there is no mutex holder and no need to determine if
1168:Source/queue.c **** 			priority disinheritance is needed.  Simply increase the count of
1169:Source/queue.c **** 			messages (semaphores) available. */
1170:Source/queue.c **** 			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 1022              		.loc 1 1170 0
 1023 0042 7B69     		ldr	r3, [r7, #20]
 1024 0044 5A1C     		adds	r2, r3, #1
 1025 0046 3B6A     		ldr	r3, [r7, #32]
 1026 0048 9A63     		str	r2, [r3, #56]
1171:Source/queue.c **** 
1172:Source/queue.c **** 			/* The event list is not altered if the queue is locked.  This will
1173:Source/queue.c **** 			be done when the queue is unlocked later. */
1174:Source/queue.c **** 			if( cTxLock == queueUNLOCKED )
 1027              		.loc 1 1174 0
 1028 004a 97F91330 		ldrsb	r3, [r7, #19]
 1029 004e B3F1FF3F 		cmp	r3, #-1
 1030 0052 12D1     		bne	.L60
1175:Source/queue.c **** 			{
1176:Source/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
1177:Source/queue.c **** 				{
1178:Source/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
1179:Source/queue.c **** 					{
1180:Source/queue.c **** 						if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
1181:Source/queue.c **** 						{
1182:Source/queue.c **** 							/* The semaphore is a member of a queue set, and
1183:Source/queue.c **** 							posting	to the queue set caused a higher priority
1184:Source/queue.c **** 							task to	unblock.  A context switch is required. */
1185:Source/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
1186:Source/queue.c **** 							{
1187:Source/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 44


1188:Source/queue.c **** 							}
1189:Source/queue.c **** 							else
1190:Source/queue.c **** 							{
1191:Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1192:Source/queue.c **** 							}
1193:Source/queue.c **** 						}
1194:Source/queue.c **** 						else
1195:Source/queue.c **** 						{
1196:Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1197:Source/queue.c **** 						}
1198:Source/queue.c **** 					}
1199:Source/queue.c **** 					else
1200:Source/queue.c **** 					{
1201:Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1202:Source/queue.c **** 						{
1203:Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1204:Source/queue.c **** 							{
1205:Source/queue.c **** 								/* The task waiting has a higher priority so
1206:Source/queue.c **** 								record that a context switch is required. */
1207:Source/queue.c **** 								if( pxHigherPriorityTaskWoken != NULL )
1208:Source/queue.c **** 								{
1209:Source/queue.c **** 									*pxHigherPriorityTaskWoken = pdTRUE;
1210:Source/queue.c **** 								}
1211:Source/queue.c **** 								else
1212:Source/queue.c **** 								{
1213:Source/queue.c **** 									mtCOVERAGE_TEST_MARKER();
1214:Source/queue.c **** 								}
1215:Source/queue.c **** 							}
1216:Source/queue.c **** 							else
1217:Source/queue.c **** 							{
1218:Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1219:Source/queue.c **** 							}
1220:Source/queue.c **** 						}
1221:Source/queue.c **** 						else
1222:Source/queue.c **** 						{
1223:Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1224:Source/queue.c **** 						}
1225:Source/queue.c **** 					}
1226:Source/queue.c **** 				}
1227:Source/queue.c **** 				#else /* configUSE_QUEUE_SETS */
1228:Source/queue.c **** 				{
1229:Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 1031              		.loc 1 1229 0
 1032 0054 3B6A     		ldr	r3, [r7, #32]
 1033 0056 5B6A     		ldr	r3, [r3, #36]
 1034 0058 002B     		cmp	r3, #0
 1035 005a 15D0     		beq	.L61
1230:Source/queue.c **** 					{
1231:Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 1036              		.loc 1 1231 0
 1037 005c 3B6A     		ldr	r3, [r7, #32]
 1038 005e 2433     		adds	r3, r3, #36
 1039 0060 1846     		mov	r0, r3
 1040 0062 FFF7FEFF 		bl	xTaskRemoveFromEventList
 1041 0066 0346     		mov	r3, r0
 1042 0068 002B     		cmp	r3, #0
 1043 006a 0DD0     		beq	.L61
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 45


1232:Source/queue.c **** 						{
1233:Source/queue.c **** 							/* The task waiting has a higher priority so record that a
1234:Source/queue.c **** 							context	switch is required. */
1235:Source/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
 1044              		.loc 1 1235 0
 1045 006c 3B68     		ldr	r3, [r7]
 1046 006e 002B     		cmp	r3, #0
 1047 0070 0AD0     		beq	.L61
1236:Source/queue.c **** 							{
1237:Source/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
 1048              		.loc 1 1237 0
 1049 0072 3B68     		ldr	r3, [r7]
 1050 0074 0122     		movs	r2, #1
 1051 0076 1A60     		str	r2, [r3]
 1052 0078 06E0     		b	.L61
 1053              	.L60:
1238:Source/queue.c **** 							}
1239:Source/queue.c **** 							else
1240:Source/queue.c **** 							{
1241:Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1242:Source/queue.c **** 							}
1243:Source/queue.c **** 						}
1244:Source/queue.c **** 						else
1245:Source/queue.c **** 						{
1246:Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1247:Source/queue.c **** 						}
1248:Source/queue.c **** 					}
1249:Source/queue.c **** 					else
1250:Source/queue.c **** 					{
1251:Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1252:Source/queue.c **** 					}
1253:Source/queue.c **** 				}
1254:Source/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
1255:Source/queue.c **** 			}
1256:Source/queue.c **** 			else
1257:Source/queue.c **** 			{
1258:Source/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1259:Source/queue.c **** 				knows that data was posted while it was locked. */
1260:Source/queue.c **** 				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 1054              		.loc 1 1260 0
 1055 007a FB7C     		ldrb	r3, [r7, #19]	@ zero_extendqisi2
 1056 007c 0133     		adds	r3, r3, #1
 1057 007e DBB2     		uxtb	r3, r3
 1058 0080 5AB2     		sxtb	r2, r3
 1059 0082 3B6A     		ldr	r3, [r7, #32]
 1060 0084 83F84520 		strb	r2, [r3, #69]
 1061              	.L61:
1261:Source/queue.c **** 			}
1262:Source/queue.c **** 
1263:Source/queue.c **** 			xReturn = pdPASS;
 1062              		.loc 1 1263 0
 1063 0088 0123     		movs	r3, #1
 1064 008a 7B62     		str	r3, [r7, #36]
 1065              	.LBE31:
 1066 008c 01E0     		b	.L62
 1067              	.L59:
1264:Source/queue.c **** 		}
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 46


1265:Source/queue.c **** 		else
1266:Source/queue.c **** 		{
1267:Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1268:Source/queue.c **** 			xReturn = errQUEUE_FULL;
 1068              		.loc 1 1268 0
 1069 008e 0023     		movs	r3, #0
 1070 0090 7B62     		str	r3, [r7, #36]
 1071              	.L62:
 1072 0092 BB69     		ldr	r3, [r7, #24]
 1073 0094 FB61     		str	r3, [r7, #28]
 1074              	.LBE30:
 1075              	.LBB32:
 1076              	.LBB33:
 1077              		.loc 2 231 0
 1078 0096 FB69     		ldr	r3, [r7, #28]
 1079              		.syntax unified
 1080              	@ 231 ".\Source\portable\GCC\ARM_CM3/portmacro.h" 1
 1081 0098 83F31188 			msr basepri, r3	
 1082              	@ 0 "" 2
 1083              		.thumb
 1084              		.syntax unified
 1085              	.LBE33:
 1086              	.LBE32:
1269:Source/queue.c **** 		}
1270:Source/queue.c **** 	}
1271:Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1272:Source/queue.c **** 
1273:Source/queue.c **** 	return xReturn;
 1087              		.loc 1 1273 0
 1088 009c 7B6A     		ldr	r3, [r7, #36]
1274:Source/queue.c **** }
 1089              		.loc 1 1274 0
 1090 009e 1846     		mov	r0, r3
 1091 00a0 2837     		adds	r7, r7, #40
 1092              		.cfi_def_cfa_offset 8
 1093 00a2 BD46     		mov	sp, r7
 1094              		.cfi_def_cfa_register 13
 1095              		@ sp needed
 1096 00a4 80BD     		pop	{r7, pc}
 1097              		.cfi_endproc
 1098              	.LFE78:
 1099              		.size	xQueueGiveFromISR, .-xQueueGiveFromISR
 1100 00a6 00BF     		.section	.text.xQueueReceive,"ax",%progbits
 1101              		.align	2
 1102              		.global	xQueueReceive
 1103              		.thumb
 1104              		.thumb_func
 1105              		.type	xQueueReceive, %function
 1106              	xQueueReceive:
 1107              	.LFB79:
1275:Source/queue.c **** /*-----------------------------------------------------------*/
1276:Source/queue.c **** 
1277:Source/queue.c **** BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
1278:Source/queue.c **** {
 1108              		.loc 1 1278 0
 1109              		.cfi_startproc
 1110              		@ args = 0, pretend = 0, frame = 40
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 47


 1111              		@ frame_needed = 1, uses_anonymous_args = 0
 1112 0000 80B5     		push	{r7, lr}
 1113              		.cfi_def_cfa_offset 8
 1114              		.cfi_offset 7, -8
 1115              		.cfi_offset 14, -4
 1116 0002 8AB0     		sub	sp, sp, #40
 1117              		.cfi_def_cfa_offset 48
 1118 0004 00AF     		add	r7, sp, #0
 1119              		.cfi_def_cfa_register 7
 1120 0006 F860     		str	r0, [r7, #12]
 1121 0008 B960     		str	r1, [r7, #8]
 1122 000a 7A60     		str	r2, [r7, #4]
1279:Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
 1123              		.loc 1 1279 0
 1124 000c 0023     		movs	r3, #0
 1125 000e 7B62     		str	r3, [r7, #36]
1280:Source/queue.c **** TimeOut_t xTimeOut;
1281:Source/queue.c **** Queue_t * const pxQueue = xQueue;
 1126              		.loc 1 1281 0
 1127 0010 FB68     		ldr	r3, [r7, #12]
 1128 0012 3B62     		str	r3, [r7, #32]
 1129              	.L76:
1282:Source/queue.c **** 
1283:Source/queue.c **** 	/* Check the pointer is not NULL. */
1284:Source/queue.c **** 	configASSERT( ( pxQueue ) );
1285:Source/queue.c **** 
1286:Source/queue.c **** 	/* The buffer into which data is received can only be NULL if the data size
1287:Source/queue.c **** 	is zero (so no data is copied into the buffer. */
1288:Source/queue.c **** 	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) )
1289:Source/queue.c **** 
1290:Source/queue.c **** 	/* Cannot block if the scheduler is suspended. */
1291:Source/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1292:Source/queue.c **** 	{
1293:Source/queue.c **** 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 )
1294:Source/queue.c **** 	}
1295:Source/queue.c **** 	#endif
1296:Source/queue.c **** 
1297:Source/queue.c **** 
1298:Source/queue.c **** 	/*lint -save -e904  This function relaxes the coding standard somewhat to
1299:Source/queue.c **** 	allow return statements within the function itself.  This is done in the
1300:Source/queue.c **** 	interest of execution time efficiency. */
1301:Source/queue.c **** 	for( ;; )
1302:Source/queue.c **** 	{
1303:Source/queue.c **** 		taskENTER_CRITICAL();
 1130              		.loc 1 1303 0
 1131 0014 FFF7FEFF 		bl	vPortEnterCritical
 1132              	.LBB34:
1304:Source/queue.c **** 		{
1305:Source/queue.c **** 			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 1133              		.loc 1 1305 0
 1134 0018 3B6A     		ldr	r3, [r7, #32]
 1135 001a 9B6B     		ldr	r3, [r3, #56]
 1136 001c FB61     		str	r3, [r7, #28]
1306:Source/queue.c **** 
1307:Source/queue.c **** 			/* Is there data in the queue now?  To be running the calling task
1308:Source/queue.c **** 			must be the highest priority task wanting to access the queue. */
1309:Source/queue.c **** 			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 48


 1137              		.loc 1 1309 0
 1138 001e FB69     		ldr	r3, [r7, #28]
 1139 0020 002B     		cmp	r3, #0
 1140 0022 1FD0     		beq	.L65
1310:Source/queue.c **** 			{
1311:Source/queue.c **** 				/* Data available, remove one item. */
1312:Source/queue.c **** 				prvCopyDataFromQueue( pxQueue, pvBuffer );
 1141              		.loc 1 1312 0
 1142 0024 B968     		ldr	r1, [r7, #8]
 1143 0026 386A     		ldr	r0, [r7, #32]
 1144 0028 FFF7FEFF 		bl	prvCopyDataFromQueue
1313:Source/queue.c **** 				traceQUEUE_RECEIVE( pxQueue );
1314:Source/queue.c **** 				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 1145              		.loc 1 1314 0
 1146 002c FB69     		ldr	r3, [r7, #28]
 1147 002e 5A1E     		subs	r2, r3, #1
 1148 0030 3B6A     		ldr	r3, [r7, #32]
 1149 0032 9A63     		str	r2, [r3, #56]
1315:Source/queue.c **** 
1316:Source/queue.c **** 				/* There is now space in the queue, were any tasks waiting to
1317:Source/queue.c **** 				post to the queue?  If so, unblock the highest priority waiting
1318:Source/queue.c **** 				task. */
1319:Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 1150              		.loc 1 1319 0
 1151 0034 3B6A     		ldr	r3, [r7, #32]
 1152 0036 1B69     		ldr	r3, [r3, #16]
 1153 0038 002B     		cmp	r3, #0
 1154 003a 0FD0     		beq	.L66
1320:Source/queue.c **** 				{
1321:Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 1155              		.loc 1 1321 0
 1156 003c 3B6A     		ldr	r3, [r7, #32]
 1157 003e 1033     		adds	r3, r3, #16
 1158 0040 1846     		mov	r0, r3
 1159 0042 FFF7FEFF 		bl	xTaskRemoveFromEventList
 1160 0046 0346     		mov	r3, r0
 1161 0048 002B     		cmp	r3, #0
 1162 004a 07D0     		beq	.L66
1322:Source/queue.c **** 					{
1323:Source/queue.c **** 						queueYIELD_IF_USING_PREEMPTION();
 1163              		.loc 1 1323 0
 1164 004c 3C4B     		ldr	r3, .L78
 1165 004e 4FF08052 		mov	r2, #268435456
 1166 0052 1A60     		str	r2, [r3]
 1167              		.syntax unified
 1168              	@ 1323 "Source\queue.c" 1
 1169 0054 BFF34F8F 		dsb
 1170              	@ 0 "" 2
 1171              	@ 1323 "Source\queue.c" 1
 1172 0058 BFF36F8F 		isb
 1173              	@ 0 "" 2
 1174              		.thumb
 1175              		.syntax unified
 1176              	.L66:
1324:Source/queue.c **** 					}
1325:Source/queue.c **** 					else
1326:Source/queue.c **** 					{
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 49


1327:Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1328:Source/queue.c **** 					}
1329:Source/queue.c **** 				}
1330:Source/queue.c **** 				else
1331:Source/queue.c **** 				{
1332:Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1333:Source/queue.c **** 				}
1334:Source/queue.c **** 
1335:Source/queue.c **** 				taskEXIT_CRITICAL();
 1177              		.loc 1 1335 0
 1178 005c FFF7FEFF 		bl	vPortExitCritical
1336:Source/queue.c **** 				return pdPASS;
 1179              		.loc 1 1336 0
 1180 0060 0123     		movs	r3, #1
 1181 0062 69E0     		b	.L77
 1182              	.L65:
1337:Source/queue.c **** 			}
1338:Source/queue.c **** 			else
1339:Source/queue.c **** 			{
1340:Source/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
 1183              		.loc 1 1340 0
 1184 0064 7B68     		ldr	r3, [r7, #4]
 1185 0066 002B     		cmp	r3, #0
 1186 0068 03D1     		bne	.L68
1341:Source/queue.c **** 				{
1342:Source/queue.c **** 					/* The queue was empty and no block time is specified (or
1343:Source/queue.c **** 					the block time has expired) so leave now. */
1344:Source/queue.c **** 					taskEXIT_CRITICAL();
 1187              		.loc 1 1344 0
 1188 006a FFF7FEFF 		bl	vPortExitCritical
1345:Source/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
1346:Source/queue.c **** 					return errQUEUE_EMPTY;
 1189              		.loc 1 1346 0
 1190 006e 0023     		movs	r3, #0
 1191 0070 62E0     		b	.L77
 1192              	.L68:
1347:Source/queue.c **** 				}
1348:Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 1193              		.loc 1 1348 0
 1194 0072 7B6A     		ldr	r3, [r7, #36]
 1195 0074 002B     		cmp	r3, #0
 1196 0076 06D1     		bne	.L69
1349:Source/queue.c **** 				{
1350:Source/queue.c **** 					/* The queue was empty and a block time was specified so
1351:Source/queue.c **** 					configure the timeout structure. */
1352:Source/queue.c **** 					vTaskInternalSetTimeOutState( &xTimeOut );
 1197              		.loc 1 1352 0
 1198 0078 07F11403 		add	r3, r7, #20
 1199 007c 1846     		mov	r0, r3
 1200 007e FFF7FEFF 		bl	vTaskInternalSetTimeOutState
1353:Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 1201              		.loc 1 1353 0
 1202 0082 0123     		movs	r3, #1
 1203 0084 7B62     		str	r3, [r7, #36]
 1204              	.L69:
 1205              	.LBE34:
1354:Source/queue.c **** 				}
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 50


1355:Source/queue.c **** 				else
1356:Source/queue.c **** 				{
1357:Source/queue.c **** 					/* Entry time was already set. */
1358:Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1359:Source/queue.c **** 				}
1360:Source/queue.c **** 			}
1361:Source/queue.c **** 		}
1362:Source/queue.c **** 		taskEXIT_CRITICAL();
 1206              		.loc 1 1362 0
 1207 0086 FFF7FEFF 		bl	vPortExitCritical
1363:Source/queue.c **** 
1364:Source/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
1365:Source/queue.c **** 		now the critical section has been exited. */
1366:Source/queue.c **** 
1367:Source/queue.c **** 		vTaskSuspendAll();
 1208              		.loc 1 1367 0
 1209 008a FFF7FEFF 		bl	vTaskSuspendAll
1368:Source/queue.c **** 		prvLockQueue( pxQueue );
 1210              		.loc 1 1368 0
 1211 008e FFF7FEFF 		bl	vPortEnterCritical
 1212 0092 3B6A     		ldr	r3, [r7, #32]
 1213 0094 93F84430 		ldrb	r3, [r3, #68]
 1214 0098 5BB2     		sxtb	r3, r3
 1215 009a B3F1FF3F 		cmp	r3, #-1
 1216 009e 03D1     		bne	.L70
 1217              		.loc 1 1368 0 is_stmt 0 discriminator 1
 1218 00a0 3B6A     		ldr	r3, [r7, #32]
 1219 00a2 0022     		movs	r2, #0
 1220 00a4 83F84420 		strb	r2, [r3, #68]
 1221              	.L70:
 1222              		.loc 1 1368 0 discriminator 3
 1223 00a8 3B6A     		ldr	r3, [r7, #32]
 1224 00aa 93F84530 		ldrb	r3, [r3, #69]
 1225 00ae 5BB2     		sxtb	r3, r3
 1226 00b0 B3F1FF3F 		cmp	r3, #-1
 1227 00b4 03D1     		bne	.L71
 1228              		.loc 1 1368 0 discriminator 4
 1229 00b6 3B6A     		ldr	r3, [r7, #32]
 1230 00b8 0022     		movs	r2, #0
 1231 00ba 83F84520 		strb	r2, [r3, #69]
 1232              	.L71:
 1233              		.loc 1 1368 0 discriminator 6
 1234 00be FFF7FEFF 		bl	vPortExitCritical
1369:Source/queue.c **** 
1370:Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
1371:Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 1235              		.loc 1 1371 0 is_stmt 1 discriminator 6
 1236 00c2 3A1D     		adds	r2, r7, #4
 1237 00c4 07F11403 		add	r3, r7, #20
 1238 00c8 1146     		mov	r1, r2
 1239 00ca 1846     		mov	r0, r3
 1240 00cc FFF7FEFF 		bl	xTaskCheckForTimeOut
 1241 00d0 0346     		mov	r3, r0
 1242 00d2 002B     		cmp	r3, #0
 1243 00d4 23D1     		bne	.L72
1372:Source/queue.c **** 		{
1373:Source/queue.c **** 			/* The timeout has not expired.  If the queue is still empty place
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 51


1374:Source/queue.c **** 			the task on the list of tasks waiting to receive from the queue. */
1375:Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 1244              		.loc 1 1375 0
 1245 00d6 386A     		ldr	r0, [r7, #32]
 1246 00d8 FFF7FEFF 		bl	prvIsQueueEmpty
 1247 00dc 0346     		mov	r3, r0
 1248 00de 002B     		cmp	r3, #0
 1249 00e0 17D0     		beq	.L73
1376:Source/queue.c **** 			{
1377:Source/queue.c **** 				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
1378:Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 1250              		.loc 1 1378 0
 1251 00e2 3B6A     		ldr	r3, [r7, #32]
 1252 00e4 2433     		adds	r3, r3, #36
 1253 00e6 7A68     		ldr	r2, [r7, #4]
 1254 00e8 1146     		mov	r1, r2
 1255 00ea 1846     		mov	r0, r3
 1256 00ec FFF7FEFF 		bl	vTaskPlaceOnEventList
1379:Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1257              		.loc 1 1379 0
 1258 00f0 386A     		ldr	r0, [r7, #32]
 1259 00f2 FFF7FEFF 		bl	prvUnlockQueue
1380:Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 1260              		.loc 1 1380 0
 1261 00f6 FFF7FEFF 		bl	xTaskResumeAll
 1262 00fa 0346     		mov	r3, r0
 1263 00fc 002B     		cmp	r3, #0
 1264 00fe 89D1     		bne	.L76
1381:Source/queue.c **** 				{
1382:Source/queue.c **** 					portYIELD_WITHIN_API();
 1265              		.loc 1 1382 0
 1266 0100 0F4B     		ldr	r3, .L78
 1267 0102 4FF08052 		mov	r2, #268435456
 1268 0106 1A60     		str	r2, [r3]
 1269              		.syntax unified
 1270              	@ 1382 "Source\queue.c" 1
 1271 0108 BFF34F8F 		dsb
 1272              	@ 0 "" 2
 1273              	@ 1382 "Source\queue.c" 1
 1274 010c BFF36F8F 		isb
 1275              	@ 0 "" 2
 1276              		.thumb
 1277              		.syntax unified
 1278 0110 80E7     		b	.L76
 1279              	.L73:
1383:Source/queue.c **** 				}
1384:Source/queue.c **** 				else
1385:Source/queue.c **** 				{
1386:Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1387:Source/queue.c **** 				}
1388:Source/queue.c **** 			}
1389:Source/queue.c **** 			else
1390:Source/queue.c **** 			{
1391:Source/queue.c **** 				/* The queue contains data again.  Loop back to try and read the
1392:Source/queue.c **** 				data. */
1393:Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1280              		.loc 1 1393 0
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 52


 1281 0112 386A     		ldr	r0, [r7, #32]
 1282 0114 FFF7FEFF 		bl	prvUnlockQueue
1394:Source/queue.c **** 				( void ) xTaskResumeAll();
 1283              		.loc 1 1394 0
 1284 0118 FFF7FEFF 		bl	xTaskResumeAll
 1285 011c 7AE7     		b	.L76
 1286              	.L72:
1395:Source/queue.c **** 			}
1396:Source/queue.c **** 		}
1397:Source/queue.c **** 		else
1398:Source/queue.c **** 		{
1399:Source/queue.c **** 			/* Timed out.  If there is no data in the queue exit, otherwise loop
1400:Source/queue.c **** 			back and attempt to read the data. */
1401:Source/queue.c **** 			prvUnlockQueue( pxQueue );
 1287              		.loc 1 1401 0
 1288 011e 386A     		ldr	r0, [r7, #32]
 1289 0120 FFF7FEFF 		bl	prvUnlockQueue
1402:Source/queue.c **** 			( void ) xTaskResumeAll();
 1290              		.loc 1 1402 0
 1291 0124 FFF7FEFF 		bl	xTaskResumeAll
1403:Source/queue.c **** 
1404:Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 1292              		.loc 1 1404 0
 1293 0128 386A     		ldr	r0, [r7, #32]
 1294 012a FFF7FEFF 		bl	prvIsQueueEmpty
 1295 012e 0346     		mov	r3, r0
 1296 0130 002B     		cmp	r3, #0
 1297 0132 3FF46FAF 		beq	.L76
1405:Source/queue.c **** 			{
1406:Source/queue.c **** 				traceQUEUE_RECEIVE_FAILED( pxQueue );
1407:Source/queue.c **** 				return errQUEUE_EMPTY;
 1298              		.loc 1 1407 0
 1299 0136 0023     		movs	r3, #0
 1300              	.L77:
1408:Source/queue.c **** 			}
1409:Source/queue.c **** 			else
1410:Source/queue.c **** 			{
1411:Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
1412:Source/queue.c **** 			}
1413:Source/queue.c **** 		}
1414:Source/queue.c **** 	} /*lint -restore */
1415:Source/queue.c **** }
 1301              		.loc 1 1415 0 discriminator 3
 1302 0138 1846     		mov	r0, r3
 1303 013a 2837     		adds	r7, r7, #40
 1304              		.cfi_def_cfa_offset 8
 1305 013c BD46     		mov	sp, r7
 1306              		.cfi_def_cfa_register 13
 1307              		@ sp needed
 1308 013e 80BD     		pop	{r7, pc}
 1309              	.L79:
 1310              		.align	2
 1311              	.L78:
 1312 0140 04ED00E0 		.word	-536810236
 1313              		.cfi_endproc
 1314              	.LFE79:
 1315              		.size	xQueueReceive, .-xQueueReceive
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 53


 1316              		.section	.text.xQueueSemaphoreTake,"ax",%progbits
 1317              		.align	2
 1318              		.global	xQueueSemaphoreTake
 1319              		.thumb
 1320              		.thumb_func
 1321              		.type	xQueueSemaphoreTake, %function
 1322              	xQueueSemaphoreTake:
 1323              	.LFB80:
1416:Source/queue.c **** /*-----------------------------------------------------------*/
1417:Source/queue.c **** 
1418:Source/queue.c **** BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
1419:Source/queue.c **** {
 1324              		.loc 1 1419 0
 1325              		.cfi_startproc
 1326              		@ args = 0, pretend = 0, frame = 40
 1327              		@ frame_needed = 1, uses_anonymous_args = 0
 1328 0000 80B5     		push	{r7, lr}
 1329              		.cfi_def_cfa_offset 8
 1330              		.cfi_offset 7, -8
 1331              		.cfi_offset 14, -4
 1332 0002 8AB0     		sub	sp, sp, #40
 1333              		.cfi_def_cfa_offset 48
 1334 0004 00AF     		add	r7, sp, #0
 1335              		.cfi_def_cfa_register 7
 1336 0006 7860     		str	r0, [r7, #4]
 1337 0008 3960     		str	r1, [r7]
1420:Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
 1338              		.loc 1 1420 0
 1339 000a 0023     		movs	r3, #0
 1340 000c 7B62     		str	r3, [r7, #36]
1421:Source/queue.c **** TimeOut_t xTimeOut;
1422:Source/queue.c **** Queue_t * const pxQueue = xQueue;
 1341              		.loc 1 1422 0
 1342 000e 7B68     		ldr	r3, [r7, #4]
 1343 0010 FB61     		str	r3, [r7, #28]
1423:Source/queue.c **** 
1424:Source/queue.c **** #if( configUSE_MUTEXES == 1 )
1425:Source/queue.c **** 	BaseType_t xInheritanceOccurred = pdFALSE;
 1344              		.loc 1 1425 0
 1345 0012 0023     		movs	r3, #0
 1346 0014 3B62     		str	r3, [r7, #32]
 1347              	.L95:
1426:Source/queue.c **** #endif
1427:Source/queue.c **** 
1428:Source/queue.c **** 	/* Check the queue pointer is not NULL. */
1429:Source/queue.c **** 	configASSERT( ( pxQueue ) );
1430:Source/queue.c **** 
1431:Source/queue.c **** 	/* Check this really is a semaphore, in which case the item size will be
1432:Source/queue.c **** 	0. */
1433:Source/queue.c **** 	configASSERT( pxQueue->uxItemSize == 0 );
1434:Source/queue.c **** 
1435:Source/queue.c **** 	/* Cannot block if the scheduler is suspended. */
1436:Source/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1437:Source/queue.c **** 	{
1438:Source/queue.c **** 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 )
1439:Source/queue.c **** 	}
1440:Source/queue.c **** 	#endif
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 54


1441:Source/queue.c **** 
1442:Source/queue.c **** 
1443:Source/queue.c **** 	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
1444:Source/queue.c **** 	statements within the function itself.  This is done in the interest
1445:Source/queue.c **** 	of execution time efficiency. */
1446:Source/queue.c **** 	for( ;; )
1447:Source/queue.c **** 	{
1448:Source/queue.c **** 		taskENTER_CRITICAL();
 1348              		.loc 1 1448 0
 1349 0016 FFF7FEFF 		bl	vPortEnterCritical
 1350              	.LBB35:
1449:Source/queue.c **** 		{
1450:Source/queue.c **** 			/* Semaphores are queues with an item size of 0, and where the
1451:Source/queue.c **** 			number of messages in the queue is the semaphore's count value. */
1452:Source/queue.c **** 			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
 1351              		.loc 1 1452 0
 1352 001a FB69     		ldr	r3, [r7, #28]
 1353 001c 9B6B     		ldr	r3, [r3, #56]
 1354 001e BB61     		str	r3, [r7, #24]
1453:Source/queue.c **** 
1454:Source/queue.c **** 			/* Is there data in the queue now?  To be running the calling task
1455:Source/queue.c **** 			must be the highest priority task wanting to access the queue. */
1456:Source/queue.c **** 			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
 1355              		.loc 1 1456 0
 1356 0020 BB69     		ldr	r3, [r7, #24]
 1357 0022 002B     		cmp	r3, #0
 1358 0024 24D0     		beq	.L81
1457:Source/queue.c **** 			{
1458:Source/queue.c **** 				traceQUEUE_RECEIVE( pxQueue );
1459:Source/queue.c **** 
1460:Source/queue.c **** 				/* Semaphores are queues with a data size of zero and where the
1461:Source/queue.c **** 				messages waiting is the semaphore's count.  Reduce the count. */
1462:Source/queue.c **** 				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
 1359              		.loc 1 1462 0
 1360 0026 BB69     		ldr	r3, [r7, #24]
 1361 0028 5A1E     		subs	r2, r3, #1
 1362 002a FB69     		ldr	r3, [r7, #28]
 1363 002c 9A63     		str	r2, [r3, #56]
1463:Source/queue.c **** 
1464:Source/queue.c **** 				#if ( configUSE_MUTEXES == 1 )
1465:Source/queue.c **** 				{
1466:Source/queue.c **** 					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 1364              		.loc 1 1466 0
 1365 002e FB69     		ldr	r3, [r7, #28]
 1366 0030 1B68     		ldr	r3, [r3]
 1367 0032 002B     		cmp	r3, #0
 1368 0034 04D1     		bne	.L82
1467:Source/queue.c **** 					{
1468:Source/queue.c **** 						/* Record the information required to implement
1469:Source/queue.c **** 						priority inheritance should it become necessary. */
1470:Source/queue.c **** 						pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
 1369              		.loc 1 1470 0
 1370 0036 FFF7FEFF 		bl	pvTaskIncrementMutexHeldCount
 1371 003a 0246     		mov	r2, r0
 1372 003c FB69     		ldr	r3, [r7, #28]
 1373 003e 9A60     		str	r2, [r3, #8]
 1374              	.L82:
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 55


1471:Source/queue.c **** 					}
1472:Source/queue.c **** 					else
1473:Source/queue.c **** 					{
1474:Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1475:Source/queue.c **** 					}
1476:Source/queue.c **** 				}
1477:Source/queue.c **** 				#endif /* configUSE_MUTEXES */
1478:Source/queue.c **** 
1479:Source/queue.c **** 				/* Check to see if other tasks are blocked waiting to give the
1480:Source/queue.c **** 				semaphore, and if so, unblock the highest priority such task. */
1481:Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 1375              		.loc 1 1481 0
 1376 0040 FB69     		ldr	r3, [r7, #28]
 1377 0042 1B69     		ldr	r3, [r3, #16]
 1378 0044 002B     		cmp	r3, #0
 1379 0046 0FD0     		beq	.L83
1482:Source/queue.c **** 				{
1483:Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 1380              		.loc 1 1483 0
 1381 0048 FB69     		ldr	r3, [r7, #28]
 1382 004a 1033     		adds	r3, r3, #16
 1383 004c 1846     		mov	r0, r3
 1384 004e FFF7FEFF 		bl	xTaskRemoveFromEventList
 1385 0052 0346     		mov	r3, r0
 1386 0054 002B     		cmp	r3, #0
 1387 0056 07D0     		beq	.L83
1484:Source/queue.c **** 					{
1485:Source/queue.c **** 						queueYIELD_IF_USING_PREEMPTION();
 1388              		.loc 1 1485 0
 1389 0058 4C4B     		ldr	r3, .L97
 1390 005a 4FF08052 		mov	r2, #268435456
 1391 005e 1A60     		str	r2, [r3]
 1392              		.syntax unified
 1393              	@ 1485 "Source\queue.c" 1
 1394 0060 BFF34F8F 		dsb
 1395              	@ 0 "" 2
 1396              	@ 1485 "Source\queue.c" 1
 1397 0064 BFF36F8F 		isb
 1398              	@ 0 "" 2
 1399              		.thumb
 1400              		.syntax unified
 1401              	.L83:
1486:Source/queue.c **** 					}
1487:Source/queue.c **** 					else
1488:Source/queue.c **** 					{
1489:Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1490:Source/queue.c **** 					}
1491:Source/queue.c **** 				}
1492:Source/queue.c **** 				else
1493:Source/queue.c **** 				{
1494:Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1495:Source/queue.c **** 				}
1496:Source/queue.c **** 
1497:Source/queue.c **** 				taskEXIT_CRITICAL();
 1402              		.loc 1 1497 0
 1403 0068 FFF7FEFF 		bl	vPortExitCritical
1498:Source/queue.c **** 				return pdPASS;
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 56


 1404              		.loc 1 1498 0
 1405 006c 0123     		movs	r3, #1
 1406 006e 89E0     		b	.L96
 1407              	.L81:
1499:Source/queue.c **** 			}
1500:Source/queue.c **** 			else
1501:Source/queue.c **** 			{
1502:Source/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
 1408              		.loc 1 1502 0
 1409 0070 3B68     		ldr	r3, [r7]
 1410 0072 002B     		cmp	r3, #0
 1411 0074 03D1     		bne	.L85
1503:Source/queue.c **** 				{
1504:Source/queue.c **** 					/* For inheritance to have occurred there must have been an
1505:Source/queue.c **** 					initial timeout, and an adjusted timeout cannot become 0, as
1506:Source/queue.c **** 					if it were 0 the function would have exited. */
1507:Source/queue.c **** 					#if( configUSE_MUTEXES == 1 )
1508:Source/queue.c **** 					{
1509:Source/queue.c **** 						configASSERT( xInheritanceOccurred == pdFALSE );
1510:Source/queue.c **** 					}
1511:Source/queue.c **** 					#endif /* configUSE_MUTEXES */
1512:Source/queue.c **** 
1513:Source/queue.c **** 					/* The semaphore count was 0 and no block time is specified
1514:Source/queue.c **** 					(or the block time has expired) so exit now. */
1515:Source/queue.c **** 					taskEXIT_CRITICAL();
 1412              		.loc 1 1515 0
 1413 0076 FFF7FEFF 		bl	vPortExitCritical
1516:Source/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
1517:Source/queue.c **** 					return errQUEUE_EMPTY;
 1414              		.loc 1 1517 0
 1415 007a 0023     		movs	r3, #0
 1416 007c 82E0     		b	.L96
 1417              	.L85:
1518:Source/queue.c **** 				}
1519:Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 1418              		.loc 1 1519 0
 1419 007e 7B6A     		ldr	r3, [r7, #36]
 1420 0080 002B     		cmp	r3, #0
 1421 0082 06D1     		bne	.L86
1520:Source/queue.c **** 				{
1521:Source/queue.c **** 					/* The semaphore count was 0 and a block time was specified
1522:Source/queue.c **** 					so configure the timeout structure ready to block. */
1523:Source/queue.c **** 					vTaskInternalSetTimeOutState( &xTimeOut );
 1422              		.loc 1 1523 0
 1423 0084 07F10C03 		add	r3, r7, #12
 1424 0088 1846     		mov	r0, r3
 1425 008a FFF7FEFF 		bl	vTaskInternalSetTimeOutState
1524:Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 1426              		.loc 1 1524 0
 1427 008e 0123     		movs	r3, #1
 1428 0090 7B62     		str	r3, [r7, #36]
 1429              	.L86:
 1430              	.LBE35:
1525:Source/queue.c **** 				}
1526:Source/queue.c **** 				else
1527:Source/queue.c **** 				{
1528:Source/queue.c **** 					/* Entry time was already set. */
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 57


1529:Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1530:Source/queue.c **** 				}
1531:Source/queue.c **** 			}
1532:Source/queue.c **** 		}
1533:Source/queue.c **** 		taskEXIT_CRITICAL();
 1431              		.loc 1 1533 0
 1432 0092 FFF7FEFF 		bl	vPortExitCritical
1534:Source/queue.c **** 
1535:Source/queue.c **** 		/* Interrupts and other tasks can give to and take from the semaphore
1536:Source/queue.c **** 		now the critical section has been exited. */
1537:Source/queue.c **** 
1538:Source/queue.c **** 		vTaskSuspendAll();
 1433              		.loc 1 1538 0
 1434 0096 FFF7FEFF 		bl	vTaskSuspendAll
1539:Source/queue.c **** 		prvLockQueue( pxQueue );
 1435              		.loc 1 1539 0
 1436 009a FFF7FEFF 		bl	vPortEnterCritical
 1437 009e FB69     		ldr	r3, [r7, #28]
 1438 00a0 93F84430 		ldrb	r3, [r3, #68]
 1439 00a4 5BB2     		sxtb	r3, r3
 1440 00a6 B3F1FF3F 		cmp	r3, #-1
 1441 00aa 03D1     		bne	.L87
 1442              		.loc 1 1539 0 is_stmt 0 discriminator 1
 1443 00ac FB69     		ldr	r3, [r7, #28]
 1444 00ae 0022     		movs	r2, #0
 1445 00b0 83F84420 		strb	r2, [r3, #68]
 1446              	.L87:
 1447              		.loc 1 1539 0 discriminator 3
 1448 00b4 FB69     		ldr	r3, [r7, #28]
 1449 00b6 93F84530 		ldrb	r3, [r3, #69]
 1450 00ba 5BB2     		sxtb	r3, r3
 1451 00bc B3F1FF3F 		cmp	r3, #-1
 1452 00c0 03D1     		bne	.L88
 1453              		.loc 1 1539 0 discriminator 4
 1454 00c2 FB69     		ldr	r3, [r7, #28]
 1455 00c4 0022     		movs	r2, #0
 1456 00c6 83F84520 		strb	r2, [r3, #69]
 1457              	.L88:
 1458              		.loc 1 1539 0 discriminator 6
 1459 00ca FFF7FEFF 		bl	vPortExitCritical
1540:Source/queue.c **** 
1541:Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
1542:Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 1460              		.loc 1 1542 0 is_stmt 1 discriminator 6
 1461 00ce 3A46     		mov	r2, r7
 1462 00d0 07F10C03 		add	r3, r7, #12
 1463 00d4 1146     		mov	r1, r2
 1464 00d6 1846     		mov	r0, r3
 1465 00d8 FFF7FEFF 		bl	xTaskCheckForTimeOut
 1466 00dc 0346     		mov	r3, r0
 1467 00de 002B     		cmp	r3, #0
 1468 00e0 32D1     		bne	.L89
1543:Source/queue.c **** 		{
1544:Source/queue.c **** 			/* A block time is specified and not expired.  If the semaphore
1545:Source/queue.c **** 			count is 0 then enter the Blocked state to wait for a semaphore to
1546:Source/queue.c **** 			become available.  As semaphores are implemented with queues the
1547:Source/queue.c **** 			queue being empty is equivalent to the semaphore count being 0. */
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 58


1548:Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 1469              		.loc 1 1548 0
 1470 00e2 F869     		ldr	r0, [r7, #28]
 1471 00e4 FFF7FEFF 		bl	prvIsQueueEmpty
 1472 00e8 0346     		mov	r3, r0
 1473 00ea 002B     		cmp	r3, #0
 1474 00ec 26D0     		beq	.L90
1549:Source/queue.c **** 			{
1550:Source/queue.c **** 				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
1551:Source/queue.c **** 
1552:Source/queue.c **** 				#if ( configUSE_MUTEXES == 1 )
1553:Source/queue.c **** 				{
1554:Source/queue.c **** 					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 1475              		.loc 1 1554 0
 1476 00ee FB69     		ldr	r3, [r7, #28]
 1477 00f0 1B68     		ldr	r3, [r3]
 1478 00f2 002B     		cmp	r3, #0
 1479 00f4 09D1     		bne	.L91
1555:Source/queue.c **** 					{
1556:Source/queue.c **** 						taskENTER_CRITICAL();
 1480              		.loc 1 1556 0
 1481 00f6 FFF7FEFF 		bl	vPortEnterCritical
1557:Source/queue.c **** 						{
1558:Source/queue.c **** 							xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
 1482              		.loc 1 1558 0
 1483 00fa FB69     		ldr	r3, [r7, #28]
 1484 00fc 9B68     		ldr	r3, [r3, #8]
 1485 00fe 1846     		mov	r0, r3
 1486 0100 FFF7FEFF 		bl	xTaskPriorityInherit
 1487 0104 3862     		str	r0, [r7, #32]
1559:Source/queue.c **** 						}
1560:Source/queue.c **** 						taskEXIT_CRITICAL();
 1488              		.loc 1 1560 0
 1489 0106 FFF7FEFF 		bl	vPortExitCritical
 1490              	.L91:
1561:Source/queue.c **** 					}
1562:Source/queue.c **** 					else
1563:Source/queue.c **** 					{
1564:Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1565:Source/queue.c **** 					}
1566:Source/queue.c **** 				}
1567:Source/queue.c **** 				#endif
1568:Source/queue.c **** 
1569:Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 1491              		.loc 1 1569 0
 1492 010a FB69     		ldr	r3, [r7, #28]
 1493 010c 2433     		adds	r3, r3, #36
 1494 010e 3A68     		ldr	r2, [r7]
 1495 0110 1146     		mov	r1, r2
 1496 0112 1846     		mov	r0, r3
 1497 0114 FFF7FEFF 		bl	vTaskPlaceOnEventList
1570:Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1498              		.loc 1 1570 0
 1499 0118 F869     		ldr	r0, [r7, #28]
 1500 011a FFF7FEFF 		bl	prvUnlockQueue
1571:Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 1501              		.loc 1 1571 0
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 59


 1502 011e FFF7FEFF 		bl	xTaskResumeAll
 1503 0122 0346     		mov	r3, r0
 1504 0124 002B     		cmp	r3, #0
 1505 0126 7FF476AF 		bne	.L95
1572:Source/queue.c **** 				{
1573:Source/queue.c **** 					portYIELD_WITHIN_API();
 1506              		.loc 1 1573 0
 1507 012a 184B     		ldr	r3, .L97
 1508 012c 4FF08052 		mov	r2, #268435456
 1509 0130 1A60     		str	r2, [r3]
 1510              		.syntax unified
 1511              	@ 1573 "Source\queue.c" 1
 1512 0132 BFF34F8F 		dsb
 1513              	@ 0 "" 2
 1514              	@ 1573 "Source\queue.c" 1
 1515 0136 BFF36F8F 		isb
 1516              	@ 0 "" 2
 1517              		.thumb
 1518              		.syntax unified
 1519 013a 6CE7     		b	.L95
 1520              	.L90:
1574:Source/queue.c **** 				}
1575:Source/queue.c **** 				else
1576:Source/queue.c **** 				{
1577:Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1578:Source/queue.c **** 				}
1579:Source/queue.c **** 			}
1580:Source/queue.c **** 			else
1581:Source/queue.c **** 			{
1582:Source/queue.c **** 				/* There was no timeout and the semaphore count was not 0, so
1583:Source/queue.c **** 				attempt to take the semaphore again. */
1584:Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1521              		.loc 1 1584 0
 1522 013c F869     		ldr	r0, [r7, #28]
 1523 013e FFF7FEFF 		bl	prvUnlockQueue
1585:Source/queue.c **** 				( void ) xTaskResumeAll();
 1524              		.loc 1 1585 0
 1525 0142 FFF7FEFF 		bl	xTaskResumeAll
 1526 0146 66E7     		b	.L95
 1527              	.L89:
1586:Source/queue.c **** 			}
1587:Source/queue.c **** 		}
1588:Source/queue.c **** 		else
1589:Source/queue.c **** 		{
1590:Source/queue.c **** 			/* Timed out. */
1591:Source/queue.c **** 			prvUnlockQueue( pxQueue );
 1528              		.loc 1 1591 0
 1529 0148 F869     		ldr	r0, [r7, #28]
 1530 014a FFF7FEFF 		bl	prvUnlockQueue
1592:Source/queue.c **** 			( void ) xTaskResumeAll();
 1531              		.loc 1 1592 0
 1532 014e FFF7FEFF 		bl	xTaskResumeAll
1593:Source/queue.c **** 
1594:Source/queue.c **** 			/* If the semaphore count is 0 exit now as the timeout has
1595:Source/queue.c **** 			expired.  Otherwise return to attempt to take the semaphore that is
1596:Source/queue.c **** 			known to be available.  As semaphores are implemented by queues the
1597:Source/queue.c **** 			queue being empty is equivalent to the semaphore count being 0. */
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 60


1598:Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 1533              		.loc 1 1598 0
 1534 0152 F869     		ldr	r0, [r7, #28]
 1535 0154 FFF7FEFF 		bl	prvIsQueueEmpty
 1536 0158 0346     		mov	r3, r0
 1537 015a 002B     		cmp	r3, #0
 1538 015c 3FF45BAF 		beq	.L95
1599:Source/queue.c **** 			{
1600:Source/queue.c **** 				#if ( configUSE_MUTEXES == 1 )
1601:Source/queue.c **** 				{
1602:Source/queue.c **** 					/* xInheritanceOccurred could only have be set if
1603:Source/queue.c **** 					pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
1604:Source/queue.c **** 					test the mutex type again to check it is actually a mutex. */
1605:Source/queue.c **** 					if( xInheritanceOccurred != pdFALSE )
 1539              		.loc 1 1605 0
 1540 0160 3B6A     		ldr	r3, [r7, #32]
 1541 0162 002B     		cmp	r3, #0
 1542 0164 0DD0     		beq	.L94
1606:Source/queue.c **** 					{
1607:Source/queue.c **** 						taskENTER_CRITICAL();
 1543              		.loc 1 1607 0
 1544 0166 FFF7FEFF 		bl	vPortEnterCritical
 1545              	.LBB36:
1608:Source/queue.c **** 						{
1609:Source/queue.c **** 							UBaseType_t uxHighestWaitingPriority;
1610:Source/queue.c **** 
1611:Source/queue.c **** 							/* This task blocking on the mutex caused another
1612:Source/queue.c **** 							task to inherit this task's priority.  Now this task
1613:Source/queue.c **** 							has timed out the priority should be disinherited
1614:Source/queue.c **** 							again, but only as low as the next highest priority
1615:Source/queue.c **** 							task that is waiting for the same mutex. */
1616:Source/queue.c **** 							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
 1546              		.loc 1 1616 0
 1547 016a F869     		ldr	r0, [r7, #28]
 1548 016c FFF7FEFF 		bl	prvGetDisinheritPriorityAfterTimeout
 1549 0170 7861     		str	r0, [r7, #20]
1617:Source/queue.c **** 							vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPri
 1550              		.loc 1 1617 0
 1551 0172 FB69     		ldr	r3, [r7, #28]
 1552 0174 9B68     		ldr	r3, [r3, #8]
 1553 0176 7969     		ldr	r1, [r7, #20]
 1554 0178 1846     		mov	r0, r3
 1555 017a FFF7FEFF 		bl	vTaskPriorityDisinheritAfterTimeout
 1556              	.LBE36:
1618:Source/queue.c **** 						}
1619:Source/queue.c **** 						taskEXIT_CRITICAL();
 1557              		.loc 1 1619 0
 1558 017e FFF7FEFF 		bl	vPortExitCritical
 1559              	.L94:
1620:Source/queue.c **** 					}
1621:Source/queue.c **** 				}
1622:Source/queue.c **** 				#endif /* configUSE_MUTEXES */
1623:Source/queue.c **** 
1624:Source/queue.c **** 				traceQUEUE_RECEIVE_FAILED( pxQueue );
1625:Source/queue.c **** 				return errQUEUE_EMPTY;
 1560              		.loc 1 1625 0
 1561 0182 0023     		movs	r3, #0
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 61


 1562              	.L96:
1626:Source/queue.c **** 			}
1627:Source/queue.c **** 			else
1628:Source/queue.c **** 			{
1629:Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
1630:Source/queue.c **** 			}
1631:Source/queue.c **** 		}
1632:Source/queue.c **** 	} /*lint -restore */
1633:Source/queue.c **** }
 1563              		.loc 1 1633 0 discriminator 3
 1564 0184 1846     		mov	r0, r3
 1565 0186 2837     		adds	r7, r7, #40
 1566              		.cfi_def_cfa_offset 8
 1567 0188 BD46     		mov	sp, r7
 1568              		.cfi_def_cfa_register 13
 1569              		@ sp needed
 1570 018a 80BD     		pop	{r7, pc}
 1571              	.L98:
 1572              		.align	2
 1573              	.L97:
 1574 018c 04ED00E0 		.word	-536810236
 1575              		.cfi_endproc
 1576              	.LFE80:
 1577              		.size	xQueueSemaphoreTake, .-xQueueSemaphoreTake
 1578              		.section	.text.xQueuePeek,"ax",%progbits
 1579              		.align	2
 1580              		.global	xQueuePeek
 1581              		.thumb
 1582              		.thumb_func
 1583              		.type	xQueuePeek, %function
 1584              	xQueuePeek:
 1585              	.LFB81:
1634:Source/queue.c **** /*-----------------------------------------------------------*/
1635:Source/queue.c **** 
1636:Source/queue.c **** BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
1637:Source/queue.c **** {
 1586              		.loc 1 1637 0
 1587              		.cfi_startproc
 1588              		@ args = 0, pretend = 0, frame = 40
 1589              		@ frame_needed = 1, uses_anonymous_args = 0
 1590 0000 80B5     		push	{r7, lr}
 1591              		.cfi_def_cfa_offset 8
 1592              		.cfi_offset 7, -8
 1593              		.cfi_offset 14, -4
 1594 0002 8AB0     		sub	sp, sp, #40
 1595              		.cfi_def_cfa_offset 48
 1596 0004 00AF     		add	r7, sp, #0
 1597              		.cfi_def_cfa_register 7
 1598 0006 F860     		str	r0, [r7, #12]
 1599 0008 B960     		str	r1, [r7, #8]
 1600 000a 7A60     		str	r2, [r7, #4]
1638:Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
 1601              		.loc 1 1638 0
 1602 000c 0023     		movs	r3, #0
 1603 000e 7B62     		str	r3, [r7, #36]
1639:Source/queue.c **** TimeOut_t xTimeOut;
1640:Source/queue.c **** int8_t *pcOriginalReadPosition;
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 62


1641:Source/queue.c **** Queue_t * const pxQueue = xQueue;
 1604              		.loc 1 1641 0
 1605 0010 FB68     		ldr	r3, [r7, #12]
 1606 0012 3B62     		str	r3, [r7, #32]
 1607              	.L111:
1642:Source/queue.c **** 
1643:Source/queue.c **** 	/* Check the pointer is not NULL. */
1644:Source/queue.c **** 	configASSERT( ( pxQueue ) );
1645:Source/queue.c **** 
1646:Source/queue.c **** 	/* The buffer into which data is received can only be NULL if the data size
1647:Source/queue.c **** 	is zero (so no data is copied into the buffer. */
1648:Source/queue.c **** 	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) )
1649:Source/queue.c **** 
1650:Source/queue.c **** 	/* Cannot block if the scheduler is suspended. */
1651:Source/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1652:Source/queue.c **** 	{
1653:Source/queue.c **** 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 )
1654:Source/queue.c **** 	}
1655:Source/queue.c **** 	#endif
1656:Source/queue.c **** 
1657:Source/queue.c **** 
1658:Source/queue.c **** 	/*lint -save -e904  This function relaxes the coding standard somewhat to
1659:Source/queue.c **** 	allow return statements within the function itself.  This is done in the
1660:Source/queue.c **** 	interest of execution time efficiency. */
1661:Source/queue.c **** 	for( ;; )
1662:Source/queue.c **** 	{
1663:Source/queue.c **** 		taskENTER_CRITICAL();
 1608              		.loc 1 1663 0
 1609 0014 FFF7FEFF 		bl	vPortEnterCritical
 1610              	.LBB37:
1664:Source/queue.c **** 		{
1665:Source/queue.c **** 			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 1611              		.loc 1 1665 0
 1612 0018 3B6A     		ldr	r3, [r7, #32]
 1613 001a 9B6B     		ldr	r3, [r3, #56]
 1614 001c FB61     		str	r3, [r7, #28]
1666:Source/queue.c **** 
1667:Source/queue.c **** 			/* Is there data in the queue now?  To be running the calling task
1668:Source/queue.c **** 			must be the highest priority task wanting to access the queue. */
1669:Source/queue.c **** 			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 1615              		.loc 1 1669 0
 1616 001e FB69     		ldr	r3, [r7, #28]
 1617 0020 002B     		cmp	r3, #0
 1618 0022 21D0     		beq	.L100
1670:Source/queue.c **** 			{
1671:Source/queue.c **** 				/* Remember the read position so it can be reset after the data
1672:Source/queue.c **** 				is read from the queue as this function is only peeking the
1673:Source/queue.c **** 				data, not removing it. */
1674:Source/queue.c **** 				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
 1619              		.loc 1 1674 0
 1620 0024 3B6A     		ldr	r3, [r7, #32]
 1621 0026 DB68     		ldr	r3, [r3, #12]
 1622 0028 BB61     		str	r3, [r7, #24]
1675:Source/queue.c **** 
1676:Source/queue.c **** 				prvCopyDataFromQueue( pxQueue, pvBuffer );
 1623              		.loc 1 1676 0
 1624 002a B968     		ldr	r1, [r7, #8]
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 63


 1625 002c 386A     		ldr	r0, [r7, #32]
 1626 002e FFF7FEFF 		bl	prvCopyDataFromQueue
1677:Source/queue.c **** 				traceQUEUE_PEEK( pxQueue );
1678:Source/queue.c **** 
1679:Source/queue.c **** 				/* The data is not being removed, so reset the read pointer. */
1680:Source/queue.c **** 				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
 1627              		.loc 1 1680 0
 1628 0032 3B6A     		ldr	r3, [r7, #32]
 1629 0034 BA69     		ldr	r2, [r7, #24]
 1630 0036 DA60     		str	r2, [r3, #12]
1681:Source/queue.c **** 
1682:Source/queue.c **** 				/* The data is being left in the queue, so see if there are
1683:Source/queue.c **** 				any other tasks waiting for the data. */
1684:Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 1631              		.loc 1 1684 0
 1632 0038 3B6A     		ldr	r3, [r7, #32]
 1633 003a 5B6A     		ldr	r3, [r3, #36]
 1634 003c 002B     		cmp	r3, #0
 1635 003e 0FD0     		beq	.L101
1685:Source/queue.c **** 				{
1686:Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 1636              		.loc 1 1686 0
 1637 0040 3B6A     		ldr	r3, [r7, #32]
 1638 0042 2433     		adds	r3, r3, #36
 1639 0044 1846     		mov	r0, r3
 1640 0046 FFF7FEFF 		bl	xTaskRemoveFromEventList
 1641 004a 0346     		mov	r3, r0
 1642 004c 002B     		cmp	r3, #0
 1643 004e 07D0     		beq	.L101
1687:Source/queue.c **** 					{
1688:Source/queue.c **** 						/* The task waiting has a higher priority than this task. */
1689:Source/queue.c **** 						queueYIELD_IF_USING_PREEMPTION();
 1644              		.loc 1 1689 0
 1645 0050 3C4B     		ldr	r3, .L113
 1646 0052 4FF08052 		mov	r2, #268435456
 1647 0056 1A60     		str	r2, [r3]
 1648              		.syntax unified
 1649              	@ 1689 "Source\queue.c" 1
 1650 0058 BFF34F8F 		dsb
 1651              	@ 0 "" 2
 1652              	@ 1689 "Source\queue.c" 1
 1653 005c BFF36F8F 		isb
 1654              	@ 0 "" 2
 1655              		.thumb
 1656              		.syntax unified
 1657              	.L101:
1690:Source/queue.c **** 					}
1691:Source/queue.c **** 					else
1692:Source/queue.c **** 					{
1693:Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1694:Source/queue.c **** 					}
1695:Source/queue.c **** 				}
1696:Source/queue.c **** 				else
1697:Source/queue.c **** 				{
1698:Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1699:Source/queue.c **** 				}
1700:Source/queue.c **** 
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 64


1701:Source/queue.c **** 				taskEXIT_CRITICAL();
 1658              		.loc 1 1701 0
 1659 0060 FFF7FEFF 		bl	vPortExitCritical
1702:Source/queue.c **** 				return pdPASS;
 1660              		.loc 1 1702 0
 1661 0064 0123     		movs	r3, #1
 1662 0066 69E0     		b	.L112
 1663              	.L100:
1703:Source/queue.c **** 			}
1704:Source/queue.c **** 			else
1705:Source/queue.c **** 			{
1706:Source/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
 1664              		.loc 1 1706 0
 1665 0068 7B68     		ldr	r3, [r7, #4]
 1666 006a 002B     		cmp	r3, #0
 1667 006c 03D1     		bne	.L103
1707:Source/queue.c **** 				{
1708:Source/queue.c **** 					/* The queue was empty and no block time is specified (or
1709:Source/queue.c **** 					the block time has expired) so leave now. */
1710:Source/queue.c **** 					taskEXIT_CRITICAL();
 1668              		.loc 1 1710 0
 1669 006e FFF7FEFF 		bl	vPortExitCritical
1711:Source/queue.c **** 					traceQUEUE_PEEK_FAILED( pxQueue );
1712:Source/queue.c **** 					return errQUEUE_EMPTY;
 1670              		.loc 1 1712 0
 1671 0072 0023     		movs	r3, #0
 1672 0074 62E0     		b	.L112
 1673              	.L103:
1713:Source/queue.c **** 				}
1714:Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 1674              		.loc 1 1714 0
 1675 0076 7B6A     		ldr	r3, [r7, #36]
 1676 0078 002B     		cmp	r3, #0
 1677 007a 06D1     		bne	.L104
1715:Source/queue.c **** 				{
1716:Source/queue.c **** 					/* The queue was empty and a block time was specified so
1717:Source/queue.c **** 					configure the timeout structure ready to enter the blocked
1718:Source/queue.c **** 					state. */
1719:Source/queue.c **** 					vTaskInternalSetTimeOutState( &xTimeOut );
 1678              		.loc 1 1719 0
 1679 007c 07F11003 		add	r3, r7, #16
 1680 0080 1846     		mov	r0, r3
 1681 0082 FFF7FEFF 		bl	vTaskInternalSetTimeOutState
1720:Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 1682              		.loc 1 1720 0
 1683 0086 0123     		movs	r3, #1
 1684 0088 7B62     		str	r3, [r7, #36]
 1685              	.L104:
 1686              	.LBE37:
1721:Source/queue.c **** 				}
1722:Source/queue.c **** 				else
1723:Source/queue.c **** 				{
1724:Source/queue.c **** 					/* Entry time was already set. */
1725:Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1726:Source/queue.c **** 				}
1727:Source/queue.c **** 			}
1728:Source/queue.c **** 		}
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 65


1729:Source/queue.c **** 		taskEXIT_CRITICAL();
 1687              		.loc 1 1729 0
 1688 008a FFF7FEFF 		bl	vPortExitCritical
1730:Source/queue.c **** 
1731:Source/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
1732:Source/queue.c **** 		now the critical section has been exited. */
1733:Source/queue.c **** 
1734:Source/queue.c **** 		vTaskSuspendAll();
 1689              		.loc 1 1734 0
 1690 008e FFF7FEFF 		bl	vTaskSuspendAll
1735:Source/queue.c **** 		prvLockQueue( pxQueue );
 1691              		.loc 1 1735 0
 1692 0092 FFF7FEFF 		bl	vPortEnterCritical
 1693 0096 3B6A     		ldr	r3, [r7, #32]
 1694 0098 93F84430 		ldrb	r3, [r3, #68]
 1695 009c 5BB2     		sxtb	r3, r3
 1696 009e B3F1FF3F 		cmp	r3, #-1
 1697 00a2 03D1     		bne	.L105
 1698              		.loc 1 1735 0 is_stmt 0 discriminator 1
 1699 00a4 3B6A     		ldr	r3, [r7, #32]
 1700 00a6 0022     		movs	r2, #0
 1701 00a8 83F84420 		strb	r2, [r3, #68]
 1702              	.L105:
 1703              		.loc 1 1735 0 discriminator 3
 1704 00ac 3B6A     		ldr	r3, [r7, #32]
 1705 00ae 93F84530 		ldrb	r3, [r3, #69]
 1706 00b2 5BB2     		sxtb	r3, r3
 1707 00b4 B3F1FF3F 		cmp	r3, #-1
 1708 00b8 03D1     		bne	.L106
 1709              		.loc 1 1735 0 discriminator 4
 1710 00ba 3B6A     		ldr	r3, [r7, #32]
 1711 00bc 0022     		movs	r2, #0
 1712 00be 83F84520 		strb	r2, [r3, #69]
 1713              	.L106:
 1714              		.loc 1 1735 0 discriminator 6
 1715 00c2 FFF7FEFF 		bl	vPortExitCritical
1736:Source/queue.c **** 
1737:Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
1738:Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 1716              		.loc 1 1738 0 is_stmt 1 discriminator 6
 1717 00c6 3A1D     		adds	r2, r7, #4
 1718 00c8 07F11003 		add	r3, r7, #16
 1719 00cc 1146     		mov	r1, r2
 1720 00ce 1846     		mov	r0, r3
 1721 00d0 FFF7FEFF 		bl	xTaskCheckForTimeOut
 1722 00d4 0346     		mov	r3, r0
 1723 00d6 002B     		cmp	r3, #0
 1724 00d8 23D1     		bne	.L107
1739:Source/queue.c **** 		{
1740:Source/queue.c **** 			/* Timeout has not expired yet, check to see if there is data in the
1741:Source/queue.c **** 			queue now, and if not enter the Blocked state to wait for data. */
1742:Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 1725              		.loc 1 1742 0
 1726 00da 386A     		ldr	r0, [r7, #32]
 1727 00dc FFF7FEFF 		bl	prvIsQueueEmpty
 1728 00e0 0346     		mov	r3, r0
 1729 00e2 002B     		cmp	r3, #0
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 66


 1730 00e4 17D0     		beq	.L108
1743:Source/queue.c **** 			{
1744:Source/queue.c **** 				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
1745:Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 1731              		.loc 1 1745 0
 1732 00e6 3B6A     		ldr	r3, [r7, #32]
 1733 00e8 2433     		adds	r3, r3, #36
 1734 00ea 7A68     		ldr	r2, [r7, #4]
 1735 00ec 1146     		mov	r1, r2
 1736 00ee 1846     		mov	r0, r3
 1737 00f0 FFF7FEFF 		bl	vTaskPlaceOnEventList
1746:Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1738              		.loc 1 1746 0
 1739 00f4 386A     		ldr	r0, [r7, #32]
 1740 00f6 FFF7FEFF 		bl	prvUnlockQueue
1747:Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 1741              		.loc 1 1747 0
 1742 00fa FFF7FEFF 		bl	xTaskResumeAll
 1743 00fe 0346     		mov	r3, r0
 1744 0100 002B     		cmp	r3, #0
 1745 0102 87D1     		bne	.L111
1748:Source/queue.c **** 				{
1749:Source/queue.c **** 					portYIELD_WITHIN_API();
 1746              		.loc 1 1749 0
 1747 0104 0F4B     		ldr	r3, .L113
 1748 0106 4FF08052 		mov	r2, #268435456
 1749 010a 1A60     		str	r2, [r3]
 1750              		.syntax unified
 1751              	@ 1749 "Source\queue.c" 1
 1752 010c BFF34F8F 		dsb
 1753              	@ 0 "" 2
 1754              	@ 1749 "Source\queue.c" 1
 1755 0110 BFF36F8F 		isb
 1756              	@ 0 "" 2
 1757              		.thumb
 1758              		.syntax unified
 1759 0114 7EE7     		b	.L111
 1760              	.L108:
1750:Source/queue.c **** 				}
1751:Source/queue.c **** 				else
1752:Source/queue.c **** 				{
1753:Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1754:Source/queue.c **** 				}
1755:Source/queue.c **** 			}
1756:Source/queue.c **** 			else
1757:Source/queue.c **** 			{
1758:Source/queue.c **** 				/* There is data in the queue now, so don't enter the blocked
1759:Source/queue.c **** 				state, instead return to try and obtain the data. */
1760:Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1761              		.loc 1 1760 0
 1762 0116 386A     		ldr	r0, [r7, #32]
 1763 0118 FFF7FEFF 		bl	prvUnlockQueue
1761:Source/queue.c **** 				( void ) xTaskResumeAll();
 1764              		.loc 1 1761 0
 1765 011c FFF7FEFF 		bl	xTaskResumeAll
 1766 0120 78E7     		b	.L111
 1767              	.L107:
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 67


1762:Source/queue.c **** 			}
1763:Source/queue.c **** 		}
1764:Source/queue.c **** 		else
1765:Source/queue.c **** 		{
1766:Source/queue.c **** 			/* The timeout has expired.  If there is still no data in the queue
1767:Source/queue.c **** 			exit, otherwise go back and try to read the data again. */
1768:Source/queue.c **** 			prvUnlockQueue( pxQueue );
 1768              		.loc 1 1768 0
 1769 0122 386A     		ldr	r0, [r7, #32]
 1770 0124 FFF7FEFF 		bl	prvUnlockQueue
1769:Source/queue.c **** 			( void ) xTaskResumeAll();
 1771              		.loc 1 1769 0
 1772 0128 FFF7FEFF 		bl	xTaskResumeAll
1770:Source/queue.c **** 
1771:Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 1773              		.loc 1 1771 0
 1774 012c 386A     		ldr	r0, [r7, #32]
 1775 012e FFF7FEFF 		bl	prvIsQueueEmpty
 1776 0132 0346     		mov	r3, r0
 1777 0134 002B     		cmp	r3, #0
 1778 0136 3FF46DAF 		beq	.L111
1772:Source/queue.c **** 			{
1773:Source/queue.c **** 				traceQUEUE_PEEK_FAILED( pxQueue );
1774:Source/queue.c **** 				return errQUEUE_EMPTY;
 1779              		.loc 1 1774 0
 1780 013a 0023     		movs	r3, #0
 1781              	.L112:
1775:Source/queue.c **** 			}
1776:Source/queue.c **** 			else
1777:Source/queue.c **** 			{
1778:Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
1779:Source/queue.c **** 			}
1780:Source/queue.c **** 		}
1781:Source/queue.c **** 	} /*lint -restore */
1782:Source/queue.c **** }
 1782              		.loc 1 1782 0 discriminator 3
 1783 013c 1846     		mov	r0, r3
 1784 013e 2837     		adds	r7, r7, #40
 1785              		.cfi_def_cfa_offset 8
 1786 0140 BD46     		mov	sp, r7
 1787              		.cfi_def_cfa_register 13
 1788              		@ sp needed
 1789 0142 80BD     		pop	{r7, pc}
 1790              	.L114:
 1791              		.align	2
 1792              	.L113:
 1793 0144 04ED00E0 		.word	-536810236
 1794              		.cfi_endproc
 1795              	.LFE81:
 1796              		.size	xQueuePeek, .-xQueuePeek
 1797              		.section	.text.xQueueReceiveFromISR,"ax",%progbits
 1798              		.align	2
 1799              		.global	xQueueReceiveFromISR
 1800              		.thumb
 1801              		.thumb_func
 1802              		.type	xQueueReceiveFromISR, %function
 1803              	xQueueReceiveFromISR:
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 68


 1804              	.LFB82:
1783:Source/queue.c **** /*-----------------------------------------------------------*/
1784:Source/queue.c **** 
1785:Source/queue.c **** BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const px
1786:Source/queue.c **** {
 1805              		.loc 1 1786 0
 1806              		.cfi_startproc
 1807              		@ args = 0, pretend = 0, frame = 48
 1808              		@ frame_needed = 1, uses_anonymous_args = 0
 1809 0000 80B5     		push	{r7, lr}
 1810              		.cfi_def_cfa_offset 8
 1811              		.cfi_offset 7, -8
 1812              		.cfi_offset 14, -4
 1813 0002 8CB0     		sub	sp, sp, #48
 1814              		.cfi_def_cfa_offset 56
 1815 0004 00AF     		add	r7, sp, #0
 1816              		.cfi_def_cfa_register 7
 1817 0006 F860     		str	r0, [r7, #12]
 1818 0008 B960     		str	r1, [r7, #8]
 1819 000a 7A60     		str	r2, [r7, #4]
1787:Source/queue.c **** BaseType_t xReturn;
1788:Source/queue.c **** UBaseType_t uxSavedInterruptStatus;
1789:Source/queue.c **** Queue_t * const pxQueue = xQueue;
 1820              		.loc 1 1789 0
 1821 000c FB68     		ldr	r3, [r7, #12]
 1822 000e BB62     		str	r3, [r7, #40]
 1823              	.LBB38:
 1824              	.LBB39:
 213:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	(
 1825              		.loc 2 213 0
 1826              		.syntax unified
 1827              	@ 213 ".\Source\portable\GCC\ARM_CM3/portmacro.h" 1
 1828 0010 EFF31182 			mrs r2, basepri											
 1829 0014 4FF0A003 		mov r3, #160												
 1830 0018 83F31188 		msr basepri, r3											
 1831 001c BFF36F8F 		isb														
 1832 0020 BFF34F8F 		dsb														
 1833              	
 1834              	@ 0 "" 2
 1835              		.thumb
 1836              		.syntax unified
 1837 0024 7A61     		str	r2, [r7, #20]
 1838 0026 3B61     		str	r3, [r7, #16]
 225:.\Source\portable\GCC\ARM_CM3/portmacro.h **** }
 1839              		.loc 2 225 0
 1840 0028 7B69     		ldr	r3, [r7, #20]
 1841              	.LBE39:
 1842              	.LBE38:
1790:Source/queue.c **** 
1791:Source/queue.c **** 	configASSERT( pxQueue );
1792:Source/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1793:Source/queue.c **** 
1794:Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1795:Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1796:Source/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
1797:Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1798:Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 69


1799:Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1800:Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1801:Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
1802:Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1803:Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1804:Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1805:Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1806:Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1807:Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1808:Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1809:Source/queue.c **** 
1810:Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1843              		.loc 1 1810 0
 1844 002a 3B62     		str	r3, [r7, #32]
 1845              	.LBB40:
1811:Source/queue.c **** 	{
1812:Source/queue.c **** 		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 1846              		.loc 1 1812 0
 1847 002c BB6A     		ldr	r3, [r7, #40]
 1848 002e 9B6B     		ldr	r3, [r3, #56]
 1849 0030 FB61     		str	r3, [r7, #28]
1813:Source/queue.c **** 
1814:Source/queue.c **** 		/* Cannot block in an ISR, so check there is data available. */
1815:Source/queue.c **** 		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 1850              		.loc 1 1815 0
 1851 0032 FB69     		ldr	r3, [r7, #28]
 1852 0034 002B     		cmp	r3, #0
 1853 0036 2DD0     		beq	.L117
 1854              	.LBB41:
1816:Source/queue.c **** 		{
1817:Source/queue.c **** 			const int8_t cRxLock = pxQueue->cRxLock;
 1855              		.loc 1 1817 0
 1856 0038 BB6A     		ldr	r3, [r7, #40]
 1857 003a 93F84430 		ldrb	r3, [r3, #68]
 1858 003e FB76     		strb	r3, [r7, #27]
1818:Source/queue.c **** 
1819:Source/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
1820:Source/queue.c **** 
1821:Source/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
 1859              		.loc 1 1821 0
 1860 0040 B968     		ldr	r1, [r7, #8]
 1861 0042 B86A     		ldr	r0, [r7, #40]
 1862 0044 FFF7FEFF 		bl	prvCopyDataFromQueue
1822:Source/queue.c **** 			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 1863              		.loc 1 1822 0
 1864 0048 FB69     		ldr	r3, [r7, #28]
 1865 004a 5A1E     		subs	r2, r3, #1
 1866 004c BB6A     		ldr	r3, [r7, #40]
 1867 004e 9A63     		str	r2, [r3, #56]
1823:Source/queue.c **** 
1824:Source/queue.c **** 			/* If the queue is locked the event list will not be modified.
1825:Source/queue.c **** 			Instead update the lock count so the task that unlocks the queue
1826:Source/queue.c **** 			will know that an ISR has removed data while the queue was
1827:Source/queue.c **** 			locked. */
1828:Source/queue.c **** 			if( cRxLock == queueUNLOCKED )
 1868              		.loc 1 1828 0
 1869 0050 97F91B30 		ldrsb	r3, [r7, #27]
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 70


 1870 0054 B3F1FF3F 		cmp	r3, #-1
 1871 0058 12D1     		bne	.L118
1829:Source/queue.c **** 			{
1830:Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 1872              		.loc 1 1830 0
 1873 005a BB6A     		ldr	r3, [r7, #40]
 1874 005c 1B69     		ldr	r3, [r3, #16]
 1875 005e 002B     		cmp	r3, #0
 1876 0060 15D0     		beq	.L119
1831:Source/queue.c **** 				{
1832:Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 1877              		.loc 1 1832 0
 1878 0062 BB6A     		ldr	r3, [r7, #40]
 1879 0064 1033     		adds	r3, r3, #16
 1880 0066 1846     		mov	r0, r3
 1881 0068 FFF7FEFF 		bl	xTaskRemoveFromEventList
 1882 006c 0346     		mov	r3, r0
 1883 006e 002B     		cmp	r3, #0
 1884 0070 0DD0     		beq	.L119
1833:Source/queue.c **** 					{
1834:Source/queue.c **** 						/* The task waiting has a higher priority than us so
1835:Source/queue.c **** 						force a context switch. */
1836:Source/queue.c **** 						if( pxHigherPriorityTaskWoken != NULL )
 1885              		.loc 1 1836 0
 1886 0072 7B68     		ldr	r3, [r7, #4]
 1887 0074 002B     		cmp	r3, #0
 1888 0076 0AD0     		beq	.L119
1837:Source/queue.c **** 						{
1838:Source/queue.c **** 							*pxHigherPriorityTaskWoken = pdTRUE;
 1889              		.loc 1 1838 0
 1890 0078 7B68     		ldr	r3, [r7, #4]
 1891 007a 0122     		movs	r2, #1
 1892 007c 1A60     		str	r2, [r3]
 1893 007e 06E0     		b	.L119
 1894              	.L118:
1839:Source/queue.c **** 						}
1840:Source/queue.c **** 						else
1841:Source/queue.c **** 						{
1842:Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1843:Source/queue.c **** 						}
1844:Source/queue.c **** 					}
1845:Source/queue.c **** 					else
1846:Source/queue.c **** 					{
1847:Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1848:Source/queue.c **** 					}
1849:Source/queue.c **** 				}
1850:Source/queue.c **** 				else
1851:Source/queue.c **** 				{
1852:Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1853:Source/queue.c **** 				}
1854:Source/queue.c **** 			}
1855:Source/queue.c **** 			else
1856:Source/queue.c **** 			{
1857:Source/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1858:Source/queue.c **** 				knows that data was removed while it was locked. */
1859:Source/queue.c **** 				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
 1895              		.loc 1 1859 0
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 71


 1896 0080 FB7E     		ldrb	r3, [r7, #27]	@ zero_extendqisi2
 1897 0082 0133     		adds	r3, r3, #1
 1898 0084 DBB2     		uxtb	r3, r3
 1899 0086 5AB2     		sxtb	r2, r3
 1900 0088 BB6A     		ldr	r3, [r7, #40]
 1901 008a 83F84420 		strb	r2, [r3, #68]
 1902              	.L119:
1860:Source/queue.c **** 			}
1861:Source/queue.c **** 
1862:Source/queue.c **** 			xReturn = pdPASS;
 1903              		.loc 1 1862 0
 1904 008e 0123     		movs	r3, #1
 1905 0090 FB62     		str	r3, [r7, #44]
 1906              	.LBE41:
 1907 0092 01E0     		b	.L120
 1908              	.L117:
1863:Source/queue.c **** 		}
1864:Source/queue.c **** 		else
1865:Source/queue.c **** 		{
1866:Source/queue.c **** 			xReturn = pdFAIL;
 1909              		.loc 1 1866 0
 1910 0094 0023     		movs	r3, #0
 1911 0096 FB62     		str	r3, [r7, #44]
 1912              	.L120:
 1913 0098 3B6A     		ldr	r3, [r7, #32]
 1914 009a 7B62     		str	r3, [r7, #36]
 1915              	.LBE40:
 1916              	.LBB42:
 1917              	.LBB43:
 1918              		.loc 2 231 0
 1919 009c 7B6A     		ldr	r3, [r7, #36]
 1920              		.syntax unified
 1921              	@ 231 ".\Source\portable\GCC\ARM_CM3/portmacro.h" 1
 1922 009e 83F31188 			msr basepri, r3	
 1923              	@ 0 "" 2
 1924              		.thumb
 1925              		.syntax unified
 1926              	.LBE43:
 1927              	.LBE42:
1867:Source/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
1868:Source/queue.c **** 		}
1869:Source/queue.c **** 	}
1870:Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1871:Source/queue.c **** 
1872:Source/queue.c **** 	return xReturn;
 1928              		.loc 1 1872 0
 1929 00a2 FB6A     		ldr	r3, [r7, #44]
1873:Source/queue.c **** }
 1930              		.loc 1 1873 0
 1931 00a4 1846     		mov	r0, r3
 1932 00a6 3037     		adds	r7, r7, #48
 1933              		.cfi_def_cfa_offset 8
 1934 00a8 BD46     		mov	sp, r7
 1935              		.cfi_def_cfa_register 13
 1936              		@ sp needed
 1937 00aa 80BD     		pop	{r7, pc}
 1938              		.cfi_endproc
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 72


 1939              	.LFE82:
 1940              		.size	xQueueReceiveFromISR, .-xQueueReceiveFromISR
 1941              		.section	.text.xQueuePeekFromISR,"ax",%progbits
 1942              		.align	2
 1943              		.global	xQueuePeekFromISR
 1944              		.thumb
 1945              		.thumb_func
 1946              		.type	xQueuePeekFromISR, %function
 1947              	xQueuePeekFromISR:
 1948              	.LFB83:
1874:Source/queue.c **** /*-----------------------------------------------------------*/
1875:Source/queue.c **** 
1876:Source/queue.c **** BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
1877:Source/queue.c **** {
 1949              		.loc 1 1877 0
 1950              		.cfi_startproc
 1951              		@ args = 0, pretend = 0, frame = 40
 1952              		@ frame_needed = 1, uses_anonymous_args = 0
 1953 0000 80B5     		push	{r7, lr}
 1954              		.cfi_def_cfa_offset 8
 1955              		.cfi_offset 7, -8
 1956              		.cfi_offset 14, -4
 1957 0002 8AB0     		sub	sp, sp, #40
 1958              		.cfi_def_cfa_offset 48
 1959 0004 00AF     		add	r7, sp, #0
 1960              		.cfi_def_cfa_register 7
 1961 0006 7860     		str	r0, [r7, #4]
 1962 0008 3960     		str	r1, [r7]
1878:Source/queue.c **** BaseType_t xReturn;
1879:Source/queue.c **** UBaseType_t uxSavedInterruptStatus;
1880:Source/queue.c **** int8_t *pcOriginalReadPosition;
1881:Source/queue.c **** Queue_t * const pxQueue = xQueue;
 1963              		.loc 1 1881 0
 1964 000a 7B68     		ldr	r3, [r7, #4]
 1965 000c 3B62     		str	r3, [r7, #32]
 1966              	.LBB44:
 1967              	.LBB45:
 213:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	(
 1968              		.loc 2 213 0
 1969              		.syntax unified
 1970              	@ 213 ".\Source\portable\GCC\ARM_CM3/portmacro.h" 1
 1971 000e EFF31182 			mrs r2, basepri											
 1972 0012 4FF0A003 		mov r3, #160												
 1973 0016 83F31188 		msr basepri, r3											
 1974 001a BFF36F8F 		isb														
 1975 001e BFF34F8F 		dsb														
 1976              	
 1977              	@ 0 "" 2
 1978              		.thumb
 1979              		.syntax unified
 1980 0022 3A61     		str	r2, [r7, #16]
 1981 0024 FB60     		str	r3, [r7, #12]
 225:.\Source\portable\GCC\ARM_CM3/portmacro.h **** }
 1982              		.loc 2 225 0
 1983 0026 3B69     		ldr	r3, [r7, #16]
 1984              	.LBE45:
 1985              	.LBE44:
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 73


1882:Source/queue.c **** 
1883:Source/queue.c **** 	configASSERT( pxQueue );
1884:Source/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1885:Source/queue.c **** 	configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
1886:Source/queue.c **** 
1887:Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1888:Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1889:Source/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
1890:Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1891:Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1892:Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1893:Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1894:Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
1895:Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1896:Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1897:Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1898:Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1899:Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1900:Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1901:Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1902:Source/queue.c **** 
1903:Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1986              		.loc 1 1903 0
 1987 0028 BB61     		str	r3, [r7, #24]
1904:Source/queue.c **** 	{
1905:Source/queue.c **** 		/* Cannot block in an ISR, so check there is data available. */
1906:Source/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 1988              		.loc 1 1906 0
 1989 002a 3B6A     		ldr	r3, [r7, #32]
 1990 002c 9B6B     		ldr	r3, [r3, #56]
 1991 002e 002B     		cmp	r3, #0
 1992 0030 0CD0     		beq	.L124
1907:Source/queue.c **** 		{
1908:Source/queue.c **** 			traceQUEUE_PEEK_FROM_ISR( pxQueue );
1909:Source/queue.c **** 
1910:Source/queue.c **** 			/* Remember the read position so it can be reset as nothing is
1911:Source/queue.c **** 			actually being removed from the queue. */
1912:Source/queue.c **** 			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
 1993              		.loc 1 1912 0
 1994 0032 3B6A     		ldr	r3, [r7, #32]
 1995 0034 DB68     		ldr	r3, [r3, #12]
 1996 0036 7B61     		str	r3, [r7, #20]
1913:Source/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
 1997              		.loc 1 1913 0
 1998 0038 3968     		ldr	r1, [r7]
 1999 003a 386A     		ldr	r0, [r7, #32]
 2000 003c FFF7FEFF 		bl	prvCopyDataFromQueue
1914:Source/queue.c **** 			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
 2001              		.loc 1 1914 0
 2002 0040 3B6A     		ldr	r3, [r7, #32]
 2003 0042 7A69     		ldr	r2, [r7, #20]
 2004 0044 DA60     		str	r2, [r3, #12]
1915:Source/queue.c **** 
1916:Source/queue.c **** 			xReturn = pdPASS;
 2005              		.loc 1 1916 0
 2006 0046 0123     		movs	r3, #1
 2007 0048 7B62     		str	r3, [r7, #36]
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 74


 2008 004a 01E0     		b	.L125
 2009              	.L124:
1917:Source/queue.c **** 		}
1918:Source/queue.c **** 		else
1919:Source/queue.c **** 		{
1920:Source/queue.c **** 			xReturn = pdFAIL;
 2010              		.loc 1 1920 0
 2011 004c 0023     		movs	r3, #0
 2012 004e 7B62     		str	r3, [r7, #36]
 2013              	.L125:
 2014 0050 BB69     		ldr	r3, [r7, #24]
 2015 0052 FB61     		str	r3, [r7, #28]
 2016              	.LBB46:
 2017              	.LBB47:
 2018              		.loc 2 231 0
 2019 0054 FB69     		ldr	r3, [r7, #28]
 2020              		.syntax unified
 2021              	@ 231 ".\Source\portable\GCC\ARM_CM3/portmacro.h" 1
 2022 0056 83F31188 			msr basepri, r3	
 2023              	@ 0 "" 2
 2024              		.thumb
 2025              		.syntax unified
 2026              	.LBE47:
 2027              	.LBE46:
1921:Source/queue.c **** 			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
1922:Source/queue.c **** 		}
1923:Source/queue.c **** 	}
1924:Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1925:Source/queue.c **** 
1926:Source/queue.c **** 	return xReturn;
 2028              		.loc 1 1926 0
 2029 005a 7B6A     		ldr	r3, [r7, #36]
1927:Source/queue.c **** }
 2030              		.loc 1 1927 0
 2031 005c 1846     		mov	r0, r3
 2032 005e 2837     		adds	r7, r7, #40
 2033              		.cfi_def_cfa_offset 8
 2034 0060 BD46     		mov	sp, r7
 2035              		.cfi_def_cfa_register 13
 2036              		@ sp needed
 2037 0062 80BD     		pop	{r7, pc}
 2038              		.cfi_endproc
 2039              	.LFE83:
 2040              		.size	xQueuePeekFromISR, .-xQueuePeekFromISR
 2041              		.section	.text.uxQueueMessagesWaiting,"ax",%progbits
 2042              		.align	2
 2043              		.global	uxQueueMessagesWaiting
 2044              		.thumb
 2045              		.thumb_func
 2046              		.type	uxQueueMessagesWaiting, %function
 2047              	uxQueueMessagesWaiting:
 2048              	.LFB84:
1928:Source/queue.c **** /*-----------------------------------------------------------*/
1929:Source/queue.c **** 
1930:Source/queue.c **** UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
1931:Source/queue.c **** {
 2049              		.loc 1 1931 0
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 75


 2050              		.cfi_startproc
 2051              		@ args = 0, pretend = 0, frame = 16
 2052              		@ frame_needed = 1, uses_anonymous_args = 0
 2053 0000 80B5     		push	{r7, lr}
 2054              		.cfi_def_cfa_offset 8
 2055              		.cfi_offset 7, -8
 2056              		.cfi_offset 14, -4
 2057 0002 84B0     		sub	sp, sp, #16
 2058              		.cfi_def_cfa_offset 24
 2059 0004 00AF     		add	r7, sp, #0
 2060              		.cfi_def_cfa_register 7
 2061 0006 7860     		str	r0, [r7, #4]
1932:Source/queue.c **** UBaseType_t uxReturn;
1933:Source/queue.c **** 
1934:Source/queue.c **** 	configASSERT( xQueue );
1935:Source/queue.c **** 
1936:Source/queue.c **** 	taskENTER_CRITICAL();
 2062              		.loc 1 1936 0
 2063 0008 FFF7FEFF 		bl	vPortEnterCritical
1937:Source/queue.c **** 	{
1938:Source/queue.c **** 		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
 2064              		.loc 1 1938 0
 2065 000c 7B68     		ldr	r3, [r7, #4]
 2066 000e 9B6B     		ldr	r3, [r3, #56]
 2067 0010 FB60     		str	r3, [r7, #12]
1939:Source/queue.c **** 	}
1940:Source/queue.c **** 	taskEXIT_CRITICAL();
 2068              		.loc 1 1940 0
 2069 0012 FFF7FEFF 		bl	vPortExitCritical
1941:Source/queue.c **** 
1942:Source/queue.c **** 	return uxReturn;
 2070              		.loc 1 1942 0
 2071 0016 FB68     		ldr	r3, [r7, #12]
1943:Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 2072              		.loc 1 1943 0
 2073 0018 1846     		mov	r0, r3
 2074 001a 1037     		adds	r7, r7, #16
 2075              		.cfi_def_cfa_offset 8
 2076 001c BD46     		mov	sp, r7
 2077              		.cfi_def_cfa_register 13
 2078              		@ sp needed
 2079 001e 80BD     		pop	{r7, pc}
 2080              		.cfi_endproc
 2081              	.LFE84:
 2082              		.size	uxQueueMessagesWaiting, .-uxQueueMessagesWaiting
 2083              		.section	.text.uxQueueSpacesAvailable,"ax",%progbits
 2084              		.align	2
 2085              		.global	uxQueueSpacesAvailable
 2086              		.thumb
 2087              		.thumb_func
 2088              		.type	uxQueueSpacesAvailable, %function
 2089              	uxQueueSpacesAvailable:
 2090              	.LFB85:
1944:Source/queue.c **** /*-----------------------------------------------------------*/
1945:Source/queue.c **** 
1946:Source/queue.c **** UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
1947:Source/queue.c **** {
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 76


 2091              		.loc 1 1947 0
 2092              		.cfi_startproc
 2093              		@ args = 0, pretend = 0, frame = 16
 2094              		@ frame_needed = 1, uses_anonymous_args = 0
 2095 0000 80B5     		push	{r7, lr}
 2096              		.cfi_def_cfa_offset 8
 2097              		.cfi_offset 7, -8
 2098              		.cfi_offset 14, -4
 2099 0002 84B0     		sub	sp, sp, #16
 2100              		.cfi_def_cfa_offset 24
 2101 0004 00AF     		add	r7, sp, #0
 2102              		.cfi_def_cfa_register 7
 2103 0006 7860     		str	r0, [r7, #4]
1948:Source/queue.c **** UBaseType_t uxReturn;
1949:Source/queue.c **** Queue_t * const pxQueue = xQueue;
 2104              		.loc 1 1949 0
 2105 0008 7B68     		ldr	r3, [r7, #4]
 2106 000a FB60     		str	r3, [r7, #12]
1950:Source/queue.c **** 
1951:Source/queue.c **** 	configASSERT( pxQueue );
1952:Source/queue.c **** 
1953:Source/queue.c **** 	taskENTER_CRITICAL();
 2107              		.loc 1 1953 0
 2108 000c FFF7FEFF 		bl	vPortEnterCritical
1954:Source/queue.c **** 	{
1955:Source/queue.c **** 		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
 2109              		.loc 1 1955 0
 2110 0010 FB68     		ldr	r3, [r7, #12]
 2111 0012 DA6B     		ldr	r2, [r3, #60]
 2112 0014 FB68     		ldr	r3, [r7, #12]
 2113 0016 9B6B     		ldr	r3, [r3, #56]
 2114 0018 D31A     		subs	r3, r2, r3
 2115 001a BB60     		str	r3, [r7, #8]
1956:Source/queue.c **** 	}
1957:Source/queue.c **** 	taskEXIT_CRITICAL();
 2116              		.loc 1 1957 0
 2117 001c FFF7FEFF 		bl	vPortExitCritical
1958:Source/queue.c **** 
1959:Source/queue.c **** 	return uxReturn;
 2118              		.loc 1 1959 0
 2119 0020 BB68     		ldr	r3, [r7, #8]
1960:Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 2120              		.loc 1 1960 0
 2121 0022 1846     		mov	r0, r3
 2122 0024 1037     		adds	r7, r7, #16
 2123              		.cfi_def_cfa_offset 8
 2124 0026 BD46     		mov	sp, r7
 2125              		.cfi_def_cfa_register 13
 2126              		@ sp needed
 2127 0028 80BD     		pop	{r7, pc}
 2128              		.cfi_endproc
 2129              	.LFE85:
 2130              		.size	uxQueueSpacesAvailable, .-uxQueueSpacesAvailable
 2131 002a 00BF     		.section	.text.uxQueueMessagesWaitingFromISR,"ax",%progbits
 2132              		.align	2
 2133              		.global	uxQueueMessagesWaitingFromISR
 2134              		.thumb
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 77


 2135              		.thumb_func
 2136              		.type	uxQueueMessagesWaitingFromISR, %function
 2137              	uxQueueMessagesWaitingFromISR:
 2138              	.LFB86:
1961:Source/queue.c **** /*-----------------------------------------------------------*/
1962:Source/queue.c **** 
1963:Source/queue.c **** UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
1964:Source/queue.c **** {
 2139              		.loc 1 1964 0
 2140              		.cfi_startproc
 2141              		@ args = 0, pretend = 0, frame = 16
 2142              		@ frame_needed = 1, uses_anonymous_args = 0
 2143              		@ link register save eliminated.
 2144 0000 80B4     		push	{r7}
 2145              		.cfi_def_cfa_offset 4
 2146              		.cfi_offset 7, -4
 2147 0002 85B0     		sub	sp, sp, #20
 2148              		.cfi_def_cfa_offset 24
 2149 0004 00AF     		add	r7, sp, #0
 2150              		.cfi_def_cfa_register 7
 2151 0006 7860     		str	r0, [r7, #4]
1965:Source/queue.c **** UBaseType_t uxReturn;
1966:Source/queue.c **** Queue_t * const pxQueue = xQueue;
 2152              		.loc 1 1966 0
 2153 0008 7B68     		ldr	r3, [r7, #4]
 2154 000a FB60     		str	r3, [r7, #12]
1967:Source/queue.c **** 
1968:Source/queue.c **** 	configASSERT( pxQueue );
1969:Source/queue.c **** 	uxReturn = pxQueue->uxMessagesWaiting;
 2155              		.loc 1 1969 0
 2156 000c FB68     		ldr	r3, [r7, #12]
 2157 000e 9B6B     		ldr	r3, [r3, #56]
 2158 0010 BB60     		str	r3, [r7, #8]
1970:Source/queue.c **** 
1971:Source/queue.c **** 	return uxReturn;
 2159              		.loc 1 1971 0
 2160 0012 BB68     		ldr	r3, [r7, #8]
1972:Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 2161              		.loc 1 1972 0
 2162 0014 1846     		mov	r0, r3
 2163 0016 1437     		adds	r7, r7, #20
 2164              		.cfi_def_cfa_offset 4
 2165 0018 BD46     		mov	sp, r7
 2166              		.cfi_def_cfa_register 13
 2167              		@ sp needed
 2168 001a 80BC     		pop	{r7}
 2169              		.cfi_restore 7
 2170              		.cfi_def_cfa_offset 0
 2171 001c 7047     		bx	lr
 2172              		.cfi_endproc
 2173              	.LFE86:
 2174              		.size	uxQueueMessagesWaitingFromISR, .-uxQueueMessagesWaitingFromISR
 2175 001e 00BF     		.section	.text.vQueueDelete,"ax",%progbits
 2176              		.align	2
 2177              		.global	vQueueDelete
 2178              		.thumb
 2179              		.thumb_func
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 78


 2180              		.type	vQueueDelete, %function
 2181              	vQueueDelete:
 2182              	.LFB87:
1973:Source/queue.c **** /*-----------------------------------------------------------*/
1974:Source/queue.c **** 
1975:Source/queue.c **** void vQueueDelete( QueueHandle_t xQueue )
1976:Source/queue.c **** {
 2183              		.loc 1 1976 0
 2184              		.cfi_startproc
 2185              		@ args = 0, pretend = 0, frame = 16
 2186              		@ frame_needed = 1, uses_anonymous_args = 0
 2187 0000 80B5     		push	{r7, lr}
 2188              		.cfi_def_cfa_offset 8
 2189              		.cfi_offset 7, -8
 2190              		.cfi_offset 14, -4
 2191 0002 84B0     		sub	sp, sp, #16
 2192              		.cfi_def_cfa_offset 24
 2193 0004 00AF     		add	r7, sp, #0
 2194              		.cfi_def_cfa_register 7
 2195 0006 7860     		str	r0, [r7, #4]
1977:Source/queue.c **** Queue_t * const pxQueue = xQueue;
 2196              		.loc 1 1977 0
 2197 0008 7B68     		ldr	r3, [r7, #4]
 2198 000a FB60     		str	r3, [r7, #12]
1978:Source/queue.c **** 
1979:Source/queue.c **** 	configASSERT( pxQueue );
1980:Source/queue.c **** 	traceQUEUE_DELETE( pxQueue );
1981:Source/queue.c **** 
1982:Source/queue.c **** 	#if ( configQUEUE_REGISTRY_SIZE > 0 )
1983:Source/queue.c **** 	{
1984:Source/queue.c **** 		vQueueUnregisterQueue( pxQueue );
 2199              		.loc 1 1984 0
 2200 000c F868     		ldr	r0, [r7, #12]
 2201 000e FFF7FEFF 		bl	vQueueUnregisterQueue
1985:Source/queue.c **** 	}
1986:Source/queue.c **** 	#endif
1987:Source/queue.c **** 
1988:Source/queue.c **** 	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
1989:Source/queue.c **** 	{
1990:Source/queue.c **** 		/* The queue can only have been allocated dynamically - free it
1991:Source/queue.c **** 		again. */
1992:Source/queue.c **** 		vPortFree( pxQueue );
 2202              		.loc 1 1992 0
 2203 0012 F868     		ldr	r0, [r7, #12]
 2204 0014 FFF7FEFF 		bl	vPortFree
1993:Source/queue.c **** 	}
1994:Source/queue.c **** 	#elif( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
1995:Source/queue.c **** 	{
1996:Source/queue.c **** 		/* The queue could have been allocated statically or dynamically, so
1997:Source/queue.c **** 		check before attempting to free the memory. */
1998:Source/queue.c **** 		if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
1999:Source/queue.c **** 		{
2000:Source/queue.c **** 			vPortFree( pxQueue );
2001:Source/queue.c **** 		}
2002:Source/queue.c **** 		else
2003:Source/queue.c **** 		{
2004:Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 79


2005:Source/queue.c **** 		}
2006:Source/queue.c **** 	}
2007:Source/queue.c **** 	#else
2008:Source/queue.c **** 	{
2009:Source/queue.c **** 		/* The queue must have been statically allocated, so is not going to be
2010:Source/queue.c **** 		deleted.  Avoid compiler warnings about the unused parameter. */
2011:Source/queue.c **** 		( void ) pxQueue;
2012:Source/queue.c **** 	}
2013:Source/queue.c **** 	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
2014:Source/queue.c **** }
 2205              		.loc 1 2014 0
 2206 0018 00BF     		nop
 2207 001a 1037     		adds	r7, r7, #16
 2208              		.cfi_def_cfa_offset 8
 2209 001c BD46     		mov	sp, r7
 2210              		.cfi_def_cfa_register 13
 2211              		@ sp needed
 2212 001e 80BD     		pop	{r7, pc}
 2213              		.cfi_endproc
 2214              	.LFE87:
 2215              		.size	vQueueDelete, .-vQueueDelete
 2216              		.section	.text.prvGetDisinheritPriorityAfterTimeout,"ax",%progbits
 2217              		.align	2
 2218              		.thumb
 2219              		.thumb_func
 2220              		.type	prvGetDisinheritPriorityAfterTimeout, %function
 2221              	prvGetDisinheritPriorityAfterTimeout:
 2222              	.LFB88:
2015:Source/queue.c **** /*-----------------------------------------------------------*/
2016:Source/queue.c **** 
2017:Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2018:Source/queue.c **** 
2019:Source/queue.c **** 	UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )
2020:Source/queue.c **** 	{
2021:Source/queue.c **** 		return ( ( Queue_t * ) xQueue )->uxQueueNumber;
2022:Source/queue.c **** 	}
2023:Source/queue.c **** 
2024:Source/queue.c **** #endif /* configUSE_TRACE_FACILITY */
2025:Source/queue.c **** /*-----------------------------------------------------------*/
2026:Source/queue.c **** 
2027:Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2028:Source/queue.c **** 
2029:Source/queue.c **** 	void vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber )
2030:Source/queue.c **** 	{
2031:Source/queue.c **** 		( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
2032:Source/queue.c **** 	}
2033:Source/queue.c **** 
2034:Source/queue.c **** #endif /* configUSE_TRACE_FACILITY */
2035:Source/queue.c **** /*-----------------------------------------------------------*/
2036:Source/queue.c **** 
2037:Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2038:Source/queue.c **** 
2039:Source/queue.c **** 	uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )
2040:Source/queue.c **** 	{
2041:Source/queue.c **** 		return ( ( Queue_t * ) xQueue )->ucQueueType;
2042:Source/queue.c **** 	}
2043:Source/queue.c **** 
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 80


2044:Source/queue.c **** #endif /* configUSE_TRACE_FACILITY */
2045:Source/queue.c **** /*-----------------------------------------------------------*/
2046:Source/queue.c **** 
2047:Source/queue.c **** #if( configUSE_MUTEXES == 1 )
2048:Source/queue.c **** 
2049:Source/queue.c **** 	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
2050:Source/queue.c **** 	{
 2223              		.loc 1 2050 0
 2224              		.cfi_startproc
 2225              		@ args = 0, pretend = 0, frame = 16
 2226              		@ frame_needed = 1, uses_anonymous_args = 0
 2227              		@ link register save eliminated.
 2228 0000 80B4     		push	{r7}
 2229              		.cfi_def_cfa_offset 4
 2230              		.cfi_offset 7, -4
 2231 0002 85B0     		sub	sp, sp, #20
 2232              		.cfi_def_cfa_offset 24
 2233 0004 00AF     		add	r7, sp, #0
 2234              		.cfi_def_cfa_register 7
 2235 0006 7860     		str	r0, [r7, #4]
2051:Source/queue.c **** 	UBaseType_t uxHighestPriorityOfWaitingTasks;
2052:Source/queue.c **** 
2053:Source/queue.c **** 		/* If a task waiting for a mutex causes the mutex holder to inherit a
2054:Source/queue.c **** 		priority, but the waiting task times out, then the holder should
2055:Source/queue.c **** 		disinherit the priority - but only down to the highest priority of any
2056:Source/queue.c **** 		other tasks that are waiting for the same mutex.  For this purpose,
2057:Source/queue.c **** 		return the priority of the highest priority task that is waiting for the
2058:Source/queue.c **** 		mutex. */
2059:Source/queue.c **** 		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
 2236              		.loc 1 2059 0
 2237 0008 7B68     		ldr	r3, [r7, #4]
 2238 000a 5B6A     		ldr	r3, [r3, #36]
 2239 000c 002B     		cmp	r3, #0
 2240 000e 06D0     		beq	.L135
2060:Source/queue.c **** 		{
2061:Source/queue.c **** 			uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET
 2241              		.loc 1 2061 0
 2242 0010 7B68     		ldr	r3, [r7, #4]
 2243 0012 1B6B     		ldr	r3, [r3, #48]
 2244 0014 1B68     		ldr	r3, [r3]
 2245 0016 C3F10503 		rsb	r3, r3, #5
 2246 001a FB60     		str	r3, [r7, #12]
 2247 001c 01E0     		b	.L136
 2248              	.L135:
2062:Source/queue.c **** 		}
2063:Source/queue.c **** 		else
2064:Source/queue.c **** 		{
2065:Source/queue.c **** 			uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
 2249              		.loc 1 2065 0
 2250 001e 0023     		movs	r3, #0
 2251 0020 FB60     		str	r3, [r7, #12]
 2252              	.L136:
2066:Source/queue.c **** 		}
2067:Source/queue.c **** 
2068:Source/queue.c **** 		return uxHighestPriorityOfWaitingTasks;
 2253              		.loc 1 2068 0
 2254 0022 FB68     		ldr	r3, [r7, #12]
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 81


2069:Source/queue.c **** 	}
 2255              		.loc 1 2069 0
 2256 0024 1846     		mov	r0, r3
 2257 0026 1437     		adds	r7, r7, #20
 2258              		.cfi_def_cfa_offset 4
 2259 0028 BD46     		mov	sp, r7
 2260              		.cfi_def_cfa_register 13
 2261              		@ sp needed
 2262 002a 80BC     		pop	{r7}
 2263              		.cfi_restore 7
 2264              		.cfi_def_cfa_offset 0
 2265 002c 7047     		bx	lr
 2266              		.cfi_endproc
 2267              	.LFE88:
 2268              		.size	prvGetDisinheritPriorityAfterTimeout, .-prvGetDisinheritPriorityAfterTimeout
 2269 002e 00BF     		.section	.text.prvCopyDataToQueue,"ax",%progbits
 2270              		.align	2
 2271              		.thumb
 2272              		.thumb_func
 2273              		.type	prvCopyDataToQueue, %function
 2274              	prvCopyDataToQueue:
 2275              	.LFB89:
2070:Source/queue.c **** 
2071:Source/queue.c **** #endif /* configUSE_MUTEXES */
2072:Source/queue.c **** /*-----------------------------------------------------------*/
2073:Source/queue.c **** 
2074:Source/queue.c **** static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const Bas
2075:Source/queue.c **** {
 2276              		.loc 1 2075 0
 2277              		.cfi_startproc
 2278              		@ args = 0, pretend = 0, frame = 24
 2279              		@ frame_needed = 1, uses_anonymous_args = 0
 2280 0000 80B5     		push	{r7, lr}
 2281              		.cfi_def_cfa_offset 8
 2282              		.cfi_offset 7, -8
 2283              		.cfi_offset 14, -4
 2284 0002 86B0     		sub	sp, sp, #24
 2285              		.cfi_def_cfa_offset 32
 2286 0004 00AF     		add	r7, sp, #0
 2287              		.cfi_def_cfa_register 7
 2288 0006 F860     		str	r0, [r7, #12]
 2289 0008 B960     		str	r1, [r7, #8]
 2290 000a 7A60     		str	r2, [r7, #4]
2076:Source/queue.c **** BaseType_t xReturn = pdFALSE;
 2291              		.loc 1 2076 0
 2292 000c 0023     		movs	r3, #0
 2293 000e 7B61     		str	r3, [r7, #20]
2077:Source/queue.c **** UBaseType_t uxMessagesWaiting;
2078:Source/queue.c **** 
2079:Source/queue.c **** 	/* This function is called from a critical section. */
2080:Source/queue.c **** 
2081:Source/queue.c **** 	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 2294              		.loc 1 2081 0
 2295 0010 FB68     		ldr	r3, [r7, #12]
 2296 0012 9B6B     		ldr	r3, [r3, #56]
 2297 0014 3B61     		str	r3, [r7, #16]
2082:Source/queue.c **** 
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 82


2083:Source/queue.c **** 	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 2298              		.loc 1 2083 0
 2299 0016 FB68     		ldr	r3, [r7, #12]
 2300 0018 1B6C     		ldr	r3, [r3, #64]
 2301 001a 002B     		cmp	r3, #0
 2302 001c 0DD1     		bne	.L139
2084:Source/queue.c **** 	{
2085:Source/queue.c **** 		#if ( configUSE_MUTEXES == 1 )
2086:Source/queue.c **** 		{
2087:Source/queue.c **** 			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 2303              		.loc 1 2087 0
 2304 001e FB68     		ldr	r3, [r7, #12]
 2305 0020 1B68     		ldr	r3, [r3]
 2306 0022 002B     		cmp	r3, #0
 2307 0024 4DD1     		bne	.L140
2088:Source/queue.c **** 			{
2089:Source/queue.c **** 				/* The mutex is no longer being held. */
2090:Source/queue.c **** 				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
 2308              		.loc 1 2090 0
 2309 0026 FB68     		ldr	r3, [r7, #12]
 2310 0028 9B68     		ldr	r3, [r3, #8]
 2311 002a 1846     		mov	r0, r3
 2312 002c FFF7FEFF 		bl	xTaskPriorityDisinherit
 2313 0030 7861     		str	r0, [r7, #20]
2091:Source/queue.c **** 				pxQueue->u.xSemaphore.xMutexHolder = NULL;
 2314              		.loc 1 2091 0
 2315 0032 FB68     		ldr	r3, [r7, #12]
 2316 0034 0022     		movs	r2, #0
 2317 0036 9A60     		str	r2, [r3, #8]
 2318 0038 43E0     		b	.L140
 2319              	.L139:
2092:Source/queue.c **** 			}
2093:Source/queue.c **** 			else
2094:Source/queue.c **** 			{
2095:Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2096:Source/queue.c **** 			}
2097:Source/queue.c **** 		}
2098:Source/queue.c **** 		#endif /* configUSE_MUTEXES */
2099:Source/queue.c **** 	}
2100:Source/queue.c **** 	else if( xPosition == queueSEND_TO_BACK )
 2320              		.loc 1 2100 0
 2321 003a 7B68     		ldr	r3, [r7, #4]
 2322 003c 002B     		cmp	r3, #0
 2323 003e 19D1     		bne	.L141
2101:Source/queue.c **** 	{
2102:Source/queue.c **** 		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); 
 2324              		.loc 1 2102 0
 2325 0040 FB68     		ldr	r3, [r7, #12]
 2326 0042 5868     		ldr	r0, [r3, #4]
 2327 0044 FB68     		ldr	r3, [r7, #12]
 2328 0046 1B6C     		ldr	r3, [r3, #64]
 2329 0048 1A46     		mov	r2, r3
 2330 004a B968     		ldr	r1, [r7, #8]
 2331 004c FFF7FEFF 		bl	memcpy
2103:Source/queue.c **** 		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, esp
 2332              		.loc 1 2103 0
 2333 0050 FB68     		ldr	r3, [r7, #12]
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 83


 2334 0052 5A68     		ldr	r2, [r3, #4]
 2335 0054 FB68     		ldr	r3, [r7, #12]
 2336 0056 1B6C     		ldr	r3, [r3, #64]
 2337 0058 1A44     		add	r2, r2, r3
 2338 005a FB68     		ldr	r3, [r7, #12]
 2339 005c 5A60     		str	r2, [r3, #4]
2104:Source/queue.c **** 		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as co
 2340              		.loc 1 2104 0
 2341 005e FB68     		ldr	r3, [r7, #12]
 2342 0060 5A68     		ldr	r2, [r3, #4]
 2343 0062 FB68     		ldr	r3, [r7, #12]
 2344 0064 9B68     		ldr	r3, [r3, #8]
 2345 0066 9A42     		cmp	r2, r3
 2346 0068 2BD3     		bcc	.L140
2105:Source/queue.c **** 		{
2106:Source/queue.c **** 			pxQueue->pcWriteTo = pxQueue->pcHead;
 2347              		.loc 1 2106 0
 2348 006a FB68     		ldr	r3, [r7, #12]
 2349 006c 1A68     		ldr	r2, [r3]
 2350 006e FB68     		ldr	r3, [r7, #12]
 2351 0070 5A60     		str	r2, [r3, #4]
 2352 0072 26E0     		b	.L140
 2353              	.L141:
2107:Source/queue.c **** 		}
2108:Source/queue.c **** 		else
2109:Source/queue.c **** 		{
2110:Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2111:Source/queue.c **** 		}
2112:Source/queue.c **** 	}
2113:Source/queue.c **** 	else
2114:Source/queue.c **** 	{
2115:Source/queue.c **** 		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxIt
 2354              		.loc 1 2115 0
 2355 0074 FB68     		ldr	r3, [r7, #12]
 2356 0076 D868     		ldr	r0, [r3, #12]
 2357 0078 FB68     		ldr	r3, [r7, #12]
 2358 007a 1B6C     		ldr	r3, [r3, #64]
 2359 007c 1A46     		mov	r2, r3
 2360 007e B968     		ldr	r1, [r7, #8]
 2361 0080 FFF7FEFF 		bl	memcpy
2116:Source/queue.c **** 		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
 2362              		.loc 1 2116 0
 2363 0084 FB68     		ldr	r3, [r7, #12]
 2364 0086 DA68     		ldr	r2, [r3, #12]
 2365 0088 FB68     		ldr	r3, [r7, #12]
 2366 008a 1B6C     		ldr	r3, [r3, #64]
 2367 008c 5B42     		negs	r3, r3
 2368 008e 1A44     		add	r2, r2, r3
 2369 0090 FB68     		ldr	r3, [r7, #12]
 2370 0092 DA60     		str	r2, [r3, #12]
2117:Source/queue.c **** 		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as co
 2371              		.loc 1 2117 0
 2372 0094 FB68     		ldr	r3, [r7, #12]
 2373 0096 DA68     		ldr	r2, [r3, #12]
 2374 0098 FB68     		ldr	r3, [r7, #12]
 2375 009a 1B68     		ldr	r3, [r3]
 2376 009c 9A42     		cmp	r2, r3
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 84


 2377 009e 07D2     		bcs	.L142
2118:Source/queue.c **** 		{
2119:Source/queue.c **** 			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
 2378              		.loc 1 2119 0
 2379 00a0 FB68     		ldr	r3, [r7, #12]
 2380 00a2 9A68     		ldr	r2, [r3, #8]
 2381 00a4 FB68     		ldr	r3, [r7, #12]
 2382 00a6 1B6C     		ldr	r3, [r3, #64]
 2383 00a8 5B42     		negs	r3, r3
 2384 00aa 1A44     		add	r2, r2, r3
 2385 00ac FB68     		ldr	r3, [r7, #12]
 2386 00ae DA60     		str	r2, [r3, #12]
 2387              	.L142:
2120:Source/queue.c **** 		}
2121:Source/queue.c **** 		else
2122:Source/queue.c **** 		{
2123:Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2124:Source/queue.c **** 		}
2125:Source/queue.c **** 
2126:Source/queue.c **** 		if( xPosition == queueOVERWRITE )
 2388              		.loc 1 2126 0
 2389 00b0 7B68     		ldr	r3, [r7, #4]
 2390 00b2 022B     		cmp	r3, #2
 2391 00b4 05D1     		bne	.L140
2127:Source/queue.c **** 		{
2128:Source/queue.c **** 			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 2392              		.loc 1 2128 0
 2393 00b6 3B69     		ldr	r3, [r7, #16]
 2394 00b8 002B     		cmp	r3, #0
 2395 00ba 02D0     		beq	.L140
2129:Source/queue.c **** 			{
2130:Source/queue.c **** 				/* An item is not being added but overwritten, so subtract
2131:Source/queue.c **** 				one from the recorded number of items in the queue so when
2132:Source/queue.c **** 				one is added again below the number of recorded items remains
2133:Source/queue.c **** 				correct. */
2134:Source/queue.c **** 				--uxMessagesWaiting;
 2396              		.loc 1 2134 0
 2397 00bc 3B69     		ldr	r3, [r7, #16]
 2398 00be 013B     		subs	r3, r3, #1
 2399 00c0 3B61     		str	r3, [r7, #16]
 2400              	.L140:
2135:Source/queue.c **** 			}
2136:Source/queue.c **** 			else
2137:Source/queue.c **** 			{
2138:Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2139:Source/queue.c **** 			}
2140:Source/queue.c **** 		}
2141:Source/queue.c **** 		else
2142:Source/queue.c **** 		{
2143:Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2144:Source/queue.c **** 		}
2145:Source/queue.c **** 	}
2146:Source/queue.c **** 
2147:Source/queue.c **** 	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 2401              		.loc 1 2147 0
 2402 00c2 3B69     		ldr	r3, [r7, #16]
 2403 00c4 5A1C     		adds	r2, r3, #1
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 85


 2404 00c6 FB68     		ldr	r3, [r7, #12]
 2405 00c8 9A63     		str	r2, [r3, #56]
2148:Source/queue.c **** 
2149:Source/queue.c **** 	return xReturn;
 2406              		.loc 1 2149 0
 2407 00ca 7B69     		ldr	r3, [r7, #20]
2150:Source/queue.c **** }
 2408              		.loc 1 2150 0
 2409 00cc 1846     		mov	r0, r3
 2410 00ce 1837     		adds	r7, r7, #24
 2411              		.cfi_def_cfa_offset 8
 2412 00d0 BD46     		mov	sp, r7
 2413              		.cfi_def_cfa_register 13
 2414              		@ sp needed
 2415 00d2 80BD     		pop	{r7, pc}
 2416              		.cfi_endproc
 2417              	.LFE89:
 2418              		.size	prvCopyDataToQueue, .-prvCopyDataToQueue
 2419              		.section	.text.prvCopyDataFromQueue,"ax",%progbits
 2420              		.align	2
 2421              		.thumb
 2422              		.thumb_func
 2423              		.type	prvCopyDataFromQueue, %function
 2424              	prvCopyDataFromQueue:
 2425              	.LFB90:
2151:Source/queue.c **** /*-----------------------------------------------------------*/
2152:Source/queue.c **** 
2153:Source/queue.c **** static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
2154:Source/queue.c **** {
 2426              		.loc 1 2154 0
 2427              		.cfi_startproc
 2428              		@ args = 0, pretend = 0, frame = 8
 2429              		@ frame_needed = 1, uses_anonymous_args = 0
 2430 0000 80B5     		push	{r7, lr}
 2431              		.cfi_def_cfa_offset 8
 2432              		.cfi_offset 7, -8
 2433              		.cfi_offset 14, -4
 2434 0002 82B0     		sub	sp, sp, #8
 2435              		.cfi_def_cfa_offset 16
 2436 0004 00AF     		add	r7, sp, #0
 2437              		.cfi_def_cfa_register 7
 2438 0006 7860     		str	r0, [r7, #4]
 2439 0008 3960     		str	r1, [r7]
2155:Source/queue.c **** 	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 2440              		.loc 1 2155 0
 2441 000a 7B68     		ldr	r3, [r7, #4]
 2442 000c 1B6C     		ldr	r3, [r3, #64]
 2443 000e 002B     		cmp	r3, #0
 2444 0010 18D0     		beq	.L147
2156:Source/queue.c **** 	{
2157:Source/queue.c **** 		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char typ
 2445              		.loc 1 2157 0
 2446 0012 7B68     		ldr	r3, [r7, #4]
 2447 0014 DA68     		ldr	r2, [r3, #12]
 2448 0016 7B68     		ldr	r3, [r7, #4]
 2449 0018 1B6C     		ldr	r3, [r3, #64]
 2450 001a 1A44     		add	r2, r2, r3
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 86


 2451 001c 7B68     		ldr	r3, [r7, #4]
 2452 001e DA60     		str	r2, [r3, #12]
2158:Source/queue.c **** 		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justi
 2453              		.loc 1 2158 0
 2454 0020 7B68     		ldr	r3, [r7, #4]
 2455 0022 DA68     		ldr	r2, [r3, #12]
 2456 0024 7B68     		ldr	r3, [r7, #4]
 2457 0026 9B68     		ldr	r3, [r3, #8]
 2458 0028 9A42     		cmp	r2, r3
 2459 002a 03D3     		bcc	.L146
2159:Source/queue.c **** 		{
2160:Source/queue.c **** 			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
 2460              		.loc 1 2160 0
 2461 002c 7B68     		ldr	r3, [r7, #4]
 2462 002e 1A68     		ldr	r2, [r3]
 2463 0030 7B68     		ldr	r3, [r7, #4]
 2464 0032 DA60     		str	r2, [r3, #12]
 2465              	.L146:
2161:Source/queue.c **** 		}
2162:Source/queue.c **** 		else
2163:Source/queue.c **** 		{
2164:Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2165:Source/queue.c **** 		}
2166:Source/queue.c **** 		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue
 2466              		.loc 1 2166 0
 2467 0034 7B68     		ldr	r3, [r7, #4]
 2468 0036 D968     		ldr	r1, [r3, #12]
 2469 0038 7B68     		ldr	r3, [r7, #4]
 2470 003a 1B6C     		ldr	r3, [r3, #64]
 2471 003c 1A46     		mov	r2, r3
 2472 003e 3868     		ldr	r0, [r7]
 2473 0040 FFF7FEFF 		bl	memcpy
 2474              	.L147:
2167:Source/queue.c **** 	}
2168:Source/queue.c **** }
 2475              		.loc 1 2168 0
 2476 0044 00BF     		nop
 2477 0046 0837     		adds	r7, r7, #8
 2478              		.cfi_def_cfa_offset 8
 2479 0048 BD46     		mov	sp, r7
 2480              		.cfi_def_cfa_register 13
 2481              		@ sp needed
 2482 004a 80BD     		pop	{r7, pc}
 2483              		.cfi_endproc
 2484              	.LFE90:
 2485              		.size	prvCopyDataFromQueue, .-prvCopyDataFromQueue
 2486              		.section	.text.prvUnlockQueue,"ax",%progbits
 2487              		.align	2
 2488              		.thumb
 2489              		.thumb_func
 2490              		.type	prvUnlockQueue, %function
 2491              	prvUnlockQueue:
 2492              	.LFB91:
2169:Source/queue.c **** /*-----------------------------------------------------------*/
2170:Source/queue.c **** 
2171:Source/queue.c **** static void prvUnlockQueue( Queue_t * const pxQueue )
2172:Source/queue.c **** {
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 87


 2493              		.loc 1 2172 0
 2494              		.cfi_startproc
 2495              		@ args = 0, pretend = 0, frame = 16
 2496              		@ frame_needed = 1, uses_anonymous_args = 0
 2497 0000 80B5     		push	{r7, lr}
 2498              		.cfi_def_cfa_offset 8
 2499              		.cfi_offset 7, -8
 2500              		.cfi_offset 14, -4
 2501 0002 84B0     		sub	sp, sp, #16
 2502              		.cfi_def_cfa_offset 24
 2503 0004 00AF     		add	r7, sp, #0
 2504              		.cfi_def_cfa_register 7
 2505 0006 7860     		str	r0, [r7, #4]
2173:Source/queue.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
2174:Source/queue.c **** 
2175:Source/queue.c **** 	/* The lock counts contains the number of extra data items placed or
2176:Source/queue.c **** 	removed from the queue while the queue was locked.  When a queue is
2177:Source/queue.c **** 	locked items can be added or removed, but the event lists cannot be
2178:Source/queue.c **** 	updated. */
2179:Source/queue.c **** 	taskENTER_CRITICAL();
 2506              		.loc 1 2179 0
 2507 0008 FFF7FEFF 		bl	vPortEnterCritical
 2508              	.LBB48:
2180:Source/queue.c **** 	{
2181:Source/queue.c **** 		int8_t cTxLock = pxQueue->cTxLock;
 2509              		.loc 1 2181 0
 2510 000c 7B68     		ldr	r3, [r7, #4]
 2511 000e 93F84530 		ldrb	r3, [r3, #69]
 2512 0012 FB73     		strb	r3, [r7, #15]
2182:Source/queue.c **** 
2183:Source/queue.c **** 		/* See if data was added to the queue while it was locked. */
2184:Source/queue.c **** 		while( cTxLock > queueLOCKED_UNMODIFIED )
 2513              		.loc 1 2184 0
 2514 0014 11E0     		b	.L149
 2515              	.L153:
2185:Source/queue.c **** 		{
2186:Source/queue.c **** 			/* Data was posted while the queue was locked.  Are any tasks
2187:Source/queue.c **** 			blocked waiting for data to become available? */
2188:Source/queue.c **** 			#if ( configUSE_QUEUE_SETS == 1 )
2189:Source/queue.c **** 			{
2190:Source/queue.c **** 				if( pxQueue->pxQueueSetContainer != NULL )
2191:Source/queue.c **** 				{
2192:Source/queue.c **** 					if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
2193:Source/queue.c **** 					{
2194:Source/queue.c **** 						/* The queue is a member of a queue set, and posting to
2195:Source/queue.c **** 						the queue set caused a higher priority task to unblock.
2196:Source/queue.c **** 						A context switch is required. */
2197:Source/queue.c **** 						vTaskMissedYield();
2198:Source/queue.c **** 					}
2199:Source/queue.c **** 					else
2200:Source/queue.c **** 					{
2201:Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2202:Source/queue.c **** 					}
2203:Source/queue.c **** 				}
2204:Source/queue.c **** 				else
2205:Source/queue.c **** 				{
2206:Source/queue.c **** 					/* Tasks that are removed from the event list will get
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 88


2207:Source/queue.c **** 					added to the pending ready list as the scheduler is still
2208:Source/queue.c **** 					suspended. */
2209:Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2210:Source/queue.c **** 					{
2211:Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
2212:Source/queue.c **** 						{
2213:Source/queue.c **** 							/* The task waiting has a higher priority so record that a
2214:Source/queue.c **** 							context	switch is required. */
2215:Source/queue.c **** 							vTaskMissedYield();
2216:Source/queue.c **** 						}
2217:Source/queue.c **** 						else
2218:Source/queue.c **** 						{
2219:Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
2220:Source/queue.c **** 						}
2221:Source/queue.c **** 					}
2222:Source/queue.c **** 					else
2223:Source/queue.c **** 					{
2224:Source/queue.c **** 						break;
2225:Source/queue.c **** 					}
2226:Source/queue.c **** 				}
2227:Source/queue.c **** 			}
2228:Source/queue.c **** 			#else /* configUSE_QUEUE_SETS */
2229:Source/queue.c **** 			{
2230:Source/queue.c **** 				/* Tasks that are removed from the event list will get added to
2231:Source/queue.c **** 				the pending ready list as the scheduler is still suspended. */
2232:Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 2516              		.loc 1 2232 0
 2517 0016 7B68     		ldr	r3, [r7, #4]
 2518 0018 5B6A     		ldr	r3, [r3, #36]
 2519 001a 002B     		cmp	r3, #0
 2520 001c 12D0     		beq	.L159
2233:Source/queue.c **** 				{
2234:Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 2521              		.loc 1 2234 0
 2522 001e 7B68     		ldr	r3, [r7, #4]
 2523 0020 2433     		adds	r3, r3, #36
 2524 0022 1846     		mov	r0, r3
 2525 0024 FFF7FEFF 		bl	xTaskRemoveFromEventList
 2526 0028 0346     		mov	r3, r0
 2527 002a 002B     		cmp	r3, #0
 2528 002c 01D0     		beq	.L151
2235:Source/queue.c **** 					{
2236:Source/queue.c **** 						/* The task waiting has a higher priority so record that
2237:Source/queue.c **** 						a context switch is required. */
2238:Source/queue.c **** 						vTaskMissedYield();
 2529              		.loc 1 2238 0
 2530 002e FFF7FEFF 		bl	vTaskMissedYield
 2531              	.L151:
2239:Source/queue.c **** 					}
2240:Source/queue.c **** 					else
2241:Source/queue.c **** 					{
2242:Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2243:Source/queue.c **** 					}
2244:Source/queue.c **** 				}
2245:Source/queue.c **** 				else
2246:Source/queue.c **** 				{
2247:Source/queue.c **** 					break;
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 89


2248:Source/queue.c **** 				}
2249:Source/queue.c **** 			}
2250:Source/queue.c **** 			#endif /* configUSE_QUEUE_SETS */
2251:Source/queue.c **** 
2252:Source/queue.c **** 			--cTxLock;
 2532              		.loc 1 2252 0
 2533 0032 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 2534 0034 013B     		subs	r3, r3, #1
 2535 0036 DBB2     		uxtb	r3, r3
 2536 0038 FB73     		strb	r3, [r7, #15]
 2537              	.L149:
2184:Source/queue.c **** 		{
 2538              		.loc 1 2184 0
 2539 003a 97F90F30 		ldrsb	r3, [r7, #15]
 2540 003e 002B     		cmp	r3, #0
 2541 0040 E9DC     		bgt	.L153
 2542 0042 00E0     		b	.L152
 2543              	.L159:
2247:Source/queue.c **** 				}
 2544              		.loc 1 2247 0
 2545 0044 00BF     		nop
 2546              	.L152:
2253:Source/queue.c **** 		}
2254:Source/queue.c **** 
2255:Source/queue.c **** 		pxQueue->cTxLock = queueUNLOCKED;
 2547              		.loc 1 2255 0
 2548 0046 7B68     		ldr	r3, [r7, #4]
 2549 0048 FF22     		movs	r2, #255
 2550 004a 83F84520 		strb	r2, [r3, #69]
 2551              	.LBE48:
2256:Source/queue.c **** 	}
2257:Source/queue.c **** 	taskEXIT_CRITICAL();
 2552              		.loc 1 2257 0
 2553 004e FFF7FEFF 		bl	vPortExitCritical
2258:Source/queue.c **** 
2259:Source/queue.c **** 	/* Do the same for the Rx lock. */
2260:Source/queue.c **** 	taskENTER_CRITICAL();
 2554              		.loc 1 2260 0
 2555 0052 FFF7FEFF 		bl	vPortEnterCritical
 2556              	.LBB49:
2261:Source/queue.c **** 	{
2262:Source/queue.c **** 		int8_t cRxLock = pxQueue->cRxLock;
 2557              		.loc 1 2262 0
 2558 0056 7B68     		ldr	r3, [r7, #4]
 2559 0058 93F84430 		ldrb	r3, [r3, #68]
 2560 005c BB73     		strb	r3, [r7, #14]
2263:Source/queue.c **** 
2264:Source/queue.c **** 		while( cRxLock > queueLOCKED_UNMODIFIED )
 2561              		.loc 1 2264 0
 2562 005e 11E0     		b	.L154
 2563              	.L158:
2265:Source/queue.c **** 		{
2266:Source/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 2564              		.loc 1 2266 0
 2565 0060 7B68     		ldr	r3, [r7, #4]
 2566 0062 1B69     		ldr	r3, [r3, #16]
 2567 0064 002B     		cmp	r3, #0
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 90


 2568 0066 12D0     		beq	.L160
2267:Source/queue.c **** 			{
2268:Source/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 2569              		.loc 1 2268 0
 2570 0068 7B68     		ldr	r3, [r7, #4]
 2571 006a 1033     		adds	r3, r3, #16
 2572 006c 1846     		mov	r0, r3
 2573 006e FFF7FEFF 		bl	xTaskRemoveFromEventList
 2574 0072 0346     		mov	r3, r0
 2575 0074 002B     		cmp	r3, #0
 2576 0076 01D0     		beq	.L156
2269:Source/queue.c **** 				{
2270:Source/queue.c **** 					vTaskMissedYield();
 2577              		.loc 1 2270 0
 2578 0078 FFF7FEFF 		bl	vTaskMissedYield
 2579              	.L156:
2271:Source/queue.c **** 				}
2272:Source/queue.c **** 				else
2273:Source/queue.c **** 				{
2274:Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2275:Source/queue.c **** 				}
2276:Source/queue.c **** 
2277:Source/queue.c **** 				--cRxLock;
 2580              		.loc 1 2277 0
 2581 007c BB7B     		ldrb	r3, [r7, #14]	@ zero_extendqisi2
 2582 007e 013B     		subs	r3, r3, #1
 2583 0080 DBB2     		uxtb	r3, r3
 2584 0082 BB73     		strb	r3, [r7, #14]
 2585              	.L154:
2264:Source/queue.c **** 		{
 2586              		.loc 1 2264 0
 2587 0084 97F90E30 		ldrsb	r3, [r7, #14]
 2588 0088 002B     		cmp	r3, #0
 2589 008a E9DC     		bgt	.L158
 2590 008c 00E0     		b	.L157
 2591              	.L160:
2278:Source/queue.c **** 			}
2279:Source/queue.c **** 			else
2280:Source/queue.c **** 			{
2281:Source/queue.c **** 				break;
 2592              		.loc 1 2281 0
 2593 008e 00BF     		nop
 2594              	.L157:
2282:Source/queue.c **** 			}
2283:Source/queue.c **** 		}
2284:Source/queue.c **** 
2285:Source/queue.c **** 		pxQueue->cRxLock = queueUNLOCKED;
 2595              		.loc 1 2285 0
 2596 0090 7B68     		ldr	r3, [r7, #4]
 2597 0092 FF22     		movs	r2, #255
 2598 0094 83F84420 		strb	r2, [r3, #68]
 2599              	.LBE49:
2286:Source/queue.c **** 	}
2287:Source/queue.c **** 	taskEXIT_CRITICAL();
 2600              		.loc 1 2287 0
 2601 0098 FFF7FEFF 		bl	vPortExitCritical
2288:Source/queue.c **** }
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 91


 2602              		.loc 1 2288 0
 2603 009c 00BF     		nop
 2604 009e 1037     		adds	r7, r7, #16
 2605              		.cfi_def_cfa_offset 8
 2606 00a0 BD46     		mov	sp, r7
 2607              		.cfi_def_cfa_register 13
 2608              		@ sp needed
 2609 00a2 80BD     		pop	{r7, pc}
 2610              		.cfi_endproc
 2611              	.LFE91:
 2612              		.size	prvUnlockQueue, .-prvUnlockQueue
 2613              		.section	.text.prvIsQueueEmpty,"ax",%progbits
 2614              		.align	2
 2615              		.thumb
 2616              		.thumb_func
 2617              		.type	prvIsQueueEmpty, %function
 2618              	prvIsQueueEmpty:
 2619              	.LFB92:
2289:Source/queue.c **** /*-----------------------------------------------------------*/
2290:Source/queue.c **** 
2291:Source/queue.c **** static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
2292:Source/queue.c **** {
 2620              		.loc 1 2292 0
 2621              		.cfi_startproc
 2622              		@ args = 0, pretend = 0, frame = 16
 2623              		@ frame_needed = 1, uses_anonymous_args = 0
 2624 0000 80B5     		push	{r7, lr}
 2625              		.cfi_def_cfa_offset 8
 2626              		.cfi_offset 7, -8
 2627              		.cfi_offset 14, -4
 2628 0002 84B0     		sub	sp, sp, #16
 2629              		.cfi_def_cfa_offset 24
 2630 0004 00AF     		add	r7, sp, #0
 2631              		.cfi_def_cfa_register 7
 2632 0006 7860     		str	r0, [r7, #4]
2293:Source/queue.c **** BaseType_t xReturn;
2294:Source/queue.c **** 
2295:Source/queue.c **** 	taskENTER_CRITICAL();
 2633              		.loc 1 2295 0
 2634 0008 FFF7FEFF 		bl	vPortEnterCritical
2296:Source/queue.c **** 	{
2297:Source/queue.c **** 		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 2635              		.loc 1 2297 0
 2636 000c 7B68     		ldr	r3, [r7, #4]
 2637 000e 9B6B     		ldr	r3, [r3, #56]
 2638 0010 002B     		cmp	r3, #0
 2639 0012 02D1     		bne	.L162
2298:Source/queue.c **** 		{
2299:Source/queue.c **** 			xReturn = pdTRUE;
 2640              		.loc 1 2299 0
 2641 0014 0123     		movs	r3, #1
 2642 0016 FB60     		str	r3, [r7, #12]
 2643 0018 01E0     		b	.L163
 2644              	.L162:
2300:Source/queue.c **** 		}
2301:Source/queue.c **** 		else
2302:Source/queue.c **** 		{
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 92


2303:Source/queue.c **** 			xReturn = pdFALSE;
 2645              		.loc 1 2303 0
 2646 001a 0023     		movs	r3, #0
 2647 001c FB60     		str	r3, [r7, #12]
 2648              	.L163:
2304:Source/queue.c **** 		}
2305:Source/queue.c **** 	}
2306:Source/queue.c **** 	taskEXIT_CRITICAL();
 2649              		.loc 1 2306 0
 2650 001e FFF7FEFF 		bl	vPortExitCritical
2307:Source/queue.c **** 
2308:Source/queue.c **** 	return xReturn;
 2651              		.loc 1 2308 0
 2652 0022 FB68     		ldr	r3, [r7, #12]
2309:Source/queue.c **** }
 2653              		.loc 1 2309 0
 2654 0024 1846     		mov	r0, r3
 2655 0026 1037     		adds	r7, r7, #16
 2656              		.cfi_def_cfa_offset 8
 2657 0028 BD46     		mov	sp, r7
 2658              		.cfi_def_cfa_register 13
 2659              		@ sp needed
 2660 002a 80BD     		pop	{r7, pc}
 2661              		.cfi_endproc
 2662              	.LFE92:
 2663              		.size	prvIsQueueEmpty, .-prvIsQueueEmpty
 2664              		.section	.text.xQueueIsQueueEmptyFromISR,"ax",%progbits
 2665              		.align	2
 2666              		.global	xQueueIsQueueEmptyFromISR
 2667              		.thumb
 2668              		.thumb_func
 2669              		.type	xQueueIsQueueEmptyFromISR, %function
 2670              	xQueueIsQueueEmptyFromISR:
 2671              	.LFB93:
2310:Source/queue.c **** /*-----------------------------------------------------------*/
2311:Source/queue.c **** 
2312:Source/queue.c **** BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
2313:Source/queue.c **** {
 2672              		.loc 1 2313 0
 2673              		.cfi_startproc
 2674              		@ args = 0, pretend = 0, frame = 16
 2675              		@ frame_needed = 1, uses_anonymous_args = 0
 2676              		@ link register save eliminated.
 2677 0000 80B4     		push	{r7}
 2678              		.cfi_def_cfa_offset 4
 2679              		.cfi_offset 7, -4
 2680 0002 85B0     		sub	sp, sp, #20
 2681              		.cfi_def_cfa_offset 24
 2682 0004 00AF     		add	r7, sp, #0
 2683              		.cfi_def_cfa_register 7
 2684 0006 7860     		str	r0, [r7, #4]
2314:Source/queue.c **** BaseType_t xReturn;
2315:Source/queue.c **** Queue_t * const pxQueue = xQueue;
 2685              		.loc 1 2315 0
 2686 0008 7B68     		ldr	r3, [r7, #4]
 2687 000a BB60     		str	r3, [r7, #8]
2316:Source/queue.c **** 
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 93


2317:Source/queue.c **** 	configASSERT( pxQueue );
2318:Source/queue.c **** 	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
 2688              		.loc 1 2318 0
 2689 000c BB68     		ldr	r3, [r7, #8]
 2690 000e 9B6B     		ldr	r3, [r3, #56]
 2691 0010 002B     		cmp	r3, #0
 2692 0012 02D1     		bne	.L166
2319:Source/queue.c **** 	{
2320:Source/queue.c **** 		xReturn = pdTRUE;
 2693              		.loc 1 2320 0
 2694 0014 0123     		movs	r3, #1
 2695 0016 FB60     		str	r3, [r7, #12]
 2696 0018 01E0     		b	.L167
 2697              	.L166:
2321:Source/queue.c **** 	}
2322:Source/queue.c **** 	else
2323:Source/queue.c **** 	{
2324:Source/queue.c **** 		xReturn = pdFALSE;
 2698              		.loc 1 2324 0
 2699 001a 0023     		movs	r3, #0
 2700 001c FB60     		str	r3, [r7, #12]
 2701              	.L167:
2325:Source/queue.c **** 	}
2326:Source/queue.c **** 
2327:Source/queue.c **** 	return xReturn;
 2702              		.loc 1 2327 0
 2703 001e FB68     		ldr	r3, [r7, #12]
2328:Source/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 2704              		.loc 1 2328 0
 2705 0020 1846     		mov	r0, r3
 2706 0022 1437     		adds	r7, r7, #20
 2707              		.cfi_def_cfa_offset 4
 2708 0024 BD46     		mov	sp, r7
 2709              		.cfi_def_cfa_register 13
 2710              		@ sp needed
 2711 0026 80BC     		pop	{r7}
 2712              		.cfi_restore 7
 2713              		.cfi_def_cfa_offset 0
 2714 0028 7047     		bx	lr
 2715              		.cfi_endproc
 2716              	.LFE93:
 2717              		.size	xQueueIsQueueEmptyFromISR, .-xQueueIsQueueEmptyFromISR
 2718 002a 00BF     		.section	.text.prvIsQueueFull,"ax",%progbits
 2719              		.align	2
 2720              		.thumb
 2721              		.thumb_func
 2722              		.type	prvIsQueueFull, %function
 2723              	prvIsQueueFull:
 2724              	.LFB94:
2329:Source/queue.c **** /*-----------------------------------------------------------*/
2330:Source/queue.c **** 
2331:Source/queue.c **** static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
2332:Source/queue.c **** {
 2725              		.loc 1 2332 0
 2726              		.cfi_startproc
 2727              		@ args = 0, pretend = 0, frame = 16
 2728              		@ frame_needed = 1, uses_anonymous_args = 0
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 94


 2729 0000 80B5     		push	{r7, lr}
 2730              		.cfi_def_cfa_offset 8
 2731              		.cfi_offset 7, -8
 2732              		.cfi_offset 14, -4
 2733 0002 84B0     		sub	sp, sp, #16
 2734              		.cfi_def_cfa_offset 24
 2735 0004 00AF     		add	r7, sp, #0
 2736              		.cfi_def_cfa_register 7
 2737 0006 7860     		str	r0, [r7, #4]
2333:Source/queue.c **** BaseType_t xReturn;
2334:Source/queue.c **** 
2335:Source/queue.c **** 	taskENTER_CRITICAL();
 2738              		.loc 1 2335 0
 2739 0008 FFF7FEFF 		bl	vPortEnterCritical
2336:Source/queue.c **** 	{
2337:Source/queue.c **** 		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 2740              		.loc 1 2337 0
 2741 000c 7B68     		ldr	r3, [r7, #4]
 2742 000e 9A6B     		ldr	r2, [r3, #56]
 2743 0010 7B68     		ldr	r3, [r7, #4]
 2744 0012 DB6B     		ldr	r3, [r3, #60]
 2745 0014 9A42     		cmp	r2, r3
 2746 0016 02D1     		bne	.L170
2338:Source/queue.c **** 		{
2339:Source/queue.c **** 			xReturn = pdTRUE;
 2747              		.loc 1 2339 0
 2748 0018 0123     		movs	r3, #1
 2749 001a FB60     		str	r3, [r7, #12]
 2750 001c 01E0     		b	.L171
 2751              	.L170:
2340:Source/queue.c **** 		}
2341:Source/queue.c **** 		else
2342:Source/queue.c **** 		{
2343:Source/queue.c **** 			xReturn = pdFALSE;
 2752              		.loc 1 2343 0
 2753 001e 0023     		movs	r3, #0
 2754 0020 FB60     		str	r3, [r7, #12]
 2755              	.L171:
2344:Source/queue.c **** 		}
2345:Source/queue.c **** 	}
2346:Source/queue.c **** 	taskEXIT_CRITICAL();
 2756              		.loc 1 2346 0
 2757 0022 FFF7FEFF 		bl	vPortExitCritical
2347:Source/queue.c **** 
2348:Source/queue.c **** 	return xReturn;
 2758              		.loc 1 2348 0
 2759 0026 FB68     		ldr	r3, [r7, #12]
2349:Source/queue.c **** }
 2760              		.loc 1 2349 0
 2761 0028 1846     		mov	r0, r3
 2762 002a 1037     		adds	r7, r7, #16
 2763              		.cfi_def_cfa_offset 8
 2764 002c BD46     		mov	sp, r7
 2765              		.cfi_def_cfa_register 13
 2766              		@ sp needed
 2767 002e 80BD     		pop	{r7, pc}
 2768              		.cfi_endproc
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 95


 2769              	.LFE94:
 2770              		.size	prvIsQueueFull, .-prvIsQueueFull
 2771              		.section	.text.xQueueIsQueueFullFromISR,"ax",%progbits
 2772              		.align	2
 2773              		.global	xQueueIsQueueFullFromISR
 2774              		.thumb
 2775              		.thumb_func
 2776              		.type	xQueueIsQueueFullFromISR, %function
 2777              	xQueueIsQueueFullFromISR:
 2778              	.LFB95:
2350:Source/queue.c **** /*-----------------------------------------------------------*/
2351:Source/queue.c **** 
2352:Source/queue.c **** BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
2353:Source/queue.c **** {
 2779              		.loc 1 2353 0
 2780              		.cfi_startproc
 2781              		@ args = 0, pretend = 0, frame = 16
 2782              		@ frame_needed = 1, uses_anonymous_args = 0
 2783              		@ link register save eliminated.
 2784 0000 80B4     		push	{r7}
 2785              		.cfi_def_cfa_offset 4
 2786              		.cfi_offset 7, -4
 2787 0002 85B0     		sub	sp, sp, #20
 2788              		.cfi_def_cfa_offset 24
 2789 0004 00AF     		add	r7, sp, #0
 2790              		.cfi_def_cfa_register 7
 2791 0006 7860     		str	r0, [r7, #4]
2354:Source/queue.c **** BaseType_t xReturn;
2355:Source/queue.c **** Queue_t * const pxQueue = xQueue;
 2792              		.loc 1 2355 0
 2793 0008 7B68     		ldr	r3, [r7, #4]
 2794 000a BB60     		str	r3, [r7, #8]
2356:Source/queue.c **** 
2357:Source/queue.c **** 	configASSERT( pxQueue );
2358:Source/queue.c **** 	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 2795              		.loc 1 2358 0
 2796 000c BB68     		ldr	r3, [r7, #8]
 2797 000e 9A6B     		ldr	r2, [r3, #56]
 2798 0010 BB68     		ldr	r3, [r7, #8]
 2799 0012 DB6B     		ldr	r3, [r3, #60]
 2800 0014 9A42     		cmp	r2, r3
 2801 0016 02D1     		bne	.L174
2359:Source/queue.c **** 	{
2360:Source/queue.c **** 		xReturn = pdTRUE;
 2802              		.loc 1 2360 0
 2803 0018 0123     		movs	r3, #1
 2804 001a FB60     		str	r3, [r7, #12]
 2805 001c 01E0     		b	.L175
 2806              	.L174:
2361:Source/queue.c **** 	}
2362:Source/queue.c **** 	else
2363:Source/queue.c **** 	{
2364:Source/queue.c **** 		xReturn = pdFALSE;
 2807              		.loc 1 2364 0
 2808 001e 0023     		movs	r3, #0
 2809 0020 FB60     		str	r3, [r7, #12]
 2810              	.L175:
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 96


2365:Source/queue.c **** 	}
2366:Source/queue.c **** 
2367:Source/queue.c **** 	return xReturn;
 2811              		.loc 1 2367 0
 2812 0022 FB68     		ldr	r3, [r7, #12]
2368:Source/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 2813              		.loc 1 2368 0
 2814 0024 1846     		mov	r0, r3
 2815 0026 1437     		adds	r7, r7, #20
 2816              		.cfi_def_cfa_offset 4
 2817 0028 BD46     		mov	sp, r7
 2818              		.cfi_def_cfa_register 13
 2819              		@ sp needed
 2820 002a 80BC     		pop	{r7}
 2821              		.cfi_restore 7
 2822              		.cfi_def_cfa_offset 0
 2823 002c 7047     		bx	lr
 2824              		.cfi_endproc
 2825              	.LFE95:
 2826              		.size	xQueueIsQueueFullFromISR, .-xQueueIsQueueFullFromISR
 2827 002e 00BF     		.section	.text.vQueueAddToRegistry,"ax",%progbits
 2828              		.align	2
 2829              		.global	vQueueAddToRegistry
 2830              		.thumb
 2831              		.thumb_func
 2832              		.type	vQueueAddToRegistry, %function
 2833              	vQueueAddToRegistry:
 2834              	.LFB96:
2369:Source/queue.c **** /*-----------------------------------------------------------*/
2370:Source/queue.c **** 
2371:Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2372:Source/queue.c **** 
2373:Source/queue.c **** 	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait 
2374:Source/queue.c **** 	{
2375:Source/queue.c **** 	BaseType_t xReturn;
2376:Source/queue.c **** 	Queue_t * const pxQueue = xQueue;
2377:Source/queue.c **** 
2378:Source/queue.c **** 		/* If the queue is already full we may have to block.  A critical section
2379:Source/queue.c **** 		is required to prevent an interrupt removing something from the queue
2380:Source/queue.c **** 		between the check to see if the queue is full and blocking on the queue. */
2381:Source/queue.c **** 		portDISABLE_INTERRUPTS();
2382:Source/queue.c **** 		{
2383:Source/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
2384:Source/queue.c **** 			{
2385:Source/queue.c **** 				/* The queue is full - do we want to block or just leave without
2386:Source/queue.c **** 				posting? */
2387:Source/queue.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
2388:Source/queue.c **** 				{
2389:Source/queue.c **** 					/* As this is called from a coroutine we cannot block directly, but
2390:Source/queue.c **** 					return indicating that we need to block. */
2391:Source/queue.c **** 					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
2392:Source/queue.c **** 					portENABLE_INTERRUPTS();
2393:Source/queue.c **** 					return errQUEUE_BLOCKED;
2394:Source/queue.c **** 				}
2395:Source/queue.c **** 				else
2396:Source/queue.c **** 				{
2397:Source/queue.c **** 					portENABLE_INTERRUPTS();
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 97


2398:Source/queue.c **** 					return errQUEUE_FULL;
2399:Source/queue.c **** 				}
2400:Source/queue.c **** 			}
2401:Source/queue.c **** 		}
2402:Source/queue.c **** 		portENABLE_INTERRUPTS();
2403:Source/queue.c **** 
2404:Source/queue.c **** 		portDISABLE_INTERRUPTS();
2405:Source/queue.c **** 		{
2406:Source/queue.c **** 			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
2407:Source/queue.c **** 			{
2408:Source/queue.c **** 				/* There is room in the queue, copy the data into the queue. */
2409:Source/queue.c **** 				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
2410:Source/queue.c **** 				xReturn = pdPASS;
2411:Source/queue.c **** 
2412:Source/queue.c **** 				/* Were any co-routines waiting for data to become available? */
2413:Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2414:Source/queue.c **** 				{
2415:Source/queue.c **** 					/* In this instance the co-routine could be placed directly
2416:Source/queue.c **** 					into the ready list as we are within a critical section.
2417:Source/queue.c **** 					Instead the same pending ready list mechanism is used as if
2418:Source/queue.c **** 					the event were caused from within an interrupt. */
2419:Source/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
2420:Source/queue.c **** 					{
2421:Source/queue.c **** 						/* The co-routine waiting has a higher priority so record
2422:Source/queue.c **** 						that a yield might be appropriate. */
2423:Source/queue.c **** 						xReturn = errQUEUE_YIELD;
2424:Source/queue.c **** 					}
2425:Source/queue.c **** 					else
2426:Source/queue.c **** 					{
2427:Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2428:Source/queue.c **** 					}
2429:Source/queue.c **** 				}
2430:Source/queue.c **** 				else
2431:Source/queue.c **** 				{
2432:Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2433:Source/queue.c **** 				}
2434:Source/queue.c **** 			}
2435:Source/queue.c **** 			else
2436:Source/queue.c **** 			{
2437:Source/queue.c **** 				xReturn = errQUEUE_FULL;
2438:Source/queue.c **** 			}
2439:Source/queue.c **** 		}
2440:Source/queue.c **** 		portENABLE_INTERRUPTS();
2441:Source/queue.c **** 
2442:Source/queue.c **** 		return xReturn;
2443:Source/queue.c **** 	}
2444:Source/queue.c **** 
2445:Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
2446:Source/queue.c **** /*-----------------------------------------------------------*/
2447:Source/queue.c **** 
2448:Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2449:Source/queue.c **** 
2450:Source/queue.c **** 	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
2451:Source/queue.c **** 	{
2452:Source/queue.c **** 	BaseType_t xReturn;
2453:Source/queue.c **** 	Queue_t * const pxQueue = xQueue;
2454:Source/queue.c **** 
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 98


2455:Source/queue.c **** 		/* If the queue is already empty we may have to block.  A critical section
2456:Source/queue.c **** 		is required to prevent an interrupt adding something to the queue
2457:Source/queue.c **** 		between the check to see if the queue is empty and blocking on the queue. */
2458:Source/queue.c **** 		portDISABLE_INTERRUPTS();
2459:Source/queue.c **** 		{
2460:Source/queue.c **** 			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
2461:Source/queue.c **** 			{
2462:Source/queue.c **** 				/* There are no messages in the queue, do we want to block or just
2463:Source/queue.c **** 				leave with nothing? */
2464:Source/queue.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
2465:Source/queue.c **** 				{
2466:Source/queue.c **** 					/* As this is a co-routine we cannot block directly, but return
2467:Source/queue.c **** 					indicating that we need to block. */
2468:Source/queue.c **** 					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
2469:Source/queue.c **** 					portENABLE_INTERRUPTS();
2470:Source/queue.c **** 					return errQUEUE_BLOCKED;
2471:Source/queue.c **** 				}
2472:Source/queue.c **** 				else
2473:Source/queue.c **** 				{
2474:Source/queue.c **** 					portENABLE_INTERRUPTS();
2475:Source/queue.c **** 					return errQUEUE_FULL;
2476:Source/queue.c **** 				}
2477:Source/queue.c **** 			}
2478:Source/queue.c **** 			else
2479:Source/queue.c **** 			{
2480:Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2481:Source/queue.c **** 			}
2482:Source/queue.c **** 		}
2483:Source/queue.c **** 		portENABLE_INTERRUPTS();
2484:Source/queue.c **** 
2485:Source/queue.c **** 		portDISABLE_INTERRUPTS();
2486:Source/queue.c **** 		{
2487:Source/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
2488:Source/queue.c **** 			{
2489:Source/queue.c **** 				/* Data is available from the queue. */
2490:Source/queue.c **** 				pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
2491:Source/queue.c **** 				if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
2492:Source/queue.c **** 				{
2493:Source/queue.c **** 					pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
2494:Source/queue.c **** 				}
2495:Source/queue.c **** 				else
2496:Source/queue.c **** 				{
2497:Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2498:Source/queue.c **** 				}
2499:Source/queue.c **** 				--( pxQueue->uxMessagesWaiting );
2500:Source/queue.c **** 				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQ
2501:Source/queue.c **** 
2502:Source/queue.c **** 				xReturn = pdPASS;
2503:Source/queue.c **** 
2504:Source/queue.c **** 				/* Were any co-routines waiting for space to become available? */
2505:Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
2506:Source/queue.c **** 				{
2507:Source/queue.c **** 					/* In this instance the co-routine could be placed directly
2508:Source/queue.c **** 					into the ready list as we are within a critical section.
2509:Source/queue.c **** 					Instead the same pending ready list mechanism is used as if
2510:Source/queue.c **** 					the event were caused from within an interrupt. */
2511:Source/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 99


2512:Source/queue.c **** 					{
2513:Source/queue.c **** 						xReturn = errQUEUE_YIELD;
2514:Source/queue.c **** 					}
2515:Source/queue.c **** 					else
2516:Source/queue.c **** 					{
2517:Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2518:Source/queue.c **** 					}
2519:Source/queue.c **** 				}
2520:Source/queue.c **** 				else
2521:Source/queue.c **** 				{
2522:Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2523:Source/queue.c **** 				}
2524:Source/queue.c **** 			}
2525:Source/queue.c **** 			else
2526:Source/queue.c **** 			{
2527:Source/queue.c **** 				xReturn = pdFAIL;
2528:Source/queue.c **** 			}
2529:Source/queue.c **** 		}
2530:Source/queue.c **** 		portENABLE_INTERRUPTS();
2531:Source/queue.c **** 
2532:Source/queue.c **** 		return xReturn;
2533:Source/queue.c **** 	}
2534:Source/queue.c **** 
2535:Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
2536:Source/queue.c **** /*-----------------------------------------------------------*/
2537:Source/queue.c **** 
2538:Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2539:Source/queue.c **** 
2540:Source/queue.c **** 	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRou
2541:Source/queue.c **** 	{
2542:Source/queue.c **** 	Queue_t * const pxQueue = xQueue;
2543:Source/queue.c **** 
2544:Source/queue.c **** 		/* Cannot block within an ISR so if there is no space on the queue then
2545:Source/queue.c **** 		exit without doing anything. */
2546:Source/queue.c **** 		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
2547:Source/queue.c **** 		{
2548:Source/queue.c **** 			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
2549:Source/queue.c **** 
2550:Source/queue.c **** 			/* We only want to wake one co-routine per ISR, so check that a
2551:Source/queue.c **** 			co-routine has not already been woken. */
2552:Source/queue.c **** 			if( xCoRoutinePreviouslyWoken == pdFALSE )
2553:Source/queue.c **** 			{
2554:Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2555:Source/queue.c **** 				{
2556:Source/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
2557:Source/queue.c **** 					{
2558:Source/queue.c **** 						return pdTRUE;
2559:Source/queue.c **** 					}
2560:Source/queue.c **** 					else
2561:Source/queue.c **** 					{
2562:Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2563:Source/queue.c **** 					}
2564:Source/queue.c **** 				}
2565:Source/queue.c **** 				else
2566:Source/queue.c **** 				{
2567:Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2568:Source/queue.c **** 				}
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 100


2569:Source/queue.c **** 			}
2570:Source/queue.c **** 			else
2571:Source/queue.c **** 			{
2572:Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2573:Source/queue.c **** 			}
2574:Source/queue.c **** 		}
2575:Source/queue.c **** 		else
2576:Source/queue.c **** 		{
2577:Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2578:Source/queue.c **** 		}
2579:Source/queue.c **** 
2580:Source/queue.c **** 		return xCoRoutinePreviouslyWoken;
2581:Source/queue.c **** 	}
2582:Source/queue.c **** 
2583:Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
2584:Source/queue.c **** /*-----------------------------------------------------------*/
2585:Source/queue.c **** 
2586:Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2587:Source/queue.c **** 
2588:Source/queue.c **** 	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWo
2589:Source/queue.c **** 	{
2590:Source/queue.c **** 	BaseType_t xReturn;
2591:Source/queue.c **** 	Queue_t * const pxQueue = xQueue;
2592:Source/queue.c **** 
2593:Source/queue.c **** 		/* We cannot block from an ISR, so check there is data available. If
2594:Source/queue.c **** 		not then just leave without doing anything. */
2595:Source/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
2596:Source/queue.c **** 		{
2597:Source/queue.c **** 			/* Copy the data from the queue. */
2598:Source/queue.c **** 			pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
2599:Source/queue.c **** 			if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
2600:Source/queue.c **** 			{
2601:Source/queue.c **** 				pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
2602:Source/queue.c **** 			}
2603:Source/queue.c **** 			else
2604:Source/queue.c **** 			{
2605:Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2606:Source/queue.c **** 			}
2607:Source/queue.c **** 			--( pxQueue->uxMessagesWaiting );
2608:Source/queue.c **** 			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQu
2609:Source/queue.c **** 
2610:Source/queue.c **** 			if( ( *pxCoRoutineWoken ) == pdFALSE )
2611:Source/queue.c **** 			{
2612:Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
2613:Source/queue.c **** 				{
2614:Source/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
2615:Source/queue.c **** 					{
2616:Source/queue.c **** 						*pxCoRoutineWoken = pdTRUE;
2617:Source/queue.c **** 					}
2618:Source/queue.c **** 					else
2619:Source/queue.c **** 					{
2620:Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2621:Source/queue.c **** 					}
2622:Source/queue.c **** 				}
2623:Source/queue.c **** 				else
2624:Source/queue.c **** 				{
2625:Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 101


2626:Source/queue.c **** 				}
2627:Source/queue.c **** 			}
2628:Source/queue.c **** 			else
2629:Source/queue.c **** 			{
2630:Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2631:Source/queue.c **** 			}
2632:Source/queue.c **** 
2633:Source/queue.c **** 			xReturn = pdPASS;
2634:Source/queue.c **** 		}
2635:Source/queue.c **** 		else
2636:Source/queue.c **** 		{
2637:Source/queue.c **** 			xReturn = pdFAIL;
2638:Source/queue.c **** 		}
2639:Source/queue.c **** 
2640:Source/queue.c **** 		return xReturn;
2641:Source/queue.c **** 	}
2642:Source/queue.c **** 
2643:Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
2644:Source/queue.c **** /*-----------------------------------------------------------*/
2645:Source/queue.c **** 
2646:Source/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
2647:Source/queue.c **** 
2648:Source/queue.c **** 	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) /*lint !e971 Unqualified
2649:Source/queue.c **** 	{
 2835              		.loc 1 2649 0
 2836              		.cfi_startproc
 2837              		@ args = 0, pretend = 0, frame = 16
 2838              		@ frame_needed = 1, uses_anonymous_args = 0
 2839              		@ link register save eliminated.
 2840 0000 80B4     		push	{r7}
 2841              		.cfi_def_cfa_offset 4
 2842              		.cfi_offset 7, -4
 2843 0002 85B0     		sub	sp, sp, #20
 2844              		.cfi_def_cfa_offset 24
 2845 0004 00AF     		add	r7, sp, #0
 2846              		.cfi_def_cfa_register 7
 2847 0006 7860     		str	r0, [r7, #4]
 2848 0008 3960     		str	r1, [r7]
2650:Source/queue.c **** 	UBaseType_t ux;
2651:Source/queue.c **** 
2652:Source/queue.c **** 		/* See if there is an empty space in the registry.  A NULL name denotes
2653:Source/queue.c **** 		a free slot. */
2654:Source/queue.c **** 		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 2849              		.loc 1 2654 0
 2850 000a 0023     		movs	r3, #0
 2851 000c FB60     		str	r3, [r7, #12]
 2852 000e 14E0     		b	.L178
 2853              	.L181:
2655:Source/queue.c **** 		{
2656:Source/queue.c **** 			if( xQueueRegistry[ ux ].pcQueueName == NULL )
 2854              		.loc 1 2656 0
 2855 0010 0E4A     		ldr	r2, .L182
 2856 0012 FB68     		ldr	r3, [r7, #12]
 2857 0014 52F83330 		ldr	r3, [r2, r3, lsl #3]
 2858 0018 002B     		cmp	r3, #0
 2859 001a 0BD1     		bne	.L179
2657:Source/queue.c **** 			{
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 102


2658:Source/queue.c **** 				/* Store the information on this queue. */
2659:Source/queue.c **** 				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
 2860              		.loc 1 2659 0
 2861 001c 0B49     		ldr	r1, .L182
 2862 001e FB68     		ldr	r3, [r7, #12]
 2863 0020 3A68     		ldr	r2, [r7]
 2864 0022 41F83320 		str	r2, [r1, r3, lsl #3]
2660:Source/queue.c **** 				xQueueRegistry[ ux ].xHandle = xQueue;
 2865              		.loc 1 2660 0
 2866 0026 094A     		ldr	r2, .L182
 2867 0028 FB68     		ldr	r3, [r7, #12]
 2868 002a DB00     		lsls	r3, r3, #3
 2869 002c 1344     		add	r3, r3, r2
 2870 002e 7A68     		ldr	r2, [r7, #4]
 2871 0030 5A60     		str	r2, [r3, #4]
2661:Source/queue.c **** 
2662:Source/queue.c **** 				traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
2663:Source/queue.c **** 				break;
 2872              		.loc 1 2663 0
 2873 0032 05E0     		b	.L180
 2874              	.L179:
2654:Source/queue.c **** 		{
 2875              		.loc 1 2654 0 discriminator 2
 2876 0034 FB68     		ldr	r3, [r7, #12]
 2877 0036 0133     		adds	r3, r3, #1
 2878 0038 FB60     		str	r3, [r7, #12]
 2879              	.L178:
2654:Source/queue.c **** 		{
 2880              		.loc 1 2654 0 is_stmt 0 discriminator 1
 2881 003a FB68     		ldr	r3, [r7, #12]
 2882 003c 092B     		cmp	r3, #9
 2883 003e E7D9     		bls	.L181
 2884              	.L180:
2664:Source/queue.c **** 			}
2665:Source/queue.c **** 			else
2666:Source/queue.c **** 			{
2667:Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2668:Source/queue.c **** 			}
2669:Source/queue.c **** 		}
2670:Source/queue.c **** 	}
 2885              		.loc 1 2670 0 is_stmt 1
 2886 0040 00BF     		nop
 2887 0042 1437     		adds	r7, r7, #20
 2888              		.cfi_def_cfa_offset 4
 2889 0044 BD46     		mov	sp, r7
 2890              		.cfi_def_cfa_register 13
 2891              		@ sp needed
 2892 0046 80BC     		pop	{r7}
 2893              		.cfi_restore 7
 2894              		.cfi_def_cfa_offset 0
 2895 0048 7047     		bx	lr
 2896              	.L183:
 2897 004a 00BF     		.align	2
 2898              	.L182:
 2899 004c 00000000 		.word	xQueueRegistry
 2900              		.cfi_endproc
 2901              	.LFE96:
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 103


 2902              		.size	vQueueAddToRegistry, .-vQueueAddToRegistry
 2903              		.section	.text.pcQueueGetName,"ax",%progbits
 2904              		.align	2
 2905              		.global	pcQueueGetName
 2906              		.thumb
 2907              		.thumb_func
 2908              		.type	pcQueueGetName, %function
 2909              	pcQueueGetName:
 2910              	.LFB97:
2671:Source/queue.c **** 
2672:Source/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
2673:Source/queue.c **** /*-----------------------------------------------------------*/
2674:Source/queue.c **** 
2675:Source/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
2676:Source/queue.c **** 
2677:Source/queue.c **** 	const char *pcQueueGetName( QueueHandle_t xQueue ) /*lint !e971 Unqualified char types are allowed
2678:Source/queue.c **** 	{
 2911              		.loc 1 2678 0
 2912              		.cfi_startproc
 2913              		@ args = 0, pretend = 0, frame = 16
 2914              		@ frame_needed = 1, uses_anonymous_args = 0
 2915              		@ link register save eliminated.
 2916 0000 80B4     		push	{r7}
 2917              		.cfi_def_cfa_offset 4
 2918              		.cfi_offset 7, -4
 2919 0002 85B0     		sub	sp, sp, #20
 2920              		.cfi_def_cfa_offset 24
 2921 0004 00AF     		add	r7, sp, #0
 2922              		.cfi_def_cfa_register 7
 2923 0006 7860     		str	r0, [r7, #4]
2679:Source/queue.c **** 	UBaseType_t ux;
2680:Source/queue.c **** 	const char *pcReturn = NULL; /*lint !e971 Unqualified char types are allowed for strings and singl
 2924              		.loc 1 2680 0
 2925 0008 0023     		movs	r3, #0
 2926 000a BB60     		str	r3, [r7, #8]
2681:Source/queue.c **** 
2682:Source/queue.c **** 		/* Note there is nothing here to protect against another task adding or
2683:Source/queue.c **** 		removing entries from the registry while it is being searched. */
2684:Source/queue.c **** 		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 2927              		.loc 1 2684 0
 2928 000c 0023     		movs	r3, #0
 2929 000e FB60     		str	r3, [r7, #12]
 2930 0010 10E0     		b	.L185
 2931              	.L188:
2685:Source/queue.c **** 		{
2686:Source/queue.c **** 			if( xQueueRegistry[ ux ].xHandle == xQueue )
 2932              		.loc 1 2686 0
 2933 0012 0D4A     		ldr	r2, .L190
 2934 0014 FB68     		ldr	r3, [r7, #12]
 2935 0016 DB00     		lsls	r3, r3, #3
 2936 0018 1344     		add	r3, r3, r2
 2937 001a 5A68     		ldr	r2, [r3, #4]
 2938 001c 7B68     		ldr	r3, [r7, #4]
 2939 001e 9A42     		cmp	r2, r3
 2940 0020 05D1     		bne	.L186
2687:Source/queue.c **** 			{
2688:Source/queue.c **** 				pcReturn = xQueueRegistry[ ux ].pcQueueName;
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 104


 2941              		.loc 1 2688 0
 2942 0022 094A     		ldr	r2, .L190
 2943 0024 FB68     		ldr	r3, [r7, #12]
 2944 0026 52F83330 		ldr	r3, [r2, r3, lsl #3]
 2945 002a BB60     		str	r3, [r7, #8]
2689:Source/queue.c **** 				break;
 2946              		.loc 1 2689 0
 2947 002c 05E0     		b	.L187
 2948              	.L186:
2684:Source/queue.c **** 		{
 2949              		.loc 1 2684 0 discriminator 2
 2950 002e FB68     		ldr	r3, [r7, #12]
 2951 0030 0133     		adds	r3, r3, #1
 2952 0032 FB60     		str	r3, [r7, #12]
 2953              	.L185:
2684:Source/queue.c **** 		{
 2954              		.loc 1 2684 0 is_stmt 0 discriminator 1
 2955 0034 FB68     		ldr	r3, [r7, #12]
 2956 0036 092B     		cmp	r3, #9
 2957 0038 EBD9     		bls	.L188
 2958              	.L187:
2690:Source/queue.c **** 			}
2691:Source/queue.c **** 			else
2692:Source/queue.c **** 			{
2693:Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2694:Source/queue.c **** 			}
2695:Source/queue.c **** 		}
2696:Source/queue.c **** 
2697:Source/queue.c **** 		return pcReturn;
 2959              		.loc 1 2697 0 is_stmt 1
 2960 003a BB68     		ldr	r3, [r7, #8]
2698:Source/queue.c **** 	} /*lint !e818 xQueue cannot be a pointer to const because it is a typedef. */
 2961              		.loc 1 2698 0
 2962 003c 1846     		mov	r0, r3
 2963 003e 1437     		adds	r7, r7, #20
 2964              		.cfi_def_cfa_offset 4
 2965 0040 BD46     		mov	sp, r7
 2966              		.cfi_def_cfa_register 13
 2967              		@ sp needed
 2968 0042 80BC     		pop	{r7}
 2969              		.cfi_restore 7
 2970              		.cfi_def_cfa_offset 0
 2971 0044 7047     		bx	lr
 2972              	.L191:
 2973 0046 00BF     		.align	2
 2974              	.L190:
 2975 0048 00000000 		.word	xQueueRegistry
 2976              		.cfi_endproc
 2977              	.LFE97:
 2978              		.size	pcQueueGetName, .-pcQueueGetName
 2979              		.section	.text.vQueueUnregisterQueue,"ax",%progbits
 2980              		.align	2
 2981              		.global	vQueueUnregisterQueue
 2982              		.thumb
 2983              		.thumb_func
 2984              		.type	vQueueUnregisterQueue, %function
 2985              	vQueueUnregisterQueue:
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 105


 2986              	.LFB98:
2699:Source/queue.c **** 
2700:Source/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
2701:Source/queue.c **** /*-----------------------------------------------------------*/
2702:Source/queue.c **** 
2703:Source/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
2704:Source/queue.c **** 
2705:Source/queue.c **** 	void vQueueUnregisterQueue( QueueHandle_t xQueue )
2706:Source/queue.c **** 	{
 2987              		.loc 1 2706 0
 2988              		.cfi_startproc
 2989              		@ args = 0, pretend = 0, frame = 16
 2990              		@ frame_needed = 1, uses_anonymous_args = 0
 2991              		@ link register save eliminated.
 2992 0000 80B4     		push	{r7}
 2993              		.cfi_def_cfa_offset 4
 2994              		.cfi_offset 7, -4
 2995 0002 85B0     		sub	sp, sp, #20
 2996              		.cfi_def_cfa_offset 24
 2997 0004 00AF     		add	r7, sp, #0
 2998              		.cfi_def_cfa_register 7
 2999 0006 7860     		str	r0, [r7, #4]
2707:Source/queue.c **** 	UBaseType_t ux;
2708:Source/queue.c **** 
2709:Source/queue.c **** 		/* See if the handle of the queue being unregistered in actually in the
2710:Source/queue.c **** 		registry. */
2711:Source/queue.c **** 		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 3000              		.loc 1 2711 0
 3001 0008 0023     		movs	r3, #0
 3002 000a FB60     		str	r3, [r7, #12]
 3003 000c 16E0     		b	.L193
 3004              	.L196:
2712:Source/queue.c **** 		{
2713:Source/queue.c **** 			if( xQueueRegistry[ ux ].xHandle == xQueue )
 3005              		.loc 1 2713 0
 3006 000e 0F4A     		ldr	r2, .L197
 3007 0010 FB68     		ldr	r3, [r7, #12]
 3008 0012 DB00     		lsls	r3, r3, #3
 3009 0014 1344     		add	r3, r3, r2
 3010 0016 5A68     		ldr	r2, [r3, #4]
 3011 0018 7B68     		ldr	r3, [r7, #4]
 3012 001a 9A42     		cmp	r2, r3
 3013 001c 0BD1     		bne	.L194
2714:Source/queue.c **** 			{
2715:Source/queue.c **** 				/* Set the name to NULL to show that this slot if free again. */
2716:Source/queue.c **** 				xQueueRegistry[ ux ].pcQueueName = NULL;
 3014              		.loc 1 2716 0
 3015 001e 0B4A     		ldr	r2, .L197
 3016 0020 FB68     		ldr	r3, [r7, #12]
 3017 0022 0021     		movs	r1, #0
 3018 0024 42F83310 		str	r1, [r2, r3, lsl #3]
2717:Source/queue.c **** 
2718:Source/queue.c **** 				/* Set the handle to NULL to ensure the same queue handle cannot
2719:Source/queue.c **** 				appear in the registry twice if it is added, removed, then
2720:Source/queue.c **** 				added again. */
2721:Source/queue.c **** 				xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
 3019              		.loc 1 2721 0
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 106


 3020 0028 084A     		ldr	r2, .L197
 3021 002a FB68     		ldr	r3, [r7, #12]
 3022 002c DB00     		lsls	r3, r3, #3
 3023 002e 1344     		add	r3, r3, r2
 3024 0030 0022     		movs	r2, #0
 3025 0032 5A60     		str	r2, [r3, #4]
2722:Source/queue.c **** 				break;
 3026              		.loc 1 2722 0
 3027 0034 05E0     		b	.L195
 3028              	.L194:
2711:Source/queue.c **** 		{
 3029              		.loc 1 2711 0 discriminator 2
 3030 0036 FB68     		ldr	r3, [r7, #12]
 3031 0038 0133     		adds	r3, r3, #1
 3032 003a FB60     		str	r3, [r7, #12]
 3033              	.L193:
2711:Source/queue.c **** 		{
 3034              		.loc 1 2711 0 is_stmt 0 discriminator 1
 3035 003c FB68     		ldr	r3, [r7, #12]
 3036 003e 092B     		cmp	r3, #9
 3037 0040 E5D9     		bls	.L196
 3038              	.L195:
2723:Source/queue.c **** 			}
2724:Source/queue.c **** 			else
2725:Source/queue.c **** 			{
2726:Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2727:Source/queue.c **** 			}
2728:Source/queue.c **** 		}
2729:Source/queue.c **** 
2730:Source/queue.c **** 	} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 3039              		.loc 1 2730 0 is_stmt 1
 3040 0042 00BF     		nop
 3041 0044 1437     		adds	r7, r7, #20
 3042              		.cfi_def_cfa_offset 4
 3043 0046 BD46     		mov	sp, r7
 3044              		.cfi_def_cfa_register 13
 3045              		@ sp needed
 3046 0048 80BC     		pop	{r7}
 3047              		.cfi_restore 7
 3048              		.cfi_def_cfa_offset 0
 3049 004a 7047     		bx	lr
 3050              	.L198:
 3051              		.align	2
 3052              	.L197:
 3053 004c 00000000 		.word	xQueueRegistry
 3054              		.cfi_endproc
 3055              	.LFE98:
 3056              		.size	vQueueUnregisterQueue, .-vQueueUnregisterQueue
 3057              		.text
 3058              	.Letext0:
 3059              		.file 3 "c:\\program files (x86)\\cypress\\psoc creator\\4.3\\psoc creator\\import\\gnu\\arm\\5.4.
 3060              		.file 4 "c:\\program files (x86)\\cypress\\psoc creator\\4.3\\psoc creator\\import\\gnu\\arm\\5.4.
 3061              		.file 5 "c:\\program files (x86)\\cypress\\psoc creator\\4.3\\psoc creator\\import\\gnu\\arm\\5.4.
 3062              		.file 6 "Generated_Source\\PSoC5/cytypes.h"
 3063              		.file 7 "Generated_Source\\PSoC5/DS18x8.h"
 3064              		.file 8 ".\\Source\\include/list.h"
 3065              		.file 9 ".\\Source\\include/task.h"
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 107


 3066              		.file 10 ".\\Source\\include/queue.h"
 3067              		.file 11 "Generated_Source\\PSoC5/core_cm3.h"
 3068              		.section	.debug_info,"",%progbits
 3069              	.Ldebug_info0:
 3070 0000 52110000 		.4byte	0x1152
 3071 0004 0400     		.2byte	0x4
 3072 0006 00000000 		.4byte	.Ldebug_abbrev0
 3073 000a 04       		.byte	0x4
 3074 000b 01       		.uleb128 0x1
 3075 000c 14010000 		.4byte	.LASF147
 3076 0010 0C       		.byte	0xc
 3077 0011 39020000 		.4byte	.LASF148
 3078 0015 55080000 		.4byte	.LASF149
 3079 0019 00000000 		.4byte	.Ldebug_ranges0+0
 3080 001d 00000000 		.4byte	0
 3081 0021 00000000 		.4byte	.Ldebug_line0
 3082 0025 02       		.uleb128 0x2
 3083 0026 A0030000 		.4byte	.LASF3
 3084 002a 03       		.byte	0x3
 3085 002b D8       		.byte	0xd8
 3086 002c 30000000 		.4byte	0x30
 3087 0030 03       		.uleb128 0x3
 3088 0031 04       		.byte	0x4
 3089 0032 07       		.byte	0x7
 3090 0033 C1000000 		.4byte	.LASF0
 3091 0037 04       		.uleb128 0x4
 3092 0038 04       		.byte	0x4
 3093 0039 05       		.byte	0x5
 3094 003a 696E7400 		.ascii	"int\000"
 3095 003e 03       		.uleb128 0x3
 3096 003f 08       		.byte	0x8
 3097 0040 05       		.byte	0x5
 3098 0041 6C050000 		.4byte	.LASF1
 3099 0045 03       		.uleb128 0x3
 3100 0046 08       		.byte	0x8
 3101 0047 04       		.byte	0x4
 3102 0048 A8060000 		.4byte	.LASF2
 3103 004c 02       		.uleb128 0x2
 3104 004d 85060000 		.4byte	.LASF4
 3105 0051 04       		.byte	0x4
 3106 0052 1B       		.byte	0x1b
 3107 0053 57000000 		.4byte	0x57
 3108 0057 03       		.uleb128 0x3
 3109 0058 01       		.byte	0x1
 3110 0059 06       		.byte	0x6
 3111 005a 10090000 		.4byte	.LASF5
 3112 005e 02       		.uleb128 0x2
 3113 005f AE070000 		.4byte	.LASF6
 3114 0063 04       		.byte	0x4
 3115 0064 1D       		.byte	0x1d
 3116 0065 69000000 		.4byte	0x69
 3117 0069 03       		.uleb128 0x3
 3118 006a 01       		.byte	0x1
 3119 006b 08       		.byte	0x8
 3120 006c 16080000 		.4byte	.LASF7
 3121 0070 03       		.uleb128 0x3
 3122 0071 02       		.byte	0x2
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 108


 3123 0072 05       		.byte	0x5
 3124 0073 1F070000 		.4byte	.LASF8
 3125 0077 03       		.uleb128 0x3
 3126 0078 02       		.byte	0x2
 3127 0079 07       		.byte	0x7
 3128 007a 1C090000 		.4byte	.LASF9
 3129 007e 02       		.uleb128 0x2
 3130 007f EB000000 		.4byte	.LASF10
 3131 0083 04       		.byte	0x4
 3132 0084 3F       		.byte	0x3f
 3133 0085 89000000 		.4byte	0x89
 3134 0089 03       		.uleb128 0x3
 3135 008a 04       		.byte	0x4
 3136 008b 05       		.byte	0x5
 3137 008c 34070000 		.4byte	.LASF11
 3138 0090 02       		.uleb128 0x2
 3139 0091 24080000 		.4byte	.LASF12
 3140 0095 04       		.byte	0x4
 3141 0096 41       		.byte	0x41
 3142 0097 9B000000 		.4byte	0x9b
 3143 009b 03       		.uleb128 0x3
 3144 009c 04       		.byte	0x4
 3145 009d 07       		.byte	0x7
 3146 009e D1070000 		.4byte	.LASF13
 3147 00a2 03       		.uleb128 0x3
 3148 00a3 08       		.byte	0x8
 3149 00a4 07       		.byte	0x7
 3150 00a5 F0020000 		.4byte	.LASF14
 3151 00a9 03       		.uleb128 0x3
 3152 00aa 04       		.byte	0x4
 3153 00ab 07       		.byte	0x7
 3154 00ac C8070000 		.4byte	.LASF15
 3155 00b0 05       		.uleb128 0x5
 3156 00b1 04       		.byte	0x4
 3157 00b2 03       		.uleb128 0x3
 3158 00b3 01       		.byte	0x1
 3159 00b4 08       		.byte	0x8
 3160 00b5 5E040000 		.4byte	.LASF16
 3161 00b9 06       		.uleb128 0x6
 3162 00ba 04       		.byte	0x4
 3163 00bb BF000000 		.4byte	0xbf
 3164 00bf 07       		.uleb128 0x7
 3165 00c0 B2000000 		.4byte	0xb2
 3166 00c4 06       		.uleb128 0x6
 3167 00c5 04       		.byte	0x4
 3168 00c6 CA000000 		.4byte	0xca
 3169 00ca 08       		.uleb128 0x8
 3170 00cb 02       		.uleb128 0x2
 3171 00cc 9F020000 		.4byte	.LASF17
 3172 00d0 05       		.byte	0x5
 3173 00d1 14       		.byte	0x14
 3174 00d2 4C000000 		.4byte	0x4c
 3175 00d6 02       		.uleb128 0x2
 3176 00d7 10050000 		.4byte	.LASF18
 3177 00db 05       		.byte	0x5
 3178 00dc 18       		.byte	0x18
 3179 00dd 5E000000 		.4byte	0x5e
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 109


 3180 00e1 02       		.uleb128 0x2
 3181 00e2 E3070000 		.4byte	.LASF19
 3182 00e6 05       		.byte	0x5
 3183 00e7 2C       		.byte	0x2c
 3184 00e8 7E000000 		.4byte	0x7e
 3185 00ec 02       		.uleb128 0x2
 3186 00ed 96020000 		.4byte	.LASF20
 3187 00f1 05       		.byte	0x5
 3188 00f2 30       		.byte	0x30
 3189 00f3 90000000 		.4byte	0x90
 3190 00f7 09       		.uleb128 0x9
 3191 00f8 43090000 		.4byte	.LASF21
 3192 00fc 06       		.byte	0x6
 3193 00fd E401     		.2byte	0x1e4
 3194 00ff 69000000 		.4byte	0x69
 3195 0103 09       		.uleb128 0x9
 3196 0104 DC040000 		.4byte	.LASF22
 3197 0108 06       		.byte	0x6
 3198 0109 E501     		.2byte	0x1e5
 3199 010b 77000000 		.4byte	0x77
 3200 010f 03       		.uleb128 0x3
 3201 0110 04       		.byte	0x4
 3202 0111 04       		.byte	0x4
 3203 0112 DA020000 		.4byte	.LASF23
 3204 0116 03       		.uleb128 0x3
 3205 0117 08       		.byte	0x8
 3206 0118 04       		.byte	0x4
 3207 0119 49090000 		.4byte	.LASF24
 3208 011d 0A       		.uleb128 0xa
 3209 011e F7000000 		.4byte	0xf7
 3210 0122 0B       		.uleb128 0xb
 3211 0123 42000000 		.4byte	.LASF30
 3212 0127 04       		.byte	0x4
 3213 0128 07       		.byte	0x7
 3214 0129 30       		.byte	0x30
 3215 012a 47010000 		.4byte	0x147
 3216 012e 0C       		.uleb128 0xc
 3217 012f 8E060000 		.4byte	.LASF25
 3218 0133 07       		.byte	0x7
 3219 0134 31       		.byte	0x31
 3220 0135 03010000 		.4byte	0x103
 3221 0139 00       		.byte	0
 3222 013a 0C       		.uleb128 0xc
 3223 013b 2B050000 		.4byte	.LASF26
 3224 013f 07       		.byte	0x7
 3225 0140 32       		.byte	0x32
 3226 0141 F7000000 		.4byte	0xf7
 3227 0145 02       		.byte	0x2
 3228 0146 00       		.byte	0
 3229 0147 02       		.uleb128 0x2
 3230 0148 8D050000 		.4byte	.LASF27
 3231 014c 02       		.byte	0x2
 3232 014d 38       		.byte	0x38
 3233 014e 89000000 		.4byte	0x89
 3234 0152 02       		.uleb128 0x2
 3235 0153 98040000 		.4byte	.LASF28
 3236 0157 02       		.byte	0x2
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 110


 3237 0158 39       		.byte	0x39
 3238 0159 9B000000 		.4byte	0x9b
 3239 015d 02       		.uleb128 0x2
 3240 015e 7A060000 		.4byte	.LASF29
 3241 0162 02       		.byte	0x2
 3242 0163 3F       		.byte	0x3f
 3243 0164 EC000000 		.4byte	0xec
 3244 0168 06       		.uleb128 0x6
 3245 0169 04       		.byte	0x4
 3246 016a D6000000 		.4byte	0xd6
 3247 016e 0B       		.uleb128 0xb
 3248 016f F5000000 		.4byte	.LASF31
 3249 0173 14       		.byte	0x14
 3250 0174 08       		.byte	0x8
 3251 0175 8C       		.byte	0x8c
 3252 0176 B7010000 		.4byte	0x1b7
 3253 017a 0C       		.uleb128 0xc
 3254 017b 29070000 		.4byte	.LASF32
 3255 017f 08       		.byte	0x8
 3256 0180 8F       		.byte	0x8f
 3257 0181 5D010000 		.4byte	0x15d
 3258 0185 00       		.byte	0
 3259 0186 0C       		.uleb128 0xc
 3260 0187 D3050000 		.4byte	.LASF33
 3261 018b 08       		.byte	0x8
 3262 018c 90       		.byte	0x90
 3263 018d B7010000 		.4byte	0x1b7
 3264 0191 04       		.byte	0x4
 3265 0192 0C       		.uleb128 0xc
 3266 0193 45030000 		.4byte	.LASF34
 3267 0197 08       		.byte	0x8
 3268 0198 91       		.byte	0x91
 3269 0199 B7010000 		.4byte	0x1b7
 3270 019d 08       		.byte	0x8
 3271 019e 0C       		.uleb128 0xc
 3272 019f AC080000 		.4byte	.LASF35
 3273 01a3 08       		.byte	0x8
 3274 01a4 92       		.byte	0x92
 3275 01a5 B0000000 		.4byte	0xb0
 3276 01a9 0C       		.byte	0xc
 3277 01aa 0C       		.uleb128 0xc
 3278 01ab E2060000 		.4byte	.LASF36
 3279 01af 08       		.byte	0x8
 3280 01b0 93       		.byte	0x93
 3281 01b1 EE010000 		.4byte	0x1ee
 3282 01b5 10       		.byte	0x10
 3283 01b6 00       		.byte	0
 3284 01b7 06       		.uleb128 0x6
 3285 01b8 04       		.byte	0x4
 3286 01b9 6E010000 		.4byte	0x16e
 3287 01bd 0B       		.uleb128 0xb
 3288 01be E2030000 		.4byte	.LASF37
 3289 01c2 14       		.byte	0x14
 3290 01c3 08       		.byte	0x8
 3291 01c4 A4       		.byte	0xa4
 3292 01c5 EE010000 		.4byte	0x1ee
 3293 01c9 0C       		.uleb128 0xc
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 111


 3294 01ca 00000000 		.4byte	.LASF38
 3295 01ce 08       		.byte	0x8
 3296 01cf A7       		.byte	0xa7
 3297 01d0 3B020000 		.4byte	0x23b
 3298 01d4 00       		.byte	0
 3299 01d5 0C       		.uleb128 0xc
 3300 01d6 CE000000 		.4byte	.LASF39
 3301 01da 08       		.byte	0x8
 3302 01db A8       		.byte	0xa8
 3303 01dc 40020000 		.4byte	0x240
 3304 01e0 04       		.byte	0x4
 3305 01e1 0C       		.uleb128 0xc
 3306 01e2 D3040000 		.4byte	.LASF40
 3307 01e6 08       		.byte	0x8
 3308 01e7 A9       		.byte	0xa9
 3309 01e8 30020000 		.4byte	0x230
 3310 01ec 08       		.byte	0x8
 3311 01ed 00       		.byte	0
 3312 01ee 06       		.uleb128 0x6
 3313 01ef 04       		.byte	0x4
 3314 01f0 BD010000 		.4byte	0x1bd
 3315 01f4 02       		.uleb128 0x2
 3316 01f5 63040000 		.4byte	.LASF41
 3317 01f9 08       		.byte	0x8
 3318 01fa 96       		.byte	0x96
 3319 01fb 6E010000 		.4byte	0x16e
 3320 01ff 0B       		.uleb128 0xb
 3321 0200 C4030000 		.4byte	.LASF42
 3322 0204 0C       		.byte	0xc
 3323 0205 08       		.byte	0x8
 3324 0206 98       		.byte	0x98
 3325 0207 30020000 		.4byte	0x230
 3326 020b 0C       		.uleb128 0xc
 3327 020c 29070000 		.4byte	.LASF32
 3328 0210 08       		.byte	0x8
 3329 0211 9B       		.byte	0x9b
 3330 0212 5D010000 		.4byte	0x15d
 3331 0216 00       		.byte	0
 3332 0217 0C       		.uleb128 0xc
 3333 0218 D3050000 		.4byte	.LASF33
 3334 021c 08       		.byte	0x8
 3335 021d 9C       		.byte	0x9c
 3336 021e B7010000 		.4byte	0x1b7
 3337 0222 04       		.byte	0x4
 3338 0223 0C       		.uleb128 0xc
 3339 0224 45030000 		.4byte	.LASF34
 3340 0228 08       		.byte	0x8
 3341 0229 9D       		.byte	0x9d
 3342 022a B7010000 		.4byte	0x1b7
 3343 022e 08       		.byte	0x8
 3344 022f 00       		.byte	0
 3345 0230 02       		.uleb128 0x2
 3346 0231 01050000 		.4byte	.LASF43
 3347 0235 08       		.byte	0x8
 3348 0236 9F       		.byte	0x9f
 3349 0237 FF010000 		.4byte	0x1ff
 3350 023b 0A       		.uleb128 0xa
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 112


 3351 023c 52010000 		.4byte	0x152
 3352 0240 06       		.uleb128 0x6
 3353 0241 04       		.byte	0x4
 3354 0242 F4010000 		.4byte	0x1f4
 3355 0246 02       		.uleb128 0x2
 3356 0247 58060000 		.4byte	.LASF44
 3357 024b 08       		.byte	0x8
 3358 024c AB       		.byte	0xab
 3359 024d BD010000 		.4byte	0x1bd
 3360 0251 02       		.uleb128 0x2
 3361 0252 10060000 		.4byte	.LASF45
 3362 0256 09       		.byte	0x9
 3363 0257 46       		.byte	0x46
 3364 0258 5C020000 		.4byte	0x25c
 3365 025c 06       		.uleb128 0x6
 3366 025d 04       		.byte	0x4
 3367 025e 62020000 		.4byte	0x262
 3368 0262 0D       		.uleb128 0xd
 3369 0263 1E000000 		.4byte	.LASF150
 3370 0267 0B       		.uleb128 0xb
 3371 0268 D6000000 		.4byte	.LASF46
 3372 026c 08       		.byte	0x8
 3373 026d 09       		.byte	0x9
 3374 026e 66       		.byte	0x66
 3375 026f 8C020000 		.4byte	0x28c
 3376 0273 0C       		.uleb128 0xc
 3377 0274 D5010000 		.4byte	.LASF47
 3378 0278 09       		.byte	0x9
 3379 0279 68       		.byte	0x68
 3380 027a 47010000 		.4byte	0x147
 3381 027e 00       		.byte	0
 3382 027f 0C       		.uleb128 0xc
 3383 0280 AF050000 		.4byte	.LASF48
 3384 0284 09       		.byte	0x9
 3385 0285 69       		.byte	0x69
 3386 0286 5D010000 		.4byte	0x15d
 3387 028a 04       		.byte	0x4
 3388 028b 00       		.byte	0
 3389 028c 02       		.uleb128 0x2
 3390 028d EF050000 		.4byte	.LASF49
 3391 0291 09       		.byte	0x9
 3392 0292 6A       		.byte	0x6a
 3393 0293 67020000 		.4byte	0x267
 3394 0297 02       		.uleb128 0x2
 3395 0298 C5040000 		.4byte	.LASF50
 3396 029c 0A       		.byte	0xa
 3397 029d 30       		.byte	0x30
 3398 029e A2020000 		.4byte	0x2a2
 3399 02a2 06       		.uleb128 0x6
 3400 02a3 04       		.byte	0x4
 3401 02a4 A8020000 		.4byte	0x2a8
 3402 02a8 0B       		.uleb128 0xb
 3403 02a9 E0020000 		.4byte	.LASF51
 3404 02ad 48       		.byte	0x48
 3405 02ae 01       		.byte	0x1
 3406 02af 61       		.byte	0x61
 3407 02b0 2B030000 		.4byte	0x32b
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 113


 3408 02b4 0C       		.uleb128 0xc
 3409 02b5 B4080000 		.4byte	.LASF52
 3410 02b9 01       		.byte	0x1
 3411 02ba 63       		.byte	0x63
 3412 02bb 50030000 		.4byte	0x350
 3413 02bf 00       		.byte	0
 3414 02c0 0C       		.uleb128 0xc
 3415 02c1 70060000 		.4byte	.LASF53
 3416 02c5 01       		.byte	0x1
 3417 02c6 64       		.byte	0x64
 3418 02c7 50030000 		.4byte	0x350
 3419 02cb 04       		.byte	0x4
 3420 02cc 0E       		.uleb128 0xe
 3421 02cd 7500     		.ascii	"u\000"
 3422 02cf 01       		.byte	0x1
 3423 02d0 6A       		.byte	0x6a
 3424 02d1 91030000 		.4byte	0x391
 3425 02d5 08       		.byte	0x8
 3426 02d6 0C       		.uleb128 0xc
 3427 02d7 A2010000 		.4byte	.LASF54
 3428 02db 01       		.byte	0x1
 3429 02dc 6C       		.byte	0x6c
 3430 02dd 46020000 		.4byte	0x246
 3431 02e1 10       		.byte	0x10
 3432 02e2 0C       		.uleb128 0xc
 3433 02e3 74000000 		.4byte	.LASF55
 3434 02e7 01       		.byte	0x1
 3435 02e8 6D       		.byte	0x6d
 3436 02e9 46020000 		.4byte	0x246
 3437 02ed 24       		.byte	0x24
 3438 02ee 0C       		.uleb128 0xc
 3439 02ef 50030000 		.4byte	.LASF56
 3440 02f3 01       		.byte	0x1
 3441 02f4 6F       		.byte	0x6f
 3442 02f5 3B020000 		.4byte	0x23b
 3443 02f9 38       		.byte	0x38
 3444 02fa 0C       		.uleb128 0xc
 3445 02fb 16070000 		.4byte	.LASF57
 3446 02ff 01       		.byte	0x1
 3447 0300 70       		.byte	0x70
 3448 0301 52010000 		.4byte	0x152
 3449 0305 3C       		.byte	0x3c
 3450 0306 0C       		.uleb128 0xc
 3451 0307 36040000 		.4byte	.LASF58
 3452 030b 01       		.byte	0x1
 3453 030c 71       		.byte	0x71
 3454 030d 52010000 		.4byte	0x152
 3455 0311 40       		.byte	0x40
 3456 0312 0C       		.uleb128 0xc
 3457 0313 5A090000 		.4byte	.LASF59
 3458 0317 01       		.byte	0x1
 3459 0318 73       		.byte	0x73
 3460 0319 B0030000 		.4byte	0x3b0
 3461 031d 44       		.byte	0x44
 3462 031e 0C       		.uleb128 0xc
 3463 031f CD010000 		.4byte	.LASF60
 3464 0323 01       		.byte	0x1
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 114


 3465 0324 74       		.byte	0x74
 3466 0325 B0030000 		.4byte	0x3b0
 3467 0329 45       		.byte	0x45
 3468 032a 00       		.byte	0
 3469 032b 0B       		.uleb128 0xb
 3470 032c 7D040000 		.4byte	.LASF61
 3471 0330 08       		.byte	0x8
 3472 0331 01       		.byte	0x1
 3473 0332 43       		.byte	0x43
 3474 0333 50030000 		.4byte	0x350
 3475 0337 0C       		.uleb128 0xc
 3476 0338 9A070000 		.4byte	.LASF62
 3477 033c 01       		.byte	0x1
 3478 033d 45       		.byte	0x45
 3479 033e 50030000 		.4byte	0x350
 3480 0342 00       		.byte	0
 3481 0343 0C       		.uleb128 0xc
 3482 0344 48020000 		.4byte	.LASF63
 3483 0348 01       		.byte	0x1
 3484 0349 46       		.byte	0x46
 3485 034a 50030000 		.4byte	0x350
 3486 034e 04       		.byte	0x4
 3487 034f 00       		.byte	0
 3488 0350 06       		.uleb128 0x6
 3489 0351 04       		.byte	0x4
 3490 0352 CB000000 		.4byte	0xcb
 3491 0356 02       		.uleb128 0x2
 3492 0357 FD060000 		.4byte	.LASF64
 3493 035b 01       		.byte	0x1
 3494 035c 47       		.byte	0x47
 3495 035d 2B030000 		.4byte	0x32b
 3496 0361 0B       		.uleb128 0xb
 3497 0362 10000000 		.4byte	.LASF65
 3498 0366 08       		.byte	0x8
 3499 0367 01       		.byte	0x1
 3500 0368 49       		.byte	0x49
 3501 0369 86030000 		.4byte	0x386
 3502 036d 0C       		.uleb128 0xc
 3503 036e 36090000 		.4byte	.LASF66
 3504 0372 01       		.byte	0x1
 3505 0373 4B       		.byte	0x4b
 3506 0374 51020000 		.4byte	0x251
 3507 0378 00       		.byte	0
 3508 0379 0C       		.uleb128 0xc
 3509 037a E4010000 		.4byte	.LASF67
 3510 037e 01       		.byte	0x1
 3511 037f 4C       		.byte	0x4c
 3512 0380 52010000 		.4byte	0x152
 3513 0384 04       		.byte	0x4
 3514 0385 00       		.byte	0
 3515 0386 02       		.uleb128 0x2
 3516 0387 32000000 		.4byte	.LASF68
 3517 038b 01       		.byte	0x1
 3518 038c 4D       		.byte	0x4d
 3519 038d 61030000 		.4byte	0x361
 3520 0391 0F       		.uleb128 0xf
 3521 0392 08       		.byte	0x8
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 115


 3522 0393 01       		.byte	0x1
 3523 0394 66       		.byte	0x66
 3524 0395 B0030000 		.4byte	0x3b0
 3525 0399 10       		.uleb128 0x10
 3526 039a D3020000 		.4byte	.LASF69
 3527 039e 01       		.byte	0x1
 3528 039f 68       		.byte	0x68
 3529 03a0 56030000 		.4byte	0x356
 3530 03a4 10       		.uleb128 0x10
 3531 03a5 62030000 		.4byte	.LASF70
 3532 03a9 01       		.byte	0x1
 3533 03aa 69       		.byte	0x69
 3534 03ab 86030000 		.4byte	0x386
 3535 03af 00       		.byte	0
 3536 03b0 0A       		.uleb128 0xa
 3537 03b1 CB000000 		.4byte	0xcb
 3538 03b5 02       		.uleb128 0x2
 3539 03b6 2F090000 		.4byte	.LASF71
 3540 03ba 01       		.byte	0x1
 3541 03bb 83       		.byte	0x83
 3542 03bc A8020000 		.4byte	0x2a8
 3543 03c0 02       		.uleb128 0x2
 3544 03c1 F9010000 		.4byte	.LASF72
 3545 03c5 01       		.byte	0x1
 3546 03c6 87       		.byte	0x87
 3547 03c7 B5030000 		.4byte	0x3b5
 3548 03cb 0B       		.uleb128 0xb
 3549 03cc 00010000 		.4byte	.LASF73
 3550 03d0 08       		.byte	0x8
 3551 03d1 01       		.byte	0x1
 3552 03d2 94       		.byte	0x94
 3553 03d3 F0030000 		.4byte	0x3f0
 3554 03d7 0C       		.uleb128 0xc
 3555 03d8 B8030000 		.4byte	.LASF74
 3556 03dc 01       		.byte	0x1
 3557 03dd 96       		.byte	0x96
 3558 03de B9000000 		.4byte	0xb9
 3559 03e2 00       		.byte	0
 3560 03e3 0C       		.uleb128 0xc
 3561 03e4 B0030000 		.4byte	.LASF75
 3562 03e8 01       		.byte	0x1
 3563 03e9 97       		.byte	0x97
 3564 03ea 97020000 		.4byte	0x297
 3565 03ee 04       		.byte	0x4
 3566 03ef 00       		.byte	0
 3567 03f0 02       		.uleb128 0x2
 3568 03f1 18050000 		.4byte	.LASF76
 3569 03f5 01       		.byte	0x1
 3570 03f6 98       		.byte	0x98
 3571 03f7 CB030000 		.4byte	0x3cb
 3572 03fb 02       		.uleb128 0x2
 3573 03fc 18020000 		.4byte	.LASF77
 3574 0400 01       		.byte	0x1
 3575 0401 9D       		.byte	0x9d
 3576 0402 F0030000 		.4byte	0x3f0
 3577 0406 11       		.uleb128 0x11
 3578 0407 59050000 		.4byte	.LASF151
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 116


 3579 040b 02       		.byte	0x2
 3580 040c D1       		.byte	0xd1
 3581 040d EC000000 		.4byte	0xec
 3582 0411 03       		.byte	0x3
 3583 0412 2D040000 		.4byte	0x42d
 3584 0416 12       		.uleb128 0x12
 3585 0417 C1020000 		.4byte	.LASF78
 3586 041b 02       		.byte	0x2
 3587 041c D3       		.byte	0xd3
 3588 041d EC000000 		.4byte	0xec
 3589 0421 12       		.uleb128 0x12
 3590 0422 8B040000 		.4byte	.LASF79
 3591 0426 02       		.byte	0x2
 3592 0427 D3       		.byte	0xd3
 3593 0428 EC000000 		.4byte	0xec
 3594 042c 00       		.byte	0
 3595 042d 13       		.uleb128 0x13
 3596 042e 01040000 		.4byte	.LASF152
 3597 0432 02       		.byte	0x2
 3598 0433 E5       		.byte	0xe5
 3599 0434 03       		.byte	0x3
 3600 0435 45040000 		.4byte	0x445
 3601 0439 14       		.uleb128 0x14
 3602 043a 1D060000 		.4byte	.LASF153
 3603 043e 02       		.byte	0x2
 3604 043f E5       		.byte	0xe5
 3605 0440 EC000000 		.4byte	0xec
 3606 0444 00       		.byte	0
 3607 0445 15       		.uleb128 0x15
 3608 0446 E3080000 		.4byte	.LASF81
 3609 044a 01       		.byte	0x1
 3610 044b FF       		.byte	0xff
 3611 044c 47010000 		.4byte	0x147
 3612 0450 00000000 		.4byte	.LFB68
 3613 0454 B4000000 		.4byte	.LFE68-.LFB68
 3614 0458 01       		.uleb128 0x1
 3615 0459 9C       		.byte	0x9c
 3616 045a 8A040000 		.4byte	0x48a
 3617 045e 16       		.uleb128 0x16
 3618 045f D3020000 		.4byte	.LASF69
 3619 0463 01       		.byte	0x1
 3620 0464 FF       		.byte	0xff
 3621 0465 97020000 		.4byte	0x297
 3622 0469 02       		.uleb128 0x2
 3623 046a 91       		.byte	0x91
 3624 046b 6C       		.sleb128 -20
 3625 046c 16       		.uleb128 0x16
 3626 046d DA050000 		.4byte	.LASF80
 3627 0471 01       		.byte	0x1
 3628 0472 FF       		.byte	0xff
 3629 0473 47010000 		.4byte	0x147
 3630 0477 02       		.uleb128 0x2
 3631 0478 91       		.byte	0x91
 3632 0479 68       		.sleb128 -24
 3633 047a 17       		.uleb128 0x17
 3634 047b B8070000 		.4byte	.LASF85
 3635 047f 01       		.byte	0x1
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 117


 3636 0480 0101     		.2byte	0x101
 3637 0482 90040000 		.4byte	0x490
 3638 0486 02       		.uleb128 0x2
 3639 0487 91       		.byte	0x91
 3640 0488 74       		.sleb128 -12
 3641 0489 00       		.byte	0
 3642 048a 06       		.uleb128 0x6
 3643 048b 04       		.byte	0x4
 3644 048c C0030000 		.4byte	0x3c0
 3645 0490 07       		.uleb128 0x7
 3646 0491 8A040000 		.4byte	0x48a
 3647 0495 18       		.uleb128 0x18
 3648 0496 33050000 		.4byte	.LASF82
 3649 049a 01       		.byte	0x1
 3650 049b 7001     		.2byte	0x170
 3651 049d 97020000 		.4byte	0x297
 3652 04a1 00000000 		.4byte	.LFB69
 3653 04a5 50000000 		.4byte	.LFE69-.LFB69
 3654 04a9 01       		.uleb128 0x1
 3655 04aa 9C       		.byte	0x9c
 3656 04ab 0A050000 		.4byte	0x50a
 3657 04af 19       		.uleb128 0x19
 3658 04b0 9A060000 		.4byte	.LASF83
 3659 04b4 01       		.byte	0x1
 3660 04b5 7001     		.2byte	0x170
 3661 04b7 0A050000 		.4byte	0x50a
 3662 04bb 02       		.uleb128 0x2
 3663 04bc 91       		.byte	0x91
 3664 04bd 64       		.sleb128 -28
 3665 04be 19       		.uleb128 0x19
 3666 04bf 36040000 		.4byte	.LASF58
 3667 04c3 01       		.byte	0x1
 3668 04c4 7001     		.2byte	0x170
 3669 04c6 0A050000 		.4byte	0x50a
 3670 04ca 02       		.uleb128 0x2
 3671 04cb 91       		.byte	0x91
 3672 04cc 60       		.sleb128 -32
 3673 04cd 19       		.uleb128 0x19
 3674 04ce 4C060000 		.4byte	.LASF84
 3675 04d2 01       		.byte	0x1
 3676 04d3 7001     		.2byte	0x170
 3677 04d5 0F050000 		.4byte	0x50f
 3678 04d9 02       		.uleb128 0x2
 3679 04da 91       		.byte	0x91
 3680 04db 5F       		.sleb128 -33
 3681 04dc 17       		.uleb128 0x17
 3682 04dd E0000000 		.4byte	.LASF86
 3683 04e1 01       		.byte	0x1
 3684 04e2 7201     		.2byte	0x172
 3685 04e4 8A040000 		.4byte	0x48a
 3686 04e8 02       		.uleb128 0x2
 3687 04e9 91       		.byte	0x91
 3688 04ea 70       		.sleb128 -16
 3689 04eb 17       		.uleb128 0x17
 3690 04ec 4A070000 		.4byte	.LASF87
 3691 04f0 01       		.byte	0x1
 3692 04f1 7301     		.2byte	0x173
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 118


 3693 04f3 25000000 		.4byte	0x25
 3694 04f7 02       		.uleb128 0x2
 3695 04f8 91       		.byte	0x91
 3696 04f9 74       		.sleb128 -12
 3697 04fa 17       		.uleb128 0x17
 3698 04fb 98050000 		.4byte	.LASF88
 3699 04ff 01       		.byte	0x1
 3700 0500 7401     		.2byte	0x174
 3701 0502 68010000 		.4byte	0x168
 3702 0506 02       		.uleb128 0x2
 3703 0507 91       		.byte	0x91
 3704 0508 6C       		.sleb128 -20
 3705 0509 00       		.byte	0
 3706 050a 07       		.uleb128 0x7
 3707 050b 52010000 		.4byte	0x152
 3708 050f 07       		.uleb128 0x7
 3709 0510 D6000000 		.4byte	0xd6
 3710 0514 1A       		.uleb128 0x1a
 3711 0515 80020000 		.4byte	.LASF89
 3712 0519 01       		.byte	0x1
 3713 051a A601     		.2byte	0x1a6
 3714 051c 00000000 		.4byte	.LFB70
 3715 0520 3E000000 		.4byte	.LFE70-.LFB70
 3716 0524 01       		.uleb128 0x1
 3717 0525 9C       		.byte	0x9c
 3718 0526 76050000 		.4byte	0x576
 3719 052a 19       		.uleb128 0x19
 3720 052b 9A060000 		.4byte	.LASF83
 3721 052f 01       		.byte	0x1
 3722 0530 A601     		.2byte	0x1a6
 3723 0532 0A050000 		.4byte	0x50a
 3724 0536 02       		.uleb128 0x2
 3725 0537 91       		.byte	0x91
 3726 0538 74       		.sleb128 -12
 3727 0539 19       		.uleb128 0x19
 3728 053a 36040000 		.4byte	.LASF58
 3729 053e 01       		.byte	0x1
 3730 053f A601     		.2byte	0x1a6
 3731 0541 0A050000 		.4byte	0x50a
 3732 0545 02       		.uleb128 0x2
 3733 0546 91       		.byte	0x91
 3734 0547 70       		.sleb128 -16
 3735 0548 19       		.uleb128 0x19
 3736 0549 98050000 		.4byte	.LASF88
 3737 054d 01       		.byte	0x1
 3738 054e A601     		.2byte	0x1a6
 3739 0550 68010000 		.4byte	0x168
 3740 0554 02       		.uleb128 0x2
 3741 0555 91       		.byte	0x91
 3742 0556 6C       		.sleb128 -20
 3743 0557 19       		.uleb128 0x19
 3744 0558 4C060000 		.4byte	.LASF84
 3745 055c 01       		.byte	0x1
 3746 055d A601     		.2byte	0x1a6
 3747 055f 0F050000 		.4byte	0x50f
 3748 0563 02       		.uleb128 0x2
 3749 0564 91       		.byte	0x91
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 119


 3750 0565 6B       		.sleb128 -21
 3751 0566 19       		.uleb128 0x19
 3752 0567 E0000000 		.4byte	.LASF86
 3753 056b 01       		.byte	0x1
 3754 056c A601     		.2byte	0x1a6
 3755 056e 8A040000 		.4byte	0x48a
 3756 0572 02       		.uleb128 0x2
 3757 0573 91       		.byte	0x91
 3758 0574 00       		.sleb128 0
 3759 0575 00       		.byte	0
 3760 0576 1A       		.uleb128 0x1a
 3761 0577 7A050000 		.4byte	.LASF90
 3762 057b 01       		.byte	0x1
 3763 057c D201     		.2byte	0x1d2
 3764 057e 00000000 		.4byte	.LFB71
 3765 0582 34000000 		.4byte	.LFE71-.LFB71
 3766 0586 01       		.uleb128 0x1
 3767 0587 9C       		.byte	0x9c
 3768 0588 9C050000 		.4byte	0x59c
 3769 058c 19       		.uleb128 0x19
 3770 058d E0000000 		.4byte	.LASF86
 3771 0591 01       		.byte	0x1
 3772 0592 D201     		.2byte	0x1d2
 3773 0594 8A040000 		.4byte	0x48a
 3774 0598 02       		.uleb128 0x2
 3775 0599 91       		.byte	0x91
 3776 059a 74       		.sleb128 -12
 3777 059b 00       		.byte	0
 3778 059c 18       		.uleb128 0x18
 3779 059d 47050000 		.4byte	.LASF91
 3780 05a1 01       		.byte	0x1
 3781 05a2 F001     		.2byte	0x1f0
 3782 05a4 97020000 		.4byte	0x297
 3783 05a8 00000000 		.4byte	.LFB72
 3784 05ac 30000000 		.4byte	.LFE72-.LFB72
 3785 05b0 01       		.uleb128 0x1
 3786 05b1 9C       		.byte	0x9c
 3787 05b2 F3050000 		.4byte	0x5f3
 3788 05b6 19       		.uleb128 0x19
 3789 05b7 4C060000 		.4byte	.LASF84
 3790 05bb 01       		.byte	0x1
 3791 05bc F001     		.2byte	0x1f0
 3792 05be 0F050000 		.4byte	0x50f
 3793 05c2 02       		.uleb128 0x2
 3794 05c3 91       		.byte	0x91
 3795 05c4 67       		.sleb128 -25
 3796 05c5 17       		.uleb128 0x17
 3797 05c6 DA050000 		.4byte	.LASF80
 3798 05ca 01       		.byte	0x1
 3799 05cb F201     		.2byte	0x1f2
 3800 05cd 97020000 		.4byte	0x297
 3801 05d1 02       		.uleb128 0x2
 3802 05d2 91       		.byte	0x91
 3803 05d3 6C       		.sleb128 -20
 3804 05d4 17       		.uleb128 0x17
 3805 05d5 50040000 		.4byte	.LASF92
 3806 05d9 01       		.byte	0x1
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 120


 3807 05da F301     		.2byte	0x1f3
 3808 05dc 0A050000 		.4byte	0x50a
 3809 05e0 02       		.uleb128 0x2
 3810 05e1 91       		.byte	0x91
 3811 05e2 74       		.sleb128 -12
 3812 05e3 17       		.uleb128 0x17
 3813 05e4 A6020000 		.4byte	.LASF93
 3814 05e8 01       		.byte	0x1
 3815 05e9 F301     		.2byte	0x1f3
 3816 05eb 0A050000 		.4byte	0x50a
 3817 05ef 02       		.uleb128 0x2
 3818 05f0 91       		.byte	0x91
 3819 05f1 70       		.sleb128 -16
 3820 05f2 00       		.byte	0
 3821 05f3 18       		.uleb128 0x18
 3822 05f4 BB080000 		.4byte	.LASF94
 3823 05f8 01       		.byte	0x1
 3824 05f9 4D02     		.2byte	0x24d
 3825 05fb 47010000 		.4byte	0x147
 3826 05ff 00000000 		.4byte	.LFB73
 3827 0603 4C000000 		.4byte	.LFE73-.LFB73
 3828 0607 01       		.uleb128 0x1
 3829 0608 9C       		.byte	0x9c
 3830 0609 3B060000 		.4byte	0x63b
 3831 060d 19       		.uleb128 0x19
 3832 060e A8050000 		.4byte	.LASF95
 3833 0612 01       		.byte	0x1
 3834 0613 4D02     		.2byte	0x24d
 3835 0615 97020000 		.4byte	0x297
 3836 0619 02       		.uleb128 0x2
 3837 061a 91       		.byte	0x91
 3838 061b 64       		.sleb128 -28
 3839 061c 17       		.uleb128 0x17
 3840 061d C0070000 		.4byte	.LASF96
 3841 0621 01       		.byte	0x1
 3842 0622 4F02     		.2byte	0x24f
 3843 0624 47010000 		.4byte	0x147
 3844 0628 02       		.uleb128 0x2
 3845 0629 91       		.byte	0x91
 3846 062a 6C       		.sleb128 -20
 3847 062b 17       		.uleb128 0x17
 3848 062c A5000000 		.4byte	.LASF97
 3849 0630 01       		.byte	0x1
 3850 0631 5002     		.2byte	0x250
 3851 0633 90040000 		.4byte	0x490
 3852 0637 02       		.uleb128 0x2
 3853 0638 91       		.byte	0x91
 3854 0639 68       		.sleb128 -24
 3855 063a 00       		.byte	0
 3856 063b 18       		.uleb128 0x18
 3857 063c C9060000 		.4byte	.LASF98
 3858 0640 01       		.byte	0x1
 3859 0641 8402     		.2byte	0x284
 3860 0643 47010000 		.4byte	0x147
 3861 0647 00000000 		.4byte	.LFB74
 3862 064b 50000000 		.4byte	.LFE74-.LFB74
 3863 064f 01       		.uleb128 0x1
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 121


 3864 0650 9C       		.byte	0x9c
 3865 0651 92060000 		.4byte	0x692
 3866 0655 19       		.uleb128 0x19
 3867 0656 A8050000 		.4byte	.LASF95
 3868 065a 01       		.byte	0x1
 3869 065b 8402     		.2byte	0x284
 3870 065d 97020000 		.4byte	0x297
 3871 0661 02       		.uleb128 0x2
 3872 0662 91       		.byte	0x91
 3873 0663 64       		.sleb128 -28
 3874 0664 19       		.uleb128 0x19
 3875 0665 A1070000 		.4byte	.LASF99
 3876 0669 01       		.byte	0x1
 3877 066a 8402     		.2byte	0x284
 3878 066c 5D010000 		.4byte	0x15d
 3879 0670 02       		.uleb128 0x2
 3880 0671 91       		.byte	0x91
 3881 0672 60       		.sleb128 -32
 3882 0673 17       		.uleb128 0x17
 3883 0674 C0070000 		.4byte	.LASF96
 3884 0678 01       		.byte	0x1
 3885 0679 8602     		.2byte	0x286
 3886 067b 47010000 		.4byte	0x147
 3887 067f 02       		.uleb128 0x2
 3888 0680 91       		.byte	0x91
 3889 0681 6C       		.sleb128 -20
 3890 0682 17       		.uleb128 0x17
 3891 0683 A5000000 		.4byte	.LASF97
 3892 0687 01       		.byte	0x1
 3893 0688 8702     		.2byte	0x287
 3894 068a 90040000 		.4byte	0x490
 3895 068e 02       		.uleb128 0x2
 3896 068f 91       		.byte	0x91
 3897 0690 68       		.sleb128 -24
 3898 0691 00       		.byte	0
 3899 0692 18       		.uleb128 0x18
 3900 0693 62090000 		.4byte	.LASF100
 3901 0697 01       		.byte	0x1
 3902 0698 CA02     		.2byte	0x2ca
 3903 069a 97020000 		.4byte	0x297
 3904 069e 00000000 		.4byte	.LFB75
 3905 06a2 2C000000 		.4byte	.LFE75-.LFB75
 3906 06a6 01       		.uleb128 0x1
 3907 06a7 9C       		.byte	0x9c
 3908 06a8 DA060000 		.4byte	0x6da
 3909 06ac 19       		.uleb128 0x19
 3910 06ad E4050000 		.4byte	.LASF101
 3911 06b1 01       		.byte	0x1
 3912 06b2 CA02     		.2byte	0x2ca
 3913 06b4 0A050000 		.4byte	0x50a
 3914 06b8 02       		.uleb128 0x2
 3915 06b9 91       		.byte	0x91
 3916 06ba 6C       		.sleb128 -20
 3917 06bb 19       		.uleb128 0x19
 3918 06bc 41040000 		.4byte	.LASF102
 3919 06c0 01       		.byte	0x1
 3920 06c1 CA02     		.2byte	0x2ca
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 122


 3921 06c3 0A050000 		.4byte	0x50a
 3922 06c7 02       		.uleb128 0x2
 3923 06c8 91       		.byte	0x91
 3924 06c9 68       		.sleb128 -24
 3925 06ca 17       		.uleb128 0x17
 3926 06cb B0030000 		.4byte	.LASF75
 3927 06cf 01       		.byte	0x1
 3928 06d0 CC02     		.2byte	0x2cc
 3929 06d2 97020000 		.4byte	0x297
 3930 06d6 02       		.uleb128 0x2
 3931 06d7 91       		.byte	0x91
 3932 06d8 74       		.sleb128 -12
 3933 06d9 00       		.byte	0
 3934 06da 18       		.uleb128 0x18
 3935 06db 24040000 		.4byte	.LASF103
 3936 06df 01       		.byte	0x1
 3937 06e0 E402     		.2byte	0x2e4
 3938 06e2 47010000 		.4byte	0x147
 3939 06e6 00000000 		.4byte	.LFB76
 3940 06ea 54010000 		.4byte	.LFE76-.LFB76
 3941 06ee 01       		.uleb128 0x1
 3942 06ef 9C       		.byte	0x9c
 3943 06f0 6D070000 		.4byte	0x76d
 3944 06f4 19       		.uleb128 0x19
 3945 06f5 D3020000 		.4byte	.LASF69
 3946 06f9 01       		.byte	0x1
 3947 06fa E402     		.2byte	0x2e4
 3948 06fc 97020000 		.4byte	0x297
 3949 0700 02       		.uleb128 0x2
 3950 0701 91       		.byte	0x91
 3951 0702 5C       		.sleb128 -36
 3952 0703 19       		.uleb128 0x19
 3953 0704 5C070000 		.4byte	.LASF104
 3954 0708 01       		.byte	0x1
 3955 0709 E402     		.2byte	0x2e4
 3956 070b 6D070000 		.4byte	0x76d
 3957 070f 02       		.uleb128 0x2
 3958 0710 91       		.byte	0x91
 3959 0711 58       		.sleb128 -40
 3960 0712 19       		.uleb128 0x19
 3961 0713 A1070000 		.4byte	.LASF99
 3962 0717 01       		.byte	0x1
 3963 0718 E402     		.2byte	0x2e4
 3964 071a 5D010000 		.4byte	0x15d
 3965 071e 02       		.uleb128 0x2
 3966 071f 91       		.byte	0x91
 3967 0720 54       		.sleb128 -44
 3968 0721 19       		.uleb128 0x19
 3969 0722 01020000 		.4byte	.LASF105
 3970 0726 01       		.byte	0x1
 3971 0727 E402     		.2byte	0x2e4
 3972 0729 72070000 		.4byte	0x772
 3973 072d 02       		.uleb128 0x2
 3974 072e 91       		.byte	0x91
 3975 072f 50       		.sleb128 -48
 3976 0730 17       		.uleb128 0x17
 3977 0731 92030000 		.4byte	.LASF106
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 123


 3978 0735 01       		.byte	0x1
 3979 0736 E602     		.2byte	0x2e6
 3980 0738 47010000 		.4byte	0x147
 3981 073c 02       		.uleb128 0x2
 3982 073d 91       		.byte	0x91
 3983 073e 74       		.sleb128 -12
 3984 073f 17       		.uleb128 0x17
 3985 0740 B2020000 		.4byte	.LASF107
 3986 0744 01       		.byte	0x1
 3987 0745 E602     		.2byte	0x2e6
 3988 0747 47010000 		.4byte	0x147
 3989 074b 02       		.uleb128 0x2
 3990 074c 91       		.byte	0x91
 3991 074d 6C       		.sleb128 -20
 3992 074e 17       		.uleb128 0x17
 3993 074f A7030000 		.4byte	.LASF108
 3994 0753 01       		.byte	0x1
 3995 0754 E702     		.2byte	0x2e7
 3996 0756 8C020000 		.4byte	0x28c
 3997 075a 02       		.uleb128 0x2
 3998 075b 91       		.byte	0x91
 3999 075c 64       		.sleb128 -28
 4000 075d 17       		.uleb128 0x17
 4001 075e B8070000 		.4byte	.LASF85
 4002 0762 01       		.byte	0x1
 4003 0763 E802     		.2byte	0x2e8
 4004 0765 90040000 		.4byte	0x490
 4005 0769 02       		.uleb128 0x2
 4006 076a 91       		.byte	0x91
 4007 076b 70       		.sleb128 -16
 4008 076c 00       		.byte	0
 4009 076d 07       		.uleb128 0x7
 4010 076e C4000000 		.4byte	0xc4
 4011 0772 07       		.uleb128 0x7
 4012 0773 47010000 		.4byte	0x147
 4013 0777 18       		.uleb128 0x18
 4014 0778 E8030000 		.4byte	.LASF109
 4015 077c 01       		.byte	0x1
 4016 077d B603     		.2byte	0x3b6
 4017 077f 47010000 		.4byte	0x147
 4018 0783 00000000 		.4byte	.LFB77
 4019 0787 B4000000 		.4byte	.LFE77-.LFB77
 4020 078b 01       		.uleb128 0x1
 4021 078c 9C       		.byte	0x9c
 4022 078d 6F080000 		.4byte	0x86f
 4023 0791 19       		.uleb128 0x19
 4024 0792 D3020000 		.4byte	.LASF69
 4025 0796 01       		.byte	0x1
 4026 0797 B603     		.2byte	0x3b6
 4027 0799 97020000 		.4byte	0x297
 4028 079d 02       		.uleb128 0x2
 4029 079e 91       		.byte	0x91
 4030 079f 54       		.sleb128 -44
 4031 07a0 19       		.uleb128 0x19
 4032 07a1 5C070000 		.4byte	.LASF104
 4033 07a5 01       		.byte	0x1
 4034 07a6 B603     		.2byte	0x3b6
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 124


 4035 07a8 6D070000 		.4byte	0x76d
 4036 07ac 02       		.uleb128 0x2
 4037 07ad 91       		.byte	0x91
 4038 07ae 50       		.sleb128 -48
 4039 07af 19       		.uleb128 0x19
 4040 07b0 8B000000 		.4byte	.LASF110
 4041 07b4 01       		.byte	0x1
 4042 07b5 B603     		.2byte	0x3b6
 4043 07b7 75080000 		.4byte	0x875
 4044 07bb 02       		.uleb128 0x2
 4045 07bc 91       		.byte	0x91
 4046 07bd 4C       		.sleb128 -52
 4047 07be 19       		.uleb128 0x19
 4048 07bf 01020000 		.4byte	.LASF105
 4049 07c3 01       		.byte	0x1
 4050 07c4 B603     		.2byte	0x3b6
 4051 07c6 72070000 		.4byte	0x772
 4052 07ca 02       		.uleb128 0x2
 4053 07cb 91       		.byte	0x91
 4054 07cc 48       		.sleb128 -56
 4055 07cd 17       		.uleb128 0x17
 4056 07ce C0070000 		.4byte	.LASF96
 4057 07d2 01       		.byte	0x1
 4058 07d3 B803     		.2byte	0x3b8
 4059 07d5 47010000 		.4byte	0x147
 4060 07d9 02       		.uleb128 0x2
 4061 07da 91       		.byte	0x91
 4062 07db 74       		.sleb128 -12
 4063 07dc 17       		.uleb128 0x17
 4064 07dd 69020000 		.4byte	.LASF111
 4065 07e1 01       		.byte	0x1
 4066 07e2 B903     		.2byte	0x3b9
 4067 07e4 52010000 		.4byte	0x152
 4068 07e8 02       		.uleb128 0x2
 4069 07e9 91       		.byte	0x91
 4070 07ea 68       		.sleb128 -24
 4071 07eb 17       		.uleb128 0x17
 4072 07ec B8070000 		.4byte	.LASF85
 4073 07f0 01       		.byte	0x1
 4074 07f1 BA03     		.2byte	0x3ba
 4075 07f3 90040000 		.4byte	0x490
 4076 07f7 02       		.uleb128 0x2
 4077 07f8 91       		.byte	0x91
 4078 07f9 70       		.sleb128 -16
 4079 07fa 1B       		.uleb128 0x1b
 4080 07fb 06040000 		.4byte	0x406
 4081 07ff 12000000 		.4byte	.LBB23
 4082 0803 1A000000 		.4byte	.LBE23-.LBB23
 4083 0807 01       		.byte	0x1
 4084 0808 D503     		.2byte	0x3d5
 4085 080a 29080000 		.4byte	0x829
 4086 080e 1C       		.uleb128 0x1c
 4087 080f 12000000 		.4byte	.LBB24
 4088 0813 1A000000 		.4byte	.LBE24-.LBB24
 4089 0817 1D       		.uleb128 0x1d
 4090 0818 16040000 		.4byte	0x416
 4091 081c 02       		.uleb128 0x2
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 125


 4092 081d 91       		.byte	0x91
 4093 081e 5C       		.sleb128 -36
 4094 081f 1D       		.uleb128 0x1d
 4095 0820 21040000 		.4byte	0x421
 4096 0824 02       		.uleb128 0x2
 4097 0825 91       		.byte	0x91
 4098 0826 58       		.sleb128 -40
 4099 0827 00       		.byte	0
 4100 0828 00       		.byte	0
 4101 0829 1E       		.uleb128 0x1e
 4102 082a 40000000 		.4byte	.LBB25
 4103 082e 5A000000 		.4byte	.LBE25-.LBB25
 4104 0832 55080000 		.4byte	0x855
 4105 0836 17       		.uleb128 0x17
 4106 0837 CD010000 		.4byte	.LASF60
 4107 083b 01       		.byte	0x1
 4108 083c D903     		.2byte	0x3d9
 4109 083e 7A080000 		.4byte	0x87a
 4110 0842 02       		.uleb128 0x2
 4111 0843 91       		.byte	0x91
 4112 0844 67       		.sleb128 -25
 4113 0845 17       		.uleb128 0x17
 4114 0846 6D030000 		.4byte	.LASF112
 4115 084a 01       		.byte	0x1
 4116 084b DA03     		.2byte	0x3da
 4117 084d 0A050000 		.4byte	0x50a
 4118 0851 02       		.uleb128 0x2
 4119 0852 91       		.byte	0x91
 4120 0853 60       		.sleb128 -32
 4121 0854 00       		.byte	0
 4122 0855 1F       		.uleb128 0x1f
 4123 0856 2D040000 		.4byte	0x42d
 4124 085a A4000000 		.4byte	.LBB26
 4125 085e 06000000 		.4byte	.LBE26-.LBB26
 4126 0862 01       		.byte	0x1
 4127 0863 5204     		.2byte	0x452
 4128 0865 20       		.uleb128 0x20
 4129 0866 39040000 		.4byte	0x439
 4130 086a 02       		.uleb128 0x2
 4131 086b 91       		.byte	0x91
 4132 086c 6C       		.sleb128 -20
 4133 086d 00       		.byte	0
 4134 086e 00       		.byte	0
 4135 086f 06       		.uleb128 0x6
 4136 0870 04       		.byte	0x4
 4137 0871 47010000 		.4byte	0x147
 4138 0875 07       		.uleb128 0x7
 4139 0876 6F080000 		.4byte	0x86f
 4140 087a 07       		.uleb128 0x7
 4141 087b CB000000 		.4byte	0xcb
 4142 087f 18       		.uleb128 0x18
 4143 0880 A4040000 		.4byte	.LASF113
 4144 0884 01       		.byte	0x1
 4145 0885 5804     		.2byte	0x458
 4146 0887 47010000 		.4byte	0x147
 4147 088b 00000000 		.4byte	.LFB78
 4148 088f A6000000 		.4byte	.LFE78-.LFB78
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 126


 4149 0893 01       		.uleb128 0x1
 4150 0894 9C       		.byte	0x9c
 4151 0895 63090000 		.4byte	0x963
 4152 0899 19       		.uleb128 0x19
 4153 089a D3020000 		.4byte	.LASF69
 4154 089e 01       		.byte	0x1
 4155 089f 5804     		.2byte	0x458
 4156 08a1 97020000 		.4byte	0x297
 4157 08a5 02       		.uleb128 0x2
 4158 08a6 91       		.byte	0x91
 4159 08a7 54       		.sleb128 -44
 4160 08a8 19       		.uleb128 0x19
 4161 08a9 8B000000 		.4byte	.LASF110
 4162 08ad 01       		.byte	0x1
 4163 08ae 5804     		.2byte	0x458
 4164 08b0 75080000 		.4byte	0x875
 4165 08b4 02       		.uleb128 0x2
 4166 08b5 91       		.byte	0x91
 4167 08b6 50       		.sleb128 -48
 4168 08b7 17       		.uleb128 0x17
 4169 08b8 C0070000 		.4byte	.LASF96
 4170 08bc 01       		.byte	0x1
 4171 08bd 5A04     		.2byte	0x45a
 4172 08bf 47010000 		.4byte	0x147
 4173 08c3 02       		.uleb128 0x2
 4174 08c4 91       		.byte	0x91
 4175 08c5 74       		.sleb128 -12
 4176 08c6 17       		.uleb128 0x17
 4177 08c7 69020000 		.4byte	.LASF111
 4178 08cb 01       		.byte	0x1
 4179 08cc 5B04     		.2byte	0x45b
 4180 08ce 52010000 		.4byte	0x152
 4181 08d2 02       		.uleb128 0x2
 4182 08d3 91       		.byte	0x91
 4183 08d4 68       		.sleb128 -24
 4184 08d5 17       		.uleb128 0x17
 4185 08d6 B8070000 		.4byte	.LASF85
 4186 08da 01       		.byte	0x1
 4187 08db 5C04     		.2byte	0x45c
 4188 08dd 90040000 		.4byte	0x490
 4189 08e1 02       		.uleb128 0x2
 4190 08e2 91       		.byte	0x91
 4191 08e3 70       		.sleb128 -16
 4192 08e4 1B       		.uleb128 0x1b
 4193 08e5 06040000 		.4byte	0x406
 4194 08e9 0E000000 		.4byte	.LBB28
 4195 08ed 1A000000 		.4byte	.LBE28-.LBB28
 4196 08f1 01       		.byte	0x1
 4197 08f2 7F04     		.2byte	0x47f
 4198 08f4 13090000 		.4byte	0x913
 4199 08f8 1C       		.uleb128 0x1c
 4200 08f9 0E000000 		.4byte	.LBB29
 4201 08fd 1A000000 		.4byte	.LBE29-.LBB29
 4202 0901 1D       		.uleb128 0x1d
 4203 0902 16040000 		.4byte	0x416
 4204 0906 02       		.uleb128 0x2
 4205 0907 91       		.byte	0x91
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 127


 4206 0908 5C       		.sleb128 -36
 4207 0909 1D       		.uleb128 0x1d
 4208 090a 21040000 		.4byte	0x421
 4209 090e 02       		.uleb128 0x2
 4210 090f 91       		.byte	0x91
 4211 0910 58       		.sleb128 -40
 4212 0911 00       		.byte	0
 4213 0912 00       		.byte	0
 4214 0913 1E       		.uleb128 0x1e
 4215 0914 2A000000 		.4byte	.LBB30
 4216 0918 6C000000 		.4byte	.LBE30-.LBB30
 4217 091c 49090000 		.4byte	0x949
 4218 0920 17       		.uleb128 0x17
 4219 0921 50030000 		.4byte	.LASF56
 4220 0925 01       		.byte	0x1
 4221 0926 8104     		.2byte	0x481
 4222 0928 0A050000 		.4byte	0x50a
 4223 092c 02       		.uleb128 0x2
 4224 092d 91       		.byte	0x91
 4225 092e 64       		.sleb128 -28
 4226 092f 1C       		.uleb128 0x1c
 4227 0930 3A000000 		.4byte	.LBB31
 4228 0934 52000000 		.4byte	.LBE31-.LBB31
 4229 0938 17       		.uleb128 0x17
 4230 0939 CD010000 		.4byte	.LASF60
 4231 093d 01       		.byte	0x1
 4232 093e 8804     		.2byte	0x488
 4233 0940 7A080000 		.4byte	0x87a
 4234 0944 02       		.uleb128 0x2
 4235 0945 91       		.byte	0x91
 4236 0946 63       		.sleb128 -29
 4237 0947 00       		.byte	0
 4238 0948 00       		.byte	0
 4239 0949 1F       		.uleb128 0x1f
 4240 094a 2D040000 		.4byte	0x42d
 4241 094e 96000000 		.4byte	.LBB32
 4242 0952 06000000 		.4byte	.LBE32-.LBB32
 4243 0956 01       		.byte	0x1
 4244 0957 F704     		.2byte	0x4f7
 4245 0959 20       		.uleb128 0x20
 4246 095a 39040000 		.4byte	0x439
 4247 095e 02       		.uleb128 0x2
 4248 095f 91       		.byte	0x91
 4249 0960 6C       		.sleb128 -20
 4250 0961 00       		.byte	0
 4251 0962 00       		.byte	0
 4252 0963 18       		.uleb128 0x18
 4253 0964 51000000 		.4byte	.LASF114
 4254 0968 01       		.byte	0x1
 4255 0969 FD04     		.2byte	0x4fd
 4256 096b 47010000 		.4byte	0x147
 4257 096f 00000000 		.4byte	.LFB79
 4258 0973 44010000 		.4byte	.LFE79-.LFB79
 4259 0977 01       		.uleb128 0x1
 4260 0978 9C       		.byte	0x9c
 4261 0979 F1090000 		.4byte	0x9f1
 4262 097d 19       		.uleb128 0x19
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 128


 4263 097e D3020000 		.4byte	.LASF69
 4264 0982 01       		.byte	0x1
 4265 0983 FD04     		.2byte	0x4fd
 4266 0985 97020000 		.4byte	0x297
 4267 0989 02       		.uleb128 0x2
 4268 098a 91       		.byte	0x91
 4269 098b 5C       		.sleb128 -36
 4270 098c 19       		.uleb128 0x19
 4271 098d 17030000 		.4byte	.LASF115
 4272 0991 01       		.byte	0x1
 4273 0992 FD04     		.2byte	0x4fd
 4274 0994 F1090000 		.4byte	0x9f1
 4275 0998 02       		.uleb128 0x2
 4276 0999 91       		.byte	0x91
 4277 099a 58       		.sleb128 -40
 4278 099b 19       		.uleb128 0x19
 4279 099c A1070000 		.4byte	.LASF99
 4280 09a0 01       		.byte	0x1
 4281 09a1 FD04     		.2byte	0x4fd
 4282 09a3 5D010000 		.4byte	0x15d
 4283 09a7 02       		.uleb128 0x2
 4284 09a8 91       		.byte	0x91
 4285 09a9 54       		.sleb128 -44
 4286 09aa 17       		.uleb128 0x17
 4287 09ab 92030000 		.4byte	.LASF106
 4288 09af 01       		.byte	0x1
 4289 09b0 FF04     		.2byte	0x4ff
 4290 09b2 47010000 		.4byte	0x147
 4291 09b6 02       		.uleb128 0x2
 4292 09b7 91       		.byte	0x91
 4293 09b8 74       		.sleb128 -12
 4294 09b9 17       		.uleb128 0x17
 4295 09ba A7030000 		.4byte	.LASF108
 4296 09be 01       		.byte	0x1
 4297 09bf 0005     		.2byte	0x500
 4298 09c1 8C020000 		.4byte	0x28c
 4299 09c5 02       		.uleb128 0x2
 4300 09c6 91       		.byte	0x91
 4301 09c7 64       		.sleb128 -28
 4302 09c8 17       		.uleb128 0x17
 4303 09c9 B8070000 		.4byte	.LASF85
 4304 09cd 01       		.byte	0x1
 4305 09ce 0105     		.2byte	0x501
 4306 09d0 90040000 		.4byte	0x490
 4307 09d4 02       		.uleb128 0x2
 4308 09d5 91       		.byte	0x91
 4309 09d6 70       		.sleb128 -16
 4310 09d7 1C       		.uleb128 0x1c
 4311 09d8 18000000 		.4byte	.LBB34
 4312 09dc 6E000000 		.4byte	.LBE34-.LBB34
 4313 09e0 17       		.uleb128 0x17
 4314 09e1 50030000 		.4byte	.LASF56
 4315 09e5 01       		.byte	0x1
 4316 09e6 1905     		.2byte	0x519
 4317 09e8 0A050000 		.4byte	0x50a
 4318 09ec 02       		.uleb128 0x2
 4319 09ed 91       		.byte	0x91
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 129


 4320 09ee 6C       		.sleb128 -20
 4321 09ef 00       		.byte	0
 4322 09f0 00       		.byte	0
 4323 09f1 07       		.uleb128 0x7
 4324 09f2 B0000000 		.4byte	0xb0
 4325 09f6 18       		.uleb128 0x18
 4326 09f7 AD000000 		.4byte	.LASF116
 4327 09fb 01       		.byte	0x1
 4328 09fc 8A05     		.2byte	0x58a
 4329 09fe 47010000 		.4byte	0x147
 4330 0a02 00000000 		.4byte	.LFB80
 4331 0a06 90010000 		.4byte	.LFE80-.LFB80
 4332 0a0a 01       		.uleb128 0x1
 4333 0a0b 9C       		.byte	0x9c
 4334 0a0c A10A0000 		.4byte	0xaa1
 4335 0a10 19       		.uleb128 0x19
 4336 0a11 D3020000 		.4byte	.LASF69
 4337 0a15 01       		.byte	0x1
 4338 0a16 8A05     		.2byte	0x58a
 4339 0a18 97020000 		.4byte	0x297
 4340 0a1c 02       		.uleb128 0x2
 4341 0a1d 91       		.byte	0x91
 4342 0a1e 54       		.sleb128 -44
 4343 0a1f 19       		.uleb128 0x19
 4344 0a20 A1070000 		.4byte	.LASF99
 4345 0a24 01       		.byte	0x1
 4346 0a25 8A05     		.2byte	0x58a
 4347 0a27 5D010000 		.4byte	0x15d
 4348 0a2b 02       		.uleb128 0x2
 4349 0a2c 91       		.byte	0x91
 4350 0a2d 50       		.sleb128 -48
 4351 0a2e 17       		.uleb128 0x17
 4352 0a2f 92030000 		.4byte	.LASF106
 4353 0a33 01       		.byte	0x1
 4354 0a34 8C05     		.2byte	0x58c
 4355 0a36 47010000 		.4byte	0x147
 4356 0a3a 02       		.uleb128 0x2
 4357 0a3b 91       		.byte	0x91
 4358 0a3c 74       		.sleb128 -12
 4359 0a3d 17       		.uleb128 0x17
 4360 0a3e A7030000 		.4byte	.LASF108
 4361 0a42 01       		.byte	0x1
 4362 0a43 8D05     		.2byte	0x58d
 4363 0a45 8C020000 		.4byte	0x28c
 4364 0a49 02       		.uleb128 0x2
 4365 0a4a 91       		.byte	0x91
 4366 0a4b 5C       		.sleb128 -36
 4367 0a4c 17       		.uleb128 0x17
 4368 0a4d B8070000 		.4byte	.LASF85
 4369 0a51 01       		.byte	0x1
 4370 0a52 8E05     		.2byte	0x58e
 4371 0a54 90040000 		.4byte	0x490
 4372 0a58 02       		.uleb128 0x2
 4373 0a59 91       		.byte	0x91
 4374 0a5a 6C       		.sleb128 -20
 4375 0a5b 17       		.uleb128 0x17
 4376 0a5c B4060000 		.4byte	.LASF117
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 130


 4377 0a60 01       		.byte	0x1
 4378 0a61 9105     		.2byte	0x591
 4379 0a63 47010000 		.4byte	0x147
 4380 0a67 02       		.uleb128 0x2
 4381 0a68 91       		.byte	0x91
 4382 0a69 70       		.sleb128 -16
 4383 0a6a 1E       		.uleb128 0x1e
 4384 0a6b 1A000000 		.4byte	.LBB35
 4385 0a6f 78000000 		.4byte	.LBE35-.LBB35
 4386 0a73 870A0000 		.4byte	0xa87
 4387 0a77 17       		.uleb128 0x17
 4388 0a78 5F060000 		.4byte	.LASF118
 4389 0a7c 01       		.byte	0x1
 4390 0a7d AC05     		.2byte	0x5ac
 4391 0a7f 0A050000 		.4byte	0x50a
 4392 0a83 02       		.uleb128 0x2
 4393 0a84 91       		.byte	0x91
 4394 0a85 68       		.sleb128 -24
 4395 0a86 00       		.byte	0
 4396 0a87 1C       		.uleb128 0x1c
 4397 0a88 6A010000 		.4byte	.LBB36
 4398 0a8c 14000000 		.4byte	.LBE36-.LBB36
 4399 0a90 17       		.uleb128 0x17
 4400 0a91 FD070000 		.4byte	.LASF119
 4401 0a95 01       		.byte	0x1
 4402 0a96 4906     		.2byte	0x649
 4403 0a98 52010000 		.4byte	0x152
 4404 0a9c 02       		.uleb128 0x2
 4405 0a9d 91       		.byte	0x91
 4406 0a9e 64       		.sleb128 -28
 4407 0a9f 00       		.byte	0
 4408 0aa0 00       		.byte	0
 4409 0aa1 18       		.uleb128 0x18
 4410 0aa2 87030000 		.4byte	.LASF120
 4411 0aa6 01       		.byte	0x1
 4412 0aa7 6406     		.2byte	0x664
 4413 0aa9 47010000 		.4byte	0x147
 4414 0aad 00000000 		.4byte	.LFB81
 4415 0ab1 48010000 		.4byte	.LFE81-.LFB81
 4416 0ab5 01       		.uleb128 0x1
 4417 0ab6 9C       		.byte	0x9c
 4418 0ab7 3E0B0000 		.4byte	0xb3e
 4419 0abb 19       		.uleb128 0x19
 4420 0abc D3020000 		.4byte	.LASF69
 4421 0ac0 01       		.byte	0x1
 4422 0ac1 6406     		.2byte	0x664
 4423 0ac3 97020000 		.4byte	0x297
 4424 0ac7 02       		.uleb128 0x2
 4425 0ac8 91       		.byte	0x91
 4426 0ac9 5C       		.sleb128 -36
 4427 0aca 19       		.uleb128 0x19
 4428 0acb 17030000 		.4byte	.LASF115
 4429 0acf 01       		.byte	0x1
 4430 0ad0 6406     		.2byte	0x664
 4431 0ad2 F1090000 		.4byte	0x9f1
 4432 0ad6 02       		.uleb128 0x2
 4433 0ad7 91       		.byte	0x91
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 131


 4434 0ad8 58       		.sleb128 -40
 4435 0ad9 19       		.uleb128 0x19
 4436 0ada A1070000 		.4byte	.LASF99
 4437 0ade 01       		.byte	0x1
 4438 0adf 6406     		.2byte	0x664
 4439 0ae1 5D010000 		.4byte	0x15d
 4440 0ae5 02       		.uleb128 0x2
 4441 0ae6 91       		.byte	0x91
 4442 0ae7 54       		.sleb128 -44
 4443 0ae8 17       		.uleb128 0x17
 4444 0ae9 92030000 		.4byte	.LASF106
 4445 0aed 01       		.byte	0x1
 4446 0aee 6606     		.2byte	0x666
 4447 0af0 47010000 		.4byte	0x147
 4448 0af4 02       		.uleb128 0x2
 4449 0af5 91       		.byte	0x91
 4450 0af6 74       		.sleb128 -12
 4451 0af7 17       		.uleb128 0x17
 4452 0af8 A7030000 		.4byte	.LASF108
 4453 0afc 01       		.byte	0x1
 4454 0afd 6706     		.2byte	0x667
 4455 0aff 8C020000 		.4byte	0x28c
 4456 0b03 02       		.uleb128 0x2
 4457 0b04 91       		.byte	0x91
 4458 0b05 60       		.sleb128 -32
 4459 0b06 17       		.uleb128 0x17
 4460 0b07 F9050000 		.4byte	.LASF121
 4461 0b0b 01       		.byte	0x1
 4462 0b0c 6806     		.2byte	0x668
 4463 0b0e 50030000 		.4byte	0x350
 4464 0b12 02       		.uleb128 0x2
 4465 0b13 91       		.byte	0x91
 4466 0b14 68       		.sleb128 -24
 4467 0b15 17       		.uleb128 0x17
 4468 0b16 B8070000 		.4byte	.LASF85
 4469 0b1a 01       		.byte	0x1
 4470 0b1b 6906     		.2byte	0x669
 4471 0b1d 90040000 		.4byte	0x490
 4472 0b21 02       		.uleb128 0x2
 4473 0b22 91       		.byte	0x91
 4474 0b23 70       		.sleb128 -16
 4475 0b24 1C       		.uleb128 0x1c
 4476 0b25 18000000 		.4byte	.LBB37
 4477 0b29 72000000 		.4byte	.LBE37-.LBB37
 4478 0b2d 17       		.uleb128 0x17
 4479 0b2e 50030000 		.4byte	.LASF56
 4480 0b32 01       		.byte	0x1
 4481 0b33 8106     		.2byte	0x681
 4482 0b35 0A050000 		.4byte	0x50a
 4483 0b39 02       		.uleb128 0x2
 4484 0b3a 91       		.byte	0x91
 4485 0b3b 6C       		.sleb128 -20
 4486 0b3c 00       		.byte	0
 4487 0b3d 00       		.byte	0
 4488 0b3e 18       		.uleb128 0x18
 4489 0b3f 5F000000 		.4byte	.LASF122
 4490 0b43 01       		.byte	0x1
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 132


 4491 0b44 F906     		.2byte	0x6f9
 4492 0b46 47010000 		.4byte	0x147
 4493 0b4a 00000000 		.4byte	.LFB82
 4494 0b4e AC000000 		.4byte	.LFE82-.LFB82
 4495 0b52 01       		.uleb128 0x1
 4496 0b53 9C       		.byte	0x9c
 4497 0b54 310C0000 		.4byte	0xc31
 4498 0b58 19       		.uleb128 0x19
 4499 0b59 D3020000 		.4byte	.LASF69
 4500 0b5d 01       		.byte	0x1
 4501 0b5e F906     		.2byte	0x6f9
 4502 0b60 97020000 		.4byte	0x297
 4503 0b64 02       		.uleb128 0x2
 4504 0b65 91       		.byte	0x91
 4505 0b66 54       		.sleb128 -44
 4506 0b67 19       		.uleb128 0x19
 4507 0b68 17030000 		.4byte	.LASF115
 4508 0b6c 01       		.byte	0x1
 4509 0b6d F906     		.2byte	0x6f9
 4510 0b6f F1090000 		.4byte	0x9f1
 4511 0b73 02       		.uleb128 0x2
 4512 0b74 91       		.byte	0x91
 4513 0b75 50       		.sleb128 -48
 4514 0b76 19       		.uleb128 0x19
 4515 0b77 8B000000 		.4byte	.LASF110
 4516 0b7b 01       		.byte	0x1
 4517 0b7c F906     		.2byte	0x6f9
 4518 0b7e 75080000 		.4byte	0x875
 4519 0b82 02       		.uleb128 0x2
 4520 0b83 91       		.byte	0x91
 4521 0b84 4C       		.sleb128 -52
 4522 0b85 17       		.uleb128 0x17
 4523 0b86 C0070000 		.4byte	.LASF96
 4524 0b8a 01       		.byte	0x1
 4525 0b8b FB06     		.2byte	0x6fb
 4526 0b8d 47010000 		.4byte	0x147
 4527 0b91 02       		.uleb128 0x2
 4528 0b92 91       		.byte	0x91
 4529 0b93 74       		.sleb128 -12
 4530 0b94 17       		.uleb128 0x17
 4531 0b95 69020000 		.4byte	.LASF111
 4532 0b99 01       		.byte	0x1
 4533 0b9a FC06     		.2byte	0x6fc
 4534 0b9c 52010000 		.4byte	0x152
 4535 0ba0 02       		.uleb128 0x2
 4536 0ba1 91       		.byte	0x91
 4537 0ba2 68       		.sleb128 -24
 4538 0ba3 17       		.uleb128 0x17
 4539 0ba4 B8070000 		.4byte	.LASF85
 4540 0ba8 01       		.byte	0x1
 4541 0ba9 FD06     		.2byte	0x6fd
 4542 0bab 90040000 		.4byte	0x490
 4543 0baf 02       		.uleb128 0x2
 4544 0bb0 91       		.byte	0x91
 4545 0bb1 70       		.sleb128 -16
 4546 0bb2 1B       		.uleb128 0x1b
 4547 0bb3 06040000 		.4byte	0x406
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 133


 4548 0bb7 10000000 		.4byte	.LBB38
 4549 0bbb 1A000000 		.4byte	.LBE38-.LBB38
 4550 0bbf 01       		.byte	0x1
 4551 0bc0 1207     		.2byte	0x712
 4552 0bc2 E10B0000 		.4byte	0xbe1
 4553 0bc6 1C       		.uleb128 0x1c
 4554 0bc7 10000000 		.4byte	.LBB39
 4555 0bcb 1A000000 		.4byte	.LBE39-.LBB39
 4556 0bcf 1D       		.uleb128 0x1d
 4557 0bd0 16040000 		.4byte	0x416
 4558 0bd4 02       		.uleb128 0x2
 4559 0bd5 91       		.byte	0x91
 4560 0bd6 5C       		.sleb128 -36
 4561 0bd7 1D       		.uleb128 0x1d
 4562 0bd8 21040000 		.4byte	0x421
 4563 0bdc 02       		.uleb128 0x2
 4564 0bdd 91       		.byte	0x91
 4565 0bde 58       		.sleb128 -40
 4566 0bdf 00       		.byte	0
 4567 0be0 00       		.byte	0
 4568 0be1 1E       		.uleb128 0x1e
 4569 0be2 2C000000 		.4byte	.LBB40
 4570 0be6 70000000 		.4byte	.LBE40-.LBB40
 4571 0bea 170C0000 		.4byte	0xc17
 4572 0bee 17       		.uleb128 0x17
 4573 0bef 50030000 		.4byte	.LASF56
 4574 0bf3 01       		.byte	0x1
 4575 0bf4 1407     		.2byte	0x714
 4576 0bf6 0A050000 		.4byte	0x50a
 4577 0bfa 02       		.uleb128 0x2
 4578 0bfb 91       		.byte	0x91
 4579 0bfc 64       		.sleb128 -28
 4580 0bfd 1C       		.uleb128 0x1c
 4581 0bfe 38000000 		.4byte	.LBB41
 4582 0c02 5A000000 		.4byte	.LBE41-.LBB41
 4583 0c06 17       		.uleb128 0x17
 4584 0c07 5A090000 		.4byte	.LASF59
 4585 0c0b 01       		.byte	0x1
 4586 0c0c 1907     		.2byte	0x719
 4587 0c0e 7A080000 		.4byte	0x87a
 4588 0c12 02       		.uleb128 0x2
 4589 0c13 91       		.byte	0x91
 4590 0c14 63       		.sleb128 -29
 4591 0c15 00       		.byte	0
 4592 0c16 00       		.byte	0
 4593 0c17 1F       		.uleb128 0x1f
 4594 0c18 2D040000 		.4byte	0x42d
 4595 0c1c 9C000000 		.4byte	.LBB42
 4596 0c20 06000000 		.4byte	.LBE42-.LBB42
 4597 0c24 01       		.byte	0x1
 4598 0c25 4E07     		.2byte	0x74e
 4599 0c27 20       		.uleb128 0x20
 4600 0c28 39040000 		.4byte	0x439
 4601 0c2c 02       		.uleb128 0x2
 4602 0c2d 91       		.byte	0x91
 4603 0c2e 6C       		.sleb128 -20
 4604 0c2f 00       		.byte	0
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 134


 4605 0c30 00       		.byte	0
 4606 0c31 18       		.uleb128 0x18
 4607 0c32 EB070000 		.4byte	.LASF123
 4608 0c36 01       		.byte	0x1
 4609 0c37 5407     		.2byte	0x754
 4610 0c39 47010000 		.4byte	0x147
 4611 0c3d 00000000 		.4byte	.LFB83
 4612 0c41 64000000 		.4byte	.LFE83-.LFB83
 4613 0c45 01       		.uleb128 0x1
 4614 0c46 9C       		.byte	0x9c
 4615 0c47 EE0C0000 		.4byte	0xcee
 4616 0c4b 19       		.uleb128 0x19
 4617 0c4c D3020000 		.4byte	.LASF69
 4618 0c50 01       		.byte	0x1
 4619 0c51 5407     		.2byte	0x754
 4620 0c53 97020000 		.4byte	0x297
 4621 0c57 02       		.uleb128 0x2
 4622 0c58 91       		.byte	0x91
 4623 0c59 54       		.sleb128 -44
 4624 0c5a 19       		.uleb128 0x19
 4625 0c5b 17030000 		.4byte	.LASF115
 4626 0c5f 01       		.byte	0x1
 4627 0c60 5407     		.2byte	0x754
 4628 0c62 F1090000 		.4byte	0x9f1
 4629 0c66 02       		.uleb128 0x2
 4630 0c67 91       		.byte	0x91
 4631 0c68 50       		.sleb128 -48
 4632 0c69 17       		.uleb128 0x17
 4633 0c6a C0070000 		.4byte	.LASF96
 4634 0c6e 01       		.byte	0x1
 4635 0c6f 5607     		.2byte	0x756
 4636 0c71 47010000 		.4byte	0x147
 4637 0c75 02       		.uleb128 0x2
 4638 0c76 91       		.byte	0x91
 4639 0c77 74       		.sleb128 -12
 4640 0c78 17       		.uleb128 0x17
 4641 0c79 69020000 		.4byte	.LASF111
 4642 0c7d 01       		.byte	0x1
 4643 0c7e 5707     		.2byte	0x757
 4644 0c80 52010000 		.4byte	0x152
 4645 0c84 02       		.uleb128 0x2
 4646 0c85 91       		.byte	0x91
 4647 0c86 68       		.sleb128 -24
 4648 0c87 17       		.uleb128 0x17
 4649 0c88 F9050000 		.4byte	.LASF121
 4650 0c8c 01       		.byte	0x1
 4651 0c8d 5807     		.2byte	0x758
 4652 0c8f 50030000 		.4byte	0x350
 4653 0c93 02       		.uleb128 0x2
 4654 0c94 91       		.byte	0x91
 4655 0c95 64       		.sleb128 -28
 4656 0c96 17       		.uleb128 0x17
 4657 0c97 B8070000 		.4byte	.LASF85
 4658 0c9b 01       		.byte	0x1
 4659 0c9c 5907     		.2byte	0x759
 4660 0c9e 90040000 		.4byte	0x490
 4661 0ca2 02       		.uleb128 0x2
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 135


 4662 0ca3 91       		.byte	0x91
 4663 0ca4 70       		.sleb128 -16
 4664 0ca5 1B       		.uleb128 0x1b
 4665 0ca6 06040000 		.4byte	0x406
 4666 0caa 0E000000 		.4byte	.LBB44
 4667 0cae 1A000000 		.4byte	.LBE44-.LBB44
 4668 0cb2 01       		.byte	0x1
 4669 0cb3 6F07     		.2byte	0x76f
 4670 0cb5 D40C0000 		.4byte	0xcd4
 4671 0cb9 1C       		.uleb128 0x1c
 4672 0cba 0E000000 		.4byte	.LBB45
 4673 0cbe 1A000000 		.4byte	.LBE45-.LBB45
 4674 0cc2 1D       		.uleb128 0x1d
 4675 0cc3 16040000 		.4byte	0x416
 4676 0cc7 02       		.uleb128 0x2
 4677 0cc8 91       		.byte	0x91
 4678 0cc9 60       		.sleb128 -32
 4679 0cca 1D       		.uleb128 0x1d
 4680 0ccb 21040000 		.4byte	0x421
 4681 0ccf 02       		.uleb128 0x2
 4682 0cd0 91       		.byte	0x91
 4683 0cd1 5C       		.sleb128 -36
 4684 0cd2 00       		.byte	0
 4685 0cd3 00       		.byte	0
 4686 0cd4 1F       		.uleb128 0x1f
 4687 0cd5 2D040000 		.4byte	0x42d
 4688 0cd9 54000000 		.4byte	.LBB46
 4689 0cdd 06000000 		.4byte	.LBE46-.LBB46
 4690 0ce1 01       		.byte	0x1
 4691 0ce2 8407     		.2byte	0x784
 4692 0ce4 20       		.uleb128 0x20
 4693 0ce5 39040000 		.4byte	0x439
 4694 0ce9 02       		.uleb128 0x2
 4695 0cea 91       		.byte	0x91
 4696 0ceb 6C       		.sleb128 -20
 4697 0cec 00       		.byte	0
 4698 0ced 00       		.byte	0
 4699 0cee 18       		.uleb128 0x18
 4700 0cef 83070000 		.4byte	.LASF124
 4701 0cf3 01       		.byte	0x1
 4702 0cf4 8A07     		.2byte	0x78a
 4703 0cf6 52010000 		.4byte	0x152
 4704 0cfa 00000000 		.4byte	.LFB84
 4705 0cfe 20000000 		.4byte	.LFE84-.LFB84
 4706 0d02 01       		.uleb128 0x1
 4707 0d03 9C       		.byte	0x9c
 4708 0d04 270D0000 		.4byte	0xd27
 4709 0d08 19       		.uleb128 0x19
 4710 0d09 D3020000 		.4byte	.LASF69
 4711 0d0d 01       		.byte	0x1
 4712 0d0e 8A07     		.2byte	0x78a
 4713 0d10 270D0000 		.4byte	0xd27
 4714 0d14 02       		.uleb128 0x2
 4715 0d15 91       		.byte	0x91
 4716 0d16 6C       		.sleb128 -20
 4717 0d17 17       		.uleb128 0x17
 4718 0d18 0F020000 		.4byte	.LASF125
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 136


 4719 0d1c 01       		.byte	0x1
 4720 0d1d 8C07     		.2byte	0x78c
 4721 0d1f 52010000 		.4byte	0x152
 4722 0d23 02       		.uleb128 0x2
 4723 0d24 91       		.byte	0x91
 4724 0d25 74       		.sleb128 -12
 4725 0d26 00       		.byte	0
 4726 0d27 07       		.uleb128 0x7
 4727 0d28 97020000 		.4byte	0x297
 4728 0d2c 18       		.uleb128 0x18
 4729 0d2d B6010000 		.4byte	.LASF126
 4730 0d31 01       		.byte	0x1
 4731 0d32 9A07     		.2byte	0x79a
 4732 0d34 52010000 		.4byte	0x152
 4733 0d38 00000000 		.4byte	.LFB85
 4734 0d3c 2A000000 		.4byte	.LFE85-.LFB85
 4735 0d40 01       		.uleb128 0x1
 4736 0d41 9C       		.byte	0x9c
 4737 0d42 740D0000 		.4byte	0xd74
 4738 0d46 19       		.uleb128 0x19
 4739 0d47 D3020000 		.4byte	.LASF69
 4740 0d4b 01       		.byte	0x1
 4741 0d4c 9A07     		.2byte	0x79a
 4742 0d4e 270D0000 		.4byte	0xd27
 4743 0d52 02       		.uleb128 0x2
 4744 0d53 91       		.byte	0x91
 4745 0d54 6C       		.sleb128 -20
 4746 0d55 17       		.uleb128 0x17
 4747 0d56 0F020000 		.4byte	.LASF125
 4748 0d5a 01       		.byte	0x1
 4749 0d5b 9C07     		.2byte	0x79c
 4750 0d5d 52010000 		.4byte	0x152
 4751 0d61 02       		.uleb128 0x2
 4752 0d62 91       		.byte	0x91
 4753 0d63 70       		.sleb128 -16
 4754 0d64 17       		.uleb128 0x17
 4755 0d65 B8070000 		.4byte	.LASF85
 4756 0d69 01       		.byte	0x1
 4757 0d6a 9D07     		.2byte	0x79d
 4758 0d6c 90040000 		.4byte	0x490
 4759 0d70 02       		.uleb128 0x2
 4760 0d71 91       		.byte	0x91
 4761 0d72 74       		.sleb128 -12
 4762 0d73 00       		.byte	0
 4763 0d74 21       		.uleb128 0x21
 4764 0d75 E3040000 		.4byte	.LASF127
 4765 0d79 01       		.byte	0x1
 4766 0d7a AB07     		.2byte	0x7ab
 4767 0d7c 52010000 		.4byte	0x152
 4768 0d80 00000000 		.4byte	.LFB86
 4769 0d84 1E000000 		.4byte	.LFE86-.LFB86
 4770 0d88 01       		.uleb128 0x1
 4771 0d89 9C       		.byte	0x9c
 4772 0d8a BC0D0000 		.4byte	0xdbc
 4773 0d8e 19       		.uleb128 0x19
 4774 0d8f D3020000 		.4byte	.LASF69
 4775 0d93 01       		.byte	0x1
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 137


 4776 0d94 AB07     		.2byte	0x7ab
 4777 0d96 270D0000 		.4byte	0xd27
 4778 0d9a 02       		.uleb128 0x2
 4779 0d9b 91       		.byte	0x91
 4780 0d9c 6C       		.sleb128 -20
 4781 0d9d 17       		.uleb128 0x17
 4782 0d9e 0F020000 		.4byte	.LASF125
 4783 0da2 01       		.byte	0x1
 4784 0da3 AD07     		.2byte	0x7ad
 4785 0da5 52010000 		.4byte	0x152
 4786 0da9 02       		.uleb128 0x2
 4787 0daa 91       		.byte	0x91
 4788 0dab 70       		.sleb128 -16
 4789 0dac 17       		.uleb128 0x17
 4790 0dad B8070000 		.4byte	.LASF85
 4791 0db1 01       		.byte	0x1
 4792 0db2 AE07     		.2byte	0x7ae
 4793 0db4 90040000 		.4byte	0x490
 4794 0db8 02       		.uleb128 0x2
 4795 0db9 91       		.byte	0x91
 4796 0dba 74       		.sleb128 -12
 4797 0dbb 00       		.byte	0
 4798 0dbc 22       		.uleb128 0x22
 4799 0dbd 2C020000 		.4byte	.LASF138
 4800 0dc1 01       		.byte	0x1
 4801 0dc2 B707     		.2byte	0x7b7
 4802 0dc4 00000000 		.4byte	.LFB87
 4803 0dc8 20000000 		.4byte	.LFE87-.LFB87
 4804 0dcc 01       		.uleb128 0x1
 4805 0dcd 9C       		.byte	0x9c
 4806 0dce F10D0000 		.4byte	0xdf1
 4807 0dd2 19       		.uleb128 0x19
 4808 0dd3 D3020000 		.4byte	.LASF69
 4809 0dd7 01       		.byte	0x1
 4810 0dd8 B707     		.2byte	0x7b7
 4811 0dda 97020000 		.4byte	0x297
 4812 0dde 02       		.uleb128 0x2
 4813 0ddf 91       		.byte	0x91
 4814 0de0 6C       		.sleb128 -20
 4815 0de1 17       		.uleb128 0x17
 4816 0de2 B8070000 		.4byte	.LASF85
 4817 0de6 01       		.byte	0x1
 4818 0de7 B907     		.2byte	0x7b9
 4819 0de9 90040000 		.4byte	0x490
 4820 0ded 02       		.uleb128 0x2
 4821 0dee 91       		.byte	0x91
 4822 0def 74       		.sleb128 -12
 4823 0df0 00       		.byte	0
 4824 0df1 23       		.uleb128 0x23
 4825 0df2 20030000 		.4byte	.LASF129
 4826 0df6 01       		.byte	0x1
 4827 0df7 0108     		.2byte	0x801
 4828 0df9 52010000 		.4byte	0x152
 4829 0dfd 00000000 		.4byte	.LFB88
 4830 0e01 2E000000 		.4byte	.LFE88-.LFB88
 4831 0e05 01       		.uleb128 0x1
 4832 0e06 9C       		.byte	0x9c
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 138


 4833 0e07 2A0E0000 		.4byte	0xe2a
 4834 0e0b 19       		.uleb128 0x19
 4835 0e0c B8070000 		.4byte	.LASF85
 4836 0e10 01       		.byte	0x1
 4837 0e11 0108     		.2byte	0x801
 4838 0e13 350E0000 		.4byte	0xe35
 4839 0e17 02       		.uleb128 0x2
 4840 0e18 91       		.byte	0x91
 4841 0e19 6C       		.sleb128 -20
 4842 0e1a 17       		.uleb128 0x17
 4843 0e1b 2C060000 		.4byte	.LASF128
 4844 0e1f 01       		.byte	0x1
 4845 0e20 0308     		.2byte	0x803
 4846 0e22 52010000 		.4byte	0x152
 4847 0e26 02       		.uleb128 0x2
 4848 0e27 91       		.byte	0x91
 4849 0e28 74       		.sleb128 -12
 4850 0e29 00       		.byte	0
 4851 0e2a 06       		.uleb128 0x6
 4852 0e2b 04       		.byte	0x4
 4853 0e2c 300E0000 		.4byte	0xe30
 4854 0e30 07       		.uleb128 0x7
 4855 0e31 C0030000 		.4byte	0x3c0
 4856 0e35 07       		.uleb128 0x7
 4857 0e36 2A0E0000 		.4byte	0xe2a
 4858 0e3a 24       		.uleb128 0x24
 4859 0e3b 11040000 		.4byte	.LASF130
 4860 0e3f 01       		.byte	0x1
 4861 0e40 1A08     		.2byte	0x81a
 4862 0e42 47010000 		.4byte	0x147
 4863 0e46 00000000 		.4byte	.LFB89
 4864 0e4a D4000000 		.4byte	.LFE89-.LFB89
 4865 0e4e 01       		.uleb128 0x1
 4866 0e4f 9C       		.byte	0x9c
 4867 0e50 A00E0000 		.4byte	0xea0
 4868 0e54 19       		.uleb128 0x19
 4869 0e55 B8070000 		.4byte	.LASF85
 4870 0e59 01       		.byte	0x1
 4871 0e5a 1A08     		.2byte	0x81a
 4872 0e5c 90040000 		.4byte	0x490
 4873 0e60 02       		.uleb128 0x2
 4874 0e61 91       		.byte	0x91
 4875 0e62 6C       		.sleb128 -20
 4876 0e63 19       		.uleb128 0x19
 4877 0e64 5C070000 		.4byte	.LASF104
 4878 0e68 01       		.byte	0x1
 4879 0e69 1A08     		.2byte	0x81a
 4880 0e6b C4000000 		.4byte	0xc4
 4881 0e6f 02       		.uleb128 0x2
 4882 0e70 91       		.byte	0x91
 4883 0e71 68       		.sleb128 -24
 4884 0e72 19       		.uleb128 0x19
 4885 0e73 50090000 		.4byte	.LASF131
 4886 0e77 01       		.byte	0x1
 4887 0e78 1A08     		.2byte	0x81a
 4888 0e7a 72070000 		.4byte	0x772
 4889 0e7e 02       		.uleb128 0x2
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 139


 4890 0e7f 91       		.byte	0x91
 4891 0e80 64       		.sleb128 -28
 4892 0e81 17       		.uleb128 0x17
 4893 0e82 C0070000 		.4byte	.LASF96
 4894 0e86 01       		.byte	0x1
 4895 0e87 1C08     		.2byte	0x81c
 4896 0e89 47010000 		.4byte	0x147
 4897 0e8d 02       		.uleb128 0x2
 4898 0e8e 91       		.byte	0x91
 4899 0e8f 74       		.sleb128 -12
 4900 0e90 17       		.uleb128 0x17
 4901 0e91 50030000 		.4byte	.LASF56
 4902 0e95 01       		.byte	0x1
 4903 0e96 1D08     		.2byte	0x81d
 4904 0e98 52010000 		.4byte	0x152
 4905 0e9c 02       		.uleb128 0x2
 4906 0e9d 91       		.byte	0x91
 4907 0e9e 70       		.sleb128 -16
 4908 0e9f 00       		.byte	0
 4909 0ea0 1A       		.uleb128 0x1a
 4910 0ea1 2F080000 		.4byte	.LASF132
 4911 0ea5 01       		.byte	0x1
 4912 0ea6 6908     		.2byte	0x869
 4913 0ea8 00000000 		.4byte	.LFB90
 4914 0eac 4C000000 		.4byte	.LFE90-.LFB90
 4915 0eb0 01       		.uleb128 0x1
 4916 0eb1 9C       		.byte	0x9c
 4917 0eb2 D50E0000 		.4byte	0xed5
 4918 0eb6 19       		.uleb128 0x19
 4919 0eb7 B8070000 		.4byte	.LASF85
 4920 0ebb 01       		.byte	0x1
 4921 0ebc 6908     		.2byte	0x869
 4922 0ebe 90040000 		.4byte	0x490
 4923 0ec2 02       		.uleb128 0x2
 4924 0ec3 91       		.byte	0x91
 4925 0ec4 74       		.sleb128 -12
 4926 0ec5 19       		.uleb128 0x19
 4927 0ec6 17030000 		.4byte	.LASF115
 4928 0eca 01       		.byte	0x1
 4929 0ecb 6908     		.2byte	0x869
 4930 0ecd F1090000 		.4byte	0x9f1
 4931 0ed1 02       		.uleb128 0x2
 4932 0ed2 91       		.byte	0x91
 4933 0ed3 70       		.sleb128 -16
 4934 0ed4 00       		.byte	0
 4935 0ed5 1A       		.uleb128 0x1a
 4936 0ed6 D4080000 		.4byte	.LASF133
 4937 0eda 01       		.byte	0x1
 4938 0edb 7B08     		.2byte	0x87b
 4939 0edd 00000000 		.4byte	.LFB91
 4940 0ee1 A4000000 		.4byte	.LFE91-.LFB91
 4941 0ee5 01       		.uleb128 0x1
 4942 0ee6 9C       		.byte	0x9c
 4943 0ee7 310F0000 		.4byte	0xf31
 4944 0eeb 19       		.uleb128 0x19
 4945 0eec B8070000 		.4byte	.LASF85
 4946 0ef0 01       		.byte	0x1
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 140


 4947 0ef1 7B08     		.2byte	0x87b
 4948 0ef3 90040000 		.4byte	0x490
 4949 0ef7 02       		.uleb128 0x2
 4950 0ef8 91       		.byte	0x91
 4951 0ef9 6C       		.sleb128 -20
 4952 0efa 1E       		.uleb128 0x1e
 4953 0efb 0C000000 		.4byte	.LBB48
 4954 0eff 42000000 		.4byte	.LBE48-.LBB48
 4955 0f03 170F0000 		.4byte	0xf17
 4956 0f07 17       		.uleb128 0x17
 4957 0f08 CD010000 		.4byte	.LASF60
 4958 0f0c 01       		.byte	0x1
 4959 0f0d 8508     		.2byte	0x885
 4960 0f0f CB000000 		.4byte	0xcb
 4961 0f13 02       		.uleb128 0x2
 4962 0f14 91       		.byte	0x91
 4963 0f15 77       		.sleb128 -9
 4964 0f16 00       		.byte	0
 4965 0f17 1C       		.uleb128 0x1c
 4966 0f18 56000000 		.4byte	.LBB49
 4967 0f1c 42000000 		.4byte	.LBE49-.LBB49
 4968 0f20 17       		.uleb128 0x17
 4969 0f21 5A090000 		.4byte	.LASF59
 4970 0f25 01       		.byte	0x1
 4971 0f26 D608     		.2byte	0x8d6
 4972 0f28 CB000000 		.4byte	0xcb
 4973 0f2c 02       		.uleb128 0x2
 4974 0f2d 91       		.byte	0x91
 4975 0f2e 76       		.sleb128 -10
 4976 0f2f 00       		.byte	0
 4977 0f30 00       		.byte	0
 4978 0f31 24       		.uleb128 0x24
 4979 0f32 07030000 		.4byte	.LASF134
 4980 0f36 01       		.byte	0x1
 4981 0f37 F308     		.2byte	0x8f3
 4982 0f39 47010000 		.4byte	0x147
 4983 0f3d 00000000 		.4byte	.LFB92
 4984 0f41 2C000000 		.4byte	.LFE92-.LFB92
 4985 0f45 01       		.uleb128 0x1
 4986 0f46 9C       		.byte	0x9c
 4987 0f47 6A0F0000 		.4byte	0xf6a
 4988 0f4b 19       		.uleb128 0x19
 4989 0f4c B8070000 		.4byte	.LASF85
 4990 0f50 01       		.byte	0x1
 4991 0f51 F308     		.2byte	0x8f3
 4992 0f53 2A0E0000 		.4byte	0xe2a
 4993 0f57 02       		.uleb128 0x2
 4994 0f58 91       		.byte	0x91
 4995 0f59 6C       		.sleb128 -20
 4996 0f5a 17       		.uleb128 0x17
 4997 0f5b C0070000 		.4byte	.LASF96
 4998 0f5f 01       		.byte	0x1
 4999 0f60 F508     		.2byte	0x8f5
 5000 0f62 47010000 		.4byte	0x147
 5001 0f66 02       		.uleb128 0x2
 5002 0f67 91       		.byte	0x91
 5003 0f68 74       		.sleb128 -12
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 141


 5004 0f69 00       		.byte	0
 5005 0f6a 21       		.uleb128 0x21
 5006 0f6b F6080000 		.4byte	.LASF135
 5007 0f6f 01       		.byte	0x1
 5008 0f70 0809     		.2byte	0x908
 5009 0f72 47010000 		.4byte	0x147
 5010 0f76 00000000 		.4byte	.LFB93
 5011 0f7a 2A000000 		.4byte	.LFE93-.LFB93
 5012 0f7e 01       		.uleb128 0x1
 5013 0f7f 9C       		.byte	0x9c
 5014 0f80 B20F0000 		.4byte	0xfb2
 5015 0f84 19       		.uleb128 0x19
 5016 0f85 D3020000 		.4byte	.LASF69
 5017 0f89 01       		.byte	0x1
 5018 0f8a 0809     		.2byte	0x908
 5019 0f8c 270D0000 		.4byte	0xd27
 5020 0f90 02       		.uleb128 0x2
 5021 0f91 91       		.byte	0x91
 5022 0f92 6C       		.sleb128 -20
 5023 0f93 17       		.uleb128 0x17
 5024 0f94 C0070000 		.4byte	.LASF96
 5025 0f98 01       		.byte	0x1
 5026 0f99 0A09     		.2byte	0x90a
 5027 0f9b 47010000 		.4byte	0x147
 5028 0f9f 02       		.uleb128 0x2
 5029 0fa0 91       		.byte	0x91
 5030 0fa1 74       		.sleb128 -12
 5031 0fa2 17       		.uleb128 0x17
 5032 0fa3 B8070000 		.4byte	.LASF85
 5033 0fa7 01       		.byte	0x1
 5034 0fa8 0B09     		.2byte	0x90b
 5035 0faa 90040000 		.4byte	0x490
 5036 0fae 02       		.uleb128 0x2
 5037 0faf 91       		.byte	0x91
 5038 0fb0 70       		.sleb128 -16
 5039 0fb1 00       		.byte	0
 5040 0fb2 24       		.uleb128 0x24
 5041 0fb3 6E040000 		.4byte	.LASF136
 5042 0fb7 01       		.byte	0x1
 5043 0fb8 1B09     		.2byte	0x91b
 5044 0fba 47010000 		.4byte	0x147
 5045 0fbe 00000000 		.4byte	.LFB94
 5046 0fc2 30000000 		.4byte	.LFE94-.LFB94
 5047 0fc6 01       		.uleb128 0x1
 5048 0fc7 9C       		.byte	0x9c
 5049 0fc8 EB0F0000 		.4byte	0xfeb
 5050 0fcc 19       		.uleb128 0x19
 5051 0fcd B8070000 		.4byte	.LASF85
 5052 0fd1 01       		.byte	0x1
 5053 0fd2 1B09     		.2byte	0x91b
 5054 0fd4 2A0E0000 		.4byte	0xe2a
 5055 0fd8 02       		.uleb128 0x2
 5056 0fd9 91       		.byte	0x91
 5057 0fda 6C       		.sleb128 -20
 5058 0fdb 17       		.uleb128 0x17
 5059 0fdc C0070000 		.4byte	.LASF96
 5060 0fe0 01       		.byte	0x1
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 142


 5061 0fe1 1D09     		.2byte	0x91d
 5062 0fe3 47010000 		.4byte	0x147
 5063 0fe7 02       		.uleb128 0x2
 5064 0fe8 91       		.byte	0x91
 5065 0fe9 74       		.sleb128 -12
 5066 0fea 00       		.byte	0
 5067 0feb 21       		.uleb128 0x21
 5068 0fec 6A070000 		.4byte	.LASF137
 5069 0ff0 01       		.byte	0x1
 5070 0ff1 3009     		.2byte	0x930
 5071 0ff3 47010000 		.4byte	0x147
 5072 0ff7 00000000 		.4byte	.LFB95
 5073 0ffb 2E000000 		.4byte	.LFE95-.LFB95
 5074 0fff 01       		.uleb128 0x1
 5075 1000 9C       		.byte	0x9c
 5076 1001 33100000 		.4byte	0x1033
 5077 1005 19       		.uleb128 0x19
 5078 1006 D3020000 		.4byte	.LASF69
 5079 100a 01       		.byte	0x1
 5080 100b 3009     		.2byte	0x930
 5081 100d 270D0000 		.4byte	0xd27
 5082 1011 02       		.uleb128 0x2
 5083 1012 91       		.byte	0x91
 5084 1013 6C       		.sleb128 -20
 5085 1014 17       		.uleb128 0x17
 5086 1015 C0070000 		.4byte	.LASF96
 5087 1019 01       		.byte	0x1
 5088 101a 3209     		.2byte	0x932
 5089 101c 47010000 		.4byte	0x147
 5090 1020 02       		.uleb128 0x2
 5091 1021 91       		.byte	0x91
 5092 1022 74       		.sleb128 -12
 5093 1023 17       		.uleb128 0x17
 5094 1024 B8070000 		.4byte	.LASF85
 5095 1028 01       		.byte	0x1
 5096 1029 3309     		.2byte	0x933
 5097 102b 90040000 		.4byte	0x490
 5098 102f 02       		.uleb128 0x2
 5099 1030 91       		.byte	0x91
 5100 1031 70       		.sleb128 -16
 5101 1032 00       		.byte	0
 5102 1033 25       		.uleb128 0x25
 5103 1034 BF050000 		.4byte	.LASF139
 5104 1038 01       		.byte	0x1
 5105 1039 580A     		.2byte	0xa58
 5106 103b 00000000 		.4byte	.LFB96
 5107 103f 50000000 		.4byte	.LFE96-.LFB96
 5108 1043 01       		.uleb128 0x1
 5109 1044 9C       		.byte	0x9c
 5110 1045 76100000 		.4byte	0x1076
 5111 1049 19       		.uleb128 0x19
 5112 104a D3020000 		.4byte	.LASF69
 5113 104e 01       		.byte	0x1
 5114 104f 580A     		.2byte	0xa58
 5115 1051 97020000 		.4byte	0x297
 5116 1055 02       		.uleb128 0x2
 5117 1056 91       		.byte	0x91
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 143


 5118 1057 6C       		.sleb128 -20
 5119 1058 19       		.uleb128 0x19
 5120 1059 B8030000 		.4byte	.LASF74
 5121 105d 01       		.byte	0x1
 5122 105e 580A     		.2byte	0xa58
 5123 1060 B9000000 		.4byte	0xb9
 5124 1064 02       		.uleb128 0x2
 5125 1065 91       		.byte	0x91
 5126 1066 68       		.sleb128 -24
 5127 1067 26       		.uleb128 0x26
 5128 1068 757800   		.ascii	"ux\000"
 5129 106b 01       		.byte	0x1
 5130 106c 5A0A     		.2byte	0xa5a
 5131 106e 52010000 		.4byte	0x152
 5132 1072 02       		.uleb128 0x2
 5133 1073 91       		.byte	0x91
 5134 1074 74       		.sleb128 -12
 5135 1075 00       		.byte	0
 5136 1076 21       		.uleb128 0x21
 5137 1077 EE060000 		.4byte	.LASF140
 5138 107b 01       		.byte	0x1
 5139 107c 750A     		.2byte	0xa75
 5140 107e B9000000 		.4byte	0xb9
 5141 1082 00000000 		.4byte	.LFB97
 5142 1086 4C000000 		.4byte	.LFE97-.LFB97
 5143 108a 01       		.uleb128 0x1
 5144 108b 9C       		.byte	0x9c
 5145 108c BD100000 		.4byte	0x10bd
 5146 1090 19       		.uleb128 0x19
 5147 1091 D3020000 		.4byte	.LASF69
 5148 1095 01       		.byte	0x1
 5149 1096 750A     		.2byte	0xa75
 5150 1098 97020000 		.4byte	0x297
 5151 109c 02       		.uleb128 0x2
 5152 109d 91       		.byte	0x91
 5153 109e 6C       		.sleb128 -20
 5154 109f 26       		.uleb128 0x26
 5155 10a0 757800   		.ascii	"ux\000"
 5156 10a3 01       		.byte	0x1
 5157 10a4 770A     		.2byte	0xa77
 5158 10a6 52010000 		.4byte	0x152
 5159 10aa 02       		.uleb128 0x2
 5160 10ab 91       		.byte	0x91
 5161 10ac 74       		.sleb128 -12
 5162 10ad 17       		.uleb128 0x17
 5163 10ae 0D070000 		.4byte	.LASF141
 5164 10b2 01       		.byte	0x1
 5165 10b3 780A     		.2byte	0xa78
 5166 10b5 B9000000 		.4byte	0xb9
 5167 10b9 02       		.uleb128 0x2
 5168 10ba 91       		.byte	0x91
 5169 10bb 70       		.sleb128 -16
 5170 10bc 00       		.byte	0
 5171 10bd 25       		.uleb128 0x25
 5172 10be 53020000 		.4byte	.LASF142
 5173 10c2 01       		.byte	0x1
 5174 10c3 910A     		.2byte	0xa91
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 144


 5175 10c5 00000000 		.4byte	.LFB98
 5176 10c9 50000000 		.4byte	.LFE98-.LFB98
 5177 10cd 01       		.uleb128 0x1
 5178 10ce 9C       		.byte	0x9c
 5179 10cf F1100000 		.4byte	0x10f1
 5180 10d3 19       		.uleb128 0x19
 5181 10d4 D3020000 		.4byte	.LASF69
 5182 10d8 01       		.byte	0x1
 5183 10d9 910A     		.2byte	0xa91
 5184 10db 97020000 		.4byte	0x297
 5185 10df 02       		.uleb128 0x2
 5186 10e0 91       		.byte	0x91
 5187 10e1 6C       		.sleb128 -20
 5188 10e2 26       		.uleb128 0x26
 5189 10e3 757800   		.ascii	"ux\000"
 5190 10e6 01       		.byte	0x1
 5191 10e7 930A     		.2byte	0xa93
 5192 10e9 52010000 		.4byte	0x152
 5193 10ed 02       		.uleb128 0x2
 5194 10ee 91       		.byte	0x91
 5195 10ef 74       		.sleb128 -12
 5196 10f0 00       		.byte	0
 5197 10f1 27       		.uleb128 0x27
 5198 10f2 22010000 		.4byte	0x122
 5199 10f6 01110000 		.4byte	0x1101
 5200 10fa 28       		.uleb128 0x28
 5201 10fb A9000000 		.4byte	0xa9
 5202 10ff 07       		.byte	0x7
 5203 1100 00       		.byte	0
 5204 1101 29       		.uleb128 0x29
 5205 1102 D4030000 		.4byte	.LASF143
 5206 1106 07       		.byte	0x7
 5207 1107 34       		.byte	0x34
 5208 1108 F1100000 		.4byte	0x10f1
 5209 110c 05       		.uleb128 0x5
 5210 110d 03       		.byte	0x3
 5211 110e 00000000 		.4byte	DS18x8_Sensor
 5212 1112 29       		.uleb128 0x29
 5213 1113 44080000 		.4byte	.LASF144
 5214 1117 07       		.byte	0x7
 5215 1118 39       		.byte	0x39
 5216 1119 1D010000 		.4byte	0x11d
 5217 111d 05       		.uleb128 0x5
 5218 111e 03       		.byte	0x3
 5219 111f 00000000 		.4byte	DS18x8_DataReady
 5220 1123 2A       		.uleb128 0x2a
 5221 1124 3D070000 		.4byte	.LASF145
 5222 1128 0B       		.byte	0xb
 5223 1129 1207     		.2byte	0x712
 5224 112b 2F110000 		.4byte	0x112f
 5225 112f 0A       		.uleb128 0xa
 5226 1130 E1000000 		.4byte	0xe1
 5227 1134 27       		.uleb128 0x27
 5228 1135 FB030000 		.4byte	0x3fb
 5229 1139 44110000 		.4byte	0x1144
 5230 113d 28       		.uleb128 0x28
 5231 113e A9000000 		.4byte	0xa9
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 145


 5232 1142 09       		.byte	0x9
 5233 1143 00       		.byte	0
 5234 1144 29       		.uleb128 0x29
 5235 1145 B6040000 		.4byte	.LASF146
 5236 1149 01       		.byte	0x1
 5237 114a A2       		.byte	0xa2
 5238 114b 34110000 		.4byte	0x1134
 5239 114f 05       		.uleb128 0x5
 5240 1150 03       		.byte	0x3
 5241 1151 00000000 		.4byte	xQueueRegistry
 5242 1155 00       		.byte	0
 5243              		.section	.debug_abbrev,"",%progbits
 5244              	.Ldebug_abbrev0:
 5245 0000 01       		.uleb128 0x1
 5246 0001 11       		.uleb128 0x11
 5247 0002 01       		.byte	0x1
 5248 0003 25       		.uleb128 0x25
 5249 0004 0E       		.uleb128 0xe
 5250 0005 13       		.uleb128 0x13
 5251 0006 0B       		.uleb128 0xb
 5252 0007 03       		.uleb128 0x3
 5253 0008 0E       		.uleb128 0xe
 5254 0009 1B       		.uleb128 0x1b
 5255 000a 0E       		.uleb128 0xe
 5256 000b 55       		.uleb128 0x55
 5257 000c 17       		.uleb128 0x17
 5258 000d 11       		.uleb128 0x11
 5259 000e 01       		.uleb128 0x1
 5260 000f 10       		.uleb128 0x10
 5261 0010 17       		.uleb128 0x17
 5262 0011 00       		.byte	0
 5263 0012 00       		.byte	0
 5264 0013 02       		.uleb128 0x2
 5265 0014 16       		.uleb128 0x16
 5266 0015 00       		.byte	0
 5267 0016 03       		.uleb128 0x3
 5268 0017 0E       		.uleb128 0xe
 5269 0018 3A       		.uleb128 0x3a
 5270 0019 0B       		.uleb128 0xb
 5271 001a 3B       		.uleb128 0x3b
 5272 001b 0B       		.uleb128 0xb
 5273 001c 49       		.uleb128 0x49
 5274 001d 13       		.uleb128 0x13
 5275 001e 00       		.byte	0
 5276 001f 00       		.byte	0
 5277 0020 03       		.uleb128 0x3
 5278 0021 24       		.uleb128 0x24
 5279 0022 00       		.byte	0
 5280 0023 0B       		.uleb128 0xb
 5281 0024 0B       		.uleb128 0xb
 5282 0025 3E       		.uleb128 0x3e
 5283 0026 0B       		.uleb128 0xb
 5284 0027 03       		.uleb128 0x3
 5285 0028 0E       		.uleb128 0xe
 5286 0029 00       		.byte	0
 5287 002a 00       		.byte	0
 5288 002b 04       		.uleb128 0x4
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 146


 5289 002c 24       		.uleb128 0x24
 5290 002d 00       		.byte	0
 5291 002e 0B       		.uleb128 0xb
 5292 002f 0B       		.uleb128 0xb
 5293 0030 3E       		.uleb128 0x3e
 5294 0031 0B       		.uleb128 0xb
 5295 0032 03       		.uleb128 0x3
 5296 0033 08       		.uleb128 0x8
 5297 0034 00       		.byte	0
 5298 0035 00       		.byte	0
 5299 0036 05       		.uleb128 0x5
 5300 0037 0F       		.uleb128 0xf
 5301 0038 00       		.byte	0
 5302 0039 0B       		.uleb128 0xb
 5303 003a 0B       		.uleb128 0xb
 5304 003b 00       		.byte	0
 5305 003c 00       		.byte	0
 5306 003d 06       		.uleb128 0x6
 5307 003e 0F       		.uleb128 0xf
 5308 003f 00       		.byte	0
 5309 0040 0B       		.uleb128 0xb
 5310 0041 0B       		.uleb128 0xb
 5311 0042 49       		.uleb128 0x49
 5312 0043 13       		.uleb128 0x13
 5313 0044 00       		.byte	0
 5314 0045 00       		.byte	0
 5315 0046 07       		.uleb128 0x7
 5316 0047 26       		.uleb128 0x26
 5317 0048 00       		.byte	0
 5318 0049 49       		.uleb128 0x49
 5319 004a 13       		.uleb128 0x13
 5320 004b 00       		.byte	0
 5321 004c 00       		.byte	0
 5322 004d 08       		.uleb128 0x8
 5323 004e 26       		.uleb128 0x26
 5324 004f 00       		.byte	0
 5325 0050 00       		.byte	0
 5326 0051 00       		.byte	0
 5327 0052 09       		.uleb128 0x9
 5328 0053 16       		.uleb128 0x16
 5329 0054 00       		.byte	0
 5330 0055 03       		.uleb128 0x3
 5331 0056 0E       		.uleb128 0xe
 5332 0057 3A       		.uleb128 0x3a
 5333 0058 0B       		.uleb128 0xb
 5334 0059 3B       		.uleb128 0x3b
 5335 005a 05       		.uleb128 0x5
 5336 005b 49       		.uleb128 0x49
 5337 005c 13       		.uleb128 0x13
 5338 005d 00       		.byte	0
 5339 005e 00       		.byte	0
 5340 005f 0A       		.uleb128 0xa
 5341 0060 35       		.uleb128 0x35
 5342 0061 00       		.byte	0
 5343 0062 49       		.uleb128 0x49
 5344 0063 13       		.uleb128 0x13
 5345 0064 00       		.byte	0
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 147


 5346 0065 00       		.byte	0
 5347 0066 0B       		.uleb128 0xb
 5348 0067 13       		.uleb128 0x13
 5349 0068 01       		.byte	0x1
 5350 0069 03       		.uleb128 0x3
 5351 006a 0E       		.uleb128 0xe
 5352 006b 0B       		.uleb128 0xb
 5353 006c 0B       		.uleb128 0xb
 5354 006d 3A       		.uleb128 0x3a
 5355 006e 0B       		.uleb128 0xb
 5356 006f 3B       		.uleb128 0x3b
 5357 0070 0B       		.uleb128 0xb
 5358 0071 01       		.uleb128 0x1
 5359 0072 13       		.uleb128 0x13
 5360 0073 00       		.byte	0
 5361 0074 00       		.byte	0
 5362 0075 0C       		.uleb128 0xc
 5363 0076 0D       		.uleb128 0xd
 5364 0077 00       		.byte	0
 5365 0078 03       		.uleb128 0x3
 5366 0079 0E       		.uleb128 0xe
 5367 007a 3A       		.uleb128 0x3a
 5368 007b 0B       		.uleb128 0xb
 5369 007c 3B       		.uleb128 0x3b
 5370 007d 0B       		.uleb128 0xb
 5371 007e 49       		.uleb128 0x49
 5372 007f 13       		.uleb128 0x13
 5373 0080 38       		.uleb128 0x38
 5374 0081 0B       		.uleb128 0xb
 5375 0082 00       		.byte	0
 5376 0083 00       		.byte	0
 5377 0084 0D       		.uleb128 0xd
 5378 0085 13       		.uleb128 0x13
 5379 0086 00       		.byte	0
 5380 0087 03       		.uleb128 0x3
 5381 0088 0E       		.uleb128 0xe
 5382 0089 3C       		.uleb128 0x3c
 5383 008a 19       		.uleb128 0x19
 5384 008b 00       		.byte	0
 5385 008c 00       		.byte	0
 5386 008d 0E       		.uleb128 0xe
 5387 008e 0D       		.uleb128 0xd
 5388 008f 00       		.byte	0
 5389 0090 03       		.uleb128 0x3
 5390 0091 08       		.uleb128 0x8
 5391 0092 3A       		.uleb128 0x3a
 5392 0093 0B       		.uleb128 0xb
 5393 0094 3B       		.uleb128 0x3b
 5394 0095 0B       		.uleb128 0xb
 5395 0096 49       		.uleb128 0x49
 5396 0097 13       		.uleb128 0x13
 5397 0098 38       		.uleb128 0x38
 5398 0099 0B       		.uleb128 0xb
 5399 009a 00       		.byte	0
 5400 009b 00       		.byte	0
 5401 009c 0F       		.uleb128 0xf
 5402 009d 17       		.uleb128 0x17
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 148


 5403 009e 01       		.byte	0x1
 5404 009f 0B       		.uleb128 0xb
 5405 00a0 0B       		.uleb128 0xb
 5406 00a1 3A       		.uleb128 0x3a
 5407 00a2 0B       		.uleb128 0xb
 5408 00a3 3B       		.uleb128 0x3b
 5409 00a4 0B       		.uleb128 0xb
 5410 00a5 01       		.uleb128 0x1
 5411 00a6 13       		.uleb128 0x13
 5412 00a7 00       		.byte	0
 5413 00a8 00       		.byte	0
 5414 00a9 10       		.uleb128 0x10
 5415 00aa 0D       		.uleb128 0xd
 5416 00ab 00       		.byte	0
 5417 00ac 03       		.uleb128 0x3
 5418 00ad 0E       		.uleb128 0xe
 5419 00ae 3A       		.uleb128 0x3a
 5420 00af 0B       		.uleb128 0xb
 5421 00b0 3B       		.uleb128 0x3b
 5422 00b1 0B       		.uleb128 0xb
 5423 00b2 49       		.uleb128 0x49
 5424 00b3 13       		.uleb128 0x13
 5425 00b4 00       		.byte	0
 5426 00b5 00       		.byte	0
 5427 00b6 11       		.uleb128 0x11
 5428 00b7 2E       		.uleb128 0x2e
 5429 00b8 01       		.byte	0x1
 5430 00b9 03       		.uleb128 0x3
 5431 00ba 0E       		.uleb128 0xe
 5432 00bb 3A       		.uleb128 0x3a
 5433 00bc 0B       		.uleb128 0xb
 5434 00bd 3B       		.uleb128 0x3b
 5435 00be 0B       		.uleb128 0xb
 5436 00bf 27       		.uleb128 0x27
 5437 00c0 19       		.uleb128 0x19
 5438 00c1 49       		.uleb128 0x49
 5439 00c2 13       		.uleb128 0x13
 5440 00c3 20       		.uleb128 0x20
 5441 00c4 0B       		.uleb128 0xb
 5442 00c5 01       		.uleb128 0x1
 5443 00c6 13       		.uleb128 0x13
 5444 00c7 00       		.byte	0
 5445 00c8 00       		.byte	0
 5446 00c9 12       		.uleb128 0x12
 5447 00ca 34       		.uleb128 0x34
 5448 00cb 00       		.byte	0
 5449 00cc 03       		.uleb128 0x3
 5450 00cd 0E       		.uleb128 0xe
 5451 00ce 3A       		.uleb128 0x3a
 5452 00cf 0B       		.uleb128 0xb
 5453 00d0 3B       		.uleb128 0x3b
 5454 00d1 0B       		.uleb128 0xb
 5455 00d2 49       		.uleb128 0x49
 5456 00d3 13       		.uleb128 0x13
 5457 00d4 00       		.byte	0
 5458 00d5 00       		.byte	0
 5459 00d6 13       		.uleb128 0x13
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 149


 5460 00d7 2E       		.uleb128 0x2e
 5461 00d8 01       		.byte	0x1
 5462 00d9 03       		.uleb128 0x3
 5463 00da 0E       		.uleb128 0xe
 5464 00db 3A       		.uleb128 0x3a
 5465 00dc 0B       		.uleb128 0xb
 5466 00dd 3B       		.uleb128 0x3b
 5467 00de 0B       		.uleb128 0xb
 5468 00df 27       		.uleb128 0x27
 5469 00e0 19       		.uleb128 0x19
 5470 00e1 20       		.uleb128 0x20
 5471 00e2 0B       		.uleb128 0xb
 5472 00e3 01       		.uleb128 0x1
 5473 00e4 13       		.uleb128 0x13
 5474 00e5 00       		.byte	0
 5475 00e6 00       		.byte	0
 5476 00e7 14       		.uleb128 0x14
 5477 00e8 05       		.uleb128 0x5
 5478 00e9 00       		.byte	0
 5479 00ea 03       		.uleb128 0x3
 5480 00eb 0E       		.uleb128 0xe
 5481 00ec 3A       		.uleb128 0x3a
 5482 00ed 0B       		.uleb128 0xb
 5483 00ee 3B       		.uleb128 0x3b
 5484 00ef 0B       		.uleb128 0xb
 5485 00f0 49       		.uleb128 0x49
 5486 00f1 13       		.uleb128 0x13
 5487 00f2 00       		.byte	0
 5488 00f3 00       		.byte	0
 5489 00f4 15       		.uleb128 0x15
 5490 00f5 2E       		.uleb128 0x2e
 5491 00f6 01       		.byte	0x1
 5492 00f7 3F       		.uleb128 0x3f
 5493 00f8 19       		.uleb128 0x19
 5494 00f9 03       		.uleb128 0x3
 5495 00fa 0E       		.uleb128 0xe
 5496 00fb 3A       		.uleb128 0x3a
 5497 00fc 0B       		.uleb128 0xb
 5498 00fd 3B       		.uleb128 0x3b
 5499 00fe 0B       		.uleb128 0xb
 5500 00ff 27       		.uleb128 0x27
 5501 0100 19       		.uleb128 0x19
 5502 0101 49       		.uleb128 0x49
 5503 0102 13       		.uleb128 0x13
 5504 0103 11       		.uleb128 0x11
 5505 0104 01       		.uleb128 0x1
 5506 0105 12       		.uleb128 0x12
 5507 0106 06       		.uleb128 0x6
 5508 0107 40       		.uleb128 0x40
 5509 0108 18       		.uleb128 0x18
 5510 0109 9642     		.uleb128 0x2116
 5511 010b 19       		.uleb128 0x19
 5512 010c 01       		.uleb128 0x1
 5513 010d 13       		.uleb128 0x13
 5514 010e 00       		.byte	0
 5515 010f 00       		.byte	0
 5516 0110 16       		.uleb128 0x16
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 150


 5517 0111 05       		.uleb128 0x5
 5518 0112 00       		.byte	0
 5519 0113 03       		.uleb128 0x3
 5520 0114 0E       		.uleb128 0xe
 5521 0115 3A       		.uleb128 0x3a
 5522 0116 0B       		.uleb128 0xb
 5523 0117 3B       		.uleb128 0x3b
 5524 0118 0B       		.uleb128 0xb
 5525 0119 49       		.uleb128 0x49
 5526 011a 13       		.uleb128 0x13
 5527 011b 02       		.uleb128 0x2
 5528 011c 18       		.uleb128 0x18
 5529 011d 00       		.byte	0
 5530 011e 00       		.byte	0
 5531 011f 17       		.uleb128 0x17
 5532 0120 34       		.uleb128 0x34
 5533 0121 00       		.byte	0
 5534 0122 03       		.uleb128 0x3
 5535 0123 0E       		.uleb128 0xe
 5536 0124 3A       		.uleb128 0x3a
 5537 0125 0B       		.uleb128 0xb
 5538 0126 3B       		.uleb128 0x3b
 5539 0127 05       		.uleb128 0x5
 5540 0128 49       		.uleb128 0x49
 5541 0129 13       		.uleb128 0x13
 5542 012a 02       		.uleb128 0x2
 5543 012b 18       		.uleb128 0x18
 5544 012c 00       		.byte	0
 5545 012d 00       		.byte	0
 5546 012e 18       		.uleb128 0x18
 5547 012f 2E       		.uleb128 0x2e
 5548 0130 01       		.byte	0x1
 5549 0131 3F       		.uleb128 0x3f
 5550 0132 19       		.uleb128 0x19
 5551 0133 03       		.uleb128 0x3
 5552 0134 0E       		.uleb128 0xe
 5553 0135 3A       		.uleb128 0x3a
 5554 0136 0B       		.uleb128 0xb
 5555 0137 3B       		.uleb128 0x3b
 5556 0138 05       		.uleb128 0x5
 5557 0139 27       		.uleb128 0x27
 5558 013a 19       		.uleb128 0x19
 5559 013b 49       		.uleb128 0x49
 5560 013c 13       		.uleb128 0x13
 5561 013d 11       		.uleb128 0x11
 5562 013e 01       		.uleb128 0x1
 5563 013f 12       		.uleb128 0x12
 5564 0140 06       		.uleb128 0x6
 5565 0141 40       		.uleb128 0x40
 5566 0142 18       		.uleb128 0x18
 5567 0143 9642     		.uleb128 0x2116
 5568 0145 19       		.uleb128 0x19
 5569 0146 01       		.uleb128 0x1
 5570 0147 13       		.uleb128 0x13
 5571 0148 00       		.byte	0
 5572 0149 00       		.byte	0
 5573 014a 19       		.uleb128 0x19
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 151


 5574 014b 05       		.uleb128 0x5
 5575 014c 00       		.byte	0
 5576 014d 03       		.uleb128 0x3
 5577 014e 0E       		.uleb128 0xe
 5578 014f 3A       		.uleb128 0x3a
 5579 0150 0B       		.uleb128 0xb
 5580 0151 3B       		.uleb128 0x3b
 5581 0152 05       		.uleb128 0x5
 5582 0153 49       		.uleb128 0x49
 5583 0154 13       		.uleb128 0x13
 5584 0155 02       		.uleb128 0x2
 5585 0156 18       		.uleb128 0x18
 5586 0157 00       		.byte	0
 5587 0158 00       		.byte	0
 5588 0159 1A       		.uleb128 0x1a
 5589 015a 2E       		.uleb128 0x2e
 5590 015b 01       		.byte	0x1
 5591 015c 03       		.uleb128 0x3
 5592 015d 0E       		.uleb128 0xe
 5593 015e 3A       		.uleb128 0x3a
 5594 015f 0B       		.uleb128 0xb
 5595 0160 3B       		.uleb128 0x3b
 5596 0161 05       		.uleb128 0x5
 5597 0162 27       		.uleb128 0x27
 5598 0163 19       		.uleb128 0x19
 5599 0164 11       		.uleb128 0x11
 5600 0165 01       		.uleb128 0x1
 5601 0166 12       		.uleb128 0x12
 5602 0167 06       		.uleb128 0x6
 5603 0168 40       		.uleb128 0x40
 5604 0169 18       		.uleb128 0x18
 5605 016a 9642     		.uleb128 0x2116
 5606 016c 19       		.uleb128 0x19
 5607 016d 01       		.uleb128 0x1
 5608 016e 13       		.uleb128 0x13
 5609 016f 00       		.byte	0
 5610 0170 00       		.byte	0
 5611 0171 1B       		.uleb128 0x1b
 5612 0172 1D       		.uleb128 0x1d
 5613 0173 01       		.byte	0x1
 5614 0174 31       		.uleb128 0x31
 5615 0175 13       		.uleb128 0x13
 5616 0176 11       		.uleb128 0x11
 5617 0177 01       		.uleb128 0x1
 5618 0178 12       		.uleb128 0x12
 5619 0179 06       		.uleb128 0x6
 5620 017a 58       		.uleb128 0x58
 5621 017b 0B       		.uleb128 0xb
 5622 017c 59       		.uleb128 0x59
 5623 017d 05       		.uleb128 0x5
 5624 017e 01       		.uleb128 0x1
 5625 017f 13       		.uleb128 0x13
 5626 0180 00       		.byte	0
 5627 0181 00       		.byte	0
 5628 0182 1C       		.uleb128 0x1c
 5629 0183 0B       		.uleb128 0xb
 5630 0184 01       		.byte	0x1
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 152


 5631 0185 11       		.uleb128 0x11
 5632 0186 01       		.uleb128 0x1
 5633 0187 12       		.uleb128 0x12
 5634 0188 06       		.uleb128 0x6
 5635 0189 00       		.byte	0
 5636 018a 00       		.byte	0
 5637 018b 1D       		.uleb128 0x1d
 5638 018c 34       		.uleb128 0x34
 5639 018d 00       		.byte	0
 5640 018e 31       		.uleb128 0x31
 5641 018f 13       		.uleb128 0x13
 5642 0190 02       		.uleb128 0x2
 5643 0191 18       		.uleb128 0x18
 5644 0192 00       		.byte	0
 5645 0193 00       		.byte	0
 5646 0194 1E       		.uleb128 0x1e
 5647 0195 0B       		.uleb128 0xb
 5648 0196 01       		.byte	0x1
 5649 0197 11       		.uleb128 0x11
 5650 0198 01       		.uleb128 0x1
 5651 0199 12       		.uleb128 0x12
 5652 019a 06       		.uleb128 0x6
 5653 019b 01       		.uleb128 0x1
 5654 019c 13       		.uleb128 0x13
 5655 019d 00       		.byte	0
 5656 019e 00       		.byte	0
 5657 019f 1F       		.uleb128 0x1f
 5658 01a0 1D       		.uleb128 0x1d
 5659 01a1 01       		.byte	0x1
 5660 01a2 31       		.uleb128 0x31
 5661 01a3 13       		.uleb128 0x13
 5662 01a4 11       		.uleb128 0x11
 5663 01a5 01       		.uleb128 0x1
 5664 01a6 12       		.uleb128 0x12
 5665 01a7 06       		.uleb128 0x6
 5666 01a8 58       		.uleb128 0x58
 5667 01a9 0B       		.uleb128 0xb
 5668 01aa 59       		.uleb128 0x59
 5669 01ab 05       		.uleb128 0x5
 5670 01ac 00       		.byte	0
 5671 01ad 00       		.byte	0
 5672 01ae 20       		.uleb128 0x20
 5673 01af 05       		.uleb128 0x5
 5674 01b0 00       		.byte	0
 5675 01b1 31       		.uleb128 0x31
 5676 01b2 13       		.uleb128 0x13
 5677 01b3 02       		.uleb128 0x2
 5678 01b4 18       		.uleb128 0x18
 5679 01b5 00       		.byte	0
 5680 01b6 00       		.byte	0
 5681 01b7 21       		.uleb128 0x21
 5682 01b8 2E       		.uleb128 0x2e
 5683 01b9 01       		.byte	0x1
 5684 01ba 3F       		.uleb128 0x3f
 5685 01bb 19       		.uleb128 0x19
 5686 01bc 03       		.uleb128 0x3
 5687 01bd 0E       		.uleb128 0xe
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 153


 5688 01be 3A       		.uleb128 0x3a
 5689 01bf 0B       		.uleb128 0xb
 5690 01c0 3B       		.uleb128 0x3b
 5691 01c1 05       		.uleb128 0x5
 5692 01c2 27       		.uleb128 0x27
 5693 01c3 19       		.uleb128 0x19
 5694 01c4 49       		.uleb128 0x49
 5695 01c5 13       		.uleb128 0x13
 5696 01c6 11       		.uleb128 0x11
 5697 01c7 01       		.uleb128 0x1
 5698 01c8 12       		.uleb128 0x12
 5699 01c9 06       		.uleb128 0x6
 5700 01ca 40       		.uleb128 0x40
 5701 01cb 18       		.uleb128 0x18
 5702 01cc 9742     		.uleb128 0x2117
 5703 01ce 19       		.uleb128 0x19
 5704 01cf 01       		.uleb128 0x1
 5705 01d0 13       		.uleb128 0x13
 5706 01d1 00       		.byte	0
 5707 01d2 00       		.byte	0
 5708 01d3 22       		.uleb128 0x22
 5709 01d4 2E       		.uleb128 0x2e
 5710 01d5 01       		.byte	0x1
 5711 01d6 3F       		.uleb128 0x3f
 5712 01d7 19       		.uleb128 0x19
 5713 01d8 03       		.uleb128 0x3
 5714 01d9 0E       		.uleb128 0xe
 5715 01da 3A       		.uleb128 0x3a
 5716 01db 0B       		.uleb128 0xb
 5717 01dc 3B       		.uleb128 0x3b
 5718 01dd 05       		.uleb128 0x5
 5719 01de 27       		.uleb128 0x27
 5720 01df 19       		.uleb128 0x19
 5721 01e0 11       		.uleb128 0x11
 5722 01e1 01       		.uleb128 0x1
 5723 01e2 12       		.uleb128 0x12
 5724 01e3 06       		.uleb128 0x6
 5725 01e4 40       		.uleb128 0x40
 5726 01e5 18       		.uleb128 0x18
 5727 01e6 9642     		.uleb128 0x2116
 5728 01e8 19       		.uleb128 0x19
 5729 01e9 01       		.uleb128 0x1
 5730 01ea 13       		.uleb128 0x13
 5731 01eb 00       		.byte	0
 5732 01ec 00       		.byte	0
 5733 01ed 23       		.uleb128 0x23
 5734 01ee 2E       		.uleb128 0x2e
 5735 01ef 01       		.byte	0x1
 5736 01f0 03       		.uleb128 0x3
 5737 01f1 0E       		.uleb128 0xe
 5738 01f2 3A       		.uleb128 0x3a
 5739 01f3 0B       		.uleb128 0xb
 5740 01f4 3B       		.uleb128 0x3b
 5741 01f5 05       		.uleb128 0x5
 5742 01f6 27       		.uleb128 0x27
 5743 01f7 19       		.uleb128 0x19
 5744 01f8 49       		.uleb128 0x49
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 154


 5745 01f9 13       		.uleb128 0x13
 5746 01fa 11       		.uleb128 0x11
 5747 01fb 01       		.uleb128 0x1
 5748 01fc 12       		.uleb128 0x12
 5749 01fd 06       		.uleb128 0x6
 5750 01fe 40       		.uleb128 0x40
 5751 01ff 18       		.uleb128 0x18
 5752 0200 9742     		.uleb128 0x2117
 5753 0202 19       		.uleb128 0x19
 5754 0203 01       		.uleb128 0x1
 5755 0204 13       		.uleb128 0x13
 5756 0205 00       		.byte	0
 5757 0206 00       		.byte	0
 5758 0207 24       		.uleb128 0x24
 5759 0208 2E       		.uleb128 0x2e
 5760 0209 01       		.byte	0x1
 5761 020a 03       		.uleb128 0x3
 5762 020b 0E       		.uleb128 0xe
 5763 020c 3A       		.uleb128 0x3a
 5764 020d 0B       		.uleb128 0xb
 5765 020e 3B       		.uleb128 0x3b
 5766 020f 05       		.uleb128 0x5
 5767 0210 27       		.uleb128 0x27
 5768 0211 19       		.uleb128 0x19
 5769 0212 49       		.uleb128 0x49
 5770 0213 13       		.uleb128 0x13
 5771 0214 11       		.uleb128 0x11
 5772 0215 01       		.uleb128 0x1
 5773 0216 12       		.uleb128 0x12
 5774 0217 06       		.uleb128 0x6
 5775 0218 40       		.uleb128 0x40
 5776 0219 18       		.uleb128 0x18
 5777 021a 9642     		.uleb128 0x2116
 5778 021c 19       		.uleb128 0x19
 5779 021d 01       		.uleb128 0x1
 5780 021e 13       		.uleb128 0x13
 5781 021f 00       		.byte	0
 5782 0220 00       		.byte	0
 5783 0221 25       		.uleb128 0x25
 5784 0222 2E       		.uleb128 0x2e
 5785 0223 01       		.byte	0x1
 5786 0224 3F       		.uleb128 0x3f
 5787 0225 19       		.uleb128 0x19
 5788 0226 03       		.uleb128 0x3
 5789 0227 0E       		.uleb128 0xe
 5790 0228 3A       		.uleb128 0x3a
 5791 0229 0B       		.uleb128 0xb
 5792 022a 3B       		.uleb128 0x3b
 5793 022b 05       		.uleb128 0x5
 5794 022c 27       		.uleb128 0x27
 5795 022d 19       		.uleb128 0x19
 5796 022e 11       		.uleb128 0x11
 5797 022f 01       		.uleb128 0x1
 5798 0230 12       		.uleb128 0x12
 5799 0231 06       		.uleb128 0x6
 5800 0232 40       		.uleb128 0x40
 5801 0233 18       		.uleb128 0x18
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 155


 5802 0234 9742     		.uleb128 0x2117
 5803 0236 19       		.uleb128 0x19
 5804 0237 01       		.uleb128 0x1
 5805 0238 13       		.uleb128 0x13
 5806 0239 00       		.byte	0
 5807 023a 00       		.byte	0
 5808 023b 26       		.uleb128 0x26
 5809 023c 34       		.uleb128 0x34
 5810 023d 00       		.byte	0
 5811 023e 03       		.uleb128 0x3
 5812 023f 08       		.uleb128 0x8
 5813 0240 3A       		.uleb128 0x3a
 5814 0241 0B       		.uleb128 0xb
 5815 0242 3B       		.uleb128 0x3b
 5816 0243 05       		.uleb128 0x5
 5817 0244 49       		.uleb128 0x49
 5818 0245 13       		.uleb128 0x13
 5819 0246 02       		.uleb128 0x2
 5820 0247 18       		.uleb128 0x18
 5821 0248 00       		.byte	0
 5822 0249 00       		.byte	0
 5823 024a 27       		.uleb128 0x27
 5824 024b 01       		.uleb128 0x1
 5825 024c 01       		.byte	0x1
 5826 024d 49       		.uleb128 0x49
 5827 024e 13       		.uleb128 0x13
 5828 024f 01       		.uleb128 0x1
 5829 0250 13       		.uleb128 0x13
 5830 0251 00       		.byte	0
 5831 0252 00       		.byte	0
 5832 0253 28       		.uleb128 0x28
 5833 0254 21       		.uleb128 0x21
 5834 0255 00       		.byte	0
 5835 0256 49       		.uleb128 0x49
 5836 0257 13       		.uleb128 0x13
 5837 0258 2F       		.uleb128 0x2f
 5838 0259 0B       		.uleb128 0xb
 5839 025a 00       		.byte	0
 5840 025b 00       		.byte	0
 5841 025c 29       		.uleb128 0x29
 5842 025d 34       		.uleb128 0x34
 5843 025e 00       		.byte	0
 5844 025f 03       		.uleb128 0x3
 5845 0260 0E       		.uleb128 0xe
 5846 0261 3A       		.uleb128 0x3a
 5847 0262 0B       		.uleb128 0xb
 5848 0263 3B       		.uleb128 0x3b
 5849 0264 0B       		.uleb128 0xb
 5850 0265 49       		.uleb128 0x49
 5851 0266 13       		.uleb128 0x13
 5852 0267 3F       		.uleb128 0x3f
 5853 0268 19       		.uleb128 0x19
 5854 0269 02       		.uleb128 0x2
 5855 026a 18       		.uleb128 0x18
 5856 026b 00       		.byte	0
 5857 026c 00       		.byte	0
 5858 026d 2A       		.uleb128 0x2a
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 156


 5859 026e 34       		.uleb128 0x34
 5860 026f 00       		.byte	0
 5861 0270 03       		.uleb128 0x3
 5862 0271 0E       		.uleb128 0xe
 5863 0272 3A       		.uleb128 0x3a
 5864 0273 0B       		.uleb128 0xb
 5865 0274 3B       		.uleb128 0x3b
 5866 0275 05       		.uleb128 0x5
 5867 0276 49       		.uleb128 0x49
 5868 0277 13       		.uleb128 0x13
 5869 0278 3F       		.uleb128 0x3f
 5870 0279 19       		.uleb128 0x19
 5871 027a 3C       		.uleb128 0x3c
 5872 027b 19       		.uleb128 0x19
 5873 027c 00       		.byte	0
 5874 027d 00       		.byte	0
 5875 027e 00       		.byte	0
 5876              		.section	.debug_aranges,"",%progbits
 5877 0000 0C010000 		.4byte	0x10c
 5878 0004 0200     		.2byte	0x2
 5879 0006 00000000 		.4byte	.Ldebug_info0
 5880 000a 04       		.byte	0x4
 5881 000b 00       		.byte	0
 5882 000c 0000     		.2byte	0
 5883 000e 0000     		.2byte	0
 5884 0010 00000000 		.4byte	.LFB68
 5885 0014 B4000000 		.4byte	.LFE68-.LFB68
 5886 0018 00000000 		.4byte	.LFB69
 5887 001c 50000000 		.4byte	.LFE69-.LFB69
 5888 0020 00000000 		.4byte	.LFB70
 5889 0024 3E000000 		.4byte	.LFE70-.LFB70
 5890 0028 00000000 		.4byte	.LFB71
 5891 002c 34000000 		.4byte	.LFE71-.LFB71
 5892 0030 00000000 		.4byte	.LFB72
 5893 0034 30000000 		.4byte	.LFE72-.LFB72
 5894 0038 00000000 		.4byte	.LFB73
 5895 003c 4C000000 		.4byte	.LFE73-.LFB73
 5896 0040 00000000 		.4byte	.LFB74
 5897 0044 50000000 		.4byte	.LFE74-.LFB74
 5898 0048 00000000 		.4byte	.LFB75
 5899 004c 2C000000 		.4byte	.LFE75-.LFB75
 5900 0050 00000000 		.4byte	.LFB76
 5901 0054 54010000 		.4byte	.LFE76-.LFB76
 5902 0058 00000000 		.4byte	.LFB77
 5903 005c B4000000 		.4byte	.LFE77-.LFB77
 5904 0060 00000000 		.4byte	.LFB78
 5905 0064 A6000000 		.4byte	.LFE78-.LFB78
 5906 0068 00000000 		.4byte	.LFB79
 5907 006c 44010000 		.4byte	.LFE79-.LFB79
 5908 0070 00000000 		.4byte	.LFB80
 5909 0074 90010000 		.4byte	.LFE80-.LFB80
 5910 0078 00000000 		.4byte	.LFB81
 5911 007c 48010000 		.4byte	.LFE81-.LFB81
 5912 0080 00000000 		.4byte	.LFB82
 5913 0084 AC000000 		.4byte	.LFE82-.LFB82
 5914 0088 00000000 		.4byte	.LFB83
 5915 008c 64000000 		.4byte	.LFE83-.LFB83
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 157


 5916 0090 00000000 		.4byte	.LFB84
 5917 0094 20000000 		.4byte	.LFE84-.LFB84
 5918 0098 00000000 		.4byte	.LFB85
 5919 009c 2A000000 		.4byte	.LFE85-.LFB85
 5920 00a0 00000000 		.4byte	.LFB86
 5921 00a4 1E000000 		.4byte	.LFE86-.LFB86
 5922 00a8 00000000 		.4byte	.LFB87
 5923 00ac 20000000 		.4byte	.LFE87-.LFB87
 5924 00b0 00000000 		.4byte	.LFB88
 5925 00b4 2E000000 		.4byte	.LFE88-.LFB88
 5926 00b8 00000000 		.4byte	.LFB89
 5927 00bc D4000000 		.4byte	.LFE89-.LFB89
 5928 00c0 00000000 		.4byte	.LFB90
 5929 00c4 4C000000 		.4byte	.LFE90-.LFB90
 5930 00c8 00000000 		.4byte	.LFB91
 5931 00cc A4000000 		.4byte	.LFE91-.LFB91
 5932 00d0 00000000 		.4byte	.LFB92
 5933 00d4 2C000000 		.4byte	.LFE92-.LFB92
 5934 00d8 00000000 		.4byte	.LFB93
 5935 00dc 2A000000 		.4byte	.LFE93-.LFB93
 5936 00e0 00000000 		.4byte	.LFB94
 5937 00e4 30000000 		.4byte	.LFE94-.LFB94
 5938 00e8 00000000 		.4byte	.LFB95
 5939 00ec 2E000000 		.4byte	.LFE95-.LFB95
 5940 00f0 00000000 		.4byte	.LFB96
 5941 00f4 50000000 		.4byte	.LFE96-.LFB96
 5942 00f8 00000000 		.4byte	.LFB97
 5943 00fc 4C000000 		.4byte	.LFE97-.LFB97
 5944 0100 00000000 		.4byte	.LFB98
 5945 0104 50000000 		.4byte	.LFE98-.LFB98
 5946 0108 00000000 		.4byte	0
 5947 010c 00000000 		.4byte	0
 5948              		.section	.debug_ranges,"",%progbits
 5949              	.Ldebug_ranges0:
 5950 0000 00000000 		.4byte	.LFB68
 5951 0004 B4000000 		.4byte	.LFE68
 5952 0008 00000000 		.4byte	.LFB69
 5953 000c 50000000 		.4byte	.LFE69
 5954 0010 00000000 		.4byte	.LFB70
 5955 0014 3E000000 		.4byte	.LFE70
 5956 0018 00000000 		.4byte	.LFB71
 5957 001c 34000000 		.4byte	.LFE71
 5958 0020 00000000 		.4byte	.LFB72
 5959 0024 30000000 		.4byte	.LFE72
 5960 0028 00000000 		.4byte	.LFB73
 5961 002c 4C000000 		.4byte	.LFE73
 5962 0030 00000000 		.4byte	.LFB74
 5963 0034 50000000 		.4byte	.LFE74
 5964 0038 00000000 		.4byte	.LFB75
 5965 003c 2C000000 		.4byte	.LFE75
 5966 0040 00000000 		.4byte	.LFB76
 5967 0044 54010000 		.4byte	.LFE76
 5968 0048 00000000 		.4byte	.LFB77
 5969 004c B4000000 		.4byte	.LFE77
 5970 0050 00000000 		.4byte	.LFB78
 5971 0054 A6000000 		.4byte	.LFE78
 5972 0058 00000000 		.4byte	.LFB79
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 158


 5973 005c 44010000 		.4byte	.LFE79
 5974 0060 00000000 		.4byte	.LFB80
 5975 0064 90010000 		.4byte	.LFE80
 5976 0068 00000000 		.4byte	.LFB81
 5977 006c 48010000 		.4byte	.LFE81
 5978 0070 00000000 		.4byte	.LFB82
 5979 0074 AC000000 		.4byte	.LFE82
 5980 0078 00000000 		.4byte	.LFB83
 5981 007c 64000000 		.4byte	.LFE83
 5982 0080 00000000 		.4byte	.LFB84
 5983 0084 20000000 		.4byte	.LFE84
 5984 0088 00000000 		.4byte	.LFB85
 5985 008c 2A000000 		.4byte	.LFE85
 5986 0090 00000000 		.4byte	.LFB86
 5987 0094 1E000000 		.4byte	.LFE86
 5988 0098 00000000 		.4byte	.LFB87
 5989 009c 20000000 		.4byte	.LFE87
 5990 00a0 00000000 		.4byte	.LFB88
 5991 00a4 2E000000 		.4byte	.LFE88
 5992 00a8 00000000 		.4byte	.LFB89
 5993 00ac D4000000 		.4byte	.LFE89
 5994 00b0 00000000 		.4byte	.LFB90
 5995 00b4 4C000000 		.4byte	.LFE90
 5996 00b8 00000000 		.4byte	.LFB91
 5997 00bc A4000000 		.4byte	.LFE91
 5998 00c0 00000000 		.4byte	.LFB92
 5999 00c4 2C000000 		.4byte	.LFE92
 6000 00c8 00000000 		.4byte	.LFB93
 6001 00cc 2A000000 		.4byte	.LFE93
 6002 00d0 00000000 		.4byte	.LFB94
 6003 00d4 30000000 		.4byte	.LFE94
 6004 00d8 00000000 		.4byte	.LFB95
 6005 00dc 2E000000 		.4byte	.LFE95
 6006 00e0 00000000 		.4byte	.LFB96
 6007 00e4 50000000 		.4byte	.LFE96
 6008 00e8 00000000 		.4byte	.LFB97
 6009 00ec 4C000000 		.4byte	.LFE97
 6010 00f0 00000000 		.4byte	.LFB98
 6011 00f4 50000000 		.4byte	.LFE98
 6012 00f8 00000000 		.4byte	0
 6013 00fc 00000000 		.4byte	0
 6014              		.section	.debug_line,"",%progbits
 6015              	.Ldebug_line0:
 6016 0000 3B070000 		.section	.debug_str,"MS",%progbits,1
 6016      02003F02 
 6016      00000201 
 6016      FB0E0D00 
 6016      01010101 
 6017              	.LASF38:
 6018 0000 75784E75 		.ascii	"uxNumberOfItems\000"
 6018      6D626572 
 6018      4F664974 
 6018      656D7300 
 6019              	.LASF65:
 6020 0010 53656D61 		.ascii	"SemaphoreData\000"
 6020      70686F72 
 6020      65446174 
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 159


 6020      6100
 6021              	.LASF150:
 6022 001e 74736B54 		.ascii	"tskTaskControlBlock\000"
 6022      61736B43 
 6022      6F6E7472 
 6022      6F6C426C 
 6022      6F636B00 
 6023              	.LASF68:
 6024 0032 53656D61 		.ascii	"SemaphoreData_t\000"
 6024      70686F72 
 6024      65446174 
 6024      615F7400 
 6025              	.LASF30:
 6026 0042 44533138 		.ascii	"DS18x8_TSensor\000"
 6026      78385F54 
 6026      53656E73 
 6026      6F7200
 6027              	.LASF114:
 6028 0051 78517565 		.ascii	"xQueueReceive\000"
 6028      75655265 
 6028      63656976 
 6028      6500
 6029              	.LASF122:
 6030 005f 78517565 		.ascii	"xQueueReceiveFromISR\000"
 6030      75655265 
 6030      63656976 
 6030      6546726F 
 6030      6D495352 
 6031              	.LASF55:
 6032 0074 78546173 		.ascii	"xTasksWaitingToReceive\000"
 6032      6B735761 
 6032      6974696E 
 6032      67546F52 
 6032      65636569 
 6033              	.LASF110:
 6034 008b 70784869 		.ascii	"pxHigherPriorityTaskWoken\000"
 6034      67686572 
 6034      5072696F 
 6034      72697479 
 6034      5461736B 
 6035              	.LASF97:
 6036 00a5 70784D75 		.ascii	"pxMutex\000"
 6036      74657800 
 6037              	.LASF116:
 6038 00ad 78517565 		.ascii	"xQueueSemaphoreTake\000"
 6038      75655365 
 6038      6D617068 
 6038      6F726554 
 6038      616B6500 
 6039              	.LASF0:
 6040 00c1 756E7369 		.ascii	"unsigned int\000"
 6040      676E6564 
 6040      20696E74 
 6040      00
 6041              	.LASF39:
 6042 00ce 7078496E 		.ascii	"pxIndex\000"
 6042      64657800 
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 160


 6043              	.LASF46:
 6044 00d6 7854494D 		.ascii	"xTIME_OUT\000"
 6044      455F4F55 
 6044      5400
 6045              	.LASF86:
 6046 00e0 70784E65 		.ascii	"pxNewQueue\000"
 6046      77517565 
 6046      756500
 6047              	.LASF10:
 6048 00eb 5F5F696E 		.ascii	"__int32_t\000"
 6048      7433325F 
 6048      7400
 6049              	.LASF31:
 6050 00f5 784C4953 		.ascii	"xLIST_ITEM\000"
 6050      545F4954 
 6050      454D00
 6051              	.LASF73:
 6052 0100 51554555 		.ascii	"QUEUE_REGISTRY_ITEM\000"
 6052      455F5245 
 6052      47495354 
 6052      52595F49 
 6052      54454D00 
 6053              	.LASF147:
 6054 0114 474E5520 		.ascii	"GNU C11 5.4.1 20160609 (release) [ARM/embedded-5-br"
 6054      43313120 
 6054      352E342E 
 6054      31203230 
 6054      31363036 
 6055 0147 616E6368 		.ascii	"anch revision 237715] -mcpu=cortex-m3 -mthumb -g -O"
 6055      20726576 
 6055      6973696F 
 6055      6E203233 
 6055      37373135 
 6056 017a 30202D66 		.ascii	"0 -ffunction-sections -ffat-lto-objects\000"
 6056      66756E63 
 6056      74696F6E 
 6056      2D736563 
 6056      74696F6E 
 6057              	.LASF54:
 6058 01a2 78546173 		.ascii	"xTasksWaitingToSend\000"
 6058      6B735761 
 6058      6974696E 
 6058      67546F53 
 6058      656E6400 
 6059              	.LASF126:
 6060 01b6 75785175 		.ascii	"uxQueueSpacesAvailable\000"
 6060      65756553 
 6060      70616365 
 6060      73417661 
 6060      696C6162 
 6061              	.LASF60:
 6062 01cd 6354784C 		.ascii	"cTxLock\000"
 6062      6F636B00 
 6063              	.LASF47:
 6064 01d5 784F7665 		.ascii	"xOverflowCount\000"
 6064      72666C6F 
 6064      77436F75 
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 161


 6064      6E7400
 6065              	.LASF67:
 6066 01e4 75785265 		.ascii	"uxRecursiveCallCount\000"
 6066      63757273 
 6066      69766543 
 6066      616C6C43 
 6066      6F756E74 
 6067              	.LASF72:
 6068 01f9 51756575 		.ascii	"Queue_t\000"
 6068      655F7400 
 6069              	.LASF105:
 6070 0201 78436F70 		.ascii	"xCopyPosition\000"
 6070      79506F73 
 6070      6974696F 
 6070      6E00
 6071              	.LASF125:
 6072 020f 75785265 		.ascii	"uxReturn\000"
 6072      7475726E 
 6072      00
 6073              	.LASF77:
 6074 0218 51756575 		.ascii	"QueueRegistryItem_t\000"
 6074      65526567 
 6074      69737472 
 6074      79497465 
 6074      6D5F7400 
 6075              	.LASF138:
 6076 022c 76517565 		.ascii	"vQueueDelete\000"
 6076      75654465 
 6076      6C657465 
 6076      00
 6077              	.LASF148:
 6078 0239 536F7572 		.ascii	"Source\\queue.c\000"
 6078      63655C71 
 6078      75657565 
 6078      2E6300
 6079              	.LASF63:
 6080 0248 70635265 		.ascii	"pcReadFrom\000"
 6080      61644672 
 6080      6F6D00
 6081              	.LASF142:
 6082 0253 76517565 		.ascii	"vQueueUnregisterQueue\000"
 6082      7565556E 
 6082      72656769 
 6082      73746572 
 6082      51756575 
 6083              	.LASF111:
 6084 0269 75785361 		.ascii	"uxSavedInterruptStatus\000"
 6084      76656449 
 6084      6E746572 
 6084      72757074 
 6084      53746174 
 6085              	.LASF89:
 6086 0280 70727649 		.ascii	"prvInitialiseNewQueue\000"
 6086      6E697469 
 6086      616C6973 
 6086      654E6577 
 6086      51756575 
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 162


 6087              	.LASF20:
 6088 0296 75696E74 		.ascii	"uint32_t\000"
 6088      33325F74 
 6088      00
 6089              	.LASF17:
 6090 029f 696E7438 		.ascii	"int8_t\000"
 6090      5F7400
 6091              	.LASF93:
 6092 02a6 75784D75 		.ascii	"uxMutexSize\000"
 6092      74657853 
 6092      697A6500 
 6093              	.LASF107:
 6094 02b2 78596965 		.ascii	"xYieldRequired\000"
 6094      6C645265 
 6094      71756972 
 6094      656400
 6095              	.LASF78:
 6096 02c1 756C4F72 		.ascii	"ulOriginalBASEPRI\000"
 6096      6967696E 
 6096      616C4241 
 6096      53455052 
 6096      4900
 6097              	.LASF69:
 6098 02d3 78517565 		.ascii	"xQueue\000"
 6098      756500
 6099              	.LASF23:
 6100 02da 666C6F61 		.ascii	"float\000"
 6100      7400
 6101              	.LASF51:
 6102 02e0 51756575 		.ascii	"QueueDefinition\000"
 6102      65446566 
 6102      696E6974 
 6102      696F6E00 
 6103              	.LASF14:
 6104 02f0 6C6F6E67 		.ascii	"long long unsigned int\000"
 6104      206C6F6E 
 6104      6720756E 
 6104      7369676E 
 6104      65642069 
 6105              	.LASF134:
 6106 0307 70727649 		.ascii	"prvIsQueueEmpty\000"
 6106      73517565 
 6106      7565456D 
 6106      70747900 
 6107              	.LASF115:
 6108 0317 70764275 		.ascii	"pvBuffer\000"
 6108      66666572 
 6108      00
 6109              	.LASF129:
 6110 0320 70727647 		.ascii	"prvGetDisinheritPriorityAfterTimeout\000"
 6110      65744469 
 6110      73696E68 
 6110      65726974 
 6110      5072696F 
 6111              	.LASF34:
 6112 0345 70785072 		.ascii	"pxPrevious\000"
 6112      6576696F 
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 163


 6112      757300
 6113              	.LASF56:
 6114 0350 75784D65 		.ascii	"uxMessagesWaiting\000"
 6114      73736167 
 6114      65735761 
 6114      6974696E 
 6114      6700
 6115              	.LASF70:
 6116 0362 7853656D 		.ascii	"xSemaphore\000"
 6116      6170686F 
 6116      726500
 6117              	.LASF112:
 6118 036d 75785072 		.ascii	"uxPreviousMessagesWaiting\000"
 6118      6576696F 
 6118      75734D65 
 6118      73736167 
 6118      65735761 
 6119              	.LASF120:
 6120 0387 78517565 		.ascii	"xQueuePeek\000"
 6120      75655065 
 6120      656B00
 6121              	.LASF106:
 6122 0392 78456E74 		.ascii	"xEntryTimeSet\000"
 6122      72795469 
 6122      6D655365 
 6122      7400
 6123              	.LASF3:
 6124 03a0 73697A65 		.ascii	"size_t\000"
 6124      5F7400
 6125              	.LASF108:
 6126 03a7 7854696D 		.ascii	"xTimeOut\000"
 6126      654F7574 
 6126      00
 6127              	.LASF75:
 6128 03b0 7848616E 		.ascii	"xHandle\000"
 6128      646C6500 
 6129              	.LASF74:
 6130 03b8 70635175 		.ascii	"pcQueueName\000"
 6130      6575654E 
 6130      616D6500 
 6131              	.LASF42:
 6132 03c4 784D494E 		.ascii	"xMINI_LIST_ITEM\000"
 6132      495F4C49 
 6132      53545F49 
 6132      54454D00 
 6133              	.LASF143:
 6134 03d4 44533138 		.ascii	"DS18x8_Sensor\000"
 6134      78385F53 
 6134      656E736F 
 6134      7200
 6135              	.LASF37:
 6136 03e2 784C4953 		.ascii	"xLIST\000"
 6136      5400
 6137              	.LASF109:
 6138 03e8 78517565 		.ascii	"xQueueGenericSendFromISR\000"
 6138      75654765 
 6138      6E657269 
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 164


 6138      6353656E 
 6138      6446726F 
 6139              	.LASF152:
 6140 0401 76506F72 		.ascii	"vPortSetBASEPRI\000"
 6140      74536574 
 6140      42415345 
 6140      50524900 
 6141              	.LASF130:
 6142 0411 70727643 		.ascii	"prvCopyDataToQueue\000"
 6142      6F707944 
 6142      61746154 
 6142      6F517565 
 6142      756500
 6143              	.LASF103:
 6144 0424 78517565 		.ascii	"xQueueGenericSend\000"
 6144      75654765 
 6144      6E657269 
 6144      6353656E 
 6144      6400
 6145              	.LASF58:
 6146 0436 75784974 		.ascii	"uxItemSize\000"
 6146      656D5369 
 6146      7A6500
 6147              	.LASF102:
 6148 0441 7578496E 		.ascii	"uxInitialCount\000"
 6148      69746961 
 6148      6C436F75 
 6148      6E7400
 6149              	.LASF92:
 6150 0450 75784D75 		.ascii	"uxMutexLength\000"
 6150      7465784C 
 6150      656E6774 
 6150      6800
 6151              	.LASF16:
 6152 045e 63686172 		.ascii	"char\000"
 6152      00
 6153              	.LASF41:
 6154 0463 4C697374 		.ascii	"ListItem_t\000"
 6154      4974656D 
 6154      5F7400
 6155              	.LASF136:
 6156 046e 70727649 		.ascii	"prvIsQueueFull\000"
 6156      73517565 
 6156      75654675 
 6156      6C6C00
 6157              	.LASF61:
 6158 047d 51756575 		.ascii	"QueuePointers\000"
 6158      65506F69 
 6158      6E746572 
 6158      7300
 6159              	.LASF79:
 6160 048b 756C4E65 		.ascii	"ulNewBASEPRI\000"
 6160      77424153 
 6160      45505249 
 6160      00
 6161              	.LASF28:
 6162 0498 55426173 		.ascii	"UBaseType_t\000"
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 165


 6162      65547970 
 6162      655F7400 
 6163              	.LASF113:
 6164 04a4 78517565 		.ascii	"xQueueGiveFromISR\000"
 6164      75654769 
 6164      76654672 
 6164      6F6D4953 
 6164      5200
 6165              	.LASF146:
 6166 04b6 78517565 		.ascii	"xQueueRegistry\000"
 6166      75655265 
 6166      67697374 
 6166      727900
 6167              	.LASF50:
 6168 04c5 51756575 		.ascii	"QueueHandle_t\000"
 6168      6548616E 
 6168      646C655F 
 6168      7400
 6169              	.LASF40:
 6170 04d3 784C6973 		.ascii	"xListEnd\000"
 6170      74456E64 
 6170      00
 6171              	.LASF22:
 6172 04dc 75696E74 		.ascii	"uint16\000"
 6172      313600
 6173              	.LASF127:
 6174 04e3 75785175 		.ascii	"uxQueueMessagesWaitingFromISR\000"
 6174      6575654D 
 6174      65737361 
 6174      67657357 
 6174      61697469 
 6175              	.LASF43:
 6176 0501 4D696E69 		.ascii	"MiniListItem_t\000"
 6176      4C697374 
 6176      4974656D 
 6176      5F7400
 6177              	.LASF18:
 6178 0510 75696E74 		.ascii	"uint8_t\000"
 6178      385F7400 
 6179              	.LASF76:
 6180 0518 78517565 		.ascii	"xQueueRegistryItem\000"
 6180      75655265 
 6180      67697374 
 6180      72794974 
 6180      656D00
 6181              	.LASF26:
 6182 052b 70726573 		.ascii	"present\000"
 6182      656E7400 
 6183              	.LASF82:
 6184 0533 78517565 		.ascii	"xQueueGenericCreate\000"
 6184      75654765 
 6184      6E657269 
 6184      63437265 
 6184      61746500 
 6185              	.LASF91:
 6186 0547 78517565 		.ascii	"xQueueCreateMutex\000"
 6186      75654372 
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 166


 6186      65617465 
 6186      4D757465 
 6186      7800
 6187              	.LASF151:
 6188 0559 756C506F 		.ascii	"ulPortRaiseBASEPRI\000"
 6188      72745261 
 6188      69736542 
 6188      41534550 
 6188      524900
 6189              	.LASF1:
 6190 056c 6C6F6E67 		.ascii	"long long int\000"
 6190      206C6F6E 
 6190      6720696E 
 6190      7400
 6191              	.LASF90:
 6192 057a 70727649 		.ascii	"prvInitialiseMutex\000"
 6192      6E697469 
 6192      616C6973 
 6192      654D7574 
 6192      657800
 6193              	.LASF27:
 6194 058d 42617365 		.ascii	"BaseType_t\000"
 6194      54797065 
 6194      5F7400
 6195              	.LASF88:
 6196 0598 70756351 		.ascii	"pucQueueStorage\000"
 6196      75657565 
 6196      53746F72 
 6196      61676500 
 6197              	.LASF95:
 6198 05a8 784D7574 		.ascii	"xMutex\000"
 6198      657800
 6199              	.LASF48:
 6200 05af 7854696D 		.ascii	"xTimeOnEntering\000"
 6200      654F6E45 
 6200      6E746572 
 6200      696E6700 
 6201              	.LASF139:
 6202 05bf 76517565 		.ascii	"vQueueAddToRegistry\000"
 6202      75654164 
 6202      64546F52 
 6202      65676973 
 6202      74727900 
 6203              	.LASF33:
 6204 05d3 70784E65 		.ascii	"pxNext\000"
 6204      787400
 6205              	.LASF80:
 6206 05da 784E6577 		.ascii	"xNewQueue\000"
 6206      51756575 
 6206      6500
 6207              	.LASF101:
 6208 05e4 75784D61 		.ascii	"uxMaxCount\000"
 6208      78436F75 
 6208      6E7400
 6209              	.LASF49:
 6210 05ef 54696D65 		.ascii	"TimeOut_t\000"
 6210      4F75745F 
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 167


 6210      7400
 6211              	.LASF121:
 6212 05f9 70634F72 		.ascii	"pcOriginalReadPosition\000"
 6212      6967696E 
 6212      616C5265 
 6212      6164506F 
 6212      73697469 
 6213              	.LASF45:
 6214 0610 5461736B 		.ascii	"TaskHandle_t\000"
 6214      48616E64 
 6214      6C655F74 
 6214      00
 6215              	.LASF153:
 6216 061d 756C4E65 		.ascii	"ulNewMaskValue\000"
 6216      774D6173 
 6216      6B56616C 
 6216      756500
 6217              	.LASF128:
 6218 062c 75784869 		.ascii	"uxHighestPriorityOfWaitingTasks\000"
 6218      67686573 
 6218      74507269 
 6218      6F726974 
 6218      794F6657 
 6219              	.LASF84:
 6220 064c 75635175 		.ascii	"ucQueueType\000"
 6220      65756554 
 6220      79706500 
 6221              	.LASF44:
 6222 0658 4C697374 		.ascii	"List_t\000"
 6222      5F7400
 6223              	.LASF118:
 6224 065f 75785365 		.ascii	"uxSemaphoreCount\000"
 6224      6D617068 
 6224      6F726543 
 6224      6F756E74 
 6224      00
 6225              	.LASF53:
 6226 0670 70635772 		.ascii	"pcWriteTo\000"
 6226      69746554 
 6226      6F00
 6227              	.LASF29:
 6228 067a 5469636B 		.ascii	"TickType_t\000"
 6228      54797065 
 6228      5F7400
 6229              	.LASF4:
 6230 0685 5F5F696E 		.ascii	"__int8_t\000"
 6230      74385F74 
 6230      00
 6231              	.LASF25:
 6232 068e 54656D70 		.ascii	"Temperature\000"
 6232      65726174 
 6232      75726500 
 6233              	.LASF83:
 6234 069a 75785175 		.ascii	"uxQueueLength\000"
 6234      6575654C 
 6234      656E6774 
 6234      6800
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 168


 6235              	.LASF2:
 6236 06a8 6C6F6E67 		.ascii	"long double\000"
 6236      20646F75 
 6236      626C6500 
 6237              	.LASF117:
 6238 06b4 78496E68 		.ascii	"xInheritanceOccurred\000"
 6238      65726974 
 6238      616E6365 
 6238      4F636375 
 6238      72726564 
 6239              	.LASF98:
 6240 06c9 78517565 		.ascii	"xQueueTakeMutexRecursive\000"
 6240      75655461 
 6240      6B654D75 
 6240      74657852 
 6240      65637572 
 6241              	.LASF36:
 6242 06e2 7076436F 		.ascii	"pvContainer\000"
 6242      6E746169 
 6242      6E657200 
 6243              	.LASF140:
 6244 06ee 70635175 		.ascii	"pcQueueGetName\000"
 6244      65756547 
 6244      65744E61 
 6244      6D6500
 6245              	.LASF64:
 6246 06fd 51756575 		.ascii	"QueuePointers_t\000"
 6246      65506F69 
 6246      6E746572 
 6246      735F7400 
 6247              	.LASF141:
 6248 070d 70635265 		.ascii	"pcReturn\000"
 6248      7475726E 
 6248      00
 6249              	.LASF57:
 6250 0716 75784C65 		.ascii	"uxLength\000"
 6250      6E677468 
 6250      00
 6251              	.LASF8:
 6252 071f 73686F72 		.ascii	"short int\000"
 6252      7420696E 
 6252      7400
 6253              	.LASF32:
 6254 0729 78497465 		.ascii	"xItemValue\000"
 6254      6D56616C 
 6254      756500
 6255              	.LASF11:
 6256 0734 6C6F6E67 		.ascii	"long int\000"
 6256      20696E74 
 6256      00
 6257              	.LASF145:
 6258 073d 49544D5F 		.ascii	"ITM_RxBuffer\000"
 6258      52784275 
 6258      66666572 
 6258      00
 6259              	.LASF87:
 6260 074a 78517565 		.ascii	"xQueueSizeInBytes\000"
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 169


 6260      75655369 
 6260      7A65496E 
 6260      42797465 
 6260      7300
 6261              	.LASF104:
 6262 075c 70764974 		.ascii	"pvItemToQueue\000"
 6262      656D546F 
 6262      51756575 
 6262      6500
 6263              	.LASF137:
 6264 076a 78517565 		.ascii	"xQueueIsQueueFullFromISR\000"
 6264      75654973 
 6264      51756575 
 6264      6546756C 
 6264      6C46726F 
 6265              	.LASF124:
 6266 0783 75785175 		.ascii	"uxQueueMessagesWaiting\000"
 6266      6575654D 
 6266      65737361 
 6266      67657357 
 6266      61697469 
 6267              	.LASF62:
 6268 079a 70635461 		.ascii	"pcTail\000"
 6268      696C00
 6269              	.LASF99:
 6270 07a1 78546963 		.ascii	"xTicksToWait\000"
 6270      6B73546F 
 6270      57616974 
 6270      00
 6271              	.LASF6:
 6272 07ae 5F5F7569 		.ascii	"__uint8_t\000"
 6272      6E74385F 
 6272      7400
 6273              	.LASF85:
 6274 07b8 70785175 		.ascii	"pxQueue\000"
 6274      65756500 
 6275              	.LASF96:
 6276 07c0 78526574 		.ascii	"xReturn\000"
 6276      75726E00 
 6277              	.LASF15:
 6278 07c8 73697A65 		.ascii	"sizetype\000"
 6278      74797065 
 6278      00
 6279              	.LASF13:
 6280 07d1 6C6F6E67 		.ascii	"long unsigned int\000"
 6280      20756E73 
 6280      69676E65 
 6280      6420696E 
 6280      7400
 6281              	.LASF19:
 6282 07e3 696E7433 		.ascii	"int32_t\000"
 6282      325F7400 
 6283              	.LASF123:
 6284 07eb 78517565 		.ascii	"xQueuePeekFromISR\000"
 6284      75655065 
 6284      656B4672 
 6284      6F6D4953 
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 170


 6284      5200
 6285              	.LASF119:
 6286 07fd 75784869 		.ascii	"uxHighestWaitingPriority\000"
 6286      67686573 
 6286      74576169 
 6286      74696E67 
 6286      5072696F 
 6287              	.LASF7:
 6288 0816 756E7369 		.ascii	"unsigned char\000"
 6288      676E6564 
 6288      20636861 
 6288      7200
 6289              	.LASF12:
 6290 0824 5F5F7569 		.ascii	"__uint32_t\000"
 6290      6E743332 
 6290      5F7400
 6291              	.LASF132:
 6292 082f 70727643 		.ascii	"prvCopyDataFromQueue\000"
 6292      6F707944 
 6292      61746146 
 6292      726F6D51 
 6292      75657565 
 6293              	.LASF144:
 6294 0844 44533138 		.ascii	"DS18x8_DataReady\000"
 6294      78385F44 
 6294      61746152 
 6294      65616479 
 6294      00
 6295              	.LASF149:
 6296 0855 433A5C55 		.ascii	"C:\\Users\\Emil\\Documents\\GitHub\\P4_Vertical_far"
 6296      73657273 
 6296      5C456D69 
 6296      6C5C446F 
 6296      63756D65 
 6297 0883 6D5C5254 		.ascii	"m\\RTOS_TEMPLATE-master\\PlanteModul.cydsn\000"
 6297      4F535F54 
 6297      454D504C 
 6297      4154452D 
 6297      6D617374 
 6298              	.LASF35:
 6299 08ac 70764F77 		.ascii	"pvOwner\000"
 6299      6E657200 
 6300              	.LASF52:
 6301 08b4 70634865 		.ascii	"pcHead\000"
 6301      616400
 6302              	.LASF94:
 6303 08bb 78517565 		.ascii	"xQueueGiveMutexRecursive\000"
 6303      75654769 
 6303      76654D75 
 6303      74657852 
 6303      65637572 
 6304              	.LASF133:
 6305 08d4 70727655 		.ascii	"prvUnlockQueue\000"
 6305      6E6C6F63 
 6305      6B517565 
 6305      756500
 6306              	.LASF81:
ARM GAS  C:\Users\Emil\AppData\Local\Temp\ccnJPzPB.s 			page 171


 6307 08e3 78517565 		.ascii	"xQueueGenericReset\000"
 6307      75654765 
 6307      6E657269 
 6307      63526573 
 6307      657400
 6308              	.LASF135:
 6309 08f6 78517565 		.ascii	"xQueueIsQueueEmptyFromISR\000"
 6309      75654973 
 6309      51756575 
 6309      65456D70 
 6309      74794672 
 6310              	.LASF5:
 6311 0910 7369676E 		.ascii	"signed char\000"
 6311      65642063 
 6311      68617200 
 6312              	.LASF9:
 6313 091c 73686F72 		.ascii	"short unsigned int\000"
 6313      7420756E 
 6313      7369676E 
 6313      65642069 
 6313      6E7400
 6314              	.LASF71:
 6315 092f 78515545 		.ascii	"xQUEUE\000"
 6315      554500
 6316              	.LASF66:
 6317 0936 784D7574 		.ascii	"xMutexHolder\000"
 6317      6578486F 
 6317      6C646572 
 6317      00
 6318              	.LASF21:
 6319 0943 75696E74 		.ascii	"uint8\000"
 6319      3800
 6320              	.LASF24:
 6321 0949 646F7562 		.ascii	"double\000"
 6321      6C6500
 6322              	.LASF131:
 6323 0950 78506F73 		.ascii	"xPosition\000"
 6323      6974696F 
 6323      6E00
 6324              	.LASF59:
 6325 095a 6352784C 		.ascii	"cRxLock\000"
 6325      6F636B00 
 6326              	.LASF100:
 6327 0962 78517565 		.ascii	"xQueueCreateCountingSemaphore\000"
 6327      75654372 
 6327      65617465 
 6327      436F756E 
 6327      74696E67 
 6328              		.ident	"GCC: (GNU Tools for ARM Embedded Processors) 5.4.1 20160609 (release) [ARM/embedded-5-bran
