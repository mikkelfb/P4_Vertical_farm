<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 1
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 1
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.syntax unified
  15              		.file	"tasks.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.comm	DS18x8_Sensor,32,4
  20              		.comm	DS18x8_DataReady,1,1
  21              		.global	pxCurrentTCB
  22              		.bss
  23              		.align	2
  24              		.type	pxCurrentTCB, %object
  25              		.size	pxCurrentTCB, 4
  26              	pxCurrentTCB:
  27 0000 00000000 		.space	4
  28              		.align	2
  29              	pxReadyTasksLists:
  30 0004 00000000 		.space	100
  30      00000000 
  30      00000000 
  30      00000000 
  30      00000000 
  31              		.align	2
  32              	xDelayedTaskList1:
  33 0068 00000000 		.space	20
  33      00000000 
  33      00000000 
  33      00000000 
  33      00000000 
  34              		.align	2
  35              	xDelayedTaskList2:
  36 007c 00000000 		.space	20
  36      00000000 
  36      00000000 
  36      00000000 
  36      00000000 
  37              		.align	2
  38              	pxDelayedTaskList:
  39 0090 00000000 		.space	4
  40              		.align	2
  41              	pxOverflowDelayedTaskList:
  42 0094 00000000 		.space	4
  43              		.align	2
  44              	xPendingReadyList:
  45 0098 00000000 		.space	20
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 2
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 2
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


  45      00000000 
  45      00000000 
  45      00000000 
  45      00000000 
  46              		.align	2
  47              	xTasksWaitingTermination:
  48 00ac 00000000 		.space	20
  48      00000000 
  48      00000000 
  48      00000000 
  48      00000000 
  49              		.align	2
  50              	uxDeletedTasksWaitingCleanUp:
  51 00c0 00000000 		.space	4
  52              		.align	2
  53              	xSuspendedTaskList:
  54 00c4 00000000 		.space	20
  54      00000000 
  54      00000000 
  54      00000000 
  54      00000000 
  55              		.align	2
  56              	uxCurrentNumberOfTasks:
  57 00d8 00000000 		.space	4
  58              		.align	2
  59              	xTickCount:
  60 00dc 00000000 		.space	4
  61              		.align	2
  62              	uxTopReadyPriority:
  63 00e0 00000000 		.space	4
  64              		.align	2
  65              	xSchedulerRunning:
  66 00e4 00000000 		.space	4
  67              		.align	2
  68              	xPendedTicks:
  69 00e8 00000000 		.space	4
  70              		.align	2
  71              	xYieldPending:
  72 00ec 00000000 		.space	4
  73              		.align	2
  74              	xNumOfOverflows:
  75 00f0 00000000 		.space	4
  76              		.align	2
  77              	uxTaskNumber:
  78 00f4 00000000 		.space	4
  79              		.align	2
  80              	xNextTaskUnblockTime:
  81 00f8 00000000 		.space	4
  82              		.align	2
  83              	xIdleTaskHandle:
  84 00fc 00000000 		.space	4
  85              		.align	2
  86              	uxSchedulerSuspended:
  87 0100 00000000 		.space	4
  88              		.section	.text.xTaskCreate,"ax",%progbits
  89              		.align	2
  90              		.global	xTaskCreate
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 3
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 3
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


  91              		.thumb
  92              		.thumb_func
  93              		.type	xTaskCreate, %function
  94              	xTaskCreate:
  95              	.LFB68:
  96              		.file 1 "Source\\tasks.c"
   1:Source/tasks.c **** /*
   2:Source/tasks.c ****  * FreeRTOS Kernel V10.3.1
   3:Source/tasks.c ****  * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:Source/tasks.c ****  *
   5:Source/tasks.c ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   6:Source/tasks.c ****  * this software and associated documentation files (the "Software"), to deal in
   7:Source/tasks.c ****  * the Software without restriction, including without limitation the rights to
   8:Source/tasks.c ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   9:Source/tasks.c ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  10:Source/tasks.c ****  * subject to the following conditions:
  11:Source/tasks.c ****  *
  12:Source/tasks.c ****  * The above copyright notice and this permission notice shall be included in all
  13:Source/tasks.c ****  * copies or substantial portions of the Software.
  14:Source/tasks.c ****  *
  15:Source/tasks.c ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:Source/tasks.c ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  17:Source/tasks.c ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  18:Source/tasks.c ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  19:Source/tasks.c ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  20:Source/tasks.c ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  21:Source/tasks.c ****  *
  22:Source/tasks.c ****  * http://www.FreeRTOS.org
  23:Source/tasks.c ****  * http://aws.amazon.com/freertos
  24:Source/tasks.c ****  *
  25:Source/tasks.c ****  * 1 tab == 4 spaces!
  26:Source/tasks.c ****  */
  27:Source/tasks.c **** 
  28:Source/tasks.c **** /* Standard includes. */
  29:Source/tasks.c **** #include <stdlib.h>
  30:Source/tasks.c **** #include <string.h>
  31:Source/tasks.c **** 
  32:Source/tasks.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  33:Source/tasks.c **** all the API functions to use the MPU wrappers.  That should only be done when
  34:Source/tasks.c **** task.h is included from an application file. */
  35:Source/tasks.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  36:Source/tasks.c **** 
  37:Source/tasks.c **** /* FreeRTOS includes. */
  38:Source/tasks.c **** #include "FreeRTOS.h"
  39:Source/tasks.c **** #include "task.h"
  40:Source/tasks.c **** #include "timers.h"
  41:Source/tasks.c **** #include "stack_macros.h"
  42:Source/tasks.c **** 
  43:Source/tasks.c **** /* Lint e9021, e961 and e750 are suppressed as a MISRA exception justified
  44:Source/tasks.c **** because the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined
  45:Source/tasks.c **** for the header files above, but not in this file, in order to generate the
  46:Source/tasks.c **** correct privileged Vs unprivileged linkage and placement. */
  47:Source/tasks.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750 !e9021. */
  48:Source/tasks.c **** 
  49:Source/tasks.c **** /* Set configUSE_STATS_FORMATTING_FUNCTIONS to 2 to include the stats formatting
  50:Source/tasks.c **** functions but without including stdio.h here. */
  51:Source/tasks.c **** #if ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 4
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 4
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


  52:Source/tasks.c **** 	/* At the bottom of this file are two optional functions that can be used
  53:Source/tasks.c **** 	to generate human readable text from the raw data generated by the
  54:Source/tasks.c **** 	uxTaskGetSystemState() function.  Note the formatting functions are provided
  55:Source/tasks.c **** 	for convenience only, and are NOT considered part of the kernel. */
  56:Source/tasks.c **** 	#include <stdio.h>
  57:Source/tasks.c **** #endif /* configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) */
  58:Source/tasks.c **** 
  59:Source/tasks.c **** #if( configUSE_PREEMPTION == 0 )
  60:Source/tasks.c **** 	/* If the cooperative scheduler is being used then a yield should not be
  61:Source/tasks.c **** 	performed just because a higher priority task has been woken. */
  62:Source/tasks.c **** 	#define taskYIELD_IF_USING_PREEMPTION()
  63:Source/tasks.c **** #else
  64:Source/tasks.c **** 	#define taskYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
  65:Source/tasks.c **** #endif
  66:Source/tasks.c **** 
  67:Source/tasks.c **** /* Values that can be assigned to the ucNotifyState member of the TCB. */
  68:Source/tasks.c **** #define taskNOT_WAITING_NOTIFICATION	( ( uint8_t ) 0 )
  69:Source/tasks.c **** #define taskWAITING_NOTIFICATION		( ( uint8_t ) 1 )
  70:Source/tasks.c **** #define taskNOTIFICATION_RECEIVED		( ( uint8_t ) 2 )
  71:Source/tasks.c **** 
  72:Source/tasks.c **** /*
  73:Source/tasks.c ****  * The value used to fill the stack of a task when the task is created.  This
  74:Source/tasks.c ****  * is used purely for checking the high water mark for tasks.
  75:Source/tasks.c ****  */
  76:Source/tasks.c **** #define tskSTACK_FILL_BYTE	( 0xa5U )
  77:Source/tasks.c **** 
  78:Source/tasks.c **** /* Bits used to recored how a task's stack and TCB were allocated. */
  79:Source/tasks.c **** #define tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB 		( ( uint8_t ) 0 )
  80:Source/tasks.c **** #define tskSTATICALLY_ALLOCATED_STACK_ONLY 			( ( uint8_t ) 1 )
  81:Source/tasks.c **** #define tskSTATICALLY_ALLOCATED_STACK_AND_TCB		( ( uint8_t ) 2 )
  82:Source/tasks.c **** 
  83:Source/tasks.c **** /* If any of the following are set then task stacks are filled with a known
  84:Source/tasks.c **** value so the high water mark can be determined.  If none of the following are
  85:Source/tasks.c **** set then don't fill the stack so there is no unnecessary dependency on memset. */
  86:Source/tasks.c **** #if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTas
  87:Source/tasks.c **** 	#define tskSET_NEW_STACKS_TO_KNOWN_VALUE	1
  88:Source/tasks.c **** #else
  89:Source/tasks.c **** 	#define tskSET_NEW_STACKS_TO_KNOWN_VALUE	0
  90:Source/tasks.c **** #endif
  91:Source/tasks.c **** 
  92:Source/tasks.c **** /*
  93:Source/tasks.c ****  * Macros used by vListTask to indicate which state a task is in.
  94:Source/tasks.c ****  */
  95:Source/tasks.c **** #define tskRUNNING_CHAR		( 'X' )
  96:Source/tasks.c **** #define tskBLOCKED_CHAR		( 'B' )
  97:Source/tasks.c **** #define tskREADY_CHAR		( 'R' )
  98:Source/tasks.c **** #define tskDELETED_CHAR		( 'D' )
  99:Source/tasks.c **** #define tskSUSPENDED_CHAR	( 'S' )
 100:Source/tasks.c **** 
 101:Source/tasks.c **** /*
 102:Source/tasks.c ****  * Some kernel aware debuggers require the data the debugger needs access to be
 103:Source/tasks.c ****  * global, rather than file scope.
 104:Source/tasks.c ****  */
 105:Source/tasks.c **** #ifdef portREMOVE_STATIC_QUALIFIER
 106:Source/tasks.c **** 	#define static
 107:Source/tasks.c **** #endif
 108:Source/tasks.c **** 
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 5
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 5
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 109:Source/tasks.c **** /* The name allocated to the Idle task.  This can be overridden by defining
 110:Source/tasks.c **** configIDLE_TASK_NAME in FreeRTOSConfig.h. */
 111:Source/tasks.c **** #ifndef configIDLE_TASK_NAME
 112:Source/tasks.c **** 	#define configIDLE_TASK_NAME "IDLE"
 113:Source/tasks.c **** #endif
 114:Source/tasks.c **** 
 115:Source/tasks.c **** #if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
 116:Source/tasks.c **** 
 117:Source/tasks.c **** 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 0 then task selection is
 118:Source/tasks.c **** 	performed in a generic way that is not optimised to any particular
 119:Source/tasks.c **** 	microcontroller architecture. */
 120:Source/tasks.c **** 
 121:Source/tasks.c **** 	/* uxTopReadyPriority holds the priority of the highest priority ready
 122:Source/tasks.c **** 	state task. */
 123:Source/tasks.c **** 	#define taskRECORD_READY_PRIORITY( uxPriority )														\
 124:Source/tasks.c **** 	{																									\
 125:Source/tasks.c **** 		if( ( uxPriority ) > uxTopReadyPriority )														\
 126:Source/tasks.c **** 		{																								\
 127:Source/tasks.c **** 			uxTopReadyPriority = ( uxPriority );														\
 128:Source/tasks.c **** 		}																								\
 129:Source/tasks.c **** 	} /* taskRECORD_READY_PRIORITY */
 130:Source/tasks.c **** 
 131:Source/tasks.c **** 	/*-----------------------------------------------------------*/
 132:Source/tasks.c **** 
 133:Source/tasks.c **** 	#define taskSELECT_HIGHEST_PRIORITY_TASK()															\
 134:Source/tasks.c **** 	{																									\
 135:Source/tasks.c **** 	UBaseType_t uxTopPriority = uxTopReadyPriority;														\
 136:Source/tasks.c **** 																										\
 137:Source/tasks.c **** 		/* Find the highest priority queue that contains ready tasks. */								\
 138:Source/tasks.c **** 		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopPriority ] ) ) )							\
 139:Source/tasks.c **** 		{																								\
 140:Source/tasks.c **** 			configASSERT( uxTopPriority );																\
 141:Source/tasks.c **** 			--uxTopPriority;																			\
 142:Source/tasks.c **** 		}																								\
 143:Source/tasks.c **** 																										\
 144:Source/tasks.c **** 		/* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of						\
 145:Source/tasks.c **** 		the	same priority get an equal share of the processor time. */									\
 146:Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );			\
 147:Source/tasks.c **** 		uxTopReadyPriority = uxTopPriority;																\
 148:Source/tasks.c **** 	} /* taskSELECT_HIGHEST_PRIORITY_TASK */
 149:Source/tasks.c **** 
 150:Source/tasks.c **** 	/*-----------------------------------------------------------*/
 151:Source/tasks.c **** 
 152:Source/tasks.c **** 	/* Define away taskRESET_READY_PRIORITY() and portRESET_READY_PRIORITY() as
 153:Source/tasks.c **** 	they are only required when a port optimised method of task selection is
 154:Source/tasks.c **** 	being used. */
 155:Source/tasks.c **** 	#define taskRESET_READY_PRIORITY( uxPriority )
 156:Source/tasks.c **** 	#define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority )
 157:Source/tasks.c **** 
 158:Source/tasks.c **** #else /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 159:Source/tasks.c **** 
 160:Source/tasks.c **** 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 1 then task selection is
 161:Source/tasks.c **** 	performed in a way that is tailored to the particular microcontroller
 162:Source/tasks.c **** 	architecture being used. */
 163:Source/tasks.c **** 
 164:Source/tasks.c **** 	/* A port optimised version is provided.  Call the port defined macros. */
 165:Source/tasks.c **** 	#define taskRECORD_READY_PRIORITY( uxPriority )	portRECORD_READY_PRIORITY( uxPriority, uxTopReadyP
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 6
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 6
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 166:Source/tasks.c **** 
 167:Source/tasks.c **** 	/*-----------------------------------------------------------*/
 168:Source/tasks.c **** 
 169:Source/tasks.c **** 	#define taskSELECT_HIGHEST_PRIORITY_TASK()														\
 170:Source/tasks.c **** 	{																								\
 171:Source/tasks.c **** 	UBaseType_t uxTopPriority;																		\
 172:Source/tasks.c **** 																									\
 173:Source/tasks.c **** 		/* Find the highest priority list that contains ready tasks. */								\
 174:Source/tasks.c **** 		portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );								\
 175:Source/tasks.c **** 		configASSERT( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ uxTopPriority ] ) ) > 0 );		\
 176:Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );		\
 177:Source/tasks.c **** 	} /* taskSELECT_HIGHEST_PRIORITY_TASK() */
 178:Source/tasks.c **** 
 179:Source/tasks.c **** 	/*-----------------------------------------------------------*/
 180:Source/tasks.c **** 
 181:Source/tasks.c **** 	/* A port optimised version is provided, call it only if the TCB being reset
 182:Source/tasks.c **** 	is being referenced from a ready list.  If it is referenced from a delayed
 183:Source/tasks.c **** 	or suspended list then it won't be in a ready list. */
 184:Source/tasks.c **** 	#define taskRESET_READY_PRIORITY( uxPriority )														\
 185:Source/tasks.c **** 	{																									\
 186:Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ ( uxPriority ) ] ) ) == ( UBaseType_t ) 0 )	\
 187:Source/tasks.c **** 		{																								\
 188:Source/tasks.c **** 			portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );							\
 189:Source/tasks.c **** 		}																								\
 190:Source/tasks.c **** 	}
 191:Source/tasks.c **** 
 192:Source/tasks.c **** #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 193:Source/tasks.c **** 
 194:Source/tasks.c **** /*-----------------------------------------------------------*/
 195:Source/tasks.c **** 
 196:Source/tasks.c **** /* pxDelayedTaskList and pxOverflowDelayedTaskList are switched when the tick
 197:Source/tasks.c **** count overflows. */
 198:Source/tasks.c **** #define taskSWITCH_DELAYED_LISTS()																	\
 199:Source/tasks.c **** {																									\
 200:Source/tasks.c **** 	List_t *pxTemp;																					\
 201:Source/tasks.c **** 																									\
 202:Source/tasks.c **** 	/* The delayed tasks list should be empty when the lists are switched. */						\
 203:Source/tasks.c **** 	configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );										\
 204:Source/tasks.c **** 																									\
 205:Source/tasks.c **** 	pxTemp = pxDelayedTaskList;																		\
 206:Source/tasks.c **** 	pxDelayedTaskList = pxOverflowDelayedTaskList;													\
 207:Source/tasks.c **** 	pxOverflowDelayedTaskList = pxTemp;																\
 208:Source/tasks.c **** 	xNumOfOverflows++;																				\
 209:Source/tasks.c **** 	prvResetNextTaskUnblockTime();																	\
 210:Source/tasks.c **** }
 211:Source/tasks.c **** 
 212:Source/tasks.c **** /*-----------------------------------------------------------*/
 213:Source/tasks.c **** 
 214:Source/tasks.c **** /*
 215:Source/tasks.c ****  * Place the task represented by pxTCB into the appropriate ready list for
 216:Source/tasks.c ****  * the task.  It is inserted at the end of the list.
 217:Source/tasks.c ****  */
 218:Source/tasks.c **** #define prvAddTaskToReadyList( pxTCB )																\
 219:Source/tasks.c **** 	traceMOVED_TASK_TO_READY_STATE( pxTCB );														\
 220:Source/tasks.c **** 	taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );												\
 221:Source/tasks.c **** 	vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xStateListItem ) );
 222:Source/tasks.c **** 	tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB )
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 7
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 7
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 223:Source/tasks.c **** /*-----------------------------------------------------------*/
 224:Source/tasks.c **** 
 225:Source/tasks.c **** /*
 226:Source/tasks.c ****  * Several functions take an TaskHandle_t parameter that can optionally be NULL,
 227:Source/tasks.c ****  * where NULL is used to indicate that the handle of the currently executing
 228:Source/tasks.c ****  * task should be used in place of the parameter.  This macro simply checks to
 229:Source/tasks.c ****  * see if the parameter is NULL and returns a pointer to the appropriate TCB.
 230:Source/tasks.c ****  */
 231:Source/tasks.c **** #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? pxCurrentTCB : ( pxHandle ) )
 232:Source/tasks.c **** 
 233:Source/tasks.c **** /* The item value of the event list item is normally used to hold the priority
 234:Source/tasks.c **** of the task to which it belongs (coded to allow it to be held in reverse
 235:Source/tasks.c **** priority order).  However, it is occasionally borrowed for other purposes.  It
 236:Source/tasks.c **** is important its value is not updated due to a task priority change while it is
 237:Source/tasks.c **** being used for another purpose.  The following bit definition is used to inform
 238:Source/tasks.c **** the scheduler that the value should not be changed - in which case it is the
 239:Source/tasks.c **** responsibility of whichever module is using the value to ensure it gets set back
 240:Source/tasks.c **** to its original value when it is released. */
 241:Source/tasks.c **** #if( configUSE_16_BIT_TICKS == 1 )
 242:Source/tasks.c **** 	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x8000U
 243:Source/tasks.c **** #else
 244:Source/tasks.c **** 	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x80000000UL
 245:Source/tasks.c **** #endif
 246:Source/tasks.c **** 
 247:Source/tasks.c **** /*
 248:Source/tasks.c ****  * Task control block.  A task control block (TCB) is allocated for each task,
 249:Source/tasks.c ****  * and stores task state information, including a pointer to the task's context
 250:Source/tasks.c ****  * (the task's run time environment, including register values)
 251:Source/tasks.c ****  */
 252:Source/tasks.c **** typedef struct tskTaskControlBlock 			/* The old naming convention is used to prevent breaking kern
 253:Source/tasks.c **** {
 254:Source/tasks.c **** 	volatile StackType_t	*pxTopOfStack;	/*< Points to the location of the last item placed on the task
 255:Source/tasks.c **** 
 256:Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
 257:Source/tasks.c **** 		xMPU_SETTINGS	xMPUSettings;		/*< The MPU settings are defined as part of the port layer.  THIS MU
 258:Source/tasks.c **** 	#endif
 259:Source/tasks.c **** 
 260:Source/tasks.c **** 	ListItem_t			xStateListItem;	/*< The list that the state list item of a task is reference from den
 261:Source/tasks.c **** 	ListItem_t			xEventListItem;		/*< Used to reference a task from an event list. */
 262:Source/tasks.c **** 	UBaseType_t			uxPriority;			/*< The priority of the task.  0 is the lowest priority. */
 263:Source/tasks.c **** 	StackType_t			*pxStack;			/*< Points to the start of the stack. */
 264:Source/tasks.c **** 	char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when created.
 265:Source/tasks.c **** 
 266:Source/tasks.c **** 	#if ( ( portSTACK_GROWTH > 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) )
 267:Source/tasks.c **** 		StackType_t		*pxEndOfStack;		/*< Points to the highest valid address for the stack. */
 268:Source/tasks.c **** 	#endif
 269:Source/tasks.c **** 
 270:Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
 271:Source/tasks.c **** 		UBaseType_t		uxCriticalNesting;	/*< Holds the critical section nesting depth for ports that do no
 272:Source/tasks.c **** 	#endif
 273:Source/tasks.c **** 
 274:Source/tasks.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 275:Source/tasks.c **** 		UBaseType_t		uxTCBNumber;		/*< Stores a number that increments each time a TCB is created.  It al
 276:Source/tasks.c **** 		UBaseType_t		uxTaskNumber;		/*< Stores a number specifically for use by third party trace code. *
 277:Source/tasks.c **** 	#endif
 278:Source/tasks.c **** 
 279:Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 8
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 8
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 280:Source/tasks.c **** 		UBaseType_t		uxBasePriority;		/*< The priority last assigned to the task - used by the priority i
 281:Source/tasks.c **** 		UBaseType_t		uxMutexesHeld;
 282:Source/tasks.c **** 	#endif
 283:Source/tasks.c **** 
 284:Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
 285:Source/tasks.c **** 		TaskHookFunction_t pxTaskTag;
 286:Source/tasks.c **** 	#endif
 287:Source/tasks.c **** 
 288:Source/tasks.c **** 	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
 289:Source/tasks.c **** 		void			*pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];
 290:Source/tasks.c **** 	#endif
 291:Source/tasks.c **** 
 292:Source/tasks.c **** 	#if( configGENERATE_RUN_TIME_STATS == 1 )
 293:Source/tasks.c **** 		uint32_t		ulRunTimeCounter;	/*< Stores the amount of time the task has spent in the Running state
 294:Source/tasks.c **** 	#endif
 295:Source/tasks.c **** 
 296:Source/tasks.c **** 	#if ( configUSE_NEWLIB_REENTRANT == 1 )
 297:Source/tasks.c **** 		/* Allocate a Newlib reent structure that is specific to this task.
 298:Source/tasks.c **** 		Note Newlib support has been included by popular demand, but is not
 299:Source/tasks.c **** 		used by the FreeRTOS maintainers themselves.  FreeRTOS is not
 300:Source/tasks.c **** 		responsible for resulting newlib operation.  User must be familiar with
 301:Source/tasks.c **** 		newlib and must provide system-wide implementations of the necessary
 302:Source/tasks.c **** 		stubs. Be warned that (at the time of writing) the current newlib design
 303:Source/tasks.c **** 		implements a system-wide malloc() that must be provided with locks.
 304:Source/tasks.c **** 
 305:Source/tasks.c **** 		See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html
 306:Source/tasks.c **** 		for additional information. */
 307:Source/tasks.c **** 		struct	_reent xNewLib_reent;
 308:Source/tasks.c **** 	#endif
 309:Source/tasks.c **** 
 310:Source/tasks.c **** 	#if( configUSE_TASK_NOTIFICATIONS == 1 )
 311:Source/tasks.c **** 		volatile uint32_t ulNotifiedValue;
 312:Source/tasks.c **** 		volatile uint8_t ucNotifyState;
 313:Source/tasks.c **** 	#endif
 314:Source/tasks.c **** 
 315:Source/tasks.c **** 	/* See the comments in FreeRTOS.h with the definition of
 316:Source/tasks.c **** 	tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE. */
 317:Source/tasks.c **** 	#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consolida
 318:Source/tasks.c **** 		uint8_t	ucStaticallyAllocated; 		/*< Set to pdTRUE if the task is a statically allocated to ensur
 319:Source/tasks.c **** 	#endif
 320:Source/tasks.c **** 
 321:Source/tasks.c **** 	#if( INCLUDE_xTaskAbortDelay == 1 )
 322:Source/tasks.c **** 		uint8_t ucDelayAborted;
 323:Source/tasks.c **** 	#endif
 324:Source/tasks.c **** 
 325:Source/tasks.c **** 	#if( configUSE_POSIX_ERRNO == 1 )
 326:Source/tasks.c **** 		int iTaskErrno;
 327:Source/tasks.c **** 	#endif
 328:Source/tasks.c **** 
 329:Source/tasks.c **** } tskTCB;
 330:Source/tasks.c **** 
 331:Source/tasks.c **** /* The old tskTCB name is maintained above then typedefed to the new TCB_t name
 332:Source/tasks.c **** below to enable the use of older kernel aware debuggers. */
 333:Source/tasks.c **** typedef tskTCB TCB_t;
 334:Source/tasks.c **** 
 335:Source/tasks.c **** /*lint -save -e956 A manual analysis and inspection has been used to determine
 336:Source/tasks.c **** which static variables must be declared volatile. */
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 9
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 9
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 337:Source/tasks.c **** PRIVILEGED_DATA TCB_t * volatile pxCurrentTCB = NULL;
 338:Source/tasks.c **** 
 339:Source/tasks.c **** /* Lists for ready and blocked tasks. --------------------
 340:Source/tasks.c **** xDelayedTaskList1 and xDelayedTaskList2 could be move to function scople but
 341:Source/tasks.c **** doing so breaks some kernel aware debuggers and debuggers that rely on removing
 342:Source/tasks.c **** the static qualifier. */
 343:Source/tasks.c **** PRIVILEGED_DATA static List_t pxReadyTasksLists[ configMAX_PRIORITIES ];/*< Prioritised ready tasks
 344:Source/tasks.c **** PRIVILEGED_DATA static List_t xDelayedTaskList1;						/*< Delayed tasks. */
 345:Source/tasks.c **** PRIVILEGED_DATA static List_t xDelayedTaskList2;						/*< Delayed tasks (two lists are used - one f
 346:Source/tasks.c **** PRIVILEGED_DATA static List_t * volatile pxDelayedTaskList;				/*< Points to the delayed task list 
 347:Source/tasks.c **** PRIVILEGED_DATA static List_t * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task
 348:Source/tasks.c **** PRIVILEGED_DATA static List_t xPendingReadyList;						/*< Tasks that have been readied while the sc
 349:Source/tasks.c **** 
 350:Source/tasks.c **** #if( INCLUDE_vTaskDelete == 1 )
 351:Source/tasks.c **** 
 352:Source/tasks.c **** 	PRIVILEGED_DATA static List_t xTasksWaitingTermination;				/*< Tasks that have been deleted - but 
 353:Source/tasks.c **** 	PRIVILEGED_DATA static volatile UBaseType_t uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
 354:Source/tasks.c **** 
 355:Source/tasks.c **** #endif
 356:Source/tasks.c **** 
 357:Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 358:Source/tasks.c **** 
 359:Source/tasks.c **** 	PRIVILEGED_DATA static List_t xSuspendedTaskList;					/*< Tasks that are currently suspended. */
 360:Source/tasks.c **** 
 361:Source/tasks.c **** #endif
 362:Source/tasks.c **** 
 363:Source/tasks.c **** /* Global POSIX errno. Its value is changed upon context switching to match
 364:Source/tasks.c **** the errno of the currently running task. */
 365:Source/tasks.c **** #if ( configUSE_POSIX_ERRNO == 1 )
 366:Source/tasks.c **** 	int FreeRTOS_errno = 0;
 367:Source/tasks.c **** #endif
 368:Source/tasks.c **** 
 369:Source/tasks.c **** /* Other file private variables. --------------------------------*/
 370:Source/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxCurrentNumberOfTasks 	= ( UBaseType_t ) 0U;
 371:Source/tasks.c **** PRIVILEGED_DATA static volatile TickType_t xTickCount 				= ( TickType_t ) configINITIAL_TICK_COUNT
 372:Source/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxTopReadyPriority 		= tskIDLE_PRIORITY;
 373:Source/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xSchedulerRunning 		= pdFALSE;
 374:Source/tasks.c **** PRIVILEGED_DATA static volatile TickType_t xPendedTicks 			= ( TickType_t ) 0U;
 375:Source/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xYieldPending 			= pdFALSE;
 376:Source/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xNumOfOverflows 			= ( BaseType_t ) 0;
 377:Source/tasks.c **** PRIVILEGED_DATA static UBaseType_t uxTaskNumber 					= ( UBaseType_t ) 0U;
 378:Source/tasks.c **** PRIVILEGED_DATA static volatile TickType_t xNextTaskUnblockTime		= ( TickType_t ) 0U; /* Initialise
 379:Source/tasks.c **** PRIVILEGED_DATA static TaskHandle_t xIdleTaskHandle					= NULL;			/*< Holds the handle of the idle 
 380:Source/tasks.c **** 
 381:Source/tasks.c **** /* Context switches are held pending while the scheduler is suspended.  Also,
 382:Source/tasks.c **** interrupts must not manipulate the xStateListItem of a TCB, or any of the
 383:Source/tasks.c **** lists the xStateListItem can be referenced from, if the scheduler is suspended.
 384:Source/tasks.c **** If an interrupt needs to unblock a task while the scheduler is suspended then it
 385:Source/tasks.c **** moves the task's event list item into the xPendingReadyList, ready for the
 386:Source/tasks.c **** kernel to move the task from the pending ready list into the real ready list
 387:Source/tasks.c **** when the scheduler is unsuspended.  The pending ready list itself can only be
 388:Source/tasks.c **** accessed from a critical section. */
 389:Source/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxSchedulerSuspended	= ( UBaseType_t ) pdFALSE;
 390:Source/tasks.c **** 
 391:Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
 392:Source/tasks.c **** 
 393:Source/tasks.c **** 	/* Do not move these variables to function scope as doing so prevents the
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 10
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 10
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 394:Source/tasks.c **** 	code working with debuggers that need to remove the static qualifier. */
 395:Source/tasks.c **** 	PRIVILEGED_DATA static uint32_t ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/counter
 396:Source/tasks.c **** 	PRIVILEGED_DATA static uint32_t ulTotalRunTime = 0UL;		/*< Holds the total amount of execution tim
 397:Source/tasks.c **** 
 398:Source/tasks.c **** #endif
 399:Source/tasks.c **** 
 400:Source/tasks.c **** /*lint -restore */
 401:Source/tasks.c **** 
 402:Source/tasks.c **** /*-----------------------------------------------------------*/
 403:Source/tasks.c **** 
 404:Source/tasks.c **** /* Callback function prototypes. --------------------------*/
 405:Source/tasks.c **** #if(  configCHECK_FOR_STACK_OVERFLOW > 0 )
 406:Source/tasks.c **** 
 407:Source/tasks.c **** 	extern void vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName );
 408:Source/tasks.c **** 
 409:Source/tasks.c **** #endif
 410:Source/tasks.c **** 
 411:Source/tasks.c **** #if( configUSE_TICK_HOOK > 0 )
 412:Source/tasks.c **** 
 413:Source/tasks.c **** 	extern void vApplicationTickHook( void ); /*lint !e526 Symbol not defined as it is an application 
 414:Source/tasks.c **** 
 415:Source/tasks.c **** #endif
 416:Source/tasks.c **** 
 417:Source/tasks.c **** #if( configSUPPORT_STATIC_ALLOCATION == 1 )
 418:Source/tasks.c **** 
 419:Source/tasks.c **** 	extern void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxI
 420:Source/tasks.c **** 
 421:Source/tasks.c **** #endif
 422:Source/tasks.c **** 
 423:Source/tasks.c **** /* File private functions. --------------------------------*/
 424:Source/tasks.c **** 
 425:Source/tasks.c **** /**
 426:Source/tasks.c ****  * Utility task that simply returns pdTRUE if the task referenced by xTask is
 427:Source/tasks.c ****  * currently in the Suspended state, or pdFALSE if the task referenced by xTask
 428:Source/tasks.c ****  * is in any other state.
 429:Source/tasks.c ****  */
 430:Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 431:Source/tasks.c **** 
 432:Source/tasks.c **** 	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
 433:Source/tasks.c **** 
 434:Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
 435:Source/tasks.c **** 
 436:Source/tasks.c **** /*
 437:Source/tasks.c ****  * Utility to ready all the lists used by the scheduler.  This is called
 438:Source/tasks.c ****  * automatically upon the creation of the first task.
 439:Source/tasks.c ****  */
 440:Source/tasks.c **** static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
 441:Source/tasks.c **** 
 442:Source/tasks.c **** /*
 443:Source/tasks.c ****  * The idle task, which as all tasks is implemented as a never ending loop.
 444:Source/tasks.c ****  * The idle task is automatically created and added to the ready lists upon
 445:Source/tasks.c ****  * creation of the first user task.
 446:Source/tasks.c ****  *
 447:Source/tasks.c ****  * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
 448:Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
 449:Source/tasks.c ****  *
 450:Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 11
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 11
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 451:Source/tasks.c ****  *
 452:Source/tasks.c ****  */
 453:Source/tasks.c **** static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
 454:Source/tasks.c **** 
 455:Source/tasks.c **** /*
 456:Source/tasks.c ****  * Utility to free all memory allocated by the scheduler to hold a TCB,
 457:Source/tasks.c ****  * including the stack pointed to by the TCB.
 458:Source/tasks.c ****  *
 459:Source/tasks.c ****  * This does not free memory allocated by the task itself (i.e. memory
 460:Source/tasks.c ****  * allocated by calls to pvPortMalloc from within the tasks application code).
 461:Source/tasks.c ****  */
 462:Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 463:Source/tasks.c **** 
 464:Source/tasks.c **** 	static void prvDeleteTCB( TCB_t *pxTCB ) PRIVILEGED_FUNCTION;
 465:Source/tasks.c **** 
 466:Source/tasks.c **** #endif
 467:Source/tasks.c **** 
 468:Source/tasks.c **** /*
 469:Source/tasks.c ****  * Used only by the idle task.  This checks to see if anything has been placed
 470:Source/tasks.c ****  * in the list of tasks waiting to be deleted.  If so the task is cleaned up
 471:Source/tasks.c ****  * and its TCB deleted.
 472:Source/tasks.c ****  */
 473:Source/tasks.c **** static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
 474:Source/tasks.c **** 
 475:Source/tasks.c **** /*
 476:Source/tasks.c ****  * The currently executing task is entering the Blocked state.  Add the task to
 477:Source/tasks.c ****  * either the current or the overflow delayed task list.
 478:Source/tasks.c ****  */
 479:Source/tasks.c **** static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockInde
 480:Source/tasks.c **** 
 481:Source/tasks.c **** /*
 482:Source/tasks.c ****  * Fills an TaskStatus_t structure with information on each task that is
 483:Source/tasks.c ****  * referenced from the pxList list (which may be a ready list, a delayed list,
 484:Source/tasks.c ****  * a suspended list, etc.).
 485:Source/tasks.c ****  *
 486:Source/tasks.c ****  * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
 487:Source/tasks.c ****  * NORMAL APPLICATION CODE.
 488:Source/tasks.c ****  */
 489:Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 490:Source/tasks.c **** 
 491:Source/tasks.c **** 	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, 
 492:Source/tasks.c **** 
 493:Source/tasks.c **** #endif
 494:Source/tasks.c **** 
 495:Source/tasks.c **** /*
 496:Source/tasks.c ****  * Searches pxList for a task with name pcNameToQuery - returning a handle to
 497:Source/tasks.c ****  * the task if it is found, or NULL if the task is not found.
 498:Source/tasks.c ****  */
 499:Source/tasks.c **** #if ( INCLUDE_xTaskGetHandle == 1 )
 500:Source/tasks.c **** 
 501:Source/tasks.c **** 	static TCB_t *prvSearchForNameWithinSingleList( List_t *pxList, const char pcNameToQuery[] ) PRIVI
 502:Source/tasks.c **** 
 503:Source/tasks.c **** #endif
 504:Source/tasks.c **** 
 505:Source/tasks.c **** /*
 506:Source/tasks.c ****  * When a task is created, the stack of the task is filled with a known value.
 507:Source/tasks.c ****  * This function determines the 'high water mark' of the task stack by
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 12
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 12
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 508:Source/tasks.c ****  * determining how much of the stack remains at the original preset value.
 509:Source/tasks.c ****  */
 510:Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUD
 511:Source/tasks.c **** 
 512:Source/tasks.c **** 	static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte ) PRIVILEGE
 513:Source/tasks.c **** 
 514:Source/tasks.c **** #endif
 515:Source/tasks.c **** 
 516:Source/tasks.c **** /*
 517:Source/tasks.c ****  * Return the amount of time, in ticks, that will pass before the kernel will
 518:Source/tasks.c ****  * next move a task from the Blocked state to the Running state.
 519:Source/tasks.c ****  *
 520:Source/tasks.c ****  * This conditional compilation should use inequality to 0, not equality to 1.
 521:Source/tasks.c ****  * This is to ensure portSUPPRESS_TICKS_AND_SLEEP() can be called when user
 522:Source/tasks.c ****  * defined low power mode implementations require configUSE_TICKLESS_IDLE to be
 523:Source/tasks.c ****  * set to a value other than 1.
 524:Source/tasks.c ****  */
 525:Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
 526:Source/tasks.c **** 
 527:Source/tasks.c **** 	static TickType_t prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;
 528:Source/tasks.c **** 
 529:Source/tasks.c **** #endif
 530:Source/tasks.c **** 
 531:Source/tasks.c **** /*
 532:Source/tasks.c ****  * Set xNextTaskUnblockTime to the time at which the next Blocked state task
 533:Source/tasks.c ****  * will exit the Blocked state.
 534:Source/tasks.c ****  */
 535:Source/tasks.c **** static void prvResetNextTaskUnblockTime( void );
 536:Source/tasks.c **** 
 537:Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
 538:Source/tasks.c **** 
 539:Source/tasks.c **** 	/*
 540:Source/tasks.c **** 	 * Helper function used to pad task names with spaces when printing out
 541:Source/tasks.c **** 	 * human readable tables of task information.
 542:Source/tasks.c **** 	 */
 543:Source/tasks.c **** 	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName ) PRIVILEGED_FUNCTION;
 544:Source/tasks.c **** 
 545:Source/tasks.c **** #endif
 546:Source/tasks.c **** 
 547:Source/tasks.c **** /*
 548:Source/tasks.c ****  * Called after a Task_t structure has been allocated either statically or
 549:Source/tasks.c ****  * dynamically to fill in the structure's members.
 550:Source/tasks.c ****  */
 551:Source/tasks.c **** static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
 552:Source/tasks.c **** 									const char * const pcName, 		/*lint !e971 Unqualified char types are allowed for strings a
 553:Source/tasks.c **** 									const uint32_t ulStackDepth,
 554:Source/tasks.c **** 									void * const pvParameters,
 555:Source/tasks.c **** 									UBaseType_t uxPriority,
 556:Source/tasks.c **** 									TaskHandle_t * const pxCreatedTask,
 557:Source/tasks.c **** 									TCB_t *pxNewTCB,
 558:Source/tasks.c **** 									const MemoryRegion_t * const xRegions ) PRIVILEGED_FUNCTION;
 559:Source/tasks.c **** 
 560:Source/tasks.c **** /*
 561:Source/tasks.c ****  * Called after a new task has been created and initialised to place the task
 562:Source/tasks.c ****  * under the control of the scheduler.
 563:Source/tasks.c ****  */
 564:Source/tasks.c **** static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB ) PRIVILEGED_FUNCTION;
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 13
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 13
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 565:Source/tasks.c **** 
 566:Source/tasks.c **** /*
 567:Source/tasks.c ****  * freertos_tasks_c_additions_init() should only be called if the user definable
 568:Source/tasks.c ****  * macro FREERTOS_TASKS_C_ADDITIONS_INIT() is defined, as that is the only macro
 569:Source/tasks.c ****  * called by the function.
 570:Source/tasks.c ****  */
 571:Source/tasks.c **** #ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
 572:Source/tasks.c **** 
 573:Source/tasks.c **** 	static void freertos_tasks_c_additions_init( void ) PRIVILEGED_FUNCTION;
 574:Source/tasks.c **** 
 575:Source/tasks.c **** #endif
 576:Source/tasks.c **** 
 577:Source/tasks.c **** /*-----------------------------------------------------------*/
 578:Source/tasks.c **** 
 579:Source/tasks.c **** #if( configSUPPORT_STATIC_ALLOCATION == 1 )
 580:Source/tasks.c **** 
 581:Source/tasks.c **** 	TaskHandle_t xTaskCreateStatic(	TaskFunction_t pxTaskCode,
 582:Source/tasks.c **** 									const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings an
 583:Source/tasks.c **** 									const uint32_t ulStackDepth,
 584:Source/tasks.c **** 									void * const pvParameters,
 585:Source/tasks.c **** 									UBaseType_t uxPriority,
 586:Source/tasks.c **** 									StackType_t * const puxStackBuffer,
 587:Source/tasks.c **** 									StaticTask_t * const pxTaskBuffer )
 588:Source/tasks.c **** 	{
 589:Source/tasks.c **** 	TCB_t *pxNewTCB;
 590:Source/tasks.c **** 	TaskHandle_t xReturn;
 591:Source/tasks.c **** 
 592:Source/tasks.c **** 		configASSERT( puxStackBuffer != NULL );
 593:Source/tasks.c **** 		configASSERT( pxTaskBuffer != NULL );
 594:Source/tasks.c **** 
 595:Source/tasks.c **** 		#if( configASSERT_DEFINED == 1 )
 596:Source/tasks.c **** 		{
 597:Source/tasks.c **** 			/* Sanity check that the size of the structure used to declare a
 598:Source/tasks.c **** 			variable of type StaticTask_t equals the size of the real task
 599:Source/tasks.c **** 			structure. */
 600:Source/tasks.c **** 			volatile size_t xSize = sizeof( StaticTask_t );
 601:Source/tasks.c **** 			configASSERT( xSize == sizeof( TCB_t ) );
 602:Source/tasks.c **** 			( void ) xSize; /* Prevent lint warning when configASSERT() is not used. */
 603:Source/tasks.c **** 		}
 604:Source/tasks.c **** 		#endif /* configASSERT_DEFINED */
 605:Source/tasks.c **** 
 606:Source/tasks.c **** 
 607:Source/tasks.c **** 		if( ( pxTaskBuffer != NULL ) && ( puxStackBuffer != NULL ) )
 608:Source/tasks.c **** 		{
 609:Source/tasks.c **** 			/* The memory used for the task's TCB and stack are passed into this
 610:Source/tasks.c **** 			function - use them. */
 611:Source/tasks.c **** 			pxNewTCB = ( TCB_t * ) pxTaskBuffer; /*lint !e740 !e9087 Unusual cast is ok as the structures ar
 612:Source/tasks.c **** 			pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
 613:Source/tasks.c **** 
 614:Source/tasks.c **** 			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consoli
 615:Source/tasks.c **** 			{
 616:Source/tasks.c **** 				/* Tasks can be created statically or dynamically, so note this
 617:Source/tasks.c **** 				task was created statically in case the task is later deleted. */
 618:Source/tasks.c **** 				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 619:Source/tasks.c **** 			}
 620:Source/tasks.c **** 			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */
 621:Source/tasks.c **** 
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 14
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 14
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 622:Source/tasks.c **** 			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNe
 623:Source/tasks.c **** 			prvAddNewTaskToReadyList( pxNewTCB );
 624:Source/tasks.c **** 		}
 625:Source/tasks.c **** 		else
 626:Source/tasks.c **** 		{
 627:Source/tasks.c **** 			xReturn = NULL;
 628:Source/tasks.c **** 		}
 629:Source/tasks.c **** 
 630:Source/tasks.c **** 		return xReturn;
 631:Source/tasks.c **** 	}
 632:Source/tasks.c **** 
 633:Source/tasks.c **** #endif /* SUPPORT_STATIC_ALLOCATION */
 634:Source/tasks.c **** /*-----------------------------------------------------------*/
 635:Source/tasks.c **** 
 636:Source/tasks.c **** #if( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
 637:Source/tasks.c **** 
 638:Source/tasks.c **** 	BaseType_t xTaskCreateRestrictedStatic( const TaskParameters_t * const pxTaskDefinition, TaskHandl
 639:Source/tasks.c **** 	{
 640:Source/tasks.c **** 	TCB_t *pxNewTCB;
 641:Source/tasks.c **** 	BaseType_t xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 642:Source/tasks.c **** 
 643:Source/tasks.c **** 		configASSERT( pxTaskDefinition->puxStackBuffer != NULL );
 644:Source/tasks.c **** 		configASSERT( pxTaskDefinition->pxTaskBuffer != NULL );
 645:Source/tasks.c **** 
 646:Source/tasks.c **** 		if( ( pxTaskDefinition->puxStackBuffer != NULL ) && ( pxTaskDefinition->pxTaskBuffer != NULL ) )
 647:Source/tasks.c **** 		{
 648:Source/tasks.c **** 			/* Allocate space for the TCB.  Where the memory comes from depends
 649:Source/tasks.c **** 			on the implementation of the port malloc function and whether or
 650:Source/tasks.c **** 			not static allocation is being used. */
 651:Source/tasks.c **** 			pxNewTCB = ( TCB_t * ) pxTaskDefinition->pxTaskBuffer;
 652:Source/tasks.c **** 
 653:Source/tasks.c **** 			/* Store the stack location in the TCB. */
 654:Source/tasks.c **** 			pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;
 655:Source/tasks.c **** 
 656:Source/tasks.c **** 			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
 657:Source/tasks.c **** 			{
 658:Source/tasks.c **** 				/* Tasks can be created statically or dynamically, so note this
 659:Source/tasks.c **** 				task was created statically in case the task is later deleted. */
 660:Source/tasks.c **** 				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 661:Source/tasks.c **** 			}
 662:Source/tasks.c **** 			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */
 663:Source/tasks.c **** 
 664:Source/tasks.c **** 			prvInitialiseNewTask(	pxTaskDefinition->pvTaskCode,
 665:Source/tasks.c **** 									pxTaskDefinition->pcName,
 666:Source/tasks.c **** 									( uint32_t ) pxTaskDefinition->usStackDepth,
 667:Source/tasks.c **** 									pxTaskDefinition->pvParameters,
 668:Source/tasks.c **** 									pxTaskDefinition->uxPriority,
 669:Source/tasks.c **** 									pxCreatedTask, pxNewTCB,
 670:Source/tasks.c **** 									pxTaskDefinition->xRegions );
 671:Source/tasks.c **** 
 672:Source/tasks.c **** 			prvAddNewTaskToReadyList( pxNewTCB );
 673:Source/tasks.c **** 			xReturn = pdPASS;
 674:Source/tasks.c **** 		}
 675:Source/tasks.c **** 
 676:Source/tasks.c **** 		return xReturn;
 677:Source/tasks.c **** 	}
 678:Source/tasks.c **** 
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 15
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 15
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 679:Source/tasks.c **** #endif /* ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
 680:Source/tasks.c **** /*-----------------------------------------------------------*/
 681:Source/tasks.c **** 
 682:Source/tasks.c **** #if( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 683:Source/tasks.c **** 
 684:Source/tasks.c **** 	BaseType_t xTaskCreateRestricted( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *p
 685:Source/tasks.c **** 	{
 686:Source/tasks.c **** 	TCB_t *pxNewTCB;
 687:Source/tasks.c **** 	BaseType_t xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 688:Source/tasks.c **** 
 689:Source/tasks.c **** 		configASSERT( pxTaskDefinition->puxStackBuffer );
 690:Source/tasks.c **** 
 691:Source/tasks.c **** 		if( pxTaskDefinition->puxStackBuffer != NULL )
 692:Source/tasks.c **** 		{
 693:Source/tasks.c **** 			/* Allocate space for the TCB.  Where the memory comes from depends
 694:Source/tasks.c **** 			on the implementation of the port malloc function and whether or
 695:Source/tasks.c **** 			not static allocation is being used. */
 696:Source/tasks.c **** 			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
 697:Source/tasks.c **** 
 698:Source/tasks.c **** 			if( pxNewTCB != NULL )
 699:Source/tasks.c **** 			{
 700:Source/tasks.c **** 				/* Store the stack location in the TCB. */
 701:Source/tasks.c **** 				pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;
 702:Source/tasks.c **** 
 703:Source/tasks.c **** 				#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
 704:Source/tasks.c **** 				{
 705:Source/tasks.c **** 					/* Tasks can be created statically or dynamically, so note
 706:Source/tasks.c **** 					this task had a statically allocated stack in case it is
 707:Source/tasks.c **** 					later deleted.  The TCB was allocated dynamically. */
 708:Source/tasks.c **** 					pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_ONLY;
 709:Source/tasks.c **** 				}
 710:Source/tasks.c **** 				#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */
 711:Source/tasks.c **** 
 712:Source/tasks.c **** 				prvInitialiseNewTask(	pxTaskDefinition->pvTaskCode,
 713:Source/tasks.c **** 										pxTaskDefinition->pcName,
 714:Source/tasks.c **** 										( uint32_t ) pxTaskDefinition->usStackDepth,
 715:Source/tasks.c **** 										pxTaskDefinition->pvParameters,
 716:Source/tasks.c **** 										pxTaskDefinition->uxPriority,
 717:Source/tasks.c **** 										pxCreatedTask, pxNewTCB,
 718:Source/tasks.c **** 										pxTaskDefinition->xRegions );
 719:Source/tasks.c **** 
 720:Source/tasks.c **** 				prvAddNewTaskToReadyList( pxNewTCB );
 721:Source/tasks.c **** 				xReturn = pdPASS;
 722:Source/tasks.c **** 			}
 723:Source/tasks.c **** 		}
 724:Source/tasks.c **** 
 725:Source/tasks.c **** 		return xReturn;
 726:Source/tasks.c **** 	}
 727:Source/tasks.c **** 
 728:Source/tasks.c **** #endif /* portUSING_MPU_WRAPPERS */
 729:Source/tasks.c **** /*-----------------------------------------------------------*/
 730:Source/tasks.c **** 
 731:Source/tasks.c **** #if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 732:Source/tasks.c **** 
 733:Source/tasks.c **** 	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
 734:Source/tasks.c **** 							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and 
 735:Source/tasks.c **** 							const configSTACK_DEPTH_TYPE usStackDepth,
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 16
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 16
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 736:Source/tasks.c **** 							void * const pvParameters,
 737:Source/tasks.c **** 							UBaseType_t uxPriority,
 738:Source/tasks.c **** 							TaskHandle_t * const pxCreatedTask )
 739:Source/tasks.c **** 	{
  97              		.loc 1 739 0
  98              		.cfi_startproc
  99              		@ args = 8, pretend = 0, frame = 32
 100              		@ frame_needed = 1, uses_anonymous_args = 0
 101 0000 80B5     		push	{r7, lr}
 102              		.cfi_def_cfa_offset 8
 103              		.cfi_offset 7, -8
 104              		.cfi_offset 14, -4
 105 0002 8CB0     		sub	sp, sp, #48
 106              		.cfi_def_cfa_offset 56
 107 0004 04AF     		add	r7, sp, #16
 108              		.cfi_def_cfa 7, 40
 109 0006 F860     		str	r0, [r7, #12]
 110 0008 B960     		str	r1, [r7, #8]
 111 000a 3B60     		str	r3, [r7]
 112 000c 1346     		mov	r3, r2	@ movhi
 113 000e FB80     		strh	r3, [r7, #6]	@ movhi
 114              	.LBB27:
 740:Source/tasks.c **** 	TCB_t *pxNewTCB;
 741:Source/tasks.c **** 	BaseType_t xReturn;
 742:Source/tasks.c **** 
 743:Source/tasks.c **** 		/* If the stack grows down then allocate the stack then the TCB so the stack
 744:Source/tasks.c **** 		does not grow into the TCB.  Likewise if the stack grows up then allocate
 745:Source/tasks.c **** 		the TCB then the stack. */
 746:Source/tasks.c **** 		#if( portSTACK_GROWTH > 0 )
 747:Source/tasks.c **** 		{
 748:Source/tasks.c **** 			/* Allocate space for the TCB.  Where the memory comes from depends on
 749:Source/tasks.c **** 			the implementation of the port malloc function and whether or not static
 750:Source/tasks.c **** 			allocation is being used. */
 751:Source/tasks.c **** 			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
 752:Source/tasks.c **** 
 753:Source/tasks.c **** 			if( pxNewTCB != NULL )
 754:Source/tasks.c **** 			{
 755:Source/tasks.c **** 				/* Allocate space for the stack used by the task being created.
 756:Source/tasks.c **** 				The base of the stack memory stored in the TCB so the task can
 757:Source/tasks.c **** 				be deleted later if required. */
 758:Source/tasks.c **** 				pxNewTCB->pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( Sta
 759:Source/tasks.c **** 
 760:Source/tasks.c **** 				if( pxNewTCB->pxStack == NULL )
 761:Source/tasks.c **** 				{
 762:Source/tasks.c **** 					/* Could not allocate the stack.  Delete the allocated TCB. */
 763:Source/tasks.c **** 					vPortFree( pxNewTCB );
 764:Source/tasks.c **** 					pxNewTCB = NULL;
 765:Source/tasks.c **** 				}
 766:Source/tasks.c **** 			}
 767:Source/tasks.c **** 		}
 768:Source/tasks.c **** 		#else /* portSTACK_GROWTH */
 769:Source/tasks.c **** 		{
 770:Source/tasks.c **** 		StackType_t *pxStack;
 771:Source/tasks.c **** 
 772:Source/tasks.c **** 			/* Allocate space for the stack used by the task being created. */
 773:Source/tasks.c **** 			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079
 115              		.loc 1 773 0
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 17
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 17
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 116 0010 FB88     		ldrh	r3, [r7, #6]
 117 0012 9B00     		lsls	r3, r3, #2
 118 0014 1846     		mov	r0, r3
 119 0016 FFF7FEFF 		bl	pvPortMalloc
 120 001a 7861     		str	r0, [r7, #20]
 774:Source/tasks.c **** 
 775:Source/tasks.c **** 			if( pxStack != NULL )
 121              		.loc 1 775 0
 122 001c 7B69     		ldr	r3, [r7, #20]
 123 001e 002B     		cmp	r3, #0
 124 0020 0ED0     		beq	.L2
 776:Source/tasks.c **** 			{
 777:Source/tasks.c **** 				/* Allocate space for the TCB. */
 778:Source/tasks.c **** 				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returne
 125              		.loc 1 778 0
 126 0022 5020     		movs	r0, #80
 127 0024 FFF7FEFF 		bl	pvPortMalloc
 128 0028 F861     		str	r0, [r7, #28]
 779:Source/tasks.c **** 
 780:Source/tasks.c **** 				if( pxNewTCB != NULL )
 129              		.loc 1 780 0
 130 002a FB69     		ldr	r3, [r7, #28]
 131 002c 002B     		cmp	r3, #0
 132 002e 03D0     		beq	.L3
 781:Source/tasks.c **** 				{
 782:Source/tasks.c **** 					/* Store the stack location in the TCB. */
 783:Source/tasks.c **** 					pxNewTCB->pxStack = pxStack;
 133              		.loc 1 783 0
 134 0030 FB69     		ldr	r3, [r7, #28]
 135 0032 7A69     		ldr	r2, [r7, #20]
 136 0034 1A63     		str	r2, [r3, #48]
 137 0036 05E0     		b	.L5
 138              	.L3:
 784:Source/tasks.c **** 				}
 785:Source/tasks.c **** 				else
 786:Source/tasks.c **** 				{
 787:Source/tasks.c **** 					/* The stack cannot be used as the TCB was not created.  Free
 788:Source/tasks.c **** 					it again. */
 789:Source/tasks.c **** 					vPortFree( pxStack );
 139              		.loc 1 789 0
 140 0038 7869     		ldr	r0, [r7, #20]
 141 003a FFF7FEFF 		bl	vPortFree
 142 003e 01E0     		b	.L5
 143              	.L2:
 790:Source/tasks.c **** 				}
 791:Source/tasks.c **** 			}
 792:Source/tasks.c **** 			else
 793:Source/tasks.c **** 			{
 794:Source/tasks.c **** 				pxNewTCB = NULL;
 144              		.loc 1 794 0
 145 0040 0023     		movs	r3, #0
 146 0042 FB61     		str	r3, [r7, #28]
 147              	.L5:
 148              	.LBE27:
 795:Source/tasks.c **** 			}
 796:Source/tasks.c **** 		}
 797:Source/tasks.c **** 		#endif /* portSTACK_GROWTH */
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 18
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 18
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 798:Source/tasks.c **** 
 799:Source/tasks.c **** 		if( pxNewTCB != NULL )
 149              		.loc 1 799 0
 150 0044 FB69     		ldr	r3, [r7, #28]
 151 0046 002B     		cmp	r3, #0
 152 0048 13D0     		beq	.L6
 800:Source/tasks.c **** 		{
 801:Source/tasks.c **** 			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e9029 !e731 Macro has been consoli
 802:Source/tasks.c **** 			{
 803:Source/tasks.c **** 				/* Tasks can be created statically or dynamically, so note this
 804:Source/tasks.c **** 				task was created dynamically in case it is later deleted. */
 805:Source/tasks.c **** 				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
 806:Source/tasks.c **** 			}
 807:Source/tasks.c **** 			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */
 808:Source/tasks.c **** 
 809:Source/tasks.c **** 			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, p
 153              		.loc 1 809 0
 154 004a FA88     		ldrh	r2, [r7, #6]
 155 004c 0023     		movs	r3, #0
 156 004e 0393     		str	r3, [sp, #12]
 157 0050 FB69     		ldr	r3, [r7, #28]
 158 0052 0293     		str	r3, [sp, #8]
 159 0054 FB6A     		ldr	r3, [r7, #44]
 160 0056 0193     		str	r3, [sp, #4]
 161 0058 BB6A     		ldr	r3, [r7, #40]
 162 005a 0093     		str	r3, [sp]
 163 005c 3B68     		ldr	r3, [r7]
 164 005e B968     		ldr	r1, [r7, #8]
 165 0060 F868     		ldr	r0, [r7, #12]
 166 0062 FFF7FEFF 		bl	prvInitialiseNewTask
 810:Source/tasks.c **** 			prvAddNewTaskToReadyList( pxNewTCB );
 167              		.loc 1 810 0
 168 0066 F869     		ldr	r0, [r7, #28]
 169 0068 FFF7FEFF 		bl	prvAddNewTaskToReadyList
 811:Source/tasks.c **** 			xReturn = pdPASS;
 170              		.loc 1 811 0
 171 006c 0123     		movs	r3, #1
 172 006e BB61     		str	r3, [r7, #24]
 173 0070 02E0     		b	.L7
 174              	.L6:
 812:Source/tasks.c **** 		}
 813:Source/tasks.c **** 		else
 814:Source/tasks.c **** 		{
 815:Source/tasks.c **** 			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 175              		.loc 1 815 0
 176 0072 4FF0FF33 		mov	r3, #-1
 177 0076 BB61     		str	r3, [r7, #24]
 178              	.L7:
 816:Source/tasks.c **** 		}
 817:Source/tasks.c **** 
 818:Source/tasks.c **** 		return xReturn;
 179              		.loc 1 818 0
 180 0078 BB69     		ldr	r3, [r7, #24]
 819:Source/tasks.c **** 	}
 181              		.loc 1 819 0
 182 007a 1846     		mov	r0, r3
 183 007c 2037     		adds	r7, r7, #32
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 19
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 19
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 184              		.cfi_def_cfa_offset 8
 185 007e BD46     		mov	sp, r7
 186              		.cfi_def_cfa_register 13
 187              		@ sp needed
 188 0080 80BD     		pop	{r7, pc}
 189              		.cfi_endproc
 190              	.LFE68:
 191              		.size	xTaskCreate, .-xTaskCreate
 192 0082 00BF     		.section	.text.prvInitialiseNewTask,"ax",%progbits
 193              		.align	2
 194              		.thumb
 195              		.thumb_func
 196              		.type	prvInitialiseNewTask, %function
 197              	prvInitialiseNewTask:
 198              	.LFB69:
 820:Source/tasks.c **** 
 821:Source/tasks.c **** #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
 822:Source/tasks.c **** /*-----------------------------------------------------------*/
 823:Source/tasks.c **** 
 824:Source/tasks.c **** static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
 825:Source/tasks.c **** 									const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings an
 826:Source/tasks.c **** 									const uint32_t ulStackDepth,
 827:Source/tasks.c **** 									void * const pvParameters,
 828:Source/tasks.c **** 									UBaseType_t uxPriority,
 829:Source/tasks.c **** 									TaskHandle_t * const pxCreatedTask,
 830:Source/tasks.c **** 									TCB_t *pxNewTCB,
 831:Source/tasks.c **** 									const MemoryRegion_t * const xRegions )
 832:Source/tasks.c **** {
 199              		.loc 1 832 0
 200              		.cfi_startproc
 201              		@ args = 16, pretend = 0, frame = 24
 202              		@ frame_needed = 1, uses_anonymous_args = 0
 203 0000 80B5     		push	{r7, lr}
 204              		.cfi_def_cfa_offset 8
 205              		.cfi_offset 7, -8
 206              		.cfi_offset 14, -4
 207 0002 86B0     		sub	sp, sp, #24
 208              		.cfi_def_cfa_offset 32
 209 0004 00AF     		add	r7, sp, #0
 210              		.cfi_def_cfa_register 7
 211 0006 F860     		str	r0, [r7, #12]
 212 0008 B960     		str	r1, [r7, #8]
 213 000a 7A60     		str	r2, [r7, #4]
 214 000c 3B60     		str	r3, [r7]
 833:Source/tasks.c **** StackType_t *pxTopOfStack;
 834:Source/tasks.c **** UBaseType_t x;
 835:Source/tasks.c **** 
 836:Source/tasks.c **** 	#if( portUSING_MPU_WRAPPERS == 1 )
 837:Source/tasks.c **** 		/* Should the task be created in privileged mode? */
 838:Source/tasks.c **** 		BaseType_t xRunPrivileged;
 839:Source/tasks.c **** 		if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
 840:Source/tasks.c **** 		{
 841:Source/tasks.c **** 			xRunPrivileged = pdTRUE;
 842:Source/tasks.c **** 		}
 843:Source/tasks.c **** 		else
 844:Source/tasks.c **** 		{
 845:Source/tasks.c **** 			xRunPrivileged = pdFALSE;
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 20
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 20
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 846:Source/tasks.c **** 		}
 847:Source/tasks.c **** 		uxPriority &= ~portPRIVILEGE_BIT;
 848:Source/tasks.c **** 	#endif /* portUSING_MPU_WRAPPERS == 1 */
 849:Source/tasks.c **** 
 850:Source/tasks.c **** 	/* Avoid dependency on memset() if it is not required. */
 851:Source/tasks.c **** 	#if( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
 852:Source/tasks.c **** 	{
 853:Source/tasks.c **** 		/* Fill the stack with a known value to assist debugging. */
 854:Source/tasks.c **** 		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof(
 215              		.loc 1 854 0
 216 000e BB6A     		ldr	r3, [r7, #40]
 217 0010 186B     		ldr	r0, [r3, #48]
 218 0012 7B68     		ldr	r3, [r7, #4]
 219 0014 9B00     		lsls	r3, r3, #2
 220 0016 1A46     		mov	r2, r3
 221 0018 A521     		movs	r1, #165
 222 001a FFF7FEFF 		bl	memset
 855:Source/tasks.c **** 	}
 856:Source/tasks.c **** 	#endif /* tskSET_NEW_STACKS_TO_KNOWN_VALUE */
 857:Source/tasks.c **** 
 858:Source/tasks.c **** 	/* Calculate the top of stack address.  This depends on whether the stack
 859:Source/tasks.c **** 	grows from high memory to low (as per the 80x86) or vice versa.
 860:Source/tasks.c **** 	portSTACK_GROWTH is used to make the result positive or negative as required
 861:Source/tasks.c **** 	by the port. */
 862:Source/tasks.c **** 	#if( portSTACK_GROWTH < 0 )
 863:Source/tasks.c **** 	{
 864:Source/tasks.c **** 		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 223              		.loc 1 864 0
 224 001e BB6A     		ldr	r3, [r7, #40]
 225 0020 1A6B     		ldr	r2, [r3, #48]
 226 0022 7B68     		ldr	r3, [r7, #4]
 227 0024 03F18043 		add	r3, r3, #1073741824
 228 0028 013B     		subs	r3, r3, #1
 229 002a 9B00     		lsls	r3, r3, #2
 230 002c 1344     		add	r3, r3, r2
 231 002e 3B61     		str	r3, [r7, #16]
 865:Source/tasks.c **** 		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTE
 232              		.loc 1 865 0
 233 0030 3B69     		ldr	r3, [r7, #16]
 234 0032 23F00703 		bic	r3, r3, #7
 235 0036 3B61     		str	r3, [r7, #16]
 866:Source/tasks.c **** 
 867:Source/tasks.c **** 		/* Check the alignment of the calculated top of stack is correct. */
 868:Source/tasks.c **** 		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALI
 869:Source/tasks.c **** 
 870:Source/tasks.c **** 		#if( configRECORD_STACK_HIGH_ADDRESS == 1 )
 871:Source/tasks.c **** 		{
 872:Source/tasks.c **** 			/* Also record the stack's high address, which may assist
 873:Source/tasks.c **** 			debugging. */
 874:Source/tasks.c **** 			pxNewTCB->pxEndOfStack = pxTopOfStack;
 875:Source/tasks.c **** 		}
 876:Source/tasks.c **** 		#endif /* configRECORD_STACK_HIGH_ADDRESS */
 877:Source/tasks.c **** 	}
 878:Source/tasks.c **** 	#else /* portSTACK_GROWTH */
 879:Source/tasks.c **** 	{
 880:Source/tasks.c **** 		pxTopOfStack = pxNewTCB->pxStack;
 881:Source/tasks.c **** 
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 21
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 21
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 882:Source/tasks.c **** 		/* Check the alignment of the stack buffer is correct. */
 883:Source/tasks.c **** 		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB->pxStack & ( portPOINTER_SIZE_TYPE ) portBYT
 884:Source/tasks.c **** 
 885:Source/tasks.c **** 		/* The other extreme of the stack space is required if stack checking is
 886:Source/tasks.c **** 		performed. */
 887:Source/tasks.c **** 		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 888:Source/tasks.c **** 	}
 889:Source/tasks.c **** 	#endif /* portSTACK_GROWTH */
 890:Source/tasks.c **** 
 891:Source/tasks.c **** 	/* Store the task name in the TCB. */
 892:Source/tasks.c **** 	if( pcName != NULL )
 236              		.loc 1 892 0
 237 0038 BB68     		ldr	r3, [r7, #8]
 238 003a 002B     		cmp	r3, #0
 239 003c 1FD0     		beq	.L10
 893:Source/tasks.c **** 	{
 894:Source/tasks.c **** 		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 240              		.loc 1 894 0
 241 003e 0023     		movs	r3, #0
 242 0040 7B61     		str	r3, [r7, #20]
 243 0042 12E0     		b	.L11
 244              	.L14:
 895:Source/tasks.c **** 		{
 896:Source/tasks.c **** 			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 245              		.loc 1 896 0
 246 0044 BA68     		ldr	r2, [r7, #8]
 247 0046 7B69     		ldr	r3, [r7, #20]
 248 0048 1344     		add	r3, r3, r2
 249 004a 1978     		ldrb	r1, [r3]	@ zero_extendqisi2
 250 004c BA6A     		ldr	r2, [r7, #40]
 251 004e 7B69     		ldr	r3, [r7, #20]
 252 0050 1344     		add	r3, r3, r2
 253 0052 3433     		adds	r3, r3, #52
 254 0054 0A46     		mov	r2, r1
 255 0056 1A70     		strb	r2, [r3]
 897:Source/tasks.c **** 
 898:Source/tasks.c **** 			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
 899:Source/tasks.c **** 			configMAX_TASK_NAME_LEN characters just in case the memory after the
 900:Source/tasks.c **** 			string is not accessible (extremely unlikely). */
 901:Source/tasks.c **** 			if( pcName[ x ] == ( char ) 0x00 )
 256              		.loc 1 901 0
 257 0058 BA68     		ldr	r2, [r7, #8]
 258 005a 7B69     		ldr	r3, [r7, #20]
 259 005c 1344     		add	r3, r3, r2
 260 005e 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 261 0060 002B     		cmp	r3, #0
 262 0062 06D0     		beq	.L18
 894:Source/tasks.c **** 		{
 263              		.loc 1 894 0 discriminator 2
 264 0064 7B69     		ldr	r3, [r7, #20]
 265 0066 0133     		adds	r3, r3, #1
 266 0068 7B61     		str	r3, [r7, #20]
 267              	.L11:
 894:Source/tasks.c **** 		{
 268              		.loc 1 894 0 is_stmt 0 discriminator 1
 269 006a 7B69     		ldr	r3, [r7, #20]
 270 006c 0B2B     		cmp	r3, #11
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 22
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 22
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 271 006e E9D9     		bls	.L14
 272 0070 00E0     		b	.L13
 273              	.L18:
 902:Source/tasks.c **** 			{
 903:Source/tasks.c **** 				break;
 274              		.loc 1 903 0 is_stmt 1
 275 0072 00BF     		nop
 276              	.L13:
 904:Source/tasks.c **** 			}
 905:Source/tasks.c **** 			else
 906:Source/tasks.c **** 			{
 907:Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
 908:Source/tasks.c **** 			}
 909:Source/tasks.c **** 		}
 910:Source/tasks.c **** 
 911:Source/tasks.c **** 		/* Ensure the name string is terminated in the case that the string length
 912:Source/tasks.c **** 		was greater or equal to configMAX_TASK_NAME_LEN. */
 913:Source/tasks.c **** 		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 277              		.loc 1 913 0
 278 0074 BB6A     		ldr	r3, [r7, #40]
 279 0076 0022     		movs	r2, #0
 280 0078 83F83F20 		strb	r2, [r3, #63]
 281 007c 03E0     		b	.L15
 282              	.L10:
 914:Source/tasks.c **** 	}
 915:Source/tasks.c **** 	else
 916:Source/tasks.c **** 	{
 917:Source/tasks.c **** 		/* The task has not been given a name, so just ensure there is a NULL
 918:Source/tasks.c **** 		terminator when it is read out. */
 919:Source/tasks.c **** 		pxNewTCB->pcTaskName[ 0 ] = 0x00;
 283              		.loc 1 919 0
 284 007e BB6A     		ldr	r3, [r7, #40]
 285 0080 0022     		movs	r2, #0
 286 0082 83F83420 		strb	r2, [r3, #52]
 287              	.L15:
 920:Source/tasks.c **** 	}
 921:Source/tasks.c **** 
 922:Source/tasks.c **** 	/* This is used as an array index so must ensure it's not too large.  First
 923:Source/tasks.c **** 	remove the privilege bit if one is present. */
 924:Source/tasks.c **** 	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 288              		.loc 1 924 0
 289 0086 3B6A     		ldr	r3, [r7, #32]
 290 0088 042B     		cmp	r3, #4
 291 008a 01D9     		bls	.L16
 925:Source/tasks.c **** 	{
 926:Source/tasks.c **** 		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 292              		.loc 1 926 0
 293 008c 0423     		movs	r3, #4
 294 008e 3B62     		str	r3, [r7, #32]
 295              	.L16:
 927:Source/tasks.c **** 	}
 928:Source/tasks.c **** 	else
 929:Source/tasks.c **** 	{
 930:Source/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
 931:Source/tasks.c **** 	}
 932:Source/tasks.c **** 
 933:Source/tasks.c **** 	pxNewTCB->uxPriority = uxPriority;
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 23
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 23
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 296              		.loc 1 933 0
 297 0090 BB6A     		ldr	r3, [r7, #40]
 298 0092 3A6A     		ldr	r2, [r7, #32]
 299 0094 DA62     		str	r2, [r3, #44]
 934:Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 935:Source/tasks.c **** 	{
 936:Source/tasks.c **** 		pxNewTCB->uxBasePriority = uxPriority;
 300              		.loc 1 936 0
 301 0096 BB6A     		ldr	r3, [r7, #40]
 302 0098 3A6A     		ldr	r2, [r7, #32]
 303 009a 1A64     		str	r2, [r3, #64]
 937:Source/tasks.c **** 		pxNewTCB->uxMutexesHeld = 0;
 304              		.loc 1 937 0
 305 009c BB6A     		ldr	r3, [r7, #40]
 306 009e 0022     		movs	r2, #0
 307 00a0 5A64     		str	r2, [r3, #68]
 938:Source/tasks.c **** 	}
 939:Source/tasks.c **** 	#endif /* configUSE_MUTEXES */
 940:Source/tasks.c **** 
 941:Source/tasks.c **** 	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 308              		.loc 1 941 0
 309 00a2 BB6A     		ldr	r3, [r7, #40]
 310 00a4 0433     		adds	r3, r3, #4
 311 00a6 1846     		mov	r0, r3
 312 00a8 FFF7FEFF 		bl	vListInitialiseItem
 942:Source/tasks.c **** 	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 313              		.loc 1 942 0
 314 00ac BB6A     		ldr	r3, [r7, #40]
 315 00ae 1833     		adds	r3, r3, #24
 316 00b0 1846     		mov	r0, r3
 317 00b2 FFF7FEFF 		bl	vListInitialiseItem
 943:Source/tasks.c **** 
 944:Source/tasks.c **** 	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
 945:Source/tasks.c **** 	back to	the containing TCB from a generic item in a list. */
 946:Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 318              		.loc 1 946 0
 319 00b6 BB6A     		ldr	r3, [r7, #40]
 320 00b8 BA6A     		ldr	r2, [r7, #40]
 321 00ba 1A61     		str	r2, [r3, #16]
 947:Source/tasks.c **** 
 948:Source/tasks.c **** 	/* Event lists are always in priority order. */
 949:Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( Ti
 322              		.loc 1 949 0
 323 00bc 3B6A     		ldr	r3, [r7, #32]
 324 00be C3F10502 		rsb	r2, r3, #5
 325 00c2 BB6A     		ldr	r3, [r7, #40]
 326 00c4 9A61     		str	r2, [r3, #24]
 950:Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 327              		.loc 1 950 0
 328 00c6 BB6A     		ldr	r3, [r7, #40]
 329 00c8 BA6A     		ldr	r2, [r7, #40]
 330 00ca 5A62     		str	r2, [r3, #36]
 951:Source/tasks.c **** 
 952:Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
 953:Source/tasks.c **** 	{
 954:Source/tasks.c **** 		pxNewTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
 955:Source/tasks.c **** 	}
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 24
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 24
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 956:Source/tasks.c **** 	#endif /* portCRITICAL_NESTING_IN_TCB */
 957:Source/tasks.c **** 
 958:Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
 959:Source/tasks.c **** 	{
 960:Source/tasks.c **** 		pxNewTCB->pxTaskTag = NULL;
 961:Source/tasks.c **** 	}
 962:Source/tasks.c **** 	#endif /* configUSE_APPLICATION_TASK_TAG */
 963:Source/tasks.c **** 
 964:Source/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
 965:Source/tasks.c **** 	{
 966:Source/tasks.c **** 		pxNewTCB->ulRunTimeCounter = 0UL;
 967:Source/tasks.c **** 	}
 968:Source/tasks.c **** 	#endif /* configGENERATE_RUN_TIME_STATS */
 969:Source/tasks.c **** 
 970:Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
 971:Source/tasks.c **** 	{
 972:Source/tasks.c **** 		vPortStoreTaskMPUSettings( &( pxNewTCB->xMPUSettings ), xRegions, pxNewTCB->pxStack, ulStackDepth
 973:Source/tasks.c **** 	}
 974:Source/tasks.c **** 	#else
 975:Source/tasks.c **** 	{
 976:Source/tasks.c **** 		/* Avoid compiler warning about unreferenced parameter. */
 977:Source/tasks.c **** 		( void ) xRegions;
 978:Source/tasks.c **** 	}
 979:Source/tasks.c **** 	#endif
 980:Source/tasks.c **** 
 981:Source/tasks.c **** 	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
 982:Source/tasks.c **** 	{
 983:Source/tasks.c **** 		for( x = 0; x < ( UBaseType_t ) configNUM_THREAD_LOCAL_STORAGE_POINTERS; x++ )
 984:Source/tasks.c **** 		{
 985:Source/tasks.c **** 			pxNewTCB->pvThreadLocalStoragePointers[ x ] = NULL;
 986:Source/tasks.c **** 		}
 987:Source/tasks.c **** 	}
 988:Source/tasks.c **** 	#endif
 989:Source/tasks.c **** 
 990:Source/tasks.c **** 	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
 991:Source/tasks.c **** 	{
 992:Source/tasks.c **** 		pxNewTCB->ulNotifiedValue = 0;
 331              		.loc 1 992 0
 332 00cc BB6A     		ldr	r3, [r7, #40]
 333 00ce 0022     		movs	r2, #0
 334 00d0 9A64     		str	r2, [r3, #72]
 993:Source/tasks.c **** 		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 335              		.loc 1 993 0
 336 00d2 BB6A     		ldr	r3, [r7, #40]
 337 00d4 0022     		movs	r2, #0
 338 00d6 83F84C20 		strb	r2, [r3, #76]
 994:Source/tasks.c **** 	}
 995:Source/tasks.c **** 	#endif
 996:Source/tasks.c **** 
 997:Source/tasks.c **** 	#if ( configUSE_NEWLIB_REENTRANT == 1 )
 998:Source/tasks.c **** 	{
 999:Source/tasks.c **** 		/* Initialise this task's Newlib reent structure.
1000:Source/tasks.c **** 		See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html
1001:Source/tasks.c **** 		for additional information. */
1002:Source/tasks.c **** 		_REENT_INIT_PTR( ( &( pxNewTCB->xNewLib_reent ) ) );
1003:Source/tasks.c **** 	}
1004:Source/tasks.c **** 	#endif
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 25
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 25
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


1005:Source/tasks.c **** 
1006:Source/tasks.c **** 	#if( INCLUDE_xTaskAbortDelay == 1 )
1007:Source/tasks.c **** 	{
1008:Source/tasks.c **** 		pxNewTCB->ucDelayAborted = pdFALSE;
1009:Source/tasks.c **** 	}
1010:Source/tasks.c **** 	#endif
1011:Source/tasks.c **** 
1012:Source/tasks.c **** 	/* Initialize the TCB stack to look as if the task was already running,
1013:Source/tasks.c **** 	but had been interrupted by the scheduler.  The return address is set
1014:Source/tasks.c **** 	to the start of the task function. Once the stack has been initialised
1015:Source/tasks.c **** 	the top of stack variable is updated. */
1016:Source/tasks.c **** 	#if( portUSING_MPU_WRAPPERS == 1 )
1017:Source/tasks.c **** 	{
1018:Source/tasks.c **** 		/* If the port has capability to detect stack overflow,
1019:Source/tasks.c **** 		pass the stack end address to the stack initialization
1020:Source/tasks.c **** 		function as well. */
1021:Source/tasks.c **** 		#if( portHAS_STACK_OVERFLOW_CHECKING == 1 )
1022:Source/tasks.c **** 		{
1023:Source/tasks.c **** 			#if( portSTACK_GROWTH < 0 )
1024:Source/tasks.c **** 			{
1025:Source/tasks.c **** 				pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB->pxStack, pxTaskCode, pv
1026:Source/tasks.c **** 			}
1027:Source/tasks.c **** 			#else /* portSTACK_GROWTH */
1028:Source/tasks.c **** 			{
1029:Source/tasks.c **** 				pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB->pxEndOfStack, pxTaskCod
1030:Source/tasks.c **** 			}
1031:Source/tasks.c **** 			#endif /* portSTACK_GROWTH */
1032:Source/tasks.c **** 		}
1033:Source/tasks.c **** 		#else /* portHAS_STACK_OVERFLOW_CHECKING */
1034:Source/tasks.c **** 		{
1035:Source/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPriv
1036:Source/tasks.c **** 		}
1037:Source/tasks.c **** 		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
1038:Source/tasks.c **** 	}
1039:Source/tasks.c **** 	#else /* portUSING_MPU_WRAPPERS */
1040:Source/tasks.c **** 	{
1041:Source/tasks.c **** 		/* If the port has capability to detect stack overflow,
1042:Source/tasks.c **** 		pass the stack end address to the stack initialization
1043:Source/tasks.c **** 		function as well. */
1044:Source/tasks.c **** 		#if( portHAS_STACK_OVERFLOW_CHECKING == 1 )
1045:Source/tasks.c **** 		{
1046:Source/tasks.c **** 			#if( portSTACK_GROWTH < 0 )
1047:Source/tasks.c **** 			{
1048:Source/tasks.c **** 				pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB->pxStack, pxTaskCode, pv
1049:Source/tasks.c **** 			}
1050:Source/tasks.c **** 			#else /* portSTACK_GROWTH */
1051:Source/tasks.c **** 			{
1052:Source/tasks.c **** 				pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB->pxEndOfStack, pxTaskCod
1053:Source/tasks.c **** 			}
1054:Source/tasks.c **** 			#endif /* portSTACK_GROWTH */
1055:Source/tasks.c **** 		}
1056:Source/tasks.c **** 		#else /* portHAS_STACK_OVERFLOW_CHECKING */
1057:Source/tasks.c **** 		{
1058:Source/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 339              		.loc 1 1058 0
 340 00da 3A68     		ldr	r2, [r7]
 341 00dc F968     		ldr	r1, [r7, #12]
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 26
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 26
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 342 00de 3869     		ldr	r0, [r7, #16]
 343 00e0 FFF7FEFF 		bl	pxPortInitialiseStack
 344 00e4 0246     		mov	r2, r0
 345 00e6 BB6A     		ldr	r3, [r7, #40]
 346 00e8 1A60     		str	r2, [r3]
1059:Source/tasks.c **** 		}
1060:Source/tasks.c **** 		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
1061:Source/tasks.c **** 	}
1062:Source/tasks.c **** 	#endif /* portUSING_MPU_WRAPPERS */
1063:Source/tasks.c **** 
1064:Source/tasks.c **** 	if( pxCreatedTask != NULL )
 347              		.loc 1 1064 0
 348 00ea 7B6A     		ldr	r3, [r7, #36]
 349 00ec 002B     		cmp	r3, #0
 350 00ee 02D0     		beq	.L19
1065:Source/tasks.c **** 	{
1066:Source/tasks.c **** 		/* Pass the handle out in an anonymous way.  The handle can be used to
1067:Source/tasks.c **** 		change the created task's priority, delete the created task, etc.*/
1068:Source/tasks.c **** 		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 351              		.loc 1 1068 0
 352 00f0 7B6A     		ldr	r3, [r7, #36]
 353 00f2 BA6A     		ldr	r2, [r7, #40]
 354 00f4 1A60     		str	r2, [r3]
 355              	.L19:
1069:Source/tasks.c **** 	}
1070:Source/tasks.c **** 	else
1071:Source/tasks.c **** 	{
1072:Source/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
1073:Source/tasks.c **** 	}
1074:Source/tasks.c **** }
 356              		.loc 1 1074 0
 357 00f6 00BF     		nop
 358 00f8 1837     		adds	r7, r7, #24
 359              		.cfi_def_cfa_offset 8
 360 00fa BD46     		mov	sp, r7
 361              		.cfi_def_cfa_register 13
 362              		@ sp needed
 363 00fc 80BD     		pop	{r7, pc}
 364              		.cfi_endproc
 365              	.LFE69:
 366              		.size	prvInitialiseNewTask, .-prvInitialiseNewTask
 367 00fe 00BF     		.section	.text.prvAddNewTaskToReadyList,"ax",%progbits
 368              		.align	2
 369              		.thumb
 370              		.thumb_func
 371              		.type	prvAddNewTaskToReadyList, %function
 372              	prvAddNewTaskToReadyList:
 373              	.LFB70:
1075:Source/tasks.c **** /*-----------------------------------------------------------*/
1076:Source/tasks.c **** 
1077:Source/tasks.c **** static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
1078:Source/tasks.c **** {
 374              		.loc 1 1078 0
 375              		.cfi_startproc
 376              		@ args = 0, pretend = 0, frame = 8
 377              		@ frame_needed = 1, uses_anonymous_args = 0
 378 0000 80B5     		push	{r7, lr}
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 27
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 27
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 379              		.cfi_def_cfa_offset 8
 380              		.cfi_offset 7, -8
 381              		.cfi_offset 14, -4
 382 0002 82B0     		sub	sp, sp, #8
 383              		.cfi_def_cfa_offset 16
 384 0004 00AF     		add	r7, sp, #0
 385              		.cfi_def_cfa_register 7
 386 0006 7860     		str	r0, [r7, #4]
1079:Source/tasks.c **** 	/* Ensure interrupts don't access the task lists while the lists are being
1080:Source/tasks.c **** 	updated. */
1081:Source/tasks.c **** 	taskENTER_CRITICAL();
 387              		.loc 1 1081 0
 388 0008 FFF7FEFF 		bl	vPortEnterCritical
1082:Source/tasks.c **** 	{
1083:Source/tasks.c **** 		uxCurrentNumberOfTasks++;
 389              		.loc 1 1083 0
 390 000c 2A4B     		ldr	r3, .L25
 391 000e 1B68     		ldr	r3, [r3]
 392 0010 0133     		adds	r3, r3, #1
 393 0012 294A     		ldr	r2, .L25
 394 0014 1360     		str	r3, [r2]
1084:Source/tasks.c **** 		if( pxCurrentTCB == NULL )
 395              		.loc 1 1084 0
 396 0016 294B     		ldr	r3, .L25+4
 397 0018 1B68     		ldr	r3, [r3]
 398 001a 002B     		cmp	r3, #0
 399 001c 09D1     		bne	.L21
1085:Source/tasks.c **** 		{
1086:Source/tasks.c **** 			/* There are no other tasks, or all the other tasks are in
1087:Source/tasks.c **** 			the suspended state - make this the current task. */
1088:Source/tasks.c **** 			pxCurrentTCB = pxNewTCB;
 400              		.loc 1 1088 0
 401 001e 274A     		ldr	r2, .L25+4
 402 0020 7B68     		ldr	r3, [r7, #4]
 403 0022 1360     		str	r3, [r2]
1089:Source/tasks.c **** 
1090:Source/tasks.c **** 			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 404              		.loc 1 1090 0
 405 0024 244B     		ldr	r3, .L25
 406 0026 1B68     		ldr	r3, [r3]
 407 0028 012B     		cmp	r3, #1
 408 002a 10D1     		bne	.L22
1091:Source/tasks.c **** 			{
1092:Source/tasks.c **** 				/* This is the first task to be created so do the preliminary
1093:Source/tasks.c **** 				initialisation required.  We will not recover if this call
1094:Source/tasks.c **** 				fails, but we will report the failure. */
1095:Source/tasks.c **** 				prvInitialiseTaskLists();
 409              		.loc 1 1095 0
 410 002c FFF7FEFF 		bl	prvInitialiseTaskLists
 411 0030 0DE0     		b	.L22
 412              	.L21:
1096:Source/tasks.c **** 			}
1097:Source/tasks.c **** 			else
1098:Source/tasks.c **** 			{
1099:Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1100:Source/tasks.c **** 			}
1101:Source/tasks.c **** 		}
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 28
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 28
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


1102:Source/tasks.c **** 		else
1103:Source/tasks.c **** 		{
1104:Source/tasks.c **** 			/* If the scheduler is not already running, make this task the
1105:Source/tasks.c **** 			current task if it is the highest priority task to be created
1106:Source/tasks.c **** 			so far. */
1107:Source/tasks.c **** 			if( xSchedulerRunning == pdFALSE )
 413              		.loc 1 1107 0
 414 0032 234B     		ldr	r3, .L25+8
 415 0034 1B68     		ldr	r3, [r3]
 416 0036 002B     		cmp	r3, #0
 417 0038 09D1     		bne	.L22
1108:Source/tasks.c **** 			{
1109:Source/tasks.c **** 				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 418              		.loc 1 1109 0
 419 003a 204B     		ldr	r3, .L25+4
 420 003c 1B68     		ldr	r3, [r3]
 421 003e DA6A     		ldr	r2, [r3, #44]
 422 0040 7B68     		ldr	r3, [r7, #4]
 423 0042 DB6A     		ldr	r3, [r3, #44]
 424 0044 9A42     		cmp	r2, r3
 425 0046 02D8     		bhi	.L22
1110:Source/tasks.c **** 				{
1111:Source/tasks.c **** 					pxCurrentTCB = pxNewTCB;
 426              		.loc 1 1111 0
 427 0048 1C4A     		ldr	r2, .L25+4
 428 004a 7B68     		ldr	r3, [r7, #4]
 429 004c 1360     		str	r3, [r2]
 430              	.L22:
1112:Source/tasks.c **** 				}
1113:Source/tasks.c **** 				else
1114:Source/tasks.c **** 				{
1115:Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1116:Source/tasks.c **** 				}
1117:Source/tasks.c **** 			}
1118:Source/tasks.c **** 			else
1119:Source/tasks.c **** 			{
1120:Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1121:Source/tasks.c **** 			}
1122:Source/tasks.c **** 		}
1123:Source/tasks.c **** 
1124:Source/tasks.c **** 		uxTaskNumber++;
 431              		.loc 1 1124 0
 432 004e 1D4B     		ldr	r3, .L25+12
 433 0050 1B68     		ldr	r3, [r3]
 434 0052 0133     		adds	r3, r3, #1
 435 0054 1B4A     		ldr	r2, .L25+12
 436 0056 1360     		str	r3, [r2]
1125:Source/tasks.c **** 
1126:Source/tasks.c **** 		#if ( configUSE_TRACE_FACILITY == 1 )
1127:Source/tasks.c **** 		{
1128:Source/tasks.c **** 			/* Add a counter into the TCB for tracing only. */
1129:Source/tasks.c **** 			pxNewTCB->uxTCBNumber = uxTaskNumber;
1130:Source/tasks.c **** 		}
1131:Source/tasks.c **** 		#endif /* configUSE_TRACE_FACILITY */
1132:Source/tasks.c **** 		traceTASK_CREATE( pxNewTCB );
1133:Source/tasks.c **** 
1134:Source/tasks.c **** 		prvAddTaskToReadyList( pxNewTCB );
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 29
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 29
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 437              		.loc 1 1134 0
 438 0058 7B68     		ldr	r3, [r7, #4]
 439 005a DB6A     		ldr	r3, [r3, #44]
 440 005c 0122     		movs	r2, #1
 441 005e 9A40     		lsls	r2, r2, r3
 442 0060 194B     		ldr	r3, .L25+16
 443 0062 1B68     		ldr	r3, [r3]
 444 0064 1343     		orrs	r3, r3, r2
 445 0066 184A     		ldr	r2, .L25+16
 446 0068 1360     		str	r3, [r2]
 447 006a 7B68     		ldr	r3, [r7, #4]
 448 006c DA6A     		ldr	r2, [r3, #44]
 449 006e 1346     		mov	r3, r2
 450 0070 9B00     		lsls	r3, r3, #2
 451 0072 1344     		add	r3, r3, r2
 452 0074 9B00     		lsls	r3, r3, #2
 453 0076 154A     		ldr	r2, .L25+20
 454 0078 1A44     		add	r2, r2, r3
 455 007a 7B68     		ldr	r3, [r7, #4]
 456 007c 0433     		adds	r3, r3, #4
 457 007e 1946     		mov	r1, r3
 458 0080 1046     		mov	r0, r2
 459 0082 FFF7FEFF 		bl	vListInsertEnd
1135:Source/tasks.c **** 
1136:Source/tasks.c **** 		portSETUP_TCB( pxNewTCB );
1137:Source/tasks.c **** 	}
1138:Source/tasks.c **** 	taskEXIT_CRITICAL();
 460              		.loc 1 1138 0
 461 0086 FFF7FEFF 		bl	vPortExitCritical
1139:Source/tasks.c **** 
1140:Source/tasks.c **** 	if( xSchedulerRunning != pdFALSE )
 462              		.loc 1 1140 0
 463 008a 0D4B     		ldr	r3, .L25+8
 464 008c 1B68     		ldr	r3, [r3]
 465 008e 002B     		cmp	r3, #0
 466 0090 0ED0     		beq	.L24
1141:Source/tasks.c **** 	{
1142:Source/tasks.c **** 		/* If the created task is of a higher priority than the current task
1143:Source/tasks.c **** 		then it should run now. */
1144:Source/tasks.c **** 		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 467              		.loc 1 1144 0
 468 0092 0A4B     		ldr	r3, .L25+4
 469 0094 1B68     		ldr	r3, [r3]
 470 0096 DA6A     		ldr	r2, [r3, #44]
 471 0098 7B68     		ldr	r3, [r7, #4]
 472 009a DB6A     		ldr	r3, [r3, #44]
 473 009c 9A42     		cmp	r2, r3
 474 009e 07D2     		bcs	.L24
1145:Source/tasks.c **** 		{
1146:Source/tasks.c **** 			taskYIELD_IF_USING_PREEMPTION();
 475              		.loc 1 1146 0
 476 00a0 0B4B     		ldr	r3, .L25+24
 477 00a2 4FF08052 		mov	r2, #268435456
 478 00a6 1A60     		str	r2, [r3]
 479              		.syntax unified
 480              	@ 1146 "Source\tasks.c" 1
 481 00a8 BFF34F8F 		dsb
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 30
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 30
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 482              	@ 0 "" 2
 483              	@ 1146 "Source\tasks.c" 1
 484 00ac BFF36F8F 		isb
 485              	@ 0 "" 2
 486              		.thumb
 487              		.syntax unified
 488              	.L24:
1147:Source/tasks.c **** 		}
1148:Source/tasks.c **** 		else
1149:Source/tasks.c **** 		{
1150:Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1151:Source/tasks.c **** 		}
1152:Source/tasks.c **** 	}
1153:Source/tasks.c **** 	else
1154:Source/tasks.c **** 	{
1155:Source/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
1156:Source/tasks.c **** 	}
1157:Source/tasks.c **** }
 489              		.loc 1 1157 0
 490 00b0 00BF     		nop
 491 00b2 0837     		adds	r7, r7, #8
 492              		.cfi_def_cfa_offset 8
 493 00b4 BD46     		mov	sp, r7
 494              		.cfi_def_cfa_register 13
 495              		@ sp needed
 496 00b6 80BD     		pop	{r7, pc}
 497              	.L26:
 498              		.align	2
 499              	.L25:
 500 00b8 D8000000 		.word	uxCurrentNumberOfTasks
 501 00bc 00000000 		.word	pxCurrentTCB
 502 00c0 E4000000 		.word	xSchedulerRunning
 503 00c4 F4000000 		.word	uxTaskNumber
 504 00c8 E0000000 		.word	uxTopReadyPriority
 505 00cc 04000000 		.word	pxReadyTasksLists
 506 00d0 04ED00E0 		.word	-536810236
 507              		.cfi_endproc
 508              	.LFE70:
 509              		.size	prvAddNewTaskToReadyList, .-prvAddNewTaskToReadyList
 510              		.section	.text.vTaskDelete,"ax",%progbits
 511              		.align	2
 512              		.global	vTaskDelete
 513              		.thumb
 514              		.thumb_func
 515              		.type	vTaskDelete, %function
 516              	vTaskDelete:
 517              	.LFB71:
1158:Source/tasks.c **** /*-----------------------------------------------------------*/
1159:Source/tasks.c **** 
1160:Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
1161:Source/tasks.c **** 
1162:Source/tasks.c **** 	void vTaskDelete( TaskHandle_t xTaskToDelete )
1163:Source/tasks.c **** 	{
 518              		.loc 1 1163 0
 519              		.cfi_startproc
 520              		@ args = 0, pretend = 0, frame = 16
 521              		@ frame_needed = 1, uses_anonymous_args = 0
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 31
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 31
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 522 0000 80B5     		push	{r7, lr}
 523              		.cfi_def_cfa_offset 8
 524              		.cfi_offset 7, -8
 525              		.cfi_offset 14, -4
 526 0002 84B0     		sub	sp, sp, #16
 527              		.cfi_def_cfa_offset 24
 528 0004 00AF     		add	r7, sp, #0
 529              		.cfi_def_cfa_register 7
 530 0006 7860     		str	r0, [r7, #4]
1164:Source/tasks.c **** 	TCB_t *pxTCB;
1165:Source/tasks.c **** 
1166:Source/tasks.c **** 		taskENTER_CRITICAL();
 531              		.loc 1 1166 0
 532 0008 FFF7FEFF 		bl	vPortEnterCritical
1167:Source/tasks.c **** 		{
1168:Source/tasks.c **** 			/* If null is passed in here then it is the calling task that is
1169:Source/tasks.c **** 			being deleted. */
1170:Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 533              		.loc 1 1170 0
 534 000c 7B68     		ldr	r3, [r7, #4]
 535 000e 002B     		cmp	r3, #0
 536 0010 02D1     		bne	.L28
 537              		.loc 1 1170 0 is_stmt 0 discriminator 1
 538 0012 314B     		ldr	r3, .L37
 539 0014 1B68     		ldr	r3, [r3]
 540 0016 00E0     		b	.L29
 541              	.L28:
 542              		.loc 1 1170 0 discriminator 2
 543 0018 7B68     		ldr	r3, [r7, #4]
 544              	.L29:
 545              		.loc 1 1170 0 discriminator 4
 546 001a FB60     		str	r3, [r7, #12]
1171:Source/tasks.c **** 
1172:Source/tasks.c **** 			/* Remove task from the ready/delayed list. */
1173:Source/tasks.c **** 			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 547              		.loc 1 1173 0 is_stmt 1 discriminator 4
 548 001c FB68     		ldr	r3, [r7, #12]
 549 001e 0433     		adds	r3, r3, #4
 550 0020 1846     		mov	r0, r3
 551 0022 FFF7FEFF 		bl	uxListRemove
 552 0026 0346     		mov	r3, r0
 553 0028 002B     		cmp	r3, #0
 554 002a 15D1     		bne	.L30
1174:Source/tasks.c **** 			{
1175:Source/tasks.c **** 				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 555              		.loc 1 1175 0
 556 002c FB68     		ldr	r3, [r7, #12]
 557 002e DA6A     		ldr	r2, [r3, #44]
 558 0030 2A49     		ldr	r1, .L37+4
 559 0032 1346     		mov	r3, r2
 560 0034 9B00     		lsls	r3, r3, #2
 561 0036 1344     		add	r3, r3, r2
 562 0038 9B00     		lsls	r3, r3, #2
 563 003a 0B44     		add	r3, r3, r1
 564 003c 1B68     		ldr	r3, [r3]
 565 003e 002B     		cmp	r3, #0
 566 0040 0AD1     		bne	.L30
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 32
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 32
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 567              		.loc 1 1175 0 is_stmt 0 discriminator 1
 568 0042 FB68     		ldr	r3, [r7, #12]
 569 0044 DB6A     		ldr	r3, [r3, #44]
 570 0046 0122     		movs	r2, #1
 571 0048 02FA03F3 		lsl	r3, r2, r3
 572 004c DA43     		mvns	r2, r3
 573 004e 244B     		ldr	r3, .L37+8
 574 0050 1B68     		ldr	r3, [r3]
 575 0052 1340     		ands	r3, r3, r2
 576 0054 224A     		ldr	r2, .L37+8
 577 0056 1360     		str	r3, [r2]
 578              	.L30:
1176:Source/tasks.c **** 			}
1177:Source/tasks.c **** 			else
1178:Source/tasks.c **** 			{
1179:Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1180:Source/tasks.c **** 			}
1181:Source/tasks.c **** 
1182:Source/tasks.c **** 			/* Is the task waiting on an event also? */
1183:Source/tasks.c **** 			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 579              		.loc 1 1183 0 is_stmt 1
 580 0058 FB68     		ldr	r3, [r7, #12]
 581 005a 9B6A     		ldr	r3, [r3, #40]
 582 005c 002B     		cmp	r3, #0
 583 005e 04D0     		beq	.L32
1184:Source/tasks.c **** 			{
1185:Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 584              		.loc 1 1185 0
 585 0060 FB68     		ldr	r3, [r7, #12]
 586 0062 1833     		adds	r3, r3, #24
 587 0064 1846     		mov	r0, r3
 588 0066 FFF7FEFF 		bl	uxListRemove
 589              	.L32:
1186:Source/tasks.c **** 			}
1187:Source/tasks.c **** 			else
1188:Source/tasks.c **** 			{
1189:Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1190:Source/tasks.c **** 			}
1191:Source/tasks.c **** 
1192:Source/tasks.c **** 			/* Increment the uxTaskNumber also so kernel aware debuggers can
1193:Source/tasks.c **** 			detect that the task lists need re-generating.  This is done before
1194:Source/tasks.c **** 			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
1195:Source/tasks.c **** 			not return. */
1196:Source/tasks.c **** 			uxTaskNumber++;
 590              		.loc 1 1196 0
 591 006a 1E4B     		ldr	r3, .L37+12
 592 006c 1B68     		ldr	r3, [r3]
 593 006e 0133     		adds	r3, r3, #1
 594 0070 1C4A     		ldr	r2, .L37+12
 595 0072 1360     		str	r3, [r2]
1197:Source/tasks.c **** 
1198:Source/tasks.c **** 			if( pxTCB == pxCurrentTCB )
 596              		.loc 1 1198 0
 597 0074 184B     		ldr	r3, .L37
 598 0076 1B68     		ldr	r3, [r3]
 599 0078 FA68     		ldr	r2, [r7, #12]
 600 007a 9A42     		cmp	r2, r3
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 33
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 33
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 601 007c 0BD1     		bne	.L33
1199:Source/tasks.c **** 			{
1200:Source/tasks.c **** 				/* A task is deleting itself.  This cannot complete within the
1201:Source/tasks.c **** 				task itself, as a context switch to another task is required.
1202:Source/tasks.c **** 				Place the task in the termination list.  The idle task will
1203:Source/tasks.c **** 				check the termination list and free up any memory allocated by
1204:Source/tasks.c **** 				the scheduler for the TCB and stack of the deleted task. */
1205:Source/tasks.c **** 				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
 602              		.loc 1 1205 0
 603 007e FB68     		ldr	r3, [r7, #12]
 604 0080 0433     		adds	r3, r3, #4
 605 0082 1946     		mov	r1, r3
 606 0084 1848     		ldr	r0, .L37+16
 607 0086 FFF7FEFF 		bl	vListInsertEnd
1206:Source/tasks.c **** 
1207:Source/tasks.c **** 				/* Increment the ucTasksDeleted variable so the idle task knows
1208:Source/tasks.c **** 				there is a task that has been deleted and that it should therefore
1209:Source/tasks.c **** 				check the xTasksWaitingTermination list. */
1210:Source/tasks.c **** 				++uxDeletedTasksWaitingCleanUp;
 608              		.loc 1 1210 0
 609 008a 184B     		ldr	r3, .L37+20
 610 008c 1B68     		ldr	r3, [r3]
 611 008e 0133     		adds	r3, r3, #1
 612 0090 164A     		ldr	r2, .L37+20
 613 0092 1360     		str	r3, [r2]
 614 0094 09E0     		b	.L34
 615              	.L33:
1211:Source/tasks.c **** 
1212:Source/tasks.c **** 				/* Call the delete hook before portPRE_TASK_DELETE_HOOK() as
1213:Source/tasks.c **** 				portPRE_TASK_DELETE_HOOK() does not return in the Win32 port. */
1214:Source/tasks.c **** 				traceTASK_DELETE( pxTCB );
1215:Source/tasks.c **** 
1216:Source/tasks.c **** 				/* The pre-delete hook is primarily for the Windows simulator,
1217:Source/tasks.c **** 				in which Windows specific clean up operations are performed,
1218:Source/tasks.c **** 				after which it is not possible to yield away from this task -
1219:Source/tasks.c **** 				hence xYieldPending is used to latch that a context switch is
1220:Source/tasks.c **** 				required. */
1221:Source/tasks.c **** 				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
1222:Source/tasks.c **** 			}
1223:Source/tasks.c **** 			else
1224:Source/tasks.c **** 			{
1225:Source/tasks.c **** 				--uxCurrentNumberOfTasks;
 616              		.loc 1 1225 0
 617 0096 164B     		ldr	r3, .L37+24
 618 0098 1B68     		ldr	r3, [r3]
 619 009a 013B     		subs	r3, r3, #1
 620 009c 144A     		ldr	r2, .L37+24
 621 009e 1360     		str	r3, [r2]
1226:Source/tasks.c **** 				traceTASK_DELETE( pxTCB );
1227:Source/tasks.c **** 				prvDeleteTCB( pxTCB );
 622              		.loc 1 1227 0
 623 00a0 F868     		ldr	r0, [r7, #12]
 624 00a2 FFF7FEFF 		bl	prvDeleteTCB
1228:Source/tasks.c **** 
1229:Source/tasks.c **** 				/* Reset the next expected unblock time in case it referred to
1230:Source/tasks.c **** 				the task that has just been deleted. */
1231:Source/tasks.c **** 				prvResetNextTaskUnblockTime();
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 34
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 34
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 625              		.loc 1 1231 0
 626 00a6 FFF7FEFF 		bl	prvResetNextTaskUnblockTime
 627              	.L34:
1232:Source/tasks.c **** 			}
1233:Source/tasks.c **** 		}
1234:Source/tasks.c **** 		taskEXIT_CRITICAL();
 628              		.loc 1 1234 0
 629 00aa FFF7FEFF 		bl	vPortExitCritical
1235:Source/tasks.c **** 
1236:Source/tasks.c **** 		/* Force a reschedule if it is the currently running task that has just
1237:Source/tasks.c **** 		been deleted. */
1238:Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 630              		.loc 1 1238 0
 631 00ae 114B     		ldr	r3, .L37+28
 632 00b0 1B68     		ldr	r3, [r3]
 633 00b2 002B     		cmp	r3, #0
 634 00b4 0CD0     		beq	.L36
1239:Source/tasks.c **** 		{
1240:Source/tasks.c **** 			if( pxTCB == pxCurrentTCB )
 635              		.loc 1 1240 0
 636 00b6 084B     		ldr	r3, .L37
 637 00b8 1B68     		ldr	r3, [r3]
 638 00ba FA68     		ldr	r2, [r7, #12]
 639 00bc 9A42     		cmp	r2, r3
 640 00be 07D1     		bne	.L36
1241:Source/tasks.c **** 			{
1242:Source/tasks.c **** 				configASSERT( uxSchedulerSuspended == 0 );
1243:Source/tasks.c **** 				portYIELD_WITHIN_API();
 641              		.loc 1 1243 0
 642 00c0 0D4B     		ldr	r3, .L37+32
 643 00c2 4FF08052 		mov	r2, #268435456
 644 00c6 1A60     		str	r2, [r3]
 645              		.syntax unified
 646              	@ 1243 "Source\tasks.c" 1
 647 00c8 BFF34F8F 		dsb
 648              	@ 0 "" 2
 649              	@ 1243 "Source\tasks.c" 1
 650 00cc BFF36F8F 		isb
 651              	@ 0 "" 2
 652              		.thumb
 653              		.syntax unified
 654              	.L36:
1244:Source/tasks.c **** 			}
1245:Source/tasks.c **** 			else
1246:Source/tasks.c **** 			{
1247:Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1248:Source/tasks.c **** 			}
1249:Source/tasks.c **** 		}
1250:Source/tasks.c **** 	}
 655              		.loc 1 1250 0
 656 00d0 00BF     		nop
 657 00d2 1037     		adds	r7, r7, #16
 658              		.cfi_def_cfa_offset 8
 659 00d4 BD46     		mov	sp, r7
 660              		.cfi_def_cfa_register 13
 661              		@ sp needed
 662 00d6 80BD     		pop	{r7, pc}
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 35
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 35
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 663              	.L38:
 664              		.align	2
 665              	.L37:
 666 00d8 00000000 		.word	pxCurrentTCB
 667 00dc 04000000 		.word	pxReadyTasksLists
 668 00e0 E0000000 		.word	uxTopReadyPriority
 669 00e4 F4000000 		.word	uxTaskNumber
 670 00e8 AC000000 		.word	xTasksWaitingTermination
 671 00ec C0000000 		.word	uxDeletedTasksWaitingCleanUp
 672 00f0 D8000000 		.word	uxCurrentNumberOfTasks
 673 00f4 E4000000 		.word	xSchedulerRunning
 674 00f8 04ED00E0 		.word	-536810236
 675              		.cfi_endproc
 676              	.LFE71:
 677              		.size	vTaskDelete, .-vTaskDelete
 678              		.section	.text.vTaskDelayUntil,"ax",%progbits
 679              		.align	2
 680              		.global	vTaskDelayUntil
 681              		.thumb
 682              		.thumb_func
 683              		.type	vTaskDelayUntil, %function
 684              	vTaskDelayUntil:
 685              	.LFB72:
1251:Source/tasks.c **** 
1252:Source/tasks.c **** #endif /* INCLUDE_vTaskDelete */
1253:Source/tasks.c **** /*-----------------------------------------------------------*/
1254:Source/tasks.c **** 
1255:Source/tasks.c **** #if ( INCLUDE_vTaskDelayUntil == 1 )
1256:Source/tasks.c **** 
1257:Source/tasks.c **** 	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
1258:Source/tasks.c **** 	{
 686              		.loc 1 1258 0
 687              		.cfi_startproc
 688              		@ args = 0, pretend = 0, frame = 24
 689              		@ frame_needed = 1, uses_anonymous_args = 0
 690 0000 80B5     		push	{r7, lr}
 691              		.cfi_def_cfa_offset 8
 692              		.cfi_offset 7, -8
 693              		.cfi_offset 14, -4
 694 0002 86B0     		sub	sp, sp, #24
 695              		.cfi_def_cfa_offset 32
 696 0004 00AF     		add	r7, sp, #0
 697              		.cfi_def_cfa_register 7
 698 0006 7860     		str	r0, [r7, #4]
 699 0008 3960     		str	r1, [r7]
1259:Source/tasks.c **** 	TickType_t xTimeToWake;
1260:Source/tasks.c **** 	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
 700              		.loc 1 1260 0
 701 000a 0023     		movs	r3, #0
 702 000c 7B61     		str	r3, [r7, #20]
1261:Source/tasks.c **** 
1262:Source/tasks.c **** 		configASSERT( pxPreviousWakeTime );
1263:Source/tasks.c **** 		configASSERT( ( xTimeIncrement > 0U ) );
1264:Source/tasks.c **** 		configASSERT( uxSchedulerSuspended == 0 );
1265:Source/tasks.c **** 
1266:Source/tasks.c **** 		vTaskSuspendAll();
 703              		.loc 1 1266 0
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 36
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 36
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 704 000e FFF7FEFF 		bl	vTaskSuspendAll
 705              	.LBB28:
1267:Source/tasks.c **** 		{
1268:Source/tasks.c **** 			/* Minor optimisation.  The tick count cannot change in this
1269:Source/tasks.c **** 			block. */
1270:Source/tasks.c **** 			const TickType_t xConstTickCount = xTickCount;
 706              		.loc 1 1270 0
 707 0012 214B     		ldr	r3, .L46
 708 0014 1B68     		ldr	r3, [r3]
 709 0016 3B61     		str	r3, [r7, #16]
1271:Source/tasks.c **** 
1272:Source/tasks.c **** 			/* Generate the tick time at which the task wants to wake. */
1273:Source/tasks.c **** 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 710              		.loc 1 1273 0
 711 0018 7B68     		ldr	r3, [r7, #4]
 712 001a 1A68     		ldr	r2, [r3]
 713 001c 3B68     		ldr	r3, [r7]
 714 001e 1344     		add	r3, r3, r2
 715 0020 FB60     		str	r3, [r7, #12]
1274:Source/tasks.c **** 
1275:Source/tasks.c **** 			if( xConstTickCount < *pxPreviousWakeTime )
 716              		.loc 1 1275 0
 717 0022 7B68     		ldr	r3, [r7, #4]
 718 0024 1A68     		ldr	r2, [r3]
 719 0026 3B69     		ldr	r3, [r7, #16]
 720 0028 9A42     		cmp	r2, r3
 721 002a 0BD9     		bls	.L40
1276:Source/tasks.c **** 			{
1277:Source/tasks.c **** 				/* The tick count has overflowed since this function was
1278:Source/tasks.c **** 				lasted called.  In this case the only time we should ever
1279:Source/tasks.c **** 				actually delay is if the wake time has also	overflowed,
1280:Source/tasks.c **** 				and the wake time is greater than the tick time.  When this
1281:Source/tasks.c **** 				is the case it is as if neither time had overflowed. */
1282:Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
 722              		.loc 1 1282 0
 723 002c 7B68     		ldr	r3, [r7, #4]
 724 002e 1A68     		ldr	r2, [r3]
 725 0030 FB68     		ldr	r3, [r7, #12]
 726 0032 9A42     		cmp	r2, r3
 727 0034 11D9     		bls	.L41
 728              		.loc 1 1282 0 is_stmt 0 discriminator 1
 729 0036 FA68     		ldr	r2, [r7, #12]
 730 0038 3B69     		ldr	r3, [r7, #16]
 731 003a 9A42     		cmp	r2, r3
 732 003c 0DD9     		bls	.L41
1283:Source/tasks.c **** 				{
1284:Source/tasks.c **** 					xShouldDelay = pdTRUE;
 733              		.loc 1 1284 0 is_stmt 1
 734 003e 0123     		movs	r3, #1
 735 0040 7B61     		str	r3, [r7, #20]
 736 0042 0AE0     		b	.L41
 737              	.L40:
1285:Source/tasks.c **** 				}
1286:Source/tasks.c **** 				else
1287:Source/tasks.c **** 				{
1288:Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1289:Source/tasks.c **** 				}
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 37
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 37
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


1290:Source/tasks.c **** 			}
1291:Source/tasks.c **** 			else
1292:Source/tasks.c **** 			{
1293:Source/tasks.c **** 				/* The tick time has not overflowed.  In this case we will
1294:Source/tasks.c **** 				delay if either the wake time has overflowed, and/or the
1295:Source/tasks.c **** 				tick time is less than the wake time. */
1296:Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
 738              		.loc 1 1296 0
 739 0044 7B68     		ldr	r3, [r7, #4]
 740 0046 1A68     		ldr	r2, [r3]
 741 0048 FB68     		ldr	r3, [r7, #12]
 742 004a 9A42     		cmp	r2, r3
 743 004c 03D8     		bhi	.L42
 744              		.loc 1 1296 0 is_stmt 0 discriminator 1
 745 004e FA68     		ldr	r2, [r7, #12]
 746 0050 3B69     		ldr	r3, [r7, #16]
 747 0052 9A42     		cmp	r2, r3
 748 0054 01D9     		bls	.L41
 749              	.L42:
1297:Source/tasks.c **** 				{
1298:Source/tasks.c **** 					xShouldDelay = pdTRUE;
 750              		.loc 1 1298 0 is_stmt 1
 751 0056 0123     		movs	r3, #1
 752 0058 7B61     		str	r3, [r7, #20]
 753              	.L41:
1299:Source/tasks.c **** 				}
1300:Source/tasks.c **** 				else
1301:Source/tasks.c **** 				{
1302:Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1303:Source/tasks.c **** 				}
1304:Source/tasks.c **** 			}
1305:Source/tasks.c **** 
1306:Source/tasks.c **** 			/* Update the wake time ready for the next call. */
1307:Source/tasks.c **** 			*pxPreviousWakeTime = xTimeToWake;
 754              		.loc 1 1307 0
 755 005a 7B68     		ldr	r3, [r7, #4]
 756 005c FA68     		ldr	r2, [r7, #12]
 757 005e 1A60     		str	r2, [r3]
1308:Source/tasks.c **** 
1309:Source/tasks.c **** 			if( xShouldDelay != pdFALSE )
 758              		.loc 1 1309 0
 759 0060 7B69     		ldr	r3, [r7, #20]
 760 0062 002B     		cmp	r3, #0
 761 0064 06D0     		beq	.L43
1310:Source/tasks.c **** 			{
1311:Source/tasks.c **** 				traceTASK_DELAY_UNTIL( xTimeToWake );
1312:Source/tasks.c **** 
1313:Source/tasks.c **** 				/* prvAddCurrentTaskToDelayedList() needs the block time, not
1314:Source/tasks.c **** 				the time to wake, so subtract the current tick count. */
1315:Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
 762              		.loc 1 1315 0
 763 0066 FA68     		ldr	r2, [r7, #12]
 764 0068 3B69     		ldr	r3, [r7, #16]
 765 006a D31A     		subs	r3, r2, r3
 766 006c 0021     		movs	r1, #0
 767 006e 1846     		mov	r0, r3
 768 0070 FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 38
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 38
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 769              	.L43:
 770              	.LBE28:
1316:Source/tasks.c **** 			}
1317:Source/tasks.c **** 			else
1318:Source/tasks.c **** 			{
1319:Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1320:Source/tasks.c **** 			}
1321:Source/tasks.c **** 		}
1322:Source/tasks.c **** 		xAlreadyYielded = xTaskResumeAll();
 771              		.loc 1 1322 0
 772 0074 FFF7FEFF 		bl	xTaskResumeAll
 773 0078 B860     		str	r0, [r7, #8]
1323:Source/tasks.c **** 
1324:Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
1325:Source/tasks.c **** 		have put ourselves to sleep. */
1326:Source/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 774              		.loc 1 1326 0
 775 007a BB68     		ldr	r3, [r7, #8]
 776 007c 002B     		cmp	r3, #0
 777 007e 07D1     		bne	.L45
1327:Source/tasks.c **** 		{
1328:Source/tasks.c **** 			portYIELD_WITHIN_API();
 778              		.loc 1 1328 0
 779 0080 064B     		ldr	r3, .L46+4
 780 0082 4FF08052 		mov	r2, #268435456
 781 0086 1A60     		str	r2, [r3]
 782              		.syntax unified
 783              	@ 1328 "Source\tasks.c" 1
 784 0088 BFF34F8F 		dsb
 785              	@ 0 "" 2
 786              	@ 1328 "Source\tasks.c" 1
 787 008c BFF36F8F 		isb
 788              	@ 0 "" 2
 789              		.thumb
 790              		.syntax unified
 791              	.L45:
1329:Source/tasks.c **** 		}
1330:Source/tasks.c **** 		else
1331:Source/tasks.c **** 		{
1332:Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1333:Source/tasks.c **** 		}
1334:Source/tasks.c **** 	}
 792              		.loc 1 1334 0
 793 0090 00BF     		nop
 794 0092 1837     		adds	r7, r7, #24
 795              		.cfi_def_cfa_offset 8
 796 0094 BD46     		mov	sp, r7
 797              		.cfi_def_cfa_register 13
 798              		@ sp needed
 799 0096 80BD     		pop	{r7, pc}
 800              	.L47:
 801              		.align	2
 802              	.L46:
 803 0098 DC000000 		.word	xTickCount
 804 009c 04ED00E0 		.word	-536810236
 805              		.cfi_endproc
 806              	.LFE72:
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 39
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 39
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 807              		.size	vTaskDelayUntil, .-vTaskDelayUntil
 808              		.section	.text.vTaskDelay,"ax",%progbits
 809              		.align	2
 810              		.global	vTaskDelay
 811              		.thumb
 812              		.thumb_func
 813              		.type	vTaskDelay, %function
 814              	vTaskDelay:
 815              	.LFB73:
1335:Source/tasks.c **** 
1336:Source/tasks.c **** #endif /* INCLUDE_vTaskDelayUntil */
1337:Source/tasks.c **** /*-----------------------------------------------------------*/
1338:Source/tasks.c **** 
1339:Source/tasks.c **** #if ( INCLUDE_vTaskDelay == 1 )
1340:Source/tasks.c **** 
1341:Source/tasks.c **** 	void vTaskDelay( const TickType_t xTicksToDelay )
1342:Source/tasks.c **** 	{
 816              		.loc 1 1342 0
 817              		.cfi_startproc
 818              		@ args = 0, pretend = 0, frame = 16
 819              		@ frame_needed = 1, uses_anonymous_args = 0
 820 0000 80B5     		push	{r7, lr}
 821              		.cfi_def_cfa_offset 8
 822              		.cfi_offset 7, -8
 823              		.cfi_offset 14, -4
 824 0002 84B0     		sub	sp, sp, #16
 825              		.cfi_def_cfa_offset 24
 826 0004 00AF     		add	r7, sp, #0
 827              		.cfi_def_cfa_register 7
 828 0006 7860     		str	r0, [r7, #4]
1343:Source/tasks.c **** 	BaseType_t xAlreadyYielded = pdFALSE;
 829              		.loc 1 1343 0
 830 0008 0023     		movs	r3, #0
 831 000a FB60     		str	r3, [r7, #12]
1344:Source/tasks.c **** 
1345:Source/tasks.c **** 		/* A delay time of zero just forces a reschedule. */
1346:Source/tasks.c **** 		if( xTicksToDelay > ( TickType_t ) 0U )
 832              		.loc 1 1346 0
 833 000c 7B68     		ldr	r3, [r7, #4]
 834 000e 002B     		cmp	r3, #0
 835 0010 08D0     		beq	.L49
1347:Source/tasks.c **** 		{
1348:Source/tasks.c **** 			configASSERT( uxSchedulerSuspended == 0 );
1349:Source/tasks.c **** 			vTaskSuspendAll();
 836              		.loc 1 1349 0
 837 0012 FFF7FEFF 		bl	vTaskSuspendAll
1350:Source/tasks.c **** 			{
1351:Source/tasks.c **** 				traceTASK_DELAY();
1352:Source/tasks.c **** 
1353:Source/tasks.c **** 				/* A task that is removed from the event list while the
1354:Source/tasks.c **** 				scheduler is suspended will not get placed in the ready
1355:Source/tasks.c **** 				list or removed from the blocked list until the scheduler
1356:Source/tasks.c **** 				is resumed.
1357:Source/tasks.c **** 
1358:Source/tasks.c **** 				This task cannot be in an event list as it is the currently
1359:Source/tasks.c **** 				executing task. */
1360:Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 40
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 40
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 838              		.loc 1 1360 0
 839 0016 0021     		movs	r1, #0
 840 0018 7868     		ldr	r0, [r7, #4]
 841 001a FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
1361:Source/tasks.c **** 			}
1362:Source/tasks.c **** 			xAlreadyYielded = xTaskResumeAll();
 842              		.loc 1 1362 0
 843 001e FFF7FEFF 		bl	xTaskResumeAll
 844 0022 F860     		str	r0, [r7, #12]
 845              	.L49:
1363:Source/tasks.c **** 		}
1364:Source/tasks.c **** 		else
1365:Source/tasks.c **** 		{
1366:Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1367:Source/tasks.c **** 		}
1368:Source/tasks.c **** 
1369:Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
1370:Source/tasks.c **** 		have put ourselves to sleep. */
1371:Source/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 846              		.loc 1 1371 0
 847 0024 FB68     		ldr	r3, [r7, #12]
 848 0026 002B     		cmp	r3, #0
 849 0028 07D1     		bne	.L51
1372:Source/tasks.c **** 		{
1373:Source/tasks.c **** 			portYIELD_WITHIN_API();
 850              		.loc 1 1373 0
 851 002a 064B     		ldr	r3, .L52
 852 002c 4FF08052 		mov	r2, #268435456
 853 0030 1A60     		str	r2, [r3]
 854              		.syntax unified
 855              	@ 1373 "Source\tasks.c" 1
 856 0032 BFF34F8F 		dsb
 857              	@ 0 "" 2
 858              	@ 1373 "Source\tasks.c" 1
 859 0036 BFF36F8F 		isb
 860              	@ 0 "" 2
 861              		.thumb
 862              		.syntax unified
 863              	.L51:
1374:Source/tasks.c **** 		}
1375:Source/tasks.c **** 		else
1376:Source/tasks.c **** 		{
1377:Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1378:Source/tasks.c **** 		}
1379:Source/tasks.c **** 	}
 864              		.loc 1 1379 0
 865 003a 00BF     		nop
 866 003c 1037     		adds	r7, r7, #16
 867              		.cfi_def_cfa_offset 8
 868 003e BD46     		mov	sp, r7
 869              		.cfi_def_cfa_register 13
 870              		@ sp needed
 871 0040 80BD     		pop	{r7, pc}
 872              	.L53:
 873 0042 00BF     		.align	2
 874              	.L52:
 875 0044 04ED00E0 		.word	-536810236
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 41
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 41
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 876              		.cfi_endproc
 877              	.LFE73:
 878              		.size	vTaskDelay, .-vTaskDelay
 879              		.section	.text.eTaskGetState,"ax",%progbits
 880              		.align	2
 881              		.global	eTaskGetState
 882              		.thumb
 883              		.thumb_func
 884              		.type	eTaskGetState, %function
 885              	eTaskGetState:
 886              	.LFB74:
1380:Source/tasks.c **** 
1381:Source/tasks.c **** #endif /* INCLUDE_vTaskDelay */
1382:Source/tasks.c **** /*-----------------------------------------------------------*/
1383:Source/tasks.c **** 
1384:Source/tasks.c **** #if( ( INCLUDE_eTaskGetState == 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_xTaskAbortDel
1385:Source/tasks.c **** 
1386:Source/tasks.c **** 	eTaskState eTaskGetState( TaskHandle_t xTask )
1387:Source/tasks.c **** 	{
 887              		.loc 1 1387 0
 888              		.cfi_startproc
 889              		@ args = 0, pretend = 0, frame = 32
 890              		@ frame_needed = 1, uses_anonymous_args = 0
 891 0000 80B5     		push	{r7, lr}
 892              		.cfi_def_cfa_offset 8
 893              		.cfi_offset 7, -8
 894              		.cfi_offset 14, -4
 895 0002 88B0     		sub	sp, sp, #32
 896              		.cfi_def_cfa_offset 40
 897 0004 00AF     		add	r7, sp, #0
 898              		.cfi_def_cfa_register 7
 899 0006 7860     		str	r0, [r7, #4]
1388:Source/tasks.c **** 	eTaskState eReturn;
1389:Source/tasks.c **** 	List_t const * pxStateList, *pxDelayedList, *pxOverflowedDelayedList;
1390:Source/tasks.c **** 	const TCB_t * const pxTCB = xTask;
 900              		.loc 1 1390 0
 901 0008 7B68     		ldr	r3, [r7, #4]
 902 000a BB61     		str	r3, [r7, #24]
1391:Source/tasks.c **** 
1392:Source/tasks.c **** 		configASSERT( pxTCB );
1393:Source/tasks.c **** 
1394:Source/tasks.c **** 		if( pxTCB == pxCurrentTCB )
 903              		.loc 1 1394 0
 904 000c 234B     		ldr	r3, .L67
 905 000e 1B68     		ldr	r3, [r3]
 906 0010 BA69     		ldr	r2, [r7, #24]
 907 0012 9A42     		cmp	r2, r3
 908 0014 02D1     		bne	.L55
1395:Source/tasks.c **** 		{
1396:Source/tasks.c **** 			/* The task calling this function is querying its own state. */
1397:Source/tasks.c **** 			eReturn = eRunning;
 909              		.loc 1 1397 0
 910 0016 0023     		movs	r3, #0
 911 0018 FB77     		strb	r3, [r7, #31]
 912 001a 3AE0     		b	.L56
 913              	.L55:
1398:Source/tasks.c **** 		}
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 42
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 42
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


1399:Source/tasks.c **** 		else
1400:Source/tasks.c **** 		{
1401:Source/tasks.c **** 			taskENTER_CRITICAL();
 914              		.loc 1 1401 0
 915 001c FFF7FEFF 		bl	vPortEnterCritical
1402:Source/tasks.c **** 			{
1403:Source/tasks.c **** 				pxStateList = listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
 916              		.loc 1 1403 0
 917 0020 BB69     		ldr	r3, [r7, #24]
 918 0022 5B69     		ldr	r3, [r3, #20]
 919 0024 7B61     		str	r3, [r7, #20]
1404:Source/tasks.c **** 				pxDelayedList = pxDelayedTaskList;
 920              		.loc 1 1404 0
 921 0026 1E4B     		ldr	r3, .L67+4
 922 0028 1B68     		ldr	r3, [r3]
 923 002a 3B61     		str	r3, [r7, #16]
1405:Source/tasks.c **** 				pxOverflowedDelayedList = pxOverflowDelayedTaskList;
 924              		.loc 1 1405 0
 925 002c 1D4B     		ldr	r3, .L67+8
 926 002e 1B68     		ldr	r3, [r3]
 927 0030 FB60     		str	r3, [r7, #12]
1406:Source/tasks.c **** 			}
1407:Source/tasks.c **** 			taskEXIT_CRITICAL();
 928              		.loc 1 1407 0
 929 0032 FFF7FEFF 		bl	vPortExitCritical
1408:Source/tasks.c **** 
1409:Source/tasks.c **** 			if( ( pxStateList == pxDelayedList ) || ( pxStateList == pxOverflowedDelayedList ) )
 930              		.loc 1 1409 0
 931 0036 7A69     		ldr	r2, [r7, #20]
 932 0038 3B69     		ldr	r3, [r7, #16]
 933 003a 9A42     		cmp	r2, r3
 934 003c 03D0     		beq	.L57
 935              		.loc 1 1409 0 is_stmt 0 discriminator 1
 936 003e 7A69     		ldr	r2, [r7, #20]
 937 0040 FB68     		ldr	r3, [r7, #12]
 938 0042 9A42     		cmp	r2, r3
 939 0044 02D1     		bne	.L58
 940              	.L57:
1410:Source/tasks.c **** 			{
1411:Source/tasks.c **** 				/* The task being queried is referenced from one of the Blocked
1412:Source/tasks.c **** 				lists. */
1413:Source/tasks.c **** 				eReturn = eBlocked;
 941              		.loc 1 1413 0 is_stmt 1
 942 0046 0223     		movs	r3, #2
 943 0048 FB77     		strb	r3, [r7, #31]
 944 004a 22E0     		b	.L56
 945              	.L58:
1414:Source/tasks.c **** 			}
1415:Source/tasks.c **** 
1416:Source/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1417:Source/tasks.c **** 				else if( pxStateList == &xSuspendedTaskList )
 946              		.loc 1 1417 0
 947 004c 7B69     		ldr	r3, [r7, #20]
 948 004e 164A     		ldr	r2, .L67+12
 949 0050 9342     		cmp	r3, r2
 950 0052 12D1     		bne	.L59
1418:Source/tasks.c **** 				{
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 43
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 43
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


1419:Source/tasks.c **** 					/* The task being queried is referenced from the suspended
1420:Source/tasks.c **** 					list.  Is it genuinely suspended or is it blocked
1421:Source/tasks.c **** 					indefinitely? */
1422:Source/tasks.c **** 					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
 951              		.loc 1 1422 0
 952 0054 BB69     		ldr	r3, [r7, #24]
 953 0056 9B6A     		ldr	r3, [r3, #40]
 954 0058 002B     		cmp	r3, #0
 955 005a 0BD1     		bne	.L60
1423:Source/tasks.c **** 					{
1424:Source/tasks.c **** 						#if( configUSE_TASK_NOTIFICATIONS == 1 )
1425:Source/tasks.c **** 						{
1426:Source/tasks.c **** 							/* The task does not appear on the event list item of
1427:Source/tasks.c **** 							and of the RTOS objects, but could still be in the
1428:Source/tasks.c **** 							blocked state if it is waiting on its notification
1429:Source/tasks.c **** 							rather than waiting on an object. */
1430:Source/tasks.c **** 							if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
 956              		.loc 1 1430 0
 957 005c BB69     		ldr	r3, [r7, #24]
 958 005e 93F84C30 		ldrb	r3, [r3, #76]
 959 0062 DBB2     		uxtb	r3, r3
 960 0064 012B     		cmp	r3, #1
 961 0066 02D1     		bne	.L61
1431:Source/tasks.c **** 							{
1432:Source/tasks.c **** 								eReturn = eBlocked;
 962              		.loc 1 1432 0
 963 0068 0223     		movs	r3, #2
 964 006a FB77     		strb	r3, [r7, #31]
 965 006c 11E0     		b	.L56
 966              	.L61:
1433:Source/tasks.c **** 							}
1434:Source/tasks.c **** 							else
1435:Source/tasks.c **** 							{
1436:Source/tasks.c **** 								eReturn = eSuspended;
 967              		.loc 1 1436 0
 968 006e 0323     		movs	r3, #3
 969 0070 FB77     		strb	r3, [r7, #31]
 970 0072 0EE0     		b	.L56
 971              	.L60:
1437:Source/tasks.c **** 							}
1438:Source/tasks.c **** 						}
1439:Source/tasks.c **** 						#else
1440:Source/tasks.c **** 						{
1441:Source/tasks.c **** 							eReturn = eSuspended;
1442:Source/tasks.c **** 						}
1443:Source/tasks.c **** 						#endif
1444:Source/tasks.c **** 					}
1445:Source/tasks.c **** 					else
1446:Source/tasks.c **** 					{
1447:Source/tasks.c **** 						eReturn = eBlocked;
 972              		.loc 1 1447 0
 973 0074 0223     		movs	r3, #2
 974 0076 FB77     		strb	r3, [r7, #31]
 975 0078 0BE0     		b	.L56
 976              	.L59:
1448:Source/tasks.c **** 					}
1449:Source/tasks.c **** 				}
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 44
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 44
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


1450:Source/tasks.c **** 			#endif
1451:Source/tasks.c **** 
1452:Source/tasks.c **** 			#if ( INCLUDE_vTaskDelete == 1 )
1453:Source/tasks.c **** 				else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
 977              		.loc 1 1453 0
 978 007a 7B69     		ldr	r3, [r7, #20]
 979 007c 0B4A     		ldr	r2, .L67+16
 980 007e 9342     		cmp	r3, r2
 981 0080 02D0     		beq	.L64
 982              		.loc 1 1453 0 is_stmt 0 discriminator 1
 983 0082 7B69     		ldr	r3, [r7, #20]
 984 0084 002B     		cmp	r3, #0
 985 0086 02D1     		bne	.L65
 986              	.L64:
1454:Source/tasks.c **** 				{
1455:Source/tasks.c **** 					/* The task being queried is referenced from the deleted
1456:Source/tasks.c **** 					tasks list, or it is not referenced from any lists at
1457:Source/tasks.c **** 					all. */
1458:Source/tasks.c **** 					eReturn = eDeleted;
 987              		.loc 1 1458 0 is_stmt 1
 988 0088 0423     		movs	r3, #4
 989 008a FB77     		strb	r3, [r7, #31]
 990 008c 01E0     		b	.L56
 991              	.L65:
1459:Source/tasks.c **** 				}
1460:Source/tasks.c **** 			#endif
1461:Source/tasks.c **** 
1462:Source/tasks.c **** 			else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
1463:Source/tasks.c **** 			{
1464:Source/tasks.c **** 				/* If the task is not in any other state, it must be in the
1465:Source/tasks.c **** 				Ready (including pending ready) state. */
1466:Source/tasks.c **** 				eReturn = eReady;
 992              		.loc 1 1466 0
 993 008e 0123     		movs	r3, #1
 994 0090 FB77     		strb	r3, [r7, #31]
 995              	.L56:
1467:Source/tasks.c **** 			}
1468:Source/tasks.c **** 		}
1469:Source/tasks.c **** 
1470:Source/tasks.c **** 		return eReturn;
 996              		.loc 1 1470 0
 997 0092 FB7F     		ldrb	r3, [r7, #31]	@ zero_extendqisi2
1471:Source/tasks.c **** 	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
 998              		.loc 1 1471 0
 999 0094 1846     		mov	r0, r3
 1000 0096 2037     		adds	r7, r7, #32
 1001              		.cfi_def_cfa_offset 8
 1002 0098 BD46     		mov	sp, r7
 1003              		.cfi_def_cfa_register 13
 1004              		@ sp needed
 1005 009a 80BD     		pop	{r7, pc}
 1006              	.L68:
 1007              		.align	2
 1008              	.L67:
 1009 009c 00000000 		.word	pxCurrentTCB
 1010 00a0 90000000 		.word	pxDelayedTaskList
 1011 00a4 94000000 		.word	pxOverflowDelayedTaskList
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 45
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 45
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 1012 00a8 C4000000 		.word	xSuspendedTaskList
 1013 00ac AC000000 		.word	xTasksWaitingTermination
 1014              		.cfi_endproc
 1015              	.LFE74:
 1016              		.size	eTaskGetState, .-eTaskGetState
 1017              		.section	.text.uxTaskPriorityGet,"ax",%progbits
 1018              		.align	2
 1019              		.global	uxTaskPriorityGet
 1020              		.thumb
 1021              		.thumb_func
 1022              		.type	uxTaskPriorityGet, %function
 1023              	uxTaskPriorityGet:
 1024              	.LFB75:
1472:Source/tasks.c **** 
1473:Source/tasks.c **** #endif /* INCLUDE_eTaskGetState */
1474:Source/tasks.c **** /*-----------------------------------------------------------*/
1475:Source/tasks.c **** 
1476:Source/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
1477:Source/tasks.c **** 
1478:Source/tasks.c **** 	UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask )
1479:Source/tasks.c **** 	{
 1025              		.loc 1 1479 0
 1026              		.cfi_startproc
 1027              		@ args = 0, pretend = 0, frame = 16
 1028              		@ frame_needed = 1, uses_anonymous_args = 0
 1029 0000 80B5     		push	{r7, lr}
 1030              		.cfi_def_cfa_offset 8
 1031              		.cfi_offset 7, -8
 1032              		.cfi_offset 14, -4
 1033 0002 84B0     		sub	sp, sp, #16
 1034              		.cfi_def_cfa_offset 24
 1035 0004 00AF     		add	r7, sp, #0
 1036              		.cfi_def_cfa_register 7
 1037 0006 7860     		str	r0, [r7, #4]
1480:Source/tasks.c **** 	TCB_t const *pxTCB;
1481:Source/tasks.c **** 	UBaseType_t uxReturn;
1482:Source/tasks.c **** 
1483:Source/tasks.c **** 		taskENTER_CRITICAL();
 1038              		.loc 1 1483 0
 1039 0008 FFF7FEFF 		bl	vPortEnterCritical
1484:Source/tasks.c **** 		{
1485:Source/tasks.c **** 			/* If null is passed in here then it is the priority of the task
1486:Source/tasks.c **** 			that called uxTaskPriorityGet() that is being queried. */
1487:Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
 1040              		.loc 1 1487 0
 1041 000c 7B68     		ldr	r3, [r7, #4]
 1042 000e 002B     		cmp	r3, #0
 1043 0010 02D1     		bne	.L70
 1044              		.loc 1 1487 0 is_stmt 0 discriminator 1
 1045 0012 074B     		ldr	r3, .L73
 1046 0014 1B68     		ldr	r3, [r3]
 1047 0016 00E0     		b	.L71
 1048              	.L70:
 1049              		.loc 1 1487 0 discriminator 2
 1050 0018 7B68     		ldr	r3, [r7, #4]
 1051              	.L71:
 1052              		.loc 1 1487 0 discriminator 4
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 46
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 46
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 1053 001a FB60     		str	r3, [r7, #12]
1488:Source/tasks.c **** 			uxReturn = pxTCB->uxPriority;
 1054              		.loc 1 1488 0 is_stmt 1 discriminator 4
 1055 001c FB68     		ldr	r3, [r7, #12]
 1056 001e DB6A     		ldr	r3, [r3, #44]
 1057 0020 BB60     		str	r3, [r7, #8]
1489:Source/tasks.c **** 		}
1490:Source/tasks.c **** 		taskEXIT_CRITICAL();
 1058              		.loc 1 1490 0 discriminator 4
 1059 0022 FFF7FEFF 		bl	vPortExitCritical
1491:Source/tasks.c **** 
1492:Source/tasks.c **** 		return uxReturn;
 1060              		.loc 1 1492 0 discriminator 4
 1061 0026 BB68     		ldr	r3, [r7, #8]
1493:Source/tasks.c **** 	}
 1062              		.loc 1 1493 0 discriminator 4
 1063 0028 1846     		mov	r0, r3
 1064 002a 1037     		adds	r7, r7, #16
 1065              		.cfi_def_cfa_offset 8
 1066 002c BD46     		mov	sp, r7
 1067              		.cfi_def_cfa_register 13
 1068              		@ sp needed
 1069 002e 80BD     		pop	{r7, pc}
 1070              	.L74:
 1071              		.align	2
 1072              	.L73:
 1073 0030 00000000 		.word	pxCurrentTCB
 1074              		.cfi_endproc
 1075              	.LFE75:
 1076              		.size	uxTaskPriorityGet, .-uxTaskPriorityGet
 1077              		.section	.text.uxTaskPriorityGetFromISR,"ax",%progbits
 1078              		.align	2
 1079              		.global	uxTaskPriorityGetFromISR
 1080              		.thumb
 1081              		.thumb_func
 1082              		.type	uxTaskPriorityGetFromISR, %function
 1083              	uxTaskPriorityGetFromISR:
 1084              	.LFB76:
1494:Source/tasks.c **** 
1495:Source/tasks.c **** #endif /* INCLUDE_uxTaskPriorityGet */
1496:Source/tasks.c **** /*-----------------------------------------------------------*/
1497:Source/tasks.c **** 
1498:Source/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
1499:Source/tasks.c **** 
1500:Source/tasks.c **** 	UBaseType_t uxTaskPriorityGetFromISR( const TaskHandle_t xTask )
1501:Source/tasks.c **** 	{
 1085              		.loc 1 1501 0
 1086              		.cfi_startproc
 1087              		@ args = 0, pretend = 0, frame = 32
 1088              		@ frame_needed = 1, uses_anonymous_args = 0
 1089              		@ link register save eliminated.
 1090 0000 80B4     		push	{r7}
 1091              		.cfi_def_cfa_offset 4
 1092              		.cfi_offset 7, -4
 1093 0002 89B0     		sub	sp, sp, #36
 1094              		.cfi_def_cfa_offset 40
 1095 0004 00AF     		add	r7, sp, #0
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 47
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 47
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 1096              		.cfi_def_cfa_register 7
 1097 0006 7860     		str	r0, [r7, #4]
 1098              	.LBB29:
 1099              	.LBB30:
 1100              		.file 2 ".\\Source\\portable\\GCC\\ARM_CM3/portmacro.h"
   1:.\Source\portable\GCC\ARM_CM3/portmacro.h **** /*
   2:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * FreeRTOS Kernel V10.3.1
   3:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  *
   5:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   6:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * this software and associated documentation files (the "Software"), to deal in
   7:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * the Software without restriction, including without limitation the rights to
   8:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   9:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  10:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * subject to the following conditions:
  11:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  *
  12:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * The above copyright notice and this permission notice shall be included in all
  13:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * copies or substantial portions of the Software.
  14:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  *
  15:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  17:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  18:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  19:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  20:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  21:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  *
  22:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * http://www.FreeRTOS.org
  23:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * http://aws.amazon.com/freertos
  24:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  *
  25:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * 1 tab == 4 spaces!
  26:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  */
  27:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  28:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  29:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #ifndef PORTMACRO_H
  30:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define PORTMACRO_H
  31:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  32:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #ifdef __cplusplus
  33:.\Source\portable\GCC\ARM_CM3/portmacro.h **** extern "C" {
  34:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #endif
  35:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  36:.\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------
  37:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * Port specific definitions.
  38:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  *
  39:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * The settings in this file configure FreeRTOS correctly for the
  40:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * given hardware and compiler.
  41:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  *
  42:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  * These settings should not be altered.
  43:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  *-----------------------------------------------------------
  44:.\Source\portable\GCC\ARM_CM3/portmacro.h ****  */
  45:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  46:.\Source\portable\GCC\ARM_CM3/portmacro.h **** /* Type definitions. */
  47:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portCHAR		char
  48:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portFLOAT		float
  49:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portDOUBLE		double
  50:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portLONG		long
  51:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portSHORT		short
  52:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portSTACK_TYPE	uint32_t
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 48
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 48
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


  53:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portBASE_TYPE	long
  54:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  55:.\Source\portable\GCC\ARM_CM3/portmacro.h **** typedef portSTACK_TYPE StackType_t;
  56:.\Source\portable\GCC\ARM_CM3/portmacro.h **** typedef long BaseType_t;
  57:.\Source\portable\GCC\ARM_CM3/portmacro.h **** typedef unsigned long UBaseType_t;
  58:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  59:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #if( configUSE_16_BIT_TICKS == 1 )
  60:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	typedef uint16_t TickType_t;
  61:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#define portMAX_DELAY ( TickType_t ) 0xffff
  62:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #else
  63:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	typedef uint32_t TickType_t;
  64:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#define portMAX_DELAY ( TickType_t ) 0xffffffffUL
  65:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  66:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	/* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
  67:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	not need to be guarded with a critical section. */
  68:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#define portTICK_TYPE_IS_ATOMIC 1
  69:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #endif
  70:.\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
  71:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  72:.\Source\portable\GCC\ARM_CM3/portmacro.h **** /* Architecture specifics. */
  73:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portSTACK_GROWTH			( -1 )
  74:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portTICK_PERIOD_MS			( ( TickType_t ) 1000 / configTICK_RATE_HZ )
  75:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portBYTE_ALIGNMENT			8
  76:.\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
  77:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  78:.\Source\portable\GCC\ARM_CM3/portmacro.h **** /* Scheduler utilities. */
  79:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portYIELD() 															\
  80:.\Source\portable\GCC\ARM_CM3/portmacro.h **** {																				\
  81:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	/* Set a PendSV to request a context switch. */								\
  82:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;								\
  83:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 																				\
  84:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	/* Barriers are normally not required but do ensure the code is completely	\
  85:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	within the specified behaviour for the architecture. */						\
  86:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	__asm volatile( "dsb" ::: "memory" );										\
  87:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	__asm volatile( "isb" );													\
  88:.\Source\portable\GCC\ARM_CM3/portmacro.h **** }
  89:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  90:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portNVIC_INT_CTRL_REG		( * ( ( volatile uint32_t * ) 0xe000ed04 ) )
  91:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portNVIC_PENDSVSET_BIT		( 1UL << 28UL )
  92:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portEND_SWITCHING_ISR( xSwitchRequired ) if( xSwitchRequired != pdFALSE ) portYIELD()
  93:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portYIELD_FROM_ISR( x ) portEND_SWITCHING_ISR( x )
  94:.\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
  95:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  96:.\Source\portable\GCC\ARM_CM3/portmacro.h **** /* Critical section management. */
  97:.\Source\portable\GCC\ARM_CM3/portmacro.h **** extern void vPortEnterCritical( void );
  98:.\Source\portable\GCC\ARM_CM3/portmacro.h **** extern void vPortExitCritical( void );
  99:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portSET_INTERRUPT_MASK_FROM_ISR()		ulPortRaiseBASEPRI()
 100:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portCLEAR_INTERRUPT_MASK_FROM_ISR(x)	vPortSetBASEPRI(x)
 101:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portDISABLE_INTERRUPTS()				vPortRaiseBASEPRI()
 102:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portENABLE_INTERRUPTS()					vPortSetBASEPRI(0)
 103:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portENTER_CRITICAL()					vPortEnterCritical()
 104:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portEXIT_CRITICAL()						vPortExitCritical()
 105:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 106:.\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 107:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 108:.\Source\portable\GCC\ARM_CM3/portmacro.h **** /* Task function macros as described on the FreeRTOS.org WEB site.  These are
 109:.\Source\portable\GCC\ARM_CM3/portmacro.h **** not necessary for to use this port.  They are defined so the common demo files
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 49
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 49
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 110:.\Source\portable\GCC\ARM_CM3/portmacro.h **** (which build with all the ports) will build. */
 111:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portTASK_FUNCTION_PROTO( vFunction, pvParameters ) void vFunction( void *pvParameters )
 112:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portTASK_FUNCTION( vFunction, pvParameters ) void vFunction( void *pvParameters )
 113:.\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 114:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 115:.\Source\portable\GCC\ARM_CM3/portmacro.h **** /* Tickless idle/low power functionality. */
 116:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #ifndef portSUPPRESS_TICKS_AND_SLEEP
 117:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	extern void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime );
 118:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime ) vPortSuppressTicksAndSleep( xExpectedIdl
 119:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #endif
 120:.\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 121:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 122:.\Source\portable\GCC\ARM_CM3/portmacro.h **** /* Architecture specific optimisations. */
 123:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
 124:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#define configUSE_PORT_OPTIMISED_TASK_SELECTION 1
 125:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #endif
 126:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 127:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #if configUSE_PORT_OPTIMISED_TASK_SELECTION == 1
 128:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 129:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	/* Generic helper function. */
 130:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	__attribute__( ( always_inline ) ) static inline uint8_t ucPortCountLeadingZeros( uint32_t ulBitma
 131:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	{
 132:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	uint8_t ucReturn;
 133:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 134:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
 135:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 		return ucReturn;
 136:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	}
 137:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 138:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	/* Check the configuration. */
 139:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#if( configMAX_PRIORITIES > 32 )
 140:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 		#error configUSE_PORT_OPTIMISED_TASK_SELECTION can only be set to 1 when configMAX_PRIORITIES is 
 141:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#endif
 142:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 143:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	/* Store/clear the ready priorities in a bit map. */
 144:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#define portRECORD_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) |= ( 1UL 
 145:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#define portRESET_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) &= ~( 1UL 
 146:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 147:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	/*-----------------------------------------------------------*/
 148:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 149:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#define portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities ) uxTopPriority = ( 31UL - ( ui
 150:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 151:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 152:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 153:.\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 154:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 155:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #ifdef configASSERT
 156:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	void vPortValidateInterruptPriority( void );
 157:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#define portASSERT_IF_INTERRUPT_PRIORITY_INVALID() 	vPortValidateInterruptPriority()
 158:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #endif
 159:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 160:.\Source\portable\GCC\ARM_CM3/portmacro.h **** /* portNOP() is not required by this port. */
 161:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portNOP()
 162:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 163:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portINLINE	__inline
 164:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 165:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #ifndef portFORCE_INLINE
 166:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#define portFORCE_INLINE inline __attribute__(( always_inline))
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 50
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 50
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 167:.\Source\portable\GCC\ARM_CM3/portmacro.h **** #endif
 168:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 169:.\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 170:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 171:.\Source\portable\GCC\ARM_CM3/portmacro.h **** portFORCE_INLINE static BaseType_t xPortIsInsideInterrupt( void )
 172:.\Source\portable\GCC\ARM_CM3/portmacro.h **** {
 173:.\Source\portable\GCC\ARM_CM3/portmacro.h **** uint32_t ulCurrentInterrupt;
 174:.\Source\portable\GCC\ARM_CM3/portmacro.h **** BaseType_t xReturn;
 175:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 176:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	/* Obtain the number of the currently executing interrupt. */
 177:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
 178:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 179:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	if( ulCurrentInterrupt == 0 )
 180:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	{
 181:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 		xReturn = pdFALSE;
 182:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	}
 183:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	else
 184:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	{
 185:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 		xReturn = pdTRUE;
 186:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	}
 187:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 188:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	return xReturn;
 189:.\Source\portable\GCC\ARM_CM3/portmacro.h **** }
 190:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 191:.\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 192:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 193:.\Source\portable\GCC\ARM_CM3/portmacro.h **** portFORCE_INLINE static void vPortRaiseBASEPRI( void )
 194:.\Source\portable\GCC\ARM_CM3/portmacro.h **** {
 195:.\Source\portable\GCC\ARM_CM3/portmacro.h **** uint32_t ulNewBASEPRI;
 196:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 197:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	__asm volatile
 198:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	(
 199:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 		"	mov %0, %1												\n" \
 200:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 		"	msr basepri, %0											\n" \
 201:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 		"	isb														\n" \
 202:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 		"	dsb														\n" \
 203:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 		:"=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
 204:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	);
 205:.\Source\portable\GCC\ARM_CM3/portmacro.h **** }
 206:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 207:.\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 208:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 209:.\Source\portable\GCC\ARM_CM3/portmacro.h **** portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
 210:.\Source\portable\GCC\ARM_CM3/portmacro.h **** {
 211:.\Source\portable\GCC\ARM_CM3/portmacro.h **** uint32_t ulOriginalBASEPRI, ulNewBASEPRI;
 212:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 213:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	__asm volatile
 1101              		.loc 2 213 0
 1102              		.syntax unified
 1103              	@ 213 ".\Source\portable\GCC\ARM_CM3/portmacro.h" 1
 1104 0008 EFF31182 			mrs r2, basepri											
 1105 000c 4FF0A003 		mov r3, #160												
 1106 0010 83F31188 		msr basepri, r3											
 1107 0014 BFF36F8F 		isb														
 1108 0018 BFF34F8F 		dsb														
 1109              	
 1110              	@ 0 "" 2
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 51
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 51
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 1111              		.thumb
 1112              		.syntax unified
 1113 001c FA60     		str	r2, [r7, #12]
 1114 001e BB60     		str	r3, [r7, #8]
 214:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	(
 215:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 		"	mrs %0, basepri											\n" \
 216:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 		"	mov %1, %2												\n" \
 217:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 		"	msr basepri, %1											\n" \
 218:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 		"	isb														\n" \
 219:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 		"	dsb														\n" \
 220:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "
 221:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	);
 222:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 223:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	/* This return will not be reached but is necessary to prevent compiler
 224:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	warnings. */
 225:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	return ulOriginalBASEPRI;
 1115              		.loc 2 225 0
 1116 0020 FB68     		ldr	r3, [r7, #12]
 1117              	.LBE30:
 1118              	.LBE29:
1502:Source/tasks.c **** 	TCB_t const *pxTCB;
1503:Source/tasks.c **** 	UBaseType_t uxReturn, uxSavedInterruptState;
1504:Source/tasks.c **** 
1505:Source/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
1506:Source/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
1507:Source/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
1508:Source/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
1509:Source/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
1510:Source/tasks.c **** 		is defined in FreeRTOSConfig.h then
1511:Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1512:Source/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
1513:Source/tasks.c **** 		been assigned a priority above the configured maximum system call
1514:Source/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
1515:Source/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
1516:Source/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
1517:Source/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
1518:Source/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
1519:Source/tasks.c **** 		provided on the following link:
1520:Source/tasks.c **** 		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
1521:Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1522:Source/tasks.c **** 
1523:Source/tasks.c **** 		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
 1119              		.loc 1 1523 0
 1120 0022 BB61     		str	r3, [r7, #24]
1524:Source/tasks.c **** 		{
1525:Source/tasks.c **** 			/* If null is passed in here then it is the priority of the calling
1526:Source/tasks.c **** 			task that is being queried. */
1527:Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
 1121              		.loc 1 1527 0
 1122 0024 7B68     		ldr	r3, [r7, #4]
 1123 0026 002B     		cmp	r3, #0
 1124 0028 02D1     		bne	.L77
 1125              		.loc 1 1527 0 is_stmt 0 discriminator 1
 1126 002a 094B     		ldr	r3, .L80
 1127 002c 1B68     		ldr	r3, [r3]
 1128 002e 00E0     		b	.L78
 1129              	.L77:
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 52
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 52
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 1130              		.loc 1 1527 0 discriminator 2
 1131 0030 7B68     		ldr	r3, [r7, #4]
 1132              	.L78:
 1133              		.loc 1 1527 0 discriminator 4
 1134 0032 7B61     		str	r3, [r7, #20]
1528:Source/tasks.c **** 			uxReturn = pxTCB->uxPriority;
 1135              		.loc 1 1528 0 is_stmt 1 discriminator 4
 1136 0034 7B69     		ldr	r3, [r7, #20]
 1137 0036 DB6A     		ldr	r3, [r3, #44]
 1138 0038 3B61     		str	r3, [r7, #16]
 1139 003a BB69     		ldr	r3, [r7, #24]
 1140 003c FB61     		str	r3, [r7, #28]
 1141              	.LBB31:
 1142              	.LBB32:
 226:.\Source\portable\GCC\ARM_CM3/portmacro.h **** }
 227:.\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 228:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 229:.\Source\portable\GCC\ARM_CM3/portmacro.h **** portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
 230:.\Source\portable\GCC\ARM_CM3/portmacro.h **** {
 231:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	__asm volatile
 1143              		.loc 2 231 0 discriminator 4
 1144 003e FB69     		ldr	r3, [r7, #28]
 1145              		.syntax unified
 1146              	@ 231 ".\Source\portable\GCC\ARM_CM3/portmacro.h" 1
 1147 0040 83F31188 			msr basepri, r3	
 1148              	@ 0 "" 2
 1149              		.thumb
 1150              		.syntax unified
 1151              	.LBE32:
 1152              	.LBE31:
1529:Source/tasks.c **** 		}
1530:Source/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );
1531:Source/tasks.c **** 
1532:Source/tasks.c **** 		return uxReturn;
 1153              		.loc 1 1532 0 discriminator 4
 1154 0044 3B69     		ldr	r3, [r7, #16]
1533:Source/tasks.c **** 	}
 1155              		.loc 1 1533 0 discriminator 4
 1156 0046 1846     		mov	r0, r3
 1157 0048 2437     		adds	r7, r7, #36
 1158              		.cfi_def_cfa_offset 4
 1159 004a BD46     		mov	sp, r7
 1160              		.cfi_def_cfa_register 13
 1161              		@ sp needed
 1162 004c 80BC     		pop	{r7}
 1163              		.cfi_restore 7
 1164              		.cfi_def_cfa_offset 0
 1165 004e 7047     		bx	lr
 1166              	.L81:
 1167              		.align	2
 1168              	.L80:
 1169 0050 00000000 		.word	pxCurrentTCB
 1170              		.cfi_endproc
 1171              	.LFE76:
 1172              		.size	uxTaskPriorityGetFromISR, .-uxTaskPriorityGetFromISR
 1173              		.section	.text.vTaskPrioritySet,"ax",%progbits
 1174              		.align	2
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 53
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 53
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 1175              		.global	vTaskPrioritySet
 1176              		.thumb
 1177              		.thumb_func
 1178              		.type	vTaskPrioritySet, %function
 1179              	vTaskPrioritySet:
 1180              	.LFB77:
1534:Source/tasks.c **** 
1535:Source/tasks.c **** #endif /* INCLUDE_uxTaskPriorityGet */
1536:Source/tasks.c **** /*-----------------------------------------------------------*/
1537:Source/tasks.c **** 
1538:Source/tasks.c **** #if ( INCLUDE_vTaskPrioritySet == 1 )
1539:Source/tasks.c **** 
1540:Source/tasks.c **** 	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
1541:Source/tasks.c **** 	{
 1181              		.loc 1 1541 0
 1182              		.cfi_startproc
 1183              		@ args = 0, pretend = 0, frame = 24
 1184              		@ frame_needed = 1, uses_anonymous_args = 0
 1185 0000 80B5     		push	{r7, lr}
 1186              		.cfi_def_cfa_offset 8
 1187              		.cfi_offset 7, -8
 1188              		.cfi_offset 14, -4
 1189 0002 86B0     		sub	sp, sp, #24
 1190              		.cfi_def_cfa_offset 32
 1191 0004 00AF     		add	r7, sp, #0
 1192              		.cfi_def_cfa_register 7
 1193 0006 7860     		str	r0, [r7, #4]
 1194 0008 3960     		str	r1, [r7]
1542:Source/tasks.c **** 	TCB_t *pxTCB;
1543:Source/tasks.c **** 	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
1544:Source/tasks.c **** 	BaseType_t xYieldRequired = pdFALSE;
 1195              		.loc 1 1544 0
 1196 000a 0023     		movs	r3, #0
 1197 000c 7B61     		str	r3, [r7, #20]
1545:Source/tasks.c **** 
1546:Source/tasks.c **** 		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
1547:Source/tasks.c **** 
1548:Source/tasks.c **** 		/* Ensure the new priority is valid. */
1549:Source/tasks.c **** 		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 1198              		.loc 1 1549 0
 1199 000e 3B68     		ldr	r3, [r7]
 1200 0010 042B     		cmp	r3, #4
 1201 0012 01D9     		bls	.L83
1550:Source/tasks.c **** 		{
1551:Source/tasks.c **** 			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 1202              		.loc 1 1551 0
 1203 0014 0423     		movs	r3, #4
 1204 0016 3B60     		str	r3, [r7]
 1205              	.L83:
1552:Source/tasks.c **** 		}
1553:Source/tasks.c **** 		else
1554:Source/tasks.c **** 		{
1555:Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1556:Source/tasks.c **** 		}
1557:Source/tasks.c **** 
1558:Source/tasks.c **** 		taskENTER_CRITICAL();
 1206              		.loc 1 1558 0
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 54
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 54
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 1207 0018 FFF7FEFF 		bl	vPortEnterCritical
1559:Source/tasks.c **** 		{
1560:Source/tasks.c **** 			/* If null is passed in here then it is the priority of the calling
1561:Source/tasks.c **** 			task that is being changed. */
1562:Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
 1208              		.loc 1 1562 0
 1209 001c 7B68     		ldr	r3, [r7, #4]
 1210 001e 002B     		cmp	r3, #0
 1211 0020 02D1     		bne	.L84
 1212              		.loc 1 1562 0 is_stmt 0 discriminator 1
 1213 0022 414B     		ldr	r3, .L93
 1214 0024 1B68     		ldr	r3, [r3]
 1215 0026 00E0     		b	.L85
 1216              	.L84:
 1217              		.loc 1 1562 0 discriminator 2
 1218 0028 7B68     		ldr	r3, [r7, #4]
 1219              	.L85:
 1220              		.loc 1 1562 0 discriminator 4
 1221 002a 3B61     		str	r3, [r7, #16]
1563:Source/tasks.c **** 
1564:Source/tasks.c **** 			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
1565:Source/tasks.c **** 
1566:Source/tasks.c **** 			#if ( configUSE_MUTEXES == 1 )
1567:Source/tasks.c **** 			{
1568:Source/tasks.c **** 				uxCurrentBasePriority = pxTCB->uxBasePriority;
 1222              		.loc 1 1568 0 is_stmt 1 discriminator 4
 1223 002c 3B69     		ldr	r3, [r7, #16]
 1224 002e 1B6C     		ldr	r3, [r3, #64]
 1225 0030 FB60     		str	r3, [r7, #12]
1569:Source/tasks.c **** 			}
1570:Source/tasks.c **** 			#else
1571:Source/tasks.c **** 			{
1572:Source/tasks.c **** 				uxCurrentBasePriority = pxTCB->uxPriority;
1573:Source/tasks.c **** 			}
1574:Source/tasks.c **** 			#endif
1575:Source/tasks.c **** 
1576:Source/tasks.c **** 			if( uxCurrentBasePriority != uxNewPriority )
 1226              		.loc 1 1576 0 discriminator 4
 1227 0032 FA68     		ldr	r2, [r7, #12]
 1228 0034 3B68     		ldr	r3, [r7]
 1229 0036 9A42     		cmp	r2, r3
 1230 0038 6FD0     		beq	.L86
1577:Source/tasks.c **** 			{
1578:Source/tasks.c **** 				/* The priority change may have readied a task of higher
1579:Source/tasks.c **** 				priority than the calling task. */
1580:Source/tasks.c **** 				if( uxNewPriority > uxCurrentBasePriority )
 1231              		.loc 1 1580 0
 1232 003a 3A68     		ldr	r2, [r7]
 1233 003c FB68     		ldr	r3, [r7, #12]
 1234 003e 9A42     		cmp	r2, r3
 1235 0040 0DD9     		bls	.L87
1581:Source/tasks.c **** 				{
1582:Source/tasks.c **** 					if( pxTCB != pxCurrentTCB )
 1236              		.loc 1 1582 0
 1237 0042 394B     		ldr	r3, .L93
 1238 0044 1B68     		ldr	r3, [r3]
 1239 0046 3A69     		ldr	r2, [r7, #16]
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 55
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 55
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 1240 0048 9A42     		cmp	r2, r3
 1241 004a 0FD0     		beq	.L88
1583:Source/tasks.c **** 					{
1584:Source/tasks.c **** 						/* The priority of a task other than the currently
1585:Source/tasks.c **** 						running task is being raised.  Is the priority being
1586:Source/tasks.c **** 						raised above that of the running task? */
1587:Source/tasks.c **** 						if( uxNewPriority >= pxCurrentTCB->uxPriority )
 1242              		.loc 1 1587 0
 1243 004c 364B     		ldr	r3, .L93
 1244 004e 1B68     		ldr	r3, [r3]
 1245 0050 DA6A     		ldr	r2, [r3, #44]
 1246 0052 3B68     		ldr	r3, [r7]
 1247 0054 9A42     		cmp	r2, r3
 1248 0056 09D8     		bhi	.L88
1588:Source/tasks.c **** 						{
1589:Source/tasks.c **** 							xYieldRequired = pdTRUE;
 1249              		.loc 1 1589 0
 1250 0058 0123     		movs	r3, #1
 1251 005a 7B61     		str	r3, [r7, #20]
 1252 005c 06E0     		b	.L88
 1253              	.L87:
1590:Source/tasks.c **** 						}
1591:Source/tasks.c **** 						else
1592:Source/tasks.c **** 						{
1593:Source/tasks.c **** 							mtCOVERAGE_TEST_MARKER();
1594:Source/tasks.c **** 						}
1595:Source/tasks.c **** 					}
1596:Source/tasks.c **** 					else
1597:Source/tasks.c **** 					{
1598:Source/tasks.c **** 						/* The priority of the running task is being raised,
1599:Source/tasks.c **** 						but the running task must already be the highest
1600:Source/tasks.c **** 						priority task able to run so no yield is required. */
1601:Source/tasks.c **** 					}
1602:Source/tasks.c **** 				}
1603:Source/tasks.c **** 				else if( pxTCB == pxCurrentTCB )
 1254              		.loc 1 1603 0
 1255 005e 324B     		ldr	r3, .L93
 1256 0060 1B68     		ldr	r3, [r3]
 1257 0062 3A69     		ldr	r2, [r7, #16]
 1258 0064 9A42     		cmp	r2, r3
 1259 0066 01D1     		bne	.L88
1604:Source/tasks.c **** 				{
1605:Source/tasks.c **** 					/* Setting the priority of the running task down means
1606:Source/tasks.c **** 					there may now be another task of higher priority that
1607:Source/tasks.c **** 					is ready to execute. */
1608:Source/tasks.c **** 					xYieldRequired = pdTRUE;
 1260              		.loc 1 1608 0
 1261 0068 0123     		movs	r3, #1
 1262 006a 7B61     		str	r3, [r7, #20]
 1263              	.L88:
1609:Source/tasks.c **** 				}
1610:Source/tasks.c **** 				else
1611:Source/tasks.c **** 				{
1612:Source/tasks.c **** 					/* Setting the priority of any other task down does not
1613:Source/tasks.c **** 					require a yield as the running task must be above the
1614:Source/tasks.c **** 					new priority of the task being modified. */
1615:Source/tasks.c **** 				}
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 56
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 56
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


1616:Source/tasks.c **** 
1617:Source/tasks.c **** 				/* Remember the ready list the task might be referenced from
1618:Source/tasks.c **** 				before its uxPriority member is changed so the
1619:Source/tasks.c **** 				taskRESET_READY_PRIORITY() macro can function correctly. */
1620:Source/tasks.c **** 				uxPriorityUsedOnEntry = pxTCB->uxPriority;
 1264              		.loc 1 1620 0
 1265 006c 3B69     		ldr	r3, [r7, #16]
 1266 006e DB6A     		ldr	r3, [r3, #44]
 1267 0070 BB60     		str	r3, [r7, #8]
1621:Source/tasks.c **** 
1622:Source/tasks.c **** 				#if ( configUSE_MUTEXES == 1 )
1623:Source/tasks.c **** 				{
1624:Source/tasks.c **** 					/* Only change the priority being used if the task is not
1625:Source/tasks.c **** 					currently using an inherited priority. */
1626:Source/tasks.c **** 					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 1268              		.loc 1 1626 0
 1269 0072 3B69     		ldr	r3, [r7, #16]
 1270 0074 1A6C     		ldr	r2, [r3, #64]
 1271 0076 3B69     		ldr	r3, [r7, #16]
 1272 0078 DB6A     		ldr	r3, [r3, #44]
 1273 007a 9A42     		cmp	r2, r3
 1274 007c 02D1     		bne	.L89
1627:Source/tasks.c **** 					{
1628:Source/tasks.c **** 						pxTCB->uxPriority = uxNewPriority;
 1275              		.loc 1 1628 0
 1276 007e 3B69     		ldr	r3, [r7, #16]
 1277 0080 3A68     		ldr	r2, [r7]
 1278 0082 DA62     		str	r2, [r3, #44]
 1279              	.L89:
1629:Source/tasks.c **** 					}
1630:Source/tasks.c **** 					else
1631:Source/tasks.c **** 					{
1632:Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1633:Source/tasks.c **** 					}
1634:Source/tasks.c **** 
1635:Source/tasks.c **** 					/* The base priority gets set whatever. */
1636:Source/tasks.c **** 					pxTCB->uxBasePriority = uxNewPriority;
 1280              		.loc 1 1636 0
 1281 0084 3B69     		ldr	r3, [r7, #16]
 1282 0086 3A68     		ldr	r2, [r7]
 1283 0088 1A64     		str	r2, [r3, #64]
1637:Source/tasks.c **** 				}
1638:Source/tasks.c **** 				#else
1639:Source/tasks.c **** 				{
1640:Source/tasks.c **** 					pxTCB->uxPriority = uxNewPriority;
1641:Source/tasks.c **** 				}
1642:Source/tasks.c **** 				#endif
1643:Source/tasks.c **** 
1644:Source/tasks.c **** 				/* Only reset the event list item value if the value is not
1645:Source/tasks.c **** 				being used for anything else. */
1646:Source/tasks.c **** 				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE 
 1284              		.loc 1 1646 0
 1285 008a 3B69     		ldr	r3, [r7, #16]
 1286 008c 9B69     		ldr	r3, [r3, #24]
 1287 008e 002B     		cmp	r3, #0
 1288 0090 04DB     		blt	.L90
1647:Source/tasks.c **** 				{
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 57
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 57
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


1648:Source/tasks.c **** 					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - (
 1289              		.loc 1 1648 0
 1290 0092 3B68     		ldr	r3, [r7]
 1291 0094 C3F10502 		rsb	r2, r3, #5
 1292 0098 3B69     		ldr	r3, [r7, #16]
 1293 009a 9A61     		str	r2, [r3, #24]
 1294              	.L90:
1649:Source/tasks.c **** 				}
1650:Source/tasks.c **** 				else
1651:Source/tasks.c **** 				{
1652:Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1653:Source/tasks.c **** 				}
1654:Source/tasks.c **** 
1655:Source/tasks.c **** 				/* If the task is in the blocked or suspended list we need do
1656:Source/tasks.c **** 				nothing more than change its priority variable. However, if
1657:Source/tasks.c **** 				the task is in a ready list it needs to be removed and placed
1658:Source/tasks.c **** 				in the list appropriate to its new priority. */
1659:Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateL
 1295              		.loc 1 1659 0
 1296 009c 3B69     		ldr	r3, [r7, #16]
 1297 009e 5969     		ldr	r1, [r3, #20]
 1298 00a0 BA68     		ldr	r2, [r7, #8]
 1299 00a2 1346     		mov	r3, r2
 1300 00a4 9B00     		lsls	r3, r3, #2
 1301 00a6 1344     		add	r3, r3, r2
 1302 00a8 9B00     		lsls	r3, r3, #2
 1303 00aa 204A     		ldr	r2, .L93+4
 1304 00ac 1344     		add	r3, r3, r2
 1305 00ae 9942     		cmp	r1, r3
 1306 00b0 28D1     		bne	.L91
1660:Source/tasks.c **** 				{
1661:Source/tasks.c **** 					/* The task is currently in its ready list - remove before
1662:Source/tasks.c **** 					adding it to it's new ready list.  As we are in a critical
1663:Source/tasks.c **** 					section we can do this even if the scheduler is suspended. */
1664:Source/tasks.c **** 					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 1307              		.loc 1 1664 0
 1308 00b2 3B69     		ldr	r3, [r7, #16]
 1309 00b4 0433     		adds	r3, r3, #4
 1310 00b6 1846     		mov	r0, r3
 1311 00b8 FFF7FEFF 		bl	uxListRemove
 1312 00bc 0346     		mov	r3, r0
 1313 00be 002B     		cmp	r3, #0
 1314 00c0 09D1     		bne	.L92
1665:Source/tasks.c **** 					{
1666:Source/tasks.c **** 						/* It is known that the task is in its ready list so
1667:Source/tasks.c **** 						there is no need to check again and the port level
1668:Source/tasks.c **** 						reset macro can be called directly. */
1669:Source/tasks.c **** 						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
 1315              		.loc 1 1669 0
 1316 00c2 0122     		movs	r2, #1
 1317 00c4 BB68     		ldr	r3, [r7, #8]
 1318 00c6 02FA03F3 		lsl	r3, r2, r3
 1319 00ca DA43     		mvns	r2, r3
 1320 00cc 184B     		ldr	r3, .L93+8
 1321 00ce 1B68     		ldr	r3, [r3]
 1322 00d0 1340     		ands	r3, r3, r2
 1323 00d2 174A     		ldr	r2, .L93+8
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 58
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 58
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 1324 00d4 1360     		str	r3, [r2]
 1325              	.L92:
1670:Source/tasks.c **** 					}
1671:Source/tasks.c **** 					else
1672:Source/tasks.c **** 					{
1673:Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1674:Source/tasks.c **** 					}
1675:Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1326              		.loc 1 1675 0
 1327 00d6 3B69     		ldr	r3, [r7, #16]
 1328 00d8 DB6A     		ldr	r3, [r3, #44]
 1329 00da 0122     		movs	r2, #1
 1330 00dc 9A40     		lsls	r2, r2, r3
 1331 00de 144B     		ldr	r3, .L93+8
 1332 00e0 1B68     		ldr	r3, [r3]
 1333 00e2 1343     		orrs	r3, r3, r2
 1334 00e4 124A     		ldr	r2, .L93+8
 1335 00e6 1360     		str	r3, [r2]
 1336 00e8 3B69     		ldr	r3, [r7, #16]
 1337 00ea DA6A     		ldr	r2, [r3, #44]
 1338 00ec 1346     		mov	r3, r2
 1339 00ee 9B00     		lsls	r3, r3, #2
 1340 00f0 1344     		add	r3, r3, r2
 1341 00f2 9B00     		lsls	r3, r3, #2
 1342 00f4 0D4A     		ldr	r2, .L93+4
 1343 00f6 1A44     		add	r2, r2, r3
 1344 00f8 3B69     		ldr	r3, [r7, #16]
 1345 00fa 0433     		adds	r3, r3, #4
 1346 00fc 1946     		mov	r1, r3
 1347 00fe 1046     		mov	r0, r2
 1348 0100 FFF7FEFF 		bl	vListInsertEnd
 1349              	.L91:
1676:Source/tasks.c **** 				}
1677:Source/tasks.c **** 				else
1678:Source/tasks.c **** 				{
1679:Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1680:Source/tasks.c **** 				}
1681:Source/tasks.c **** 
1682:Source/tasks.c **** 				if( xYieldRequired != pdFALSE )
 1350              		.loc 1 1682 0
 1351 0104 7B69     		ldr	r3, [r7, #20]
 1352 0106 002B     		cmp	r3, #0
 1353 0108 07D0     		beq	.L86
1683:Source/tasks.c **** 				{
1684:Source/tasks.c **** 					taskYIELD_IF_USING_PREEMPTION();
 1354              		.loc 1 1684 0
 1355 010a 0A4B     		ldr	r3, .L93+12
 1356 010c 4FF08052 		mov	r2, #268435456
 1357 0110 1A60     		str	r2, [r3]
 1358              		.syntax unified
 1359              	@ 1684 "Source\tasks.c" 1
 1360 0112 BFF34F8F 		dsb
 1361              	@ 0 "" 2
 1362              	@ 1684 "Source\tasks.c" 1
 1363 0116 BFF36F8F 		isb
 1364              	@ 0 "" 2
 1365              		.thumb
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 59
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 59
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 1366              		.syntax unified
 1367              	.L86:
1685:Source/tasks.c **** 				}
1686:Source/tasks.c **** 				else
1687:Source/tasks.c **** 				{
1688:Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1689:Source/tasks.c **** 				}
1690:Source/tasks.c **** 
1691:Source/tasks.c **** 				/* Remove compiler warning about unused variables when the port
1692:Source/tasks.c **** 				optimised task selection is not being used. */
1693:Source/tasks.c **** 				( void ) uxPriorityUsedOnEntry;
1694:Source/tasks.c **** 			}
1695:Source/tasks.c **** 		}
1696:Source/tasks.c **** 		taskEXIT_CRITICAL();
 1368              		.loc 1 1696 0
 1369 011a FFF7FEFF 		bl	vPortExitCritical
1697:Source/tasks.c **** 	}
 1370              		.loc 1 1697 0
 1371 011e 00BF     		nop
 1372 0120 1837     		adds	r7, r7, #24
 1373              		.cfi_def_cfa_offset 8
 1374 0122 BD46     		mov	sp, r7
 1375              		.cfi_def_cfa_register 13
 1376              		@ sp needed
 1377 0124 80BD     		pop	{r7, pc}
 1378              	.L94:
 1379 0126 00BF     		.align	2
 1380              	.L93:
 1381 0128 00000000 		.word	pxCurrentTCB
 1382 012c 04000000 		.word	pxReadyTasksLists
 1383 0130 E0000000 		.word	uxTopReadyPriority
 1384 0134 04ED00E0 		.word	-536810236
 1385              		.cfi_endproc
 1386              	.LFE77:
 1387              		.size	vTaskPrioritySet, .-vTaskPrioritySet
 1388              		.section	.text.vTaskSuspend,"ax",%progbits
 1389              		.align	2
 1390              		.global	vTaskSuspend
 1391              		.thumb
 1392              		.thumb_func
 1393              		.type	vTaskSuspend, %function
 1394              	vTaskSuspend:
 1395              	.LFB78:
1698:Source/tasks.c **** 
1699:Source/tasks.c **** #endif /* INCLUDE_vTaskPrioritySet */
1700:Source/tasks.c **** /*-----------------------------------------------------------*/
1701:Source/tasks.c **** 
1702:Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1703:Source/tasks.c **** 
1704:Source/tasks.c **** 	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
1705:Source/tasks.c **** 	{
 1396              		.loc 1 1705 0
 1397              		.cfi_startproc
 1398              		@ args = 0, pretend = 0, frame = 16
 1399              		@ frame_needed = 1, uses_anonymous_args = 0
 1400 0000 80B5     		push	{r7, lr}
 1401              		.cfi_def_cfa_offset 8
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 60
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 60
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 1402              		.cfi_offset 7, -8
 1403              		.cfi_offset 14, -4
 1404 0002 84B0     		sub	sp, sp, #16
 1405              		.cfi_def_cfa_offset 24
 1406 0004 00AF     		add	r7, sp, #0
 1407              		.cfi_def_cfa_register 7
 1408 0006 7860     		str	r0, [r7, #4]
1706:Source/tasks.c **** 	TCB_t *pxTCB;
1707:Source/tasks.c **** 
1708:Source/tasks.c **** 		taskENTER_CRITICAL();
 1409              		.loc 1 1708 0
 1410 0008 FFF7FEFF 		bl	vPortEnterCritical
1709:Source/tasks.c **** 		{
1710:Source/tasks.c **** 			/* If null is passed in here then it is the running task that is
1711:Source/tasks.c **** 			being suspended. */
1712:Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
 1411              		.loc 1 1712 0
 1412 000c 7B68     		ldr	r3, [r7, #4]
 1413 000e 002B     		cmp	r3, #0
 1414 0010 02D1     		bne	.L96
 1415              		.loc 1 1712 0 is_stmt 0 discriminator 1
 1416 0012 354B     		ldr	r3, .L108
 1417 0014 1B68     		ldr	r3, [r3]
 1418 0016 00E0     		b	.L97
 1419              	.L96:
 1420              		.loc 1 1712 0 discriminator 2
 1421 0018 7B68     		ldr	r3, [r7, #4]
 1422              	.L97:
 1423              		.loc 1 1712 0 discriminator 4
 1424 001a FB60     		str	r3, [r7, #12]
1713:Source/tasks.c **** 
1714:Source/tasks.c **** 			traceTASK_SUSPEND( pxTCB );
1715:Source/tasks.c **** 
1716:Source/tasks.c **** 			/* Remove task from the ready/delayed list and place in the
1717:Source/tasks.c **** 			suspended list. */
1718:Source/tasks.c **** 			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 1425              		.loc 1 1718 0 is_stmt 1 discriminator 4
 1426 001c FB68     		ldr	r3, [r7, #12]
 1427 001e 0433     		adds	r3, r3, #4
 1428 0020 1846     		mov	r0, r3
 1429 0022 FFF7FEFF 		bl	uxListRemove
 1430 0026 0346     		mov	r3, r0
 1431 0028 002B     		cmp	r3, #0
 1432 002a 15D1     		bne	.L98
1719:Source/tasks.c **** 			{
1720:Source/tasks.c **** 				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 1433              		.loc 1 1720 0
 1434 002c FB68     		ldr	r3, [r7, #12]
 1435 002e DA6A     		ldr	r2, [r3, #44]
 1436 0030 2E49     		ldr	r1, .L108+4
 1437 0032 1346     		mov	r3, r2
 1438 0034 9B00     		lsls	r3, r3, #2
 1439 0036 1344     		add	r3, r3, r2
 1440 0038 9B00     		lsls	r3, r3, #2
 1441 003a 0B44     		add	r3, r3, r1
 1442 003c 1B68     		ldr	r3, [r3]
 1443 003e 002B     		cmp	r3, #0
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 61
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 61
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 1444 0040 0AD1     		bne	.L98
 1445              		.loc 1 1720 0 is_stmt 0 discriminator 1
 1446 0042 FB68     		ldr	r3, [r7, #12]
 1447 0044 DB6A     		ldr	r3, [r3, #44]
 1448 0046 0122     		movs	r2, #1
 1449 0048 02FA03F3 		lsl	r3, r2, r3
 1450 004c DA43     		mvns	r2, r3
 1451 004e 284B     		ldr	r3, .L108+8
 1452 0050 1B68     		ldr	r3, [r3]
 1453 0052 1340     		ands	r3, r3, r2
 1454 0054 264A     		ldr	r2, .L108+8
 1455 0056 1360     		str	r3, [r2]
 1456              	.L98:
1721:Source/tasks.c **** 			}
1722:Source/tasks.c **** 			else
1723:Source/tasks.c **** 			{
1724:Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1725:Source/tasks.c **** 			}
1726:Source/tasks.c **** 
1727:Source/tasks.c **** 			/* Is the task waiting on an event also? */
1728:Source/tasks.c **** 			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 1457              		.loc 1 1728 0 is_stmt 1
 1458 0058 FB68     		ldr	r3, [r7, #12]
 1459 005a 9B6A     		ldr	r3, [r3, #40]
 1460 005c 002B     		cmp	r3, #0
 1461 005e 04D0     		beq	.L100
1729:Source/tasks.c **** 			{
1730:Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 1462              		.loc 1 1730 0
 1463 0060 FB68     		ldr	r3, [r7, #12]
 1464 0062 1833     		adds	r3, r3, #24
 1465 0064 1846     		mov	r0, r3
 1466 0066 FFF7FEFF 		bl	uxListRemove
 1467              	.L100:
1731:Source/tasks.c **** 			}
1732:Source/tasks.c **** 			else
1733:Source/tasks.c **** 			{
1734:Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1735:Source/tasks.c **** 			}
1736:Source/tasks.c **** 
1737:Source/tasks.c **** 			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
 1468              		.loc 1 1737 0
 1469 006a FB68     		ldr	r3, [r7, #12]
 1470 006c 0433     		adds	r3, r3, #4
 1471 006e 1946     		mov	r1, r3
 1472 0070 2048     		ldr	r0, .L108+12
 1473 0072 FFF7FEFF 		bl	vListInsertEnd
1738:Source/tasks.c **** 
1739:Source/tasks.c **** 			#if( configUSE_TASK_NOTIFICATIONS == 1 )
1740:Source/tasks.c **** 			{
1741:Source/tasks.c **** 				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
 1474              		.loc 1 1741 0
 1475 0076 FB68     		ldr	r3, [r7, #12]
 1476 0078 93F84C30 		ldrb	r3, [r3, #76]
 1477 007c DBB2     		uxtb	r3, r3
 1478 007e 012B     		cmp	r3, #1
 1479 0080 03D1     		bne	.L101
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 62
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 62
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


1742:Source/tasks.c **** 				{
1743:Source/tasks.c **** 					/* The task was blocked to wait for a notification, but is
1744:Source/tasks.c **** 					now suspended, so no notification was received. */
1745:Source/tasks.c **** 					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 1480              		.loc 1 1745 0
 1481 0082 FB68     		ldr	r3, [r7, #12]
 1482 0084 0022     		movs	r2, #0
 1483 0086 83F84C20 		strb	r2, [r3, #76]
 1484              	.L101:
1746:Source/tasks.c **** 				}
1747:Source/tasks.c **** 			}
1748:Source/tasks.c **** 			#endif
1749:Source/tasks.c **** 		}
1750:Source/tasks.c **** 		taskEXIT_CRITICAL();
 1485              		.loc 1 1750 0
 1486 008a FFF7FEFF 		bl	vPortExitCritical
1751:Source/tasks.c **** 
1752:Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 1487              		.loc 1 1752 0
 1488 008e 1A4B     		ldr	r3, .L108+16
 1489 0090 1B68     		ldr	r3, [r3]
 1490 0092 002B     		cmp	r3, #0
 1491 0094 05D0     		beq	.L102
1753:Source/tasks.c **** 		{
1754:Source/tasks.c **** 			/* Reset the next expected unblock time in case it referred to the
1755:Source/tasks.c **** 			task that is now in the Suspended state. */
1756:Source/tasks.c **** 			taskENTER_CRITICAL();
 1492              		.loc 1 1756 0
 1493 0096 FFF7FEFF 		bl	vPortEnterCritical
1757:Source/tasks.c **** 			{
1758:Source/tasks.c **** 				prvResetNextTaskUnblockTime();
 1494              		.loc 1 1758 0
 1495 009a FFF7FEFF 		bl	prvResetNextTaskUnblockTime
1759:Source/tasks.c **** 			}
1760:Source/tasks.c **** 			taskEXIT_CRITICAL();
 1496              		.loc 1 1760 0
 1497 009e FFF7FEFF 		bl	vPortExitCritical
 1498              	.L102:
1761:Source/tasks.c **** 		}
1762:Source/tasks.c **** 		else
1763:Source/tasks.c **** 		{
1764:Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1765:Source/tasks.c **** 		}
1766:Source/tasks.c **** 
1767:Source/tasks.c **** 		if( pxTCB == pxCurrentTCB )
 1499              		.loc 1 1767 0
 1500 00a2 114B     		ldr	r3, .L108
 1501 00a4 1B68     		ldr	r3, [r3]
 1502 00a6 FA68     		ldr	r2, [r7, #12]
 1503 00a8 9A42     		cmp	r2, r3
 1504 00aa 18D1     		bne	.L107
1768:Source/tasks.c **** 		{
1769:Source/tasks.c **** 			if( xSchedulerRunning != pdFALSE )
 1505              		.loc 1 1769 0
 1506 00ac 124B     		ldr	r3, .L108+16
 1507 00ae 1B68     		ldr	r3, [r3]
 1508 00b0 002B     		cmp	r3, #0
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 63
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 63
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 1509 00b2 08D0     		beq	.L104
1770:Source/tasks.c **** 			{
1771:Source/tasks.c **** 				/* The current task has just been suspended. */
1772:Source/tasks.c **** 				configASSERT( uxSchedulerSuspended == 0 );
1773:Source/tasks.c **** 				portYIELD_WITHIN_API();
 1510              		.loc 1 1773 0
 1511 00b4 114B     		ldr	r3, .L108+20
 1512 00b6 4FF08052 		mov	r2, #268435456
 1513 00ba 1A60     		str	r2, [r3]
 1514              		.syntax unified
 1515              	@ 1773 "Source\tasks.c" 1
 1516 00bc BFF34F8F 		dsb
 1517              	@ 0 "" 2
 1518              	@ 1773 "Source\tasks.c" 1
 1519 00c0 BFF36F8F 		isb
 1520              	@ 0 "" 2
1774:Source/tasks.c **** 			}
1775:Source/tasks.c **** 			else
1776:Source/tasks.c **** 			{
1777:Source/tasks.c **** 				/* The scheduler is not running, but the task that was pointed
1778:Source/tasks.c **** 				to by pxCurrentTCB has just been suspended and pxCurrentTCB
1779:Source/tasks.c **** 				must be adjusted to point to a different task. */
1780:Source/tasks.c **** 				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Rig
1781:Source/tasks.c **** 				{
1782:Source/tasks.c **** 					/* No other tasks are ready, so set pxCurrentTCB back to
1783:Source/tasks.c **** 					NULL so when the next task is created pxCurrentTCB will
1784:Source/tasks.c **** 					be set to point to it no matter what its relative priority
1785:Source/tasks.c **** 					is. */
1786:Source/tasks.c **** 					pxCurrentTCB = NULL;
1787:Source/tasks.c **** 				}
1788:Source/tasks.c **** 				else
1789:Source/tasks.c **** 				{
1790:Source/tasks.c **** 					vTaskSwitchContext();
1791:Source/tasks.c **** 				}
1792:Source/tasks.c **** 			}
1793:Source/tasks.c **** 		}
1794:Source/tasks.c **** 		else
1795:Source/tasks.c **** 		{
1796:Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1797:Source/tasks.c **** 		}
1798:Source/tasks.c **** 	}
 1521              		.loc 1 1798 0
 1522              		.thumb
 1523              		.syntax unified
 1524 00c4 0BE0     		b	.L107
 1525              	.L104:
1780:Source/tasks.c **** 				{
 1526              		.loc 1 1780 0
 1527 00c6 0B4B     		ldr	r3, .L108+12
 1528 00c8 1A68     		ldr	r2, [r3]
 1529 00ca 0D4B     		ldr	r3, .L108+24
 1530 00cc 1B68     		ldr	r3, [r3]
 1531 00ce 9A42     		cmp	r2, r3
 1532 00d0 03D1     		bne	.L106
1786:Source/tasks.c **** 				}
 1533              		.loc 1 1786 0
 1534 00d2 054B     		ldr	r3, .L108
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 64
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 64
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 1535 00d4 0022     		movs	r2, #0
 1536 00d6 1A60     		str	r2, [r3]
 1537              		.loc 1 1798 0
 1538 00d8 01E0     		b	.L107
 1539              	.L106:
1790:Source/tasks.c **** 				}
 1540              		.loc 1 1790 0
 1541 00da FFF7FEFF 		bl	vTaskSwitchContext
 1542              	.L107:
 1543              		.loc 1 1798 0
 1544 00de 00BF     		nop
 1545 00e0 1037     		adds	r7, r7, #16
 1546              		.cfi_def_cfa_offset 8
 1547 00e2 BD46     		mov	sp, r7
 1548              		.cfi_def_cfa_register 13
 1549              		@ sp needed
 1550 00e4 80BD     		pop	{r7, pc}
 1551              	.L109:
 1552 00e6 00BF     		.align	2
 1553              	.L108:
 1554 00e8 00000000 		.word	pxCurrentTCB
 1555 00ec 04000000 		.word	pxReadyTasksLists
 1556 00f0 E0000000 		.word	uxTopReadyPriority
 1557 00f4 C4000000 		.word	xSuspendedTaskList
 1558 00f8 E4000000 		.word	xSchedulerRunning
 1559 00fc 04ED00E0 		.word	-536810236
 1560 0100 D8000000 		.word	uxCurrentNumberOfTasks
 1561              		.cfi_endproc
 1562              	.LFE78:
 1563              		.size	vTaskSuspend, .-vTaskSuspend
 1564              		.section	.text.prvTaskIsTaskSuspended,"ax",%progbits
 1565              		.align	2
 1566              		.thumb
 1567              		.thumb_func
 1568              		.type	prvTaskIsTaskSuspended, %function
 1569              	prvTaskIsTaskSuspended:
 1570              	.LFB79:
1799:Source/tasks.c **** 
1800:Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1801:Source/tasks.c **** /*-----------------------------------------------------------*/
1802:Source/tasks.c **** 
1803:Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1804:Source/tasks.c **** 
1805:Source/tasks.c **** 	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
1806:Source/tasks.c **** 	{
 1571              		.loc 1 1806 0
 1572              		.cfi_startproc
 1573              		@ args = 0, pretend = 0, frame = 16
 1574              		@ frame_needed = 1, uses_anonymous_args = 0
 1575              		@ link register save eliminated.
 1576 0000 80B4     		push	{r7}
 1577              		.cfi_def_cfa_offset 4
 1578              		.cfi_offset 7, -4
 1579 0002 85B0     		sub	sp, sp, #20
 1580              		.cfi_def_cfa_offset 24
 1581 0004 00AF     		add	r7, sp, #0
 1582              		.cfi_def_cfa_register 7
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 65
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 65
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 1583 0006 7860     		str	r0, [r7, #4]
1807:Source/tasks.c **** 	BaseType_t xReturn = pdFALSE;
 1584              		.loc 1 1807 0
 1585 0008 0023     		movs	r3, #0
 1586 000a FB60     		str	r3, [r7, #12]
1808:Source/tasks.c **** 	const TCB_t * const pxTCB = xTask;
 1587              		.loc 1 1808 0
 1588 000c 7B68     		ldr	r3, [r7, #4]
 1589 000e BB60     		str	r3, [r7, #8]
1809:Source/tasks.c **** 
1810:Source/tasks.c **** 		/* Accesses xPendingReadyList so must be called from a critical
1811:Source/tasks.c **** 		section. */
1812:Source/tasks.c **** 
1813:Source/tasks.c **** 		/* It does not make sense to check if the calling task is suspended. */
1814:Source/tasks.c **** 		configASSERT( xTask );
1815:Source/tasks.c **** 
1816:Source/tasks.c **** 		/* Is the task being resumed actually in the suspended list? */
1817:Source/tasks.c **** 		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
 1590              		.loc 1 1817 0
 1591 0010 BB68     		ldr	r3, [r7, #8]
 1592 0012 5B69     		ldr	r3, [r3, #20]
 1593 0014 094A     		ldr	r2, .L113
 1594 0016 9342     		cmp	r3, r2
 1595 0018 0AD1     		bne	.L111
1818:Source/tasks.c **** 		{
1819:Source/tasks.c **** 			/* Has the task already been resumed from within an ISR? */
1820:Source/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
 1596              		.loc 1 1820 0
 1597 001a BB68     		ldr	r3, [r7, #8]
 1598 001c 9B6A     		ldr	r3, [r3, #40]
 1599 001e 084A     		ldr	r2, .L113+4
 1600 0020 9342     		cmp	r3, r2
 1601 0022 05D0     		beq	.L111
1821:Source/tasks.c **** 			{
1822:Source/tasks.c **** 				/* Is it in the suspended list because it is in the	Suspended
1823:Source/tasks.c **** 				state, or because is is blocked with no timeout? */
1824:Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The
 1602              		.loc 1 1824 0
 1603 0024 BB68     		ldr	r3, [r7, #8]
 1604 0026 9B6A     		ldr	r3, [r3, #40]
 1605 0028 002B     		cmp	r3, #0
 1606 002a 01D1     		bne	.L111
1825:Source/tasks.c **** 				{
1826:Source/tasks.c **** 					xReturn = pdTRUE;
 1607              		.loc 1 1826 0
 1608 002c 0123     		movs	r3, #1
 1609 002e FB60     		str	r3, [r7, #12]
 1610              	.L111:
1827:Source/tasks.c **** 				}
1828:Source/tasks.c **** 				else
1829:Source/tasks.c **** 				{
1830:Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1831:Source/tasks.c **** 				}
1832:Source/tasks.c **** 			}
1833:Source/tasks.c **** 			else
1834:Source/tasks.c **** 			{
1835:Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 66
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 66
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


1836:Source/tasks.c **** 			}
1837:Source/tasks.c **** 		}
1838:Source/tasks.c **** 		else
1839:Source/tasks.c **** 		{
1840:Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1841:Source/tasks.c **** 		}
1842:Source/tasks.c **** 
1843:Source/tasks.c **** 		return xReturn;
 1611              		.loc 1 1843 0
 1612 0030 FB68     		ldr	r3, [r7, #12]
1844:Source/tasks.c **** 	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
 1613              		.loc 1 1844 0
 1614 0032 1846     		mov	r0, r3
 1615 0034 1437     		adds	r7, r7, #20
 1616              		.cfi_def_cfa_offset 4
 1617 0036 BD46     		mov	sp, r7
 1618              		.cfi_def_cfa_register 13
 1619              		@ sp needed
 1620 0038 80BC     		pop	{r7}
 1621              		.cfi_restore 7
 1622              		.cfi_def_cfa_offset 0
 1623 003a 7047     		bx	lr
 1624              	.L114:
 1625              		.align	2
 1626              	.L113:
 1627 003c C4000000 		.word	xSuspendedTaskList
 1628 0040 98000000 		.word	xPendingReadyList
 1629              		.cfi_endproc
 1630              	.LFE79:
 1631              		.size	prvTaskIsTaskSuspended, .-prvTaskIsTaskSuspended
 1632              		.section	.text.vTaskResume,"ax",%progbits
 1633              		.align	2
 1634              		.global	vTaskResume
 1635              		.thumb
 1636              		.thumb_func
 1637              		.type	vTaskResume, %function
 1638              	vTaskResume:
 1639              	.LFB80:
1845:Source/tasks.c **** 
1846:Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1847:Source/tasks.c **** /*-----------------------------------------------------------*/
1848:Source/tasks.c **** 
1849:Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1850:Source/tasks.c **** 
1851:Source/tasks.c **** 	void vTaskResume( TaskHandle_t xTaskToResume )
1852:Source/tasks.c **** 	{
 1640              		.loc 1 1852 0
 1641              		.cfi_startproc
 1642              		@ args = 0, pretend = 0, frame = 16
 1643              		@ frame_needed = 1, uses_anonymous_args = 0
 1644 0000 80B5     		push	{r7, lr}
 1645              		.cfi_def_cfa_offset 8
 1646              		.cfi_offset 7, -8
 1647              		.cfi_offset 14, -4
 1648 0002 84B0     		sub	sp, sp, #16
 1649              		.cfi_def_cfa_offset 24
 1650 0004 00AF     		add	r7, sp, #0
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 67
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 67
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 1651              		.cfi_def_cfa_register 7
 1652 0006 7860     		str	r0, [r7, #4]
1853:Source/tasks.c **** 	TCB_t * const pxTCB = xTaskToResume;
 1653              		.loc 1 1853 0
 1654 0008 7B68     		ldr	r3, [r7, #4]
 1655 000a FB60     		str	r3, [r7, #12]
1854:Source/tasks.c **** 
1855:Source/tasks.c **** 		/* It does not make sense to resume the calling task. */
1856:Source/tasks.c **** 		configASSERT( xTaskToResume );
1857:Source/tasks.c **** 
1858:Source/tasks.c **** 		/* The parameter cannot be NULL as it is impossible to resume the
1859:Source/tasks.c **** 		currently executing task. */
1860:Source/tasks.c **** 		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
 1656              		.loc 1 1860 0
 1657 000c 204B     		ldr	r3, .L119
 1658 000e 1B68     		ldr	r3, [r3]
 1659 0010 FA68     		ldr	r2, [r7, #12]
 1660 0012 9A42     		cmp	r2, r3
 1661 0014 37D0     		beq	.L118
 1662              		.loc 1 1860 0 is_stmt 0 discriminator 1
 1663 0016 FB68     		ldr	r3, [r7, #12]
 1664 0018 002B     		cmp	r3, #0
 1665 001a 34D0     		beq	.L118
1861:Source/tasks.c **** 		{
1862:Source/tasks.c **** 			taskENTER_CRITICAL();
 1666              		.loc 1 1862 0 is_stmt 1
 1667 001c FFF7FEFF 		bl	vPortEnterCritical
1863:Source/tasks.c **** 			{
1864:Source/tasks.c **** 				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
 1668              		.loc 1 1864 0
 1669 0020 F868     		ldr	r0, [r7, #12]
 1670 0022 FFF7FEFF 		bl	prvTaskIsTaskSuspended
 1671 0026 0346     		mov	r3, r0
 1672 0028 002B     		cmp	r3, #0
 1673 002a 2AD0     		beq	.L117
1865:Source/tasks.c **** 				{
1866:Source/tasks.c **** 					traceTASK_RESUME( pxTCB );
1867:Source/tasks.c **** 
1868:Source/tasks.c **** 					/* The ready list can be accessed even if the scheduler is
1869:Source/tasks.c **** 					suspended because this is inside a critical section. */
1870:Source/tasks.c **** 					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
 1674              		.loc 1 1870 0
 1675 002c FB68     		ldr	r3, [r7, #12]
 1676 002e 0433     		adds	r3, r3, #4
 1677 0030 1846     		mov	r0, r3
 1678 0032 FFF7FEFF 		bl	uxListRemove
1871:Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1679              		.loc 1 1871 0
 1680 0036 FB68     		ldr	r3, [r7, #12]
 1681 0038 DB6A     		ldr	r3, [r3, #44]
 1682 003a 0122     		movs	r2, #1
 1683 003c 9A40     		lsls	r2, r2, r3
 1684 003e 154B     		ldr	r3, .L119+4
 1685 0040 1B68     		ldr	r3, [r3]
 1686 0042 1343     		orrs	r3, r3, r2
 1687 0044 134A     		ldr	r2, .L119+4
 1688 0046 1360     		str	r3, [r2]
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 68
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 68
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 1689 0048 FB68     		ldr	r3, [r7, #12]
 1690 004a DA6A     		ldr	r2, [r3, #44]
 1691 004c 1346     		mov	r3, r2
 1692 004e 9B00     		lsls	r3, r3, #2
 1693 0050 1344     		add	r3, r3, r2
 1694 0052 9B00     		lsls	r3, r3, #2
 1695 0054 104A     		ldr	r2, .L119+8
 1696 0056 1A44     		add	r2, r2, r3
 1697 0058 FB68     		ldr	r3, [r7, #12]
 1698 005a 0433     		adds	r3, r3, #4
 1699 005c 1946     		mov	r1, r3
 1700 005e 1046     		mov	r0, r2
 1701 0060 FFF7FEFF 		bl	vListInsertEnd
1872:Source/tasks.c **** 
1873:Source/tasks.c **** 					/* A higher priority task may have just been resumed. */
1874:Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1702              		.loc 1 1874 0
 1703 0064 FB68     		ldr	r3, [r7, #12]
 1704 0066 DA6A     		ldr	r2, [r3, #44]
 1705 0068 094B     		ldr	r3, .L119
 1706 006a 1B68     		ldr	r3, [r3]
 1707 006c DB6A     		ldr	r3, [r3, #44]
 1708 006e 9A42     		cmp	r2, r3
 1709 0070 07D3     		bcc	.L117
1875:Source/tasks.c **** 					{
1876:Source/tasks.c **** 						/* This yield may not cause the task just resumed to run,
1877:Source/tasks.c **** 						but will leave the lists in the correct state for the
1878:Source/tasks.c **** 						next yield. */
1879:Source/tasks.c **** 						taskYIELD_IF_USING_PREEMPTION();
 1710              		.loc 1 1879 0
 1711 0072 0A4B     		ldr	r3, .L119+12
 1712 0074 4FF08052 		mov	r2, #268435456
 1713 0078 1A60     		str	r2, [r3]
 1714              		.syntax unified
 1715              	@ 1879 "Source\tasks.c" 1
 1716 007a BFF34F8F 		dsb
 1717              	@ 0 "" 2
 1718              	@ 1879 "Source\tasks.c" 1
 1719 007e BFF36F8F 		isb
 1720              	@ 0 "" 2
 1721              		.thumb
 1722              		.syntax unified
 1723              	.L117:
1880:Source/tasks.c **** 					}
1881:Source/tasks.c **** 					else
1882:Source/tasks.c **** 					{
1883:Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1884:Source/tasks.c **** 					}
1885:Source/tasks.c **** 				}
1886:Source/tasks.c **** 				else
1887:Source/tasks.c **** 				{
1888:Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1889:Source/tasks.c **** 				}
1890:Source/tasks.c **** 			}
1891:Source/tasks.c **** 			taskEXIT_CRITICAL();
 1724              		.loc 1 1891 0
 1725 0082 FFF7FEFF 		bl	vPortExitCritical
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 69
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 69
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 1726              	.L118:
1892:Source/tasks.c **** 		}
1893:Source/tasks.c **** 		else
1894:Source/tasks.c **** 		{
1895:Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1896:Source/tasks.c **** 		}
1897:Source/tasks.c **** 	}
 1727              		.loc 1 1897 0
 1728 0086 00BF     		nop
 1729 0088 1037     		adds	r7, r7, #16
 1730              		.cfi_def_cfa_offset 8
 1731 008a BD46     		mov	sp, r7
 1732              		.cfi_def_cfa_register 13
 1733              		@ sp needed
 1734 008c 80BD     		pop	{r7, pc}
 1735              	.L120:
 1736 008e 00BF     		.align	2
 1737              	.L119:
 1738 0090 00000000 		.word	pxCurrentTCB
 1739 0094 E0000000 		.word	uxTopReadyPriority
 1740 0098 04000000 		.word	pxReadyTasksLists
 1741 009c 04ED00E0 		.word	-536810236
 1742              		.cfi_endproc
 1743              	.LFE80:
 1744              		.size	vTaskResume, .-vTaskResume
 1745              		.section	.text.xTaskResumeFromISR,"ax",%progbits
 1746              		.align	2
 1747              		.global	xTaskResumeFromISR
 1748              		.thumb
 1749              		.thumb_func
 1750              		.type	xTaskResumeFromISR, %function
 1751              	xTaskResumeFromISR:
 1752              	.LFB81:
1898:Source/tasks.c **** 
1899:Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1900:Source/tasks.c **** 
1901:Source/tasks.c **** /*-----------------------------------------------------------*/
1902:Source/tasks.c **** 
1903:Source/tasks.c **** #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
1904:Source/tasks.c **** 
1905:Source/tasks.c **** 	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
1906:Source/tasks.c **** 	{
 1753              		.loc 1 1906 0
 1754              		.cfi_startproc
 1755              		@ args = 0, pretend = 0, frame = 32
 1756              		@ frame_needed = 1, uses_anonymous_args = 0
 1757 0000 80B5     		push	{r7, lr}
 1758              		.cfi_def_cfa_offset 8
 1759              		.cfi_offset 7, -8
 1760              		.cfi_offset 14, -4
 1761 0002 88B0     		sub	sp, sp, #32
 1762              		.cfi_def_cfa_offset 40
 1763 0004 00AF     		add	r7, sp, #0
 1764              		.cfi_def_cfa_register 7
 1765 0006 7860     		str	r0, [r7, #4]
1907:Source/tasks.c **** 	BaseType_t xYieldRequired = pdFALSE;
 1766              		.loc 1 1907 0
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 70
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 70
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 1767 0008 0023     		movs	r3, #0
 1768 000a FB61     		str	r3, [r7, #28]
1908:Source/tasks.c **** 	TCB_t * const pxTCB = xTaskToResume;
 1769              		.loc 1 1908 0
 1770 000c 7B68     		ldr	r3, [r7, #4]
 1771 000e BB61     		str	r3, [r7, #24]
 1772              	.LBB33:
 1773              	.LBB34:
 213:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	(
 1774              		.loc 2 213 0
 1775              		.syntax unified
 1776              	@ 213 ".\Source\portable\GCC\ARM_CM3/portmacro.h" 1
 1777 0010 EFF31182 			mrs r2, basepri											
 1778 0014 4FF0A003 		mov r3, #160												
 1779 0018 83F31188 		msr basepri, r3											
 1780 001c BFF36F8F 		isb														
 1781 0020 BFF34F8F 		dsb														
 1782              	
 1783              	@ 0 "" 2
 1784              		.thumb
 1785              		.syntax unified
 1786 0024 FA60     		str	r2, [r7, #12]
 1787 0026 BB60     		str	r3, [r7, #8]
 225:.\Source\portable\GCC\ARM_CM3/portmacro.h **** }
 1788              		.loc 2 225 0
 1789 0028 FB68     		ldr	r3, [r7, #12]
 1790              	.LBE34:
 1791              	.LBE33:
1909:Source/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
1910:Source/tasks.c **** 
1911:Source/tasks.c **** 		configASSERT( xTaskToResume );
1912:Source/tasks.c **** 
1913:Source/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
1914:Source/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
1915:Source/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
1916:Source/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
1917:Source/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
1918:Source/tasks.c **** 		is defined in FreeRTOSConfig.h then
1919:Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1920:Source/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
1921:Source/tasks.c **** 		been assigned a priority above the configured maximum system call
1922:Source/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
1923:Source/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
1924:Source/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
1925:Source/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
1926:Source/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
1927:Source/tasks.c **** 		provided on the following link:
1928:Source/tasks.c **** 		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
1929:Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1930:Source/tasks.c **** 
1931:Source/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1792              		.loc 1 1931 0
 1793 002a 3B61     		str	r3, [r7, #16]
1932:Source/tasks.c **** 		{
1933:Source/tasks.c **** 			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
 1794              		.loc 1 1933 0
 1795 002c B869     		ldr	r0, [r7, #24]
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 71
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 71
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 1796 002e FFF7FEFF 		bl	prvTaskIsTaskSuspended
 1797 0032 0346     		mov	r3, r0
 1798 0034 002B     		cmp	r3, #0
 1799 0036 2FD0     		beq	.L123
1934:Source/tasks.c **** 			{
1935:Source/tasks.c **** 				traceTASK_RESUME_FROM_ISR( pxTCB );
1936:Source/tasks.c **** 
1937:Source/tasks.c **** 				/* Check the ready lists can be accessed. */
1938:Source/tasks.c **** 				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 1800              		.loc 1 1938 0
 1801 0038 1C4B     		ldr	r3, .L128
 1802 003a 1B68     		ldr	r3, [r3]
 1803 003c 002B     		cmp	r3, #0
 1804 003e 25D1     		bne	.L124
1939:Source/tasks.c **** 				{
1940:Source/tasks.c **** 					/* Ready lists can be accessed so move the task from the
1941:Source/tasks.c **** 					suspended list to the ready list directly. */
1942:Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1805              		.loc 1 1942 0
 1806 0040 BB69     		ldr	r3, [r7, #24]
 1807 0042 DA6A     		ldr	r2, [r3, #44]
 1808 0044 1A4B     		ldr	r3, .L128+4
 1809 0046 1B68     		ldr	r3, [r3]
 1810 0048 DB6A     		ldr	r3, [r3, #44]
 1811 004a 9A42     		cmp	r2, r3
 1812 004c 01D3     		bcc	.L125
1943:Source/tasks.c **** 					{
1944:Source/tasks.c **** 						xYieldRequired = pdTRUE;
 1813              		.loc 1 1944 0
 1814 004e 0123     		movs	r3, #1
 1815 0050 FB61     		str	r3, [r7, #28]
 1816              	.L125:
1945:Source/tasks.c **** 					}
1946:Source/tasks.c **** 					else
1947:Source/tasks.c **** 					{
1948:Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1949:Source/tasks.c **** 					}
1950:Source/tasks.c **** 
1951:Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 1817              		.loc 1 1951 0
 1818 0052 BB69     		ldr	r3, [r7, #24]
 1819 0054 0433     		adds	r3, r3, #4
 1820 0056 1846     		mov	r0, r3
 1821 0058 FFF7FEFF 		bl	uxListRemove
1952:Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1822              		.loc 1 1952 0
 1823 005c BB69     		ldr	r3, [r7, #24]
 1824 005e DB6A     		ldr	r3, [r3, #44]
 1825 0060 0122     		movs	r2, #1
 1826 0062 9A40     		lsls	r2, r2, r3
 1827 0064 134B     		ldr	r3, .L128+8
 1828 0066 1B68     		ldr	r3, [r3]
 1829 0068 1343     		orrs	r3, r3, r2
 1830 006a 124A     		ldr	r2, .L128+8
 1831 006c 1360     		str	r3, [r2]
 1832 006e BB69     		ldr	r3, [r7, #24]
 1833 0070 DA6A     		ldr	r2, [r3, #44]
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 72
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 72
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 1834 0072 1346     		mov	r3, r2
 1835 0074 9B00     		lsls	r3, r3, #2
 1836 0076 1344     		add	r3, r3, r2
 1837 0078 9B00     		lsls	r3, r3, #2
 1838 007a 0F4A     		ldr	r2, .L128+12
 1839 007c 1A44     		add	r2, r2, r3
 1840 007e BB69     		ldr	r3, [r7, #24]
 1841 0080 0433     		adds	r3, r3, #4
 1842 0082 1946     		mov	r1, r3
 1843 0084 1046     		mov	r0, r2
 1844 0086 FFF7FEFF 		bl	vListInsertEnd
 1845 008a 05E0     		b	.L123
 1846              	.L124:
1953:Source/tasks.c **** 				}
1954:Source/tasks.c **** 				else
1955:Source/tasks.c **** 				{
1956:Source/tasks.c **** 					/* The delayed or ready lists cannot be accessed so the task
1957:Source/tasks.c **** 					is held in the pending ready list until the scheduler is
1958:Source/tasks.c **** 					unsuspended. */
1959:Source/tasks.c **** 					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 1847              		.loc 1 1959 0
 1848 008c BB69     		ldr	r3, [r7, #24]
 1849 008e 1833     		adds	r3, r3, #24
 1850 0090 1946     		mov	r1, r3
 1851 0092 0A48     		ldr	r0, .L128+16
 1852 0094 FFF7FEFF 		bl	vListInsertEnd
 1853              	.L123:
 1854 0098 3B69     		ldr	r3, [r7, #16]
 1855 009a 7B61     		str	r3, [r7, #20]
 1856              	.LBB35:
 1857              	.LBB36:
 1858              		.loc 2 231 0
 1859 009c 7B69     		ldr	r3, [r7, #20]
 1860              		.syntax unified
 1861              	@ 231 ".\Source\portable\GCC\ARM_CM3/portmacro.h" 1
 1862 009e 83F31188 			msr basepri, r3	
 1863              	@ 0 "" 2
 1864              		.thumb
 1865              		.syntax unified
 1866              	.LBE36:
 1867              	.LBE35:
1960:Source/tasks.c **** 				}
1961:Source/tasks.c **** 			}
1962:Source/tasks.c **** 			else
1963:Source/tasks.c **** 			{
1964:Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1965:Source/tasks.c **** 			}
1966:Source/tasks.c **** 		}
1967:Source/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1968:Source/tasks.c **** 
1969:Source/tasks.c **** 		return xYieldRequired;
 1868              		.loc 1 1969 0
 1869 00a2 FB69     		ldr	r3, [r7, #28]
1970:Source/tasks.c **** 	}
 1870              		.loc 1 1970 0
 1871 00a4 1846     		mov	r0, r3
 1872 00a6 2037     		adds	r7, r7, #32
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 73
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 73
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 1873              		.cfi_def_cfa_offset 8
 1874 00a8 BD46     		mov	sp, r7
 1875              		.cfi_def_cfa_register 13
 1876              		@ sp needed
 1877 00aa 80BD     		pop	{r7, pc}
 1878              	.L129:
 1879              		.align	2
 1880              	.L128:
 1881 00ac 00010000 		.word	uxSchedulerSuspended
 1882 00b0 00000000 		.word	pxCurrentTCB
 1883 00b4 E0000000 		.word	uxTopReadyPriority
 1884 00b8 04000000 		.word	pxReadyTasksLists
 1885 00bc 98000000 		.word	xPendingReadyList
 1886              		.cfi_endproc
 1887              	.LFE81:
 1888              		.size	xTaskResumeFromISR, .-xTaskResumeFromISR
 1889              		.section	.rodata
 1890              		.align	2
 1891              	.LC0:
 1892 0000 49444C45 		.ascii	"IDLE\000"
 1892      00
 1893              		.section	.text.vTaskStartScheduler,"ax",%progbits
 1894              		.align	2
 1895              		.global	vTaskStartScheduler
 1896              		.thumb
 1897              		.thumb_func
 1898              		.type	vTaskStartScheduler, %function
 1899              	vTaskStartScheduler:
 1900              	.LFB82:
1971:Source/tasks.c **** 
1972:Source/tasks.c **** #endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
1973:Source/tasks.c **** /*-----------------------------------------------------------*/
1974:Source/tasks.c **** 
1975:Source/tasks.c **** void vTaskStartScheduler( void )
1976:Source/tasks.c **** {
 1901              		.loc 1 1976 0
 1902              		.cfi_startproc
 1903              		@ args = 0, pretend = 0, frame = 8
 1904              		@ frame_needed = 1, uses_anonymous_args = 0
 1905 0000 80B5     		push	{r7, lr}
 1906              		.cfi_def_cfa_offset 8
 1907              		.cfi_offset 7, -8
 1908              		.cfi_offset 14, -4
 1909 0002 84B0     		sub	sp, sp, #16
 1910              		.cfi_def_cfa_offset 24
 1911 0004 02AF     		add	r7, sp, #8
 1912              		.cfi_def_cfa 7, 16
1977:Source/tasks.c **** BaseType_t xReturn;
1978:Source/tasks.c **** 
1979:Source/tasks.c **** 	/* Add the idle task at the lowest priority. */
1980:Source/tasks.c **** 	#if( configSUPPORT_STATIC_ALLOCATION == 1 )
1981:Source/tasks.c **** 	{
1982:Source/tasks.c **** 		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
1983:Source/tasks.c **** 		StackType_t *pxIdleTaskStackBuffer = NULL;
1984:Source/tasks.c **** 		uint32_t ulIdleTaskStackSize;
1985:Source/tasks.c **** 
1986:Source/tasks.c **** 		/* The Idle task is created using user provided RAM - obtain the
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 74
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 74
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


1987:Source/tasks.c **** 		address of the RAM then create the idle task. */
1988:Source/tasks.c **** 		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize
1989:Source/tasks.c **** 		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
1990:Source/tasks.c **** 												configIDLE_TASK_NAME,
1991:Source/tasks.c **** 												ulIdleTaskStackSize,
1992:Source/tasks.c **** 												( void * ) NULL, /*lint !e961.  The cast is not redundant for all compilers. */
1993:Source/tasks.c **** 												portPRIVILEGE_BIT, /* In effect ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), but tskIDLE_P
1994:Source/tasks.c **** 												pxIdleTaskStackBuffer,
1995:Source/tasks.c **** 												pxIdleTaskTCBBuffer ); /*lint !e961 MISRA exception, justified as it is not a redundant
1996:Source/tasks.c **** 
1997:Source/tasks.c **** 		if( xIdleTaskHandle != NULL )
1998:Source/tasks.c **** 		{
1999:Source/tasks.c **** 			xReturn = pdPASS;
2000:Source/tasks.c **** 		}
2001:Source/tasks.c **** 		else
2002:Source/tasks.c **** 		{
2003:Source/tasks.c **** 			xReturn = pdFAIL;
2004:Source/tasks.c **** 		}
2005:Source/tasks.c **** 	}
2006:Source/tasks.c **** 	#else
2007:Source/tasks.c **** 	{
2008:Source/tasks.c **** 		/* The Idle task is being created using dynamically allocated RAM. */
2009:Source/tasks.c **** 		xReturn = xTaskCreate(	prvIdleTask,
 1913              		.loc 1 2009 0
 1914 0006 134B     		ldr	r3, .L133
 1915 0008 0193     		str	r3, [sp, #4]
 1916 000a 0023     		movs	r3, #0
 1917 000c 0093     		str	r3, [sp]
 1918 000e 0023     		movs	r3, #0
 1919 0010 6422     		movs	r2, #100
 1920 0012 1149     		ldr	r1, .L133+4
 1921 0014 1148     		ldr	r0, .L133+8
 1922 0016 FFF7FEFF 		bl	xTaskCreate
 1923 001a 7860     		str	r0, [r7, #4]
2010:Source/tasks.c **** 								configIDLE_TASK_NAME,
2011:Source/tasks.c **** 								configMINIMAL_STACK_SIZE,
2012:Source/tasks.c **** 								( void * ) NULL,
2013:Source/tasks.c **** 								portPRIVILEGE_BIT, /* In effect ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), but tskIDLE_PRIOR
2014:Source/tasks.c **** 								&xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explic
2015:Source/tasks.c **** 	}
2016:Source/tasks.c **** 	#endif /* configSUPPORT_STATIC_ALLOCATION */
2017:Source/tasks.c **** 
2018:Source/tasks.c **** 	#if ( configUSE_TIMERS == 1 )
2019:Source/tasks.c **** 	{
2020:Source/tasks.c **** 		if( xReturn == pdPASS )
2021:Source/tasks.c **** 		{
2022:Source/tasks.c **** 			xReturn = xTimerCreateTimerTask();
2023:Source/tasks.c **** 		}
2024:Source/tasks.c **** 		else
2025:Source/tasks.c **** 		{
2026:Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2027:Source/tasks.c **** 		}
2028:Source/tasks.c **** 	}
2029:Source/tasks.c **** 	#endif /* configUSE_TIMERS */
2030:Source/tasks.c **** 
2031:Source/tasks.c **** 	if( xReturn == pdPASS )
 1924              		.loc 1 2031 0
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 75
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 75
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 1925 001c 7B68     		ldr	r3, [r7, #4]
 1926 001e 012B     		cmp	r3, #1
 1927 0020 14D1     		bne	.L132
 1928              	.LBB37:
 1929              	.LBB38:
 197:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	(
 1930              		.loc 2 197 0
 1931              		.syntax unified
 1932              	@ 197 ".\Source\portable\GCC\ARM_CM3/portmacro.h" 1
 1933 0022 4FF0A003 			mov r3, #160												
 1934 0026 83F31188 		msr basepri, r3											
 1935 002a BFF36F8F 		isb														
 1936 002e BFF34F8F 		dsb														
 1937              	
 1938              	@ 0 "" 2
 1939              		.thumb
 1940              		.syntax unified
 1941 0032 3B60     		str	r3, [r7]
 1942              	.LBE38:
 1943              	.LBE37:
2032:Source/tasks.c **** 	{
2033:Source/tasks.c **** 		/* freertos_tasks_c_additions_init() should only be called if the user
2034:Source/tasks.c **** 		definable macro FREERTOS_TASKS_C_ADDITIONS_INIT() is defined, as that is
2035:Source/tasks.c **** 		the only macro called by the function. */
2036:Source/tasks.c **** 		#ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
2037:Source/tasks.c **** 		{
2038:Source/tasks.c **** 			freertos_tasks_c_additions_init();
2039:Source/tasks.c **** 		}
2040:Source/tasks.c **** 		#endif
2041:Source/tasks.c **** 
2042:Source/tasks.c **** 		/* Interrupts are turned off here, to ensure a tick does not occur
2043:Source/tasks.c **** 		before or during the call to xPortStartScheduler().  The stacks of
2044:Source/tasks.c **** 		the created tasks contain a status word with interrupts switched on
2045:Source/tasks.c **** 		so interrupts will automatically get re-enabled when the first task
2046:Source/tasks.c **** 		starts to run. */
2047:Source/tasks.c **** 		portDISABLE_INTERRUPTS();
2048:Source/tasks.c **** 
2049:Source/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
2050:Source/tasks.c **** 		{
2051:Source/tasks.c **** 			/* Switch Newlib's _impure_ptr variable to point to the _reent
2052:Source/tasks.c **** 			structure specific to the task that will run first.
2053:Source/tasks.c **** 			See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html
2054:Source/tasks.c **** 			for additional information. */
2055:Source/tasks.c **** 			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
2056:Source/tasks.c **** 		}
2057:Source/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
2058:Source/tasks.c **** 
2059:Source/tasks.c **** 		xNextTaskUnblockTime = portMAX_DELAY;
 1944              		.loc 1 2059 0
 1945 0034 0A4B     		ldr	r3, .L133+12
 1946 0036 4FF0FF32 		mov	r2, #-1
 1947 003a 1A60     		str	r2, [r3]
2060:Source/tasks.c **** 		xSchedulerRunning = pdTRUE;
 1948              		.loc 1 2060 0
 1949 003c 094B     		ldr	r3, .L133+16
 1950 003e 0122     		movs	r2, #1
 1951 0040 1A60     		str	r2, [r3]
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 76
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 76
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


2061:Source/tasks.c **** 		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
 1952              		.loc 1 2061 0
 1953 0042 094B     		ldr	r3, .L133+20
 1954 0044 0022     		movs	r2, #0
 1955 0046 1A60     		str	r2, [r3]
2062:Source/tasks.c **** 
2063:Source/tasks.c **** 		/* If configGENERATE_RUN_TIME_STATS is defined then the following
2064:Source/tasks.c **** 		macro must be defined to configure the timer/counter used to generate
2065:Source/tasks.c **** 		the run time counter time base.   NOTE:  If configGENERATE_RUN_TIME_STATS
2066:Source/tasks.c **** 		is set to 0 and the following line fails to build then ensure you do not
2067:Source/tasks.c **** 		have portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() defined in your
2068:Source/tasks.c **** 		FreeRTOSConfig.h file. */
2069:Source/tasks.c **** 		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
2070:Source/tasks.c **** 
2071:Source/tasks.c **** 		traceTASK_SWITCHED_IN();
2072:Source/tasks.c **** 
2073:Source/tasks.c **** 		/* Setting up the timer tick is hardware specific and thus in the
2074:Source/tasks.c **** 		portable interface. */
2075:Source/tasks.c **** 		if( xPortStartScheduler() != pdFALSE )
 1956              		.loc 1 2075 0
 1957 0048 FFF7FEFF 		bl	xPortStartScheduler
 1958              	.L132:
2076:Source/tasks.c **** 		{
2077:Source/tasks.c **** 			/* Should not reach here as if the scheduler is running the
2078:Source/tasks.c **** 			function will not return. */
2079:Source/tasks.c **** 		}
2080:Source/tasks.c **** 		else
2081:Source/tasks.c **** 		{
2082:Source/tasks.c **** 			/* Should only reach here if a task calls xTaskEndScheduler(). */
2083:Source/tasks.c **** 		}
2084:Source/tasks.c **** 	}
2085:Source/tasks.c **** 	else
2086:Source/tasks.c **** 	{
2087:Source/tasks.c **** 		/* This line will only be reached if the kernel could not be started,
2088:Source/tasks.c **** 		because there was not enough FreeRTOS heap to create the idle task
2089:Source/tasks.c **** 		or the timer task. */
2090:Source/tasks.c **** 		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
2091:Source/tasks.c **** 	}
2092:Source/tasks.c **** 
2093:Source/tasks.c **** 	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
2094:Source/tasks.c **** 	meaning xIdleTaskHandle is not used anywhere else. */
2095:Source/tasks.c **** 	( void ) xIdleTaskHandle;
2096:Source/tasks.c **** }
 1959              		.loc 1 2096 0
 1960 004c 00BF     		nop
 1961 004e 0837     		adds	r7, r7, #8
 1962              		.cfi_def_cfa_offset 8
 1963 0050 BD46     		mov	sp, r7
 1964              		.cfi_def_cfa_register 13
 1965              		@ sp needed
 1966 0052 80BD     		pop	{r7, pc}
 1967              	.L134:
 1968              		.align	2
 1969              	.L133:
 1970 0054 FC000000 		.word	xIdleTaskHandle
 1971 0058 00000000 		.word	.LC0
 1972 005c 00000000 		.word	prvIdleTask
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 77
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 77
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 1973 0060 F8000000 		.word	xNextTaskUnblockTime
 1974 0064 E4000000 		.word	xSchedulerRunning
 1975 0068 DC000000 		.word	xTickCount
 1976              		.cfi_endproc
 1977              	.LFE82:
 1978              		.size	vTaskStartScheduler, .-vTaskStartScheduler
 1979              		.section	.text.vTaskEndScheduler,"ax",%progbits
 1980              		.align	2
 1981              		.global	vTaskEndScheduler
 1982              		.thumb
 1983              		.thumb_func
 1984              		.type	vTaskEndScheduler, %function
 1985              	vTaskEndScheduler:
 1986              	.LFB83:
2097:Source/tasks.c **** /*-----------------------------------------------------------*/
2098:Source/tasks.c **** 
2099:Source/tasks.c **** void vTaskEndScheduler( void )
2100:Source/tasks.c **** {
 1987              		.loc 1 2100 0
 1988              		.cfi_startproc
 1989              		@ args = 0, pretend = 0, frame = 8
 1990              		@ frame_needed = 1, uses_anonymous_args = 0
 1991 0000 80B5     		push	{r7, lr}
 1992              		.cfi_def_cfa_offset 8
 1993              		.cfi_offset 7, -8
 1994              		.cfi_offset 14, -4
 1995 0002 82B0     		sub	sp, sp, #8
 1996              		.cfi_def_cfa_offset 16
 1997 0004 00AF     		add	r7, sp, #0
 1998              		.cfi_def_cfa_register 7
 1999              	.LBB39:
 2000              	.LBB40:
 197:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	(
 2001              		.loc 2 197 0
 2002              		.syntax unified
 2003              	@ 197 ".\Source\portable\GCC\ARM_CM3/portmacro.h" 1
 2004 0006 4FF0A003 			mov r3, #160												
 2005 000a 83F31188 		msr basepri, r3											
 2006 000e BFF36F8F 		isb														
 2007 0012 BFF34F8F 		dsb														
 2008              	
 2009              	@ 0 "" 2
 2010              		.thumb
 2011              		.syntax unified
 2012 0016 7B60     		str	r3, [r7, #4]
 2013              	.LBE40:
 2014              	.LBE39:
2101:Source/tasks.c **** 	/* Stop the scheduler interrupts and call the portable scheduler end
2102:Source/tasks.c **** 	routine so the original ISRs can be restored if necessary.  The port
2103:Source/tasks.c **** 	layer must ensure interrupts enable	bit is left in the correct state. */
2104:Source/tasks.c **** 	portDISABLE_INTERRUPTS();
2105:Source/tasks.c **** 	xSchedulerRunning = pdFALSE;
 2015              		.loc 1 2105 0
 2016 0018 044B     		ldr	r3, .L136
 2017 001a 0022     		movs	r2, #0
 2018 001c 1A60     		str	r2, [r3]
2106:Source/tasks.c **** 	vPortEndScheduler();
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 78
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 78
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 2019              		.loc 1 2106 0
 2020 001e FFF7FEFF 		bl	vPortEndScheduler
2107:Source/tasks.c **** }
 2021              		.loc 1 2107 0
 2022 0022 00BF     		nop
 2023 0024 0837     		adds	r7, r7, #8
 2024              		.cfi_def_cfa_offset 8
 2025 0026 BD46     		mov	sp, r7
 2026              		.cfi_def_cfa_register 13
 2027              		@ sp needed
 2028 0028 80BD     		pop	{r7, pc}
 2029              	.L137:
 2030 002a 00BF     		.align	2
 2031              	.L136:
 2032 002c E4000000 		.word	xSchedulerRunning
 2033              		.cfi_endproc
 2034              	.LFE83:
 2035              		.size	vTaskEndScheduler, .-vTaskEndScheduler
 2036              		.section	.text.vTaskSuspendAll,"ax",%progbits
 2037              		.align	2
 2038              		.global	vTaskSuspendAll
 2039              		.thumb
 2040              		.thumb_func
 2041              		.type	vTaskSuspendAll, %function
 2042              	vTaskSuspendAll:
 2043              	.LFB84:
2108:Source/tasks.c **** /*----------------------------------------------------------*/
2109:Source/tasks.c **** 
2110:Source/tasks.c **** void vTaskSuspendAll( void )
2111:Source/tasks.c **** {
 2044              		.loc 1 2111 0
 2045              		.cfi_startproc
 2046              		@ args = 0, pretend = 0, frame = 0
 2047              		@ frame_needed = 1, uses_anonymous_args = 0
 2048              		@ link register save eliminated.
 2049 0000 80B4     		push	{r7}
 2050              		.cfi_def_cfa_offset 4
 2051              		.cfi_offset 7, -4
 2052 0002 00AF     		add	r7, sp, #0
 2053              		.cfi_def_cfa_register 7
2112:Source/tasks.c **** 	/* A critical section is not required as the variable is of type
2113:Source/tasks.c **** 	BaseType_t.  Please read Richard Barry's reply in the following link to a
2114:Source/tasks.c **** 	post in the FreeRTOS support forum before reporting this as a bug! -
2115:Source/tasks.c **** 	http://goo.gl/wu4acr */
2116:Source/tasks.c **** 
2117:Source/tasks.c **** 	/* portSOFRWARE_BARRIER() is only implemented for emulated/simulated ports that
2118:Source/tasks.c **** 	do not otherwise exhibit real time behaviour. */
2119:Source/tasks.c **** 	portSOFTWARE_BARRIER();
2120:Source/tasks.c **** 
2121:Source/tasks.c **** 	/* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
2122:Source/tasks.c **** 	is used to allow calls to vTaskSuspendAll() to nest. */
2123:Source/tasks.c **** 	++uxSchedulerSuspended;
 2054              		.loc 1 2123 0
 2055 0004 044B     		ldr	r3, .L139
 2056 0006 1B68     		ldr	r3, [r3]
 2057 0008 0133     		adds	r3, r3, #1
 2058 000a 034A     		ldr	r2, .L139
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 79
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 79
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 2059 000c 1360     		str	r3, [r2]
2124:Source/tasks.c **** 
2125:Source/tasks.c **** 	/* Enforces ordering for ports and optimised compilers that may otherwise place
2126:Source/tasks.c **** 	the above increment elsewhere. */
2127:Source/tasks.c **** 	portMEMORY_BARRIER();
 2060              		.loc 1 2127 0
2128:Source/tasks.c **** }
 2061              		.loc 1 2128 0
 2062 000e 00BF     		nop
 2063 0010 BD46     		mov	sp, r7
 2064              		.cfi_def_cfa_register 13
 2065              		@ sp needed
 2066 0012 80BC     		pop	{r7}
 2067              		.cfi_restore 7
 2068              		.cfi_def_cfa_offset 0
 2069 0014 7047     		bx	lr
 2070              	.L140:
 2071 0016 00BF     		.align	2
 2072              	.L139:
 2073 0018 00010000 		.word	uxSchedulerSuspended
 2074              		.cfi_endproc
 2075              	.LFE84:
 2076              		.size	vTaskSuspendAll, .-vTaskSuspendAll
 2077              		.section	.text.xTaskResumeAll,"ax",%progbits
 2078              		.align	2
 2079              		.global	xTaskResumeAll
 2080              		.thumb
 2081              		.thumb_func
 2082              		.type	xTaskResumeAll, %function
 2083              	xTaskResumeAll:
 2084              	.LFB85:
2129:Source/tasks.c **** /*----------------------------------------------------------*/
2130:Source/tasks.c **** 
2131:Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
2132:Source/tasks.c **** 
2133:Source/tasks.c **** 	static TickType_t prvGetExpectedIdleTime( void )
2134:Source/tasks.c **** 	{
2135:Source/tasks.c **** 	TickType_t xReturn;
2136:Source/tasks.c **** 	UBaseType_t uxHigherPriorityReadyTasks = pdFALSE;
2137:Source/tasks.c **** 
2138:Source/tasks.c **** 		/* uxHigherPriorityReadyTasks takes care of the case where
2139:Source/tasks.c **** 		configUSE_PREEMPTION is 0, so there may be tasks above the idle priority
2140:Source/tasks.c **** 		task that are in the Ready state, even though the idle task is
2141:Source/tasks.c **** 		running. */
2142:Source/tasks.c **** 		#if( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
2143:Source/tasks.c **** 		{
2144:Source/tasks.c **** 			if( uxTopReadyPriority > tskIDLE_PRIORITY )
2145:Source/tasks.c **** 			{
2146:Source/tasks.c **** 				uxHigherPriorityReadyTasks = pdTRUE;
2147:Source/tasks.c **** 			}
2148:Source/tasks.c **** 		}
2149:Source/tasks.c **** 		#else
2150:Source/tasks.c **** 		{
2151:Source/tasks.c **** 			const UBaseType_t uxLeastSignificantBit = ( UBaseType_t ) 0x01;
2152:Source/tasks.c **** 
2153:Source/tasks.c **** 			/* When port optimised task selection is used the uxTopReadyPriority
2154:Source/tasks.c **** 			variable is used as a bit map.  If bits other than the least
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 80
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 80
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


2155:Source/tasks.c **** 			significant bit are set then there are tasks that have a priority
2156:Source/tasks.c **** 			above the idle priority that are in the Ready state.  This takes
2157:Source/tasks.c **** 			care of the case where the co-operative scheduler is in use. */
2158:Source/tasks.c **** 			if( uxTopReadyPriority > uxLeastSignificantBit )
2159:Source/tasks.c **** 			{
2160:Source/tasks.c **** 				uxHigherPriorityReadyTasks = pdTRUE;
2161:Source/tasks.c **** 			}
2162:Source/tasks.c **** 		}
2163:Source/tasks.c **** 		#endif
2164:Source/tasks.c **** 
2165:Source/tasks.c **** 		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
2166:Source/tasks.c **** 		{
2167:Source/tasks.c **** 			xReturn = 0;
2168:Source/tasks.c **** 		}
2169:Source/tasks.c **** 		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
2170:Source/tasks.c **** 		{
2171:Source/tasks.c **** 			/* There are other idle priority tasks in the ready state.  If
2172:Source/tasks.c **** 			time slicing is used then the very next tick interrupt must be
2173:Source/tasks.c **** 			processed. */
2174:Source/tasks.c **** 			xReturn = 0;
2175:Source/tasks.c **** 		}
2176:Source/tasks.c **** 		else if( uxHigherPriorityReadyTasks != pdFALSE )
2177:Source/tasks.c **** 		{
2178:Source/tasks.c **** 			/* There are tasks in the Ready state that have a priority above the
2179:Source/tasks.c **** 			idle priority.  This path can only be reached if
2180:Source/tasks.c **** 			configUSE_PREEMPTION is 0. */
2181:Source/tasks.c **** 			xReturn = 0;
2182:Source/tasks.c **** 		}
2183:Source/tasks.c **** 		else
2184:Source/tasks.c **** 		{
2185:Source/tasks.c **** 			xReturn = xNextTaskUnblockTime - xTickCount;
2186:Source/tasks.c **** 		}
2187:Source/tasks.c **** 
2188:Source/tasks.c **** 		return xReturn;
2189:Source/tasks.c **** 	}
2190:Source/tasks.c **** 
2191:Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
2192:Source/tasks.c **** /*----------------------------------------------------------*/
2193:Source/tasks.c **** 
2194:Source/tasks.c **** BaseType_t xTaskResumeAll( void )
2195:Source/tasks.c **** {
 2085              		.loc 1 2195 0
 2086              		.cfi_startproc
 2087              		@ args = 0, pretend = 0, frame = 16
 2088              		@ frame_needed = 1, uses_anonymous_args = 0
 2089 0000 80B5     		push	{r7, lr}
 2090              		.cfi_def_cfa_offset 8
 2091              		.cfi_offset 7, -8
 2092              		.cfi_offset 14, -4
 2093 0002 84B0     		sub	sp, sp, #16
 2094              		.cfi_def_cfa_offset 24
 2095 0004 00AF     		add	r7, sp, #0
 2096              		.cfi_def_cfa_register 7
2196:Source/tasks.c **** TCB_t *pxTCB = NULL;
 2097              		.loc 1 2196 0
 2098 0006 0023     		movs	r3, #0
 2099 0008 FB60     		str	r3, [r7, #12]
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 81
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 81
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


2197:Source/tasks.c **** BaseType_t xAlreadyYielded = pdFALSE;
 2100              		.loc 1 2197 0
 2101 000a 0023     		movs	r3, #0
 2102 000c BB60     		str	r3, [r7, #8]
2198:Source/tasks.c **** 
2199:Source/tasks.c **** 	/* If uxSchedulerSuspended is zero then this function does not match a
2200:Source/tasks.c **** 	previous call to vTaskSuspendAll(). */
2201:Source/tasks.c **** 	configASSERT( uxSchedulerSuspended );
2202:Source/tasks.c **** 
2203:Source/tasks.c **** 	/* It is possible that an ISR caused a task to be removed from an event
2204:Source/tasks.c **** 	list while the scheduler was suspended.  If this was the case then the
2205:Source/tasks.c **** 	removed task will have been added to the xPendingReadyList.  Once the
2206:Source/tasks.c **** 	scheduler has been resumed it is safe to move all the pending ready
2207:Source/tasks.c **** 	tasks from this list into their appropriate ready list. */
2208:Source/tasks.c **** 	taskENTER_CRITICAL();
 2103              		.loc 1 2208 0
 2104 000e FFF7FEFF 		bl	vPortEnterCritical
2209:Source/tasks.c **** 	{
2210:Source/tasks.c **** 		--uxSchedulerSuspended;
 2105              		.loc 1 2210 0
 2106 0012 394B     		ldr	r3, .L150
 2107 0014 1B68     		ldr	r3, [r3]
 2108 0016 013B     		subs	r3, r3, #1
 2109 0018 374A     		ldr	r2, .L150
 2110 001a 1360     		str	r3, [r2]
2211:Source/tasks.c **** 
2212:Source/tasks.c **** 		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 2111              		.loc 1 2212 0
 2112 001c 364B     		ldr	r3, .L150
 2113 001e 1B68     		ldr	r3, [r3]
 2114 0020 002B     		cmp	r3, #0
 2115 0022 61D1     		bne	.L142
2213:Source/tasks.c **** 		{
2214:Source/tasks.c **** 			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 2116              		.loc 1 2214 0
 2117 0024 354B     		ldr	r3, .L150+4
 2118 0026 1B68     		ldr	r3, [r3]
 2119 0028 002B     		cmp	r3, #0
 2120 002a 5DD0     		beq	.L142
2215:Source/tasks.c **** 			{
2216:Source/tasks.c **** 				/* Move any readied tasks from the pending list into the
2217:Source/tasks.c **** 				appropriate ready list. */
2218:Source/tasks.c **** 				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 2121              		.loc 1 2218 0
 2122 002c 2EE0     		b	.L143
 2123              	.L144:
2219:Source/tasks.c **** 				{
2220:Source/tasks.c **** 					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as
 2124              		.loc 1 2220 0
 2125 002e 344B     		ldr	r3, .L150+8
 2126 0030 DB68     		ldr	r3, [r3, #12]
 2127 0032 DB68     		ldr	r3, [r3, #12]
 2128 0034 FB60     		str	r3, [r7, #12]
2221:Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 2129              		.loc 1 2221 0
 2130 0036 FB68     		ldr	r3, [r7, #12]
 2131 0038 1833     		adds	r3, r3, #24
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 82
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 82
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 2132 003a 1846     		mov	r0, r3
 2133 003c FFF7FEFF 		bl	uxListRemove
2222:Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 2134              		.loc 1 2222 0
 2135 0040 FB68     		ldr	r3, [r7, #12]
 2136 0042 0433     		adds	r3, r3, #4
 2137 0044 1846     		mov	r0, r3
 2138 0046 FFF7FEFF 		bl	uxListRemove
2223:Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 2139              		.loc 1 2223 0
 2140 004a FB68     		ldr	r3, [r7, #12]
 2141 004c DB6A     		ldr	r3, [r3, #44]
 2142 004e 0122     		movs	r2, #1
 2143 0050 9A40     		lsls	r2, r2, r3
 2144 0052 2C4B     		ldr	r3, .L150+12
 2145 0054 1B68     		ldr	r3, [r3]
 2146 0056 1343     		orrs	r3, r3, r2
 2147 0058 2A4A     		ldr	r2, .L150+12
 2148 005a 1360     		str	r3, [r2]
 2149 005c FB68     		ldr	r3, [r7, #12]
 2150 005e DA6A     		ldr	r2, [r3, #44]
 2151 0060 1346     		mov	r3, r2
 2152 0062 9B00     		lsls	r3, r3, #2
 2153 0064 1344     		add	r3, r3, r2
 2154 0066 9B00     		lsls	r3, r3, #2
 2155 0068 274A     		ldr	r2, .L150+16
 2156 006a 1A44     		add	r2, r2, r3
 2157 006c FB68     		ldr	r3, [r7, #12]
 2158 006e 0433     		adds	r3, r3, #4
 2159 0070 1946     		mov	r1, r3
 2160 0072 1046     		mov	r0, r2
 2161 0074 FFF7FEFF 		bl	vListInsertEnd
2224:Source/tasks.c **** 
2225:Source/tasks.c **** 					/* If the moved task has a priority higher than the current
2226:Source/tasks.c **** 					task then a yield must be performed. */
2227:Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 2162              		.loc 1 2227 0
 2163 0078 FB68     		ldr	r3, [r7, #12]
 2164 007a DA6A     		ldr	r2, [r3, #44]
 2165 007c 234B     		ldr	r3, .L150+20
 2166 007e 1B68     		ldr	r3, [r3]
 2167 0080 DB6A     		ldr	r3, [r3, #44]
 2168 0082 9A42     		cmp	r2, r3
 2169 0084 02D3     		bcc	.L143
2228:Source/tasks.c **** 					{
2229:Source/tasks.c **** 						xYieldPending = pdTRUE;
 2170              		.loc 1 2229 0
 2171 0086 224B     		ldr	r3, .L150+24
 2172 0088 0122     		movs	r2, #1
 2173 008a 1A60     		str	r2, [r3]
 2174              	.L143:
2218:Source/tasks.c **** 				{
 2175              		.loc 1 2218 0
 2176 008c 1C4B     		ldr	r3, .L150+8
 2177 008e 1B68     		ldr	r3, [r3]
 2178 0090 002B     		cmp	r3, #0
 2179 0092 CCD1     		bne	.L144
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 83
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 83
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


2230:Source/tasks.c **** 					}
2231:Source/tasks.c **** 					else
2232:Source/tasks.c **** 					{
2233:Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2234:Source/tasks.c **** 					}
2235:Source/tasks.c **** 				}
2236:Source/tasks.c **** 
2237:Source/tasks.c **** 				if( pxTCB != NULL )
 2180              		.loc 1 2237 0
 2181 0094 FB68     		ldr	r3, [r7, #12]
 2182 0096 002B     		cmp	r3, #0
 2183 0098 01D0     		beq	.L145
2238:Source/tasks.c **** 				{
2239:Source/tasks.c **** 					/* A task was unblocked while the scheduler was suspended,
2240:Source/tasks.c **** 					which may have prevented the next unblock time from being
2241:Source/tasks.c **** 					re-calculated, in which case re-calculate it now.  Mainly
2242:Source/tasks.c **** 					important for low power tickless implementations, where
2243:Source/tasks.c **** 					this can prevent an unnecessary exit from low power
2244:Source/tasks.c **** 					state. */
2245:Source/tasks.c **** 					prvResetNextTaskUnblockTime();
 2184              		.loc 1 2245 0
 2185 009a FFF7FEFF 		bl	prvResetNextTaskUnblockTime
 2186              	.L145:
 2187              	.LBB41:
2246:Source/tasks.c **** 				}
2247:Source/tasks.c **** 
2248:Source/tasks.c **** 				/* If any ticks occurred while the scheduler was suspended then
2249:Source/tasks.c **** 				they should be processed now.  This ensures the tick count does
2250:Source/tasks.c **** 				not	slip, and that any delayed tasks are resumed at the correct
2251:Source/tasks.c **** 				time. */
2252:Source/tasks.c **** 				{
2253:Source/tasks.c **** 					TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
 2188              		.loc 1 2253 0
 2189 009e 1D4B     		ldr	r3, .L150+28
 2190 00a0 1B68     		ldr	r3, [r3]
 2191 00a2 7B60     		str	r3, [r7, #4]
2254:Source/tasks.c **** 
2255:Source/tasks.c **** 					if( xPendedCounts > ( TickType_t ) 0U )
 2192              		.loc 1 2255 0
 2193 00a4 7B68     		ldr	r3, [r7, #4]
 2194 00a6 002B     		cmp	r3, #0
 2195 00a8 10D0     		beq	.L146
 2196              	.L148:
2256:Source/tasks.c **** 					{
2257:Source/tasks.c **** 						do
2258:Source/tasks.c **** 						{
2259:Source/tasks.c **** 							if( xTaskIncrementTick() != pdFALSE )
 2197              		.loc 1 2259 0
 2198 00aa FFF7FEFF 		bl	xTaskIncrementTick
 2199 00ae 0346     		mov	r3, r0
 2200 00b0 002B     		cmp	r3, #0
 2201 00b2 02D0     		beq	.L147
2260:Source/tasks.c **** 							{
2261:Source/tasks.c **** 								xYieldPending = pdTRUE;
 2202              		.loc 1 2261 0
 2203 00b4 164B     		ldr	r3, .L150+24
 2204 00b6 0122     		movs	r2, #1
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 84
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 84
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 2205 00b8 1A60     		str	r2, [r3]
 2206              	.L147:
2262:Source/tasks.c **** 							}
2263:Source/tasks.c **** 							else
2264:Source/tasks.c **** 							{
2265:Source/tasks.c **** 								mtCOVERAGE_TEST_MARKER();
2266:Source/tasks.c **** 							}
2267:Source/tasks.c **** 							--xPendedCounts;
 2207              		.loc 1 2267 0
 2208 00ba 7B68     		ldr	r3, [r7, #4]
 2209 00bc 013B     		subs	r3, r3, #1
 2210 00be 7B60     		str	r3, [r7, #4]
2268:Source/tasks.c **** 						} while( xPendedCounts > ( TickType_t ) 0U );
 2211              		.loc 1 2268 0
 2212 00c0 7B68     		ldr	r3, [r7, #4]
 2213 00c2 002B     		cmp	r3, #0
 2214 00c4 F1D1     		bne	.L148
2269:Source/tasks.c **** 
2270:Source/tasks.c **** 						xPendedTicks = 0;
 2215              		.loc 1 2270 0
 2216 00c6 134B     		ldr	r3, .L150+28
 2217 00c8 0022     		movs	r2, #0
 2218 00ca 1A60     		str	r2, [r3]
 2219              	.L146:
 2220              	.LBE41:
2271:Source/tasks.c **** 					}
2272:Source/tasks.c **** 					else
2273:Source/tasks.c **** 					{
2274:Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2275:Source/tasks.c **** 					}
2276:Source/tasks.c **** 				}
2277:Source/tasks.c **** 
2278:Source/tasks.c **** 				if( xYieldPending != pdFALSE )
 2221              		.loc 1 2278 0
 2222 00cc 104B     		ldr	r3, .L150+24
 2223 00ce 1B68     		ldr	r3, [r3]
 2224 00d0 002B     		cmp	r3, #0
 2225 00d2 09D0     		beq	.L142
2279:Source/tasks.c **** 				{
2280:Source/tasks.c **** 					#if( configUSE_PREEMPTION != 0 )
2281:Source/tasks.c **** 					{
2282:Source/tasks.c **** 						xAlreadyYielded = pdTRUE;
 2226              		.loc 1 2282 0
 2227 00d4 0123     		movs	r3, #1
 2228 00d6 BB60     		str	r3, [r7, #8]
2283:Source/tasks.c **** 					}
2284:Source/tasks.c **** 					#endif
2285:Source/tasks.c **** 					taskYIELD_IF_USING_PREEMPTION();
 2229              		.loc 1 2285 0
 2230 00d8 0F4B     		ldr	r3, .L150+32
 2231 00da 4FF08052 		mov	r2, #268435456
 2232 00de 1A60     		str	r2, [r3]
 2233              		.syntax unified
 2234              	@ 2285 "Source\tasks.c" 1
 2235 00e0 BFF34F8F 		dsb
 2236              	@ 0 "" 2
 2237              	@ 2285 "Source\tasks.c" 1
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 85
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 85
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 2238 00e4 BFF36F8F 		isb
 2239              	@ 0 "" 2
 2240              		.thumb
 2241              		.syntax unified
 2242              	.L142:
2286:Source/tasks.c **** 				}
2287:Source/tasks.c **** 				else
2288:Source/tasks.c **** 				{
2289:Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
2290:Source/tasks.c **** 				}
2291:Source/tasks.c **** 			}
2292:Source/tasks.c **** 		}
2293:Source/tasks.c **** 		else
2294:Source/tasks.c **** 		{
2295:Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2296:Source/tasks.c **** 		}
2297:Source/tasks.c **** 	}
2298:Source/tasks.c **** 	taskEXIT_CRITICAL();
 2243              		.loc 1 2298 0
 2244 00e8 FFF7FEFF 		bl	vPortExitCritical
2299:Source/tasks.c **** 
2300:Source/tasks.c **** 	return xAlreadyYielded;
 2245              		.loc 1 2300 0
 2246 00ec BB68     		ldr	r3, [r7, #8]
2301:Source/tasks.c **** }
 2247              		.loc 1 2301 0
 2248 00ee 1846     		mov	r0, r3
 2249 00f0 1037     		adds	r7, r7, #16
 2250              		.cfi_def_cfa_offset 8
 2251 00f2 BD46     		mov	sp, r7
 2252              		.cfi_def_cfa_register 13
 2253              		@ sp needed
 2254 00f4 80BD     		pop	{r7, pc}
 2255              	.L151:
 2256 00f6 00BF     		.align	2
 2257              	.L150:
 2258 00f8 00010000 		.word	uxSchedulerSuspended
 2259 00fc D8000000 		.word	uxCurrentNumberOfTasks
 2260 0100 98000000 		.word	xPendingReadyList
 2261 0104 E0000000 		.word	uxTopReadyPriority
 2262 0108 04000000 		.word	pxReadyTasksLists
 2263 010c 00000000 		.word	pxCurrentTCB
 2264 0110 EC000000 		.word	xYieldPending
 2265 0114 E8000000 		.word	xPendedTicks
 2266 0118 04ED00E0 		.word	-536810236
 2267              		.cfi_endproc
 2268              	.LFE85:
 2269              		.size	xTaskResumeAll, .-xTaskResumeAll
 2270              		.section	.text.xTaskGetTickCount,"ax",%progbits
 2271              		.align	2
 2272              		.global	xTaskGetTickCount
 2273              		.thumb
 2274              		.thumb_func
 2275              		.type	xTaskGetTickCount, %function
 2276              	xTaskGetTickCount:
 2277              	.LFB86:
2302:Source/tasks.c **** /*-----------------------------------------------------------*/
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 86
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 86
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


2303:Source/tasks.c **** 
2304:Source/tasks.c **** TickType_t xTaskGetTickCount( void )
2305:Source/tasks.c **** {
 2278              		.loc 1 2305 0
 2279              		.cfi_startproc
 2280              		@ args = 0, pretend = 0, frame = 8
 2281              		@ frame_needed = 1, uses_anonymous_args = 0
 2282              		@ link register save eliminated.
 2283 0000 80B4     		push	{r7}
 2284              		.cfi_def_cfa_offset 4
 2285              		.cfi_offset 7, -4
 2286 0002 83B0     		sub	sp, sp, #12
 2287              		.cfi_def_cfa_offset 16
 2288 0004 00AF     		add	r7, sp, #0
 2289              		.cfi_def_cfa_register 7
2306:Source/tasks.c **** TickType_t xTicks;
2307:Source/tasks.c **** 
2308:Source/tasks.c **** 	/* Critical section required if running on a 16 bit processor. */
2309:Source/tasks.c **** 	portTICK_TYPE_ENTER_CRITICAL();
2310:Source/tasks.c **** 	{
2311:Source/tasks.c **** 		xTicks = xTickCount;
 2290              		.loc 1 2311 0
 2291 0006 044B     		ldr	r3, .L154
 2292 0008 1B68     		ldr	r3, [r3]
 2293 000a 7B60     		str	r3, [r7, #4]
2312:Source/tasks.c **** 	}
2313:Source/tasks.c **** 	portTICK_TYPE_EXIT_CRITICAL();
2314:Source/tasks.c **** 
2315:Source/tasks.c **** 	return xTicks;
 2294              		.loc 1 2315 0
 2295 000c 7B68     		ldr	r3, [r7, #4]
2316:Source/tasks.c **** }
 2296              		.loc 1 2316 0
 2297 000e 1846     		mov	r0, r3
 2298 0010 0C37     		adds	r7, r7, #12
 2299              		.cfi_def_cfa_offset 4
 2300 0012 BD46     		mov	sp, r7
 2301              		.cfi_def_cfa_register 13
 2302              		@ sp needed
 2303 0014 80BC     		pop	{r7}
 2304              		.cfi_restore 7
 2305              		.cfi_def_cfa_offset 0
 2306 0016 7047     		bx	lr
 2307              	.L155:
 2308              		.align	2
 2309              	.L154:
 2310 0018 DC000000 		.word	xTickCount
 2311              		.cfi_endproc
 2312              	.LFE86:
 2313              		.size	xTaskGetTickCount, .-xTaskGetTickCount
 2314              		.section	.text.xTaskGetTickCountFromISR,"ax",%progbits
 2315              		.align	2
 2316              		.global	xTaskGetTickCountFromISR
 2317              		.thumb
 2318              		.thumb_func
 2319              		.type	xTaskGetTickCountFromISR, %function
 2320              	xTaskGetTickCountFromISR:
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 87
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 87
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 2321              	.LFB87:
2317:Source/tasks.c **** /*-----------------------------------------------------------*/
2318:Source/tasks.c **** 
2319:Source/tasks.c **** TickType_t xTaskGetTickCountFromISR( void )
2320:Source/tasks.c **** {
 2322              		.loc 1 2320 0
 2323              		.cfi_startproc
 2324              		@ args = 0, pretend = 0, frame = 8
 2325              		@ frame_needed = 1, uses_anonymous_args = 0
 2326              		@ link register save eliminated.
 2327 0000 80B4     		push	{r7}
 2328              		.cfi_def_cfa_offset 4
 2329              		.cfi_offset 7, -4
 2330 0002 83B0     		sub	sp, sp, #12
 2331              		.cfi_def_cfa_offset 16
 2332 0004 00AF     		add	r7, sp, #0
 2333              		.cfi_def_cfa_register 7
2321:Source/tasks.c **** TickType_t xReturn;
2322:Source/tasks.c **** UBaseType_t uxSavedInterruptStatus;
2323:Source/tasks.c **** 
2324:Source/tasks.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
2325:Source/tasks.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
2326:Source/tasks.c **** 	above the maximum system call priority are kept permanently enabled, even
2327:Source/tasks.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
2328:Source/tasks.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
2329:Source/tasks.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
2330:Source/tasks.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
2331:Source/tasks.c **** 	assigned a priority above the configured maximum system call priority.
2332:Source/tasks.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
2333:Source/tasks.c **** 	that have been assigned a priority at or (logically) below the maximum
2334:Source/tasks.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
2335:Source/tasks.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
2336:Source/tasks.c **** 	More information (albeit Cortex-M specific) is provided on the following
2337:Source/tasks.c **** 	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
2338:Source/tasks.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
2339:Source/tasks.c **** 
2340:Source/tasks.c **** 	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
 2334              		.loc 1 2340 0
 2335 0006 0023     		movs	r3, #0
 2336 0008 7B60     		str	r3, [r7, #4]
2341:Source/tasks.c **** 	{
2342:Source/tasks.c **** 		xReturn = xTickCount;
 2337              		.loc 1 2342 0
 2338 000a 044B     		ldr	r3, .L158
 2339 000c 1B68     		ldr	r3, [r3]
 2340 000e 3B60     		str	r3, [r7]
2343:Source/tasks.c **** 	}
2344:Source/tasks.c **** 	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
2345:Source/tasks.c **** 
2346:Source/tasks.c **** 	return xReturn;
 2341              		.loc 1 2346 0
 2342 0010 3B68     		ldr	r3, [r7]
2347:Source/tasks.c **** }
 2343              		.loc 1 2347 0
 2344 0012 1846     		mov	r0, r3
 2345 0014 0C37     		adds	r7, r7, #12
 2346              		.cfi_def_cfa_offset 4
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 88
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 88
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 2347 0016 BD46     		mov	sp, r7
 2348              		.cfi_def_cfa_register 13
 2349              		@ sp needed
 2350 0018 80BC     		pop	{r7}
 2351              		.cfi_restore 7
 2352              		.cfi_def_cfa_offset 0
 2353 001a 7047     		bx	lr
 2354              	.L159:
 2355              		.align	2
 2356              	.L158:
 2357 001c DC000000 		.word	xTickCount
 2358              		.cfi_endproc
 2359              	.LFE87:
 2360              		.size	xTaskGetTickCountFromISR, .-xTaskGetTickCountFromISR
 2361              		.section	.text.uxTaskGetNumberOfTasks,"ax",%progbits
 2362              		.align	2
 2363              		.global	uxTaskGetNumberOfTasks
 2364              		.thumb
 2365              		.thumb_func
 2366              		.type	uxTaskGetNumberOfTasks, %function
 2367              	uxTaskGetNumberOfTasks:
 2368              	.LFB88:
2348:Source/tasks.c **** /*-----------------------------------------------------------*/
2349:Source/tasks.c **** 
2350:Source/tasks.c **** UBaseType_t uxTaskGetNumberOfTasks( void )
2351:Source/tasks.c **** {
 2369              		.loc 1 2351 0
 2370              		.cfi_startproc
 2371              		@ args = 0, pretend = 0, frame = 0
 2372              		@ frame_needed = 1, uses_anonymous_args = 0
 2373              		@ link register save eliminated.
 2374 0000 80B4     		push	{r7}
 2375              		.cfi_def_cfa_offset 4
 2376              		.cfi_offset 7, -4
 2377 0002 00AF     		add	r7, sp, #0
 2378              		.cfi_def_cfa_register 7
2352:Source/tasks.c **** 	/* A critical section is not required because the variables are of type
2353:Source/tasks.c **** 	BaseType_t. */
2354:Source/tasks.c **** 	return uxCurrentNumberOfTasks;
 2379              		.loc 1 2354 0
 2380 0004 024B     		ldr	r3, .L162
 2381 0006 1B68     		ldr	r3, [r3]
2355:Source/tasks.c **** }
 2382              		.loc 1 2355 0
 2383 0008 1846     		mov	r0, r3
 2384 000a BD46     		mov	sp, r7
 2385              		.cfi_def_cfa_register 13
 2386              		@ sp needed
 2387 000c 80BC     		pop	{r7}
 2388              		.cfi_restore 7
 2389              		.cfi_def_cfa_offset 0
 2390 000e 7047     		bx	lr
 2391              	.L163:
 2392              		.align	2
 2393              	.L162:
 2394 0010 D8000000 		.word	uxCurrentNumberOfTasks
 2395              		.cfi_endproc
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 89
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 89
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 2396              	.LFE88:
 2397              		.size	uxTaskGetNumberOfTasks, .-uxTaskGetNumberOfTasks
 2398              		.section	.text.pcTaskGetName,"ax",%progbits
 2399              		.align	2
 2400              		.global	pcTaskGetName
 2401              		.thumb
 2402              		.thumb_func
 2403              		.type	pcTaskGetName, %function
 2404              	pcTaskGetName:
 2405              	.LFB89:
2356:Source/tasks.c **** /*-----------------------------------------------------------*/
2357:Source/tasks.c **** 
2358:Source/tasks.c **** char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed fo
2359:Source/tasks.c **** {
 2406              		.loc 1 2359 0
 2407              		.cfi_startproc
 2408              		@ args = 0, pretend = 0, frame = 16
 2409              		@ frame_needed = 1, uses_anonymous_args = 0
 2410              		@ link register save eliminated.
 2411 0000 80B4     		push	{r7}
 2412              		.cfi_def_cfa_offset 4
 2413              		.cfi_offset 7, -4
 2414 0002 85B0     		sub	sp, sp, #20
 2415              		.cfi_def_cfa_offset 24
 2416 0004 00AF     		add	r7, sp, #0
 2417              		.cfi_def_cfa_register 7
 2418 0006 7860     		str	r0, [r7, #4]
2360:Source/tasks.c **** TCB_t *pxTCB;
2361:Source/tasks.c **** 
2362:Source/tasks.c **** 	/* If null is passed in here then the name of the calling task is being
2363:Source/tasks.c **** 	queried. */
2364:Source/tasks.c **** 	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
 2419              		.loc 1 2364 0
 2420 0008 7B68     		ldr	r3, [r7, #4]
 2421 000a 002B     		cmp	r3, #0
 2422 000c 02D1     		bne	.L165
 2423              		.loc 1 2364 0 is_stmt 0 discriminator 1
 2424 000e 064B     		ldr	r3, .L168
 2425 0010 1B68     		ldr	r3, [r3]
 2426 0012 00E0     		b	.L166
 2427              	.L165:
 2428              		.loc 1 2364 0 discriminator 2
 2429 0014 7B68     		ldr	r3, [r7, #4]
 2430              	.L166:
 2431              		.loc 1 2364 0 discriminator 4
 2432 0016 FB60     		str	r3, [r7, #12]
2365:Source/tasks.c **** 	configASSERT( pxTCB );
2366:Source/tasks.c **** 	return &( pxTCB->pcTaskName[ 0 ] );
 2433              		.loc 1 2366 0 is_stmt 1 discriminator 4
 2434 0018 FB68     		ldr	r3, [r7, #12]
 2435 001a 3433     		adds	r3, r3, #52
2367:Source/tasks.c **** }
 2436              		.loc 1 2367 0 discriminator 4
 2437 001c 1846     		mov	r0, r3
 2438 001e 1437     		adds	r7, r7, #20
 2439              		.cfi_def_cfa_offset 4
 2440 0020 BD46     		mov	sp, r7
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 90
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 90
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 2441              		.cfi_def_cfa_register 13
 2442              		@ sp needed
 2443 0022 80BC     		pop	{r7}
 2444              		.cfi_restore 7
 2445              		.cfi_def_cfa_offset 0
 2446 0024 7047     		bx	lr
 2447              	.L169:
 2448 0026 00BF     		.align	2
 2449              	.L168:
 2450 0028 00000000 		.word	pxCurrentTCB
 2451              		.cfi_endproc
 2452              	.LFE89:
 2453              		.size	pcTaskGetName, .-pcTaskGetName
 2454              		.section	.text.xTaskCatchUpTicks,"ax",%progbits
 2455              		.align	2
 2456              		.global	xTaskCatchUpTicks
 2457              		.thumb
 2458              		.thumb_func
 2459              		.type	xTaskCatchUpTicks, %function
 2460              	xTaskCatchUpTicks:
 2461              	.LFB90:
2368:Source/tasks.c **** /*-----------------------------------------------------------*/
2369:Source/tasks.c **** 
2370:Source/tasks.c **** #if ( INCLUDE_xTaskGetHandle == 1 )
2371:Source/tasks.c **** 
2372:Source/tasks.c **** 	static TCB_t *prvSearchForNameWithinSingleList( List_t *pxList, const char pcNameToQuery[] )
2373:Source/tasks.c **** 	{
2374:Source/tasks.c **** 	TCB_t *pxNextTCB, *pxFirstTCB, *pxReturn = NULL;
2375:Source/tasks.c **** 	UBaseType_t x;
2376:Source/tasks.c **** 	char cNextChar;
2377:Source/tasks.c **** 	BaseType_t xBreakLoop;
2378:Source/tasks.c **** 
2379:Source/tasks.c **** 		/* This function is called with the scheduler suspended. */
2380:Source/tasks.c **** 
2381:Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
2382:Source/tasks.c **** 		{
2383:Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );  /*lint !e9079 void * is used as this macro i
2384:Source/tasks.c **** 
2385:Source/tasks.c **** 			do
2386:Source/tasks.c **** 			{
2387:Source/tasks.c **** 				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList ); /*lint !e9079 void * is used as this macro is
2388:Source/tasks.c **** 
2389:Source/tasks.c **** 				/* Check each character in the name looking for a match or
2390:Source/tasks.c **** 				mismatch. */
2391:Source/tasks.c **** 				xBreakLoop = pdFALSE;
2392:Source/tasks.c **** 				for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
2393:Source/tasks.c **** 				{
2394:Source/tasks.c **** 					cNextChar = pxNextTCB->pcTaskName[ x ];
2395:Source/tasks.c **** 
2396:Source/tasks.c **** 					if( cNextChar != pcNameToQuery[ x ] )
2397:Source/tasks.c **** 					{
2398:Source/tasks.c **** 						/* Characters didn't match. */
2399:Source/tasks.c **** 						xBreakLoop = pdTRUE;
2400:Source/tasks.c **** 					}
2401:Source/tasks.c **** 					else if( cNextChar == ( char ) 0x00 )
2402:Source/tasks.c **** 					{
2403:Source/tasks.c **** 						/* Both strings terminated, a match must have been
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 91
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 91
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


2404:Source/tasks.c **** 						found. */
2405:Source/tasks.c **** 						pxReturn = pxNextTCB;
2406:Source/tasks.c **** 						xBreakLoop = pdTRUE;
2407:Source/tasks.c **** 					}
2408:Source/tasks.c **** 					else
2409:Source/tasks.c **** 					{
2410:Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2411:Source/tasks.c **** 					}
2412:Source/tasks.c **** 
2413:Source/tasks.c **** 					if( xBreakLoop != pdFALSE )
2414:Source/tasks.c **** 					{
2415:Source/tasks.c **** 						break;
2416:Source/tasks.c **** 					}
2417:Source/tasks.c **** 				}
2418:Source/tasks.c **** 
2419:Source/tasks.c **** 				if( pxReturn != NULL )
2420:Source/tasks.c **** 				{
2421:Source/tasks.c **** 					/* The handle has been found. */
2422:Source/tasks.c **** 					break;
2423:Source/tasks.c **** 				}
2424:Source/tasks.c **** 
2425:Source/tasks.c **** 			} while( pxNextTCB != pxFirstTCB );
2426:Source/tasks.c **** 		}
2427:Source/tasks.c **** 		else
2428:Source/tasks.c **** 		{
2429:Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2430:Source/tasks.c **** 		}
2431:Source/tasks.c **** 
2432:Source/tasks.c **** 		return pxReturn;
2433:Source/tasks.c **** 	}
2434:Source/tasks.c **** 
2435:Source/tasks.c **** #endif /* INCLUDE_xTaskGetHandle */
2436:Source/tasks.c **** /*-----------------------------------------------------------*/
2437:Source/tasks.c **** 
2438:Source/tasks.c **** #if ( INCLUDE_xTaskGetHandle == 1 )
2439:Source/tasks.c **** 
2440:Source/tasks.c **** 	TaskHandle_t xTaskGetHandle( const char *pcNameToQuery ) /*lint !e971 Unqualified char types are a
2441:Source/tasks.c **** 	{
2442:Source/tasks.c **** 	UBaseType_t uxQueue = configMAX_PRIORITIES;
2443:Source/tasks.c **** 	TCB_t* pxTCB;
2444:Source/tasks.c **** 
2445:Source/tasks.c **** 		/* Task names will be truncated to configMAX_TASK_NAME_LEN - 1 bytes. */
2446:Source/tasks.c **** 		configASSERT( strlen( pcNameToQuery ) < configMAX_TASK_NAME_LEN );
2447:Source/tasks.c **** 
2448:Source/tasks.c **** 		vTaskSuspendAll();
2449:Source/tasks.c **** 		{
2450:Source/tasks.c **** 			/* Search the ready lists. */
2451:Source/tasks.c **** 			do
2452:Source/tasks.c **** 			{
2453:Source/tasks.c **** 				uxQueue--;
2454:Source/tasks.c **** 				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) &( pxReadyTasksLists[ uxQueue ] ), pcNam
2455:Source/tasks.c **** 
2456:Source/tasks.c **** 				if( pxTCB != NULL )
2457:Source/tasks.c **** 				{
2458:Source/tasks.c **** 					/* Found the handle. */
2459:Source/tasks.c **** 					break;
2460:Source/tasks.c **** 				}
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 92
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 92
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


2461:Source/tasks.c **** 
2462:Source/tasks.c **** 			} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts
2463:Source/tasks.c **** 
2464:Source/tasks.c **** 			/* Search the delayed lists. */
2465:Source/tasks.c **** 			if( pxTCB == NULL )
2466:Source/tasks.c **** 			{
2467:Source/tasks.c **** 				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxDelayedTaskList, pcNameToQuery );
2468:Source/tasks.c **** 			}
2469:Source/tasks.c **** 
2470:Source/tasks.c **** 			if( pxTCB == NULL )
2471:Source/tasks.c **** 			{
2472:Source/tasks.c **** 				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxOverflowDelayedTaskList, pcNameToQuery
2473:Source/tasks.c **** 			}
2474:Source/tasks.c **** 
2475:Source/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
2476:Source/tasks.c **** 			{
2477:Source/tasks.c **** 				if( pxTCB == NULL )
2478:Source/tasks.c **** 				{
2479:Source/tasks.c **** 					/* Search the suspended list. */
2480:Source/tasks.c **** 					pxTCB = prvSearchForNameWithinSingleList( &xSuspendedTaskList, pcNameToQuery );
2481:Source/tasks.c **** 				}
2482:Source/tasks.c **** 			}
2483:Source/tasks.c **** 			#endif
2484:Source/tasks.c **** 
2485:Source/tasks.c **** 			#if( INCLUDE_vTaskDelete == 1 )
2486:Source/tasks.c **** 			{
2487:Source/tasks.c **** 				if( pxTCB == NULL )
2488:Source/tasks.c **** 				{
2489:Source/tasks.c **** 					/* Search the deleted list. */
2490:Source/tasks.c **** 					pxTCB = prvSearchForNameWithinSingleList( &xTasksWaitingTermination, pcNameToQuery );
2491:Source/tasks.c **** 				}
2492:Source/tasks.c **** 			}
2493:Source/tasks.c **** 			#endif
2494:Source/tasks.c **** 		}
2495:Source/tasks.c **** 		( void ) xTaskResumeAll();
2496:Source/tasks.c **** 
2497:Source/tasks.c **** 		return pxTCB;
2498:Source/tasks.c **** 	}
2499:Source/tasks.c **** 
2500:Source/tasks.c **** #endif /* INCLUDE_xTaskGetHandle */
2501:Source/tasks.c **** /*-----------------------------------------------------------*/
2502:Source/tasks.c **** 
2503:Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2504:Source/tasks.c **** 
2505:Source/tasks.c **** 	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArra
2506:Source/tasks.c **** 	{
2507:Source/tasks.c **** 	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
2508:Source/tasks.c **** 
2509:Source/tasks.c **** 		vTaskSuspendAll();
2510:Source/tasks.c **** 		{
2511:Source/tasks.c **** 			/* Is there a space in the array for each task in the system? */
2512:Source/tasks.c **** 			if( uxArraySize >= uxCurrentNumberOfTasks )
2513:Source/tasks.c **** 			{
2514:Source/tasks.c **** 				/* Fill in an TaskStatus_t structure with information on each
2515:Source/tasks.c **** 				task in the Ready state. */
2516:Source/tasks.c **** 				do
2517:Source/tasks.c **** 				{
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 93
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 93
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


2518:Source/tasks.c **** 					uxQueue--;
2519:Source/tasks.c **** 					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists
2520:Source/tasks.c **** 
2521:Source/tasks.c **** 				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the cast
2522:Source/tasks.c **** 
2523:Source/tasks.c **** 				/* Fill in an TaskStatus_t structure with information on each
2524:Source/tasks.c **** 				task in the Blocked state. */
2525:Source/tasks.c **** 				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelaye
2526:Source/tasks.c **** 				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverfl
2527:Source/tasks.c **** 
2528:Source/tasks.c **** 				#if( INCLUDE_vTaskDelete == 1 )
2529:Source/tasks.c **** 				{
2530:Source/tasks.c **** 					/* Fill in an TaskStatus_t structure with information on
2531:Source/tasks.c **** 					each task that has been deleted but not yet cleaned up. */
2532:Source/tasks.c **** 					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermin
2533:Source/tasks.c **** 				}
2534:Source/tasks.c **** 				#endif
2535:Source/tasks.c **** 
2536:Source/tasks.c **** 				#if ( INCLUDE_vTaskSuspend == 1 )
2537:Source/tasks.c **** 				{
2538:Source/tasks.c **** 					/* Fill in an TaskStatus_t structure with information on
2539:Source/tasks.c **** 					each task in the Suspended state. */
2540:Source/tasks.c **** 					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList,
2541:Source/tasks.c **** 				}
2542:Source/tasks.c **** 				#endif
2543:Source/tasks.c **** 
2544:Source/tasks.c **** 				#if ( configGENERATE_RUN_TIME_STATS == 1)
2545:Source/tasks.c **** 				{
2546:Source/tasks.c **** 					if( pulTotalRunTime != NULL )
2547:Source/tasks.c **** 					{
2548:Source/tasks.c **** 						#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
2549:Source/tasks.c **** 							portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
2550:Source/tasks.c **** 						#else
2551:Source/tasks.c **** 							*pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
2552:Source/tasks.c **** 						#endif
2553:Source/tasks.c **** 					}
2554:Source/tasks.c **** 				}
2555:Source/tasks.c **** 				#else
2556:Source/tasks.c **** 				{
2557:Source/tasks.c **** 					if( pulTotalRunTime != NULL )
2558:Source/tasks.c **** 					{
2559:Source/tasks.c **** 						*pulTotalRunTime = 0;
2560:Source/tasks.c **** 					}
2561:Source/tasks.c **** 				}
2562:Source/tasks.c **** 				#endif
2563:Source/tasks.c **** 			}
2564:Source/tasks.c **** 			else
2565:Source/tasks.c **** 			{
2566:Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2567:Source/tasks.c **** 			}
2568:Source/tasks.c **** 		}
2569:Source/tasks.c **** 		( void ) xTaskResumeAll();
2570:Source/tasks.c **** 
2571:Source/tasks.c **** 		return uxTask;
2572:Source/tasks.c **** 	}
2573:Source/tasks.c **** 
2574:Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 94
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 94
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


2575:Source/tasks.c **** /*----------------------------------------------------------*/
2576:Source/tasks.c **** 
2577:Source/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
2578:Source/tasks.c **** 
2579:Source/tasks.c **** 	TaskHandle_t xTaskGetIdleTaskHandle( void )
2580:Source/tasks.c **** 	{
2581:Source/tasks.c **** 		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
2582:Source/tasks.c **** 		started, then xIdleTaskHandle will be NULL. */
2583:Source/tasks.c **** 		configASSERT( ( xIdleTaskHandle != NULL ) );
2584:Source/tasks.c **** 		return xIdleTaskHandle;
2585:Source/tasks.c **** 	}
2586:Source/tasks.c **** 
2587:Source/tasks.c **** #endif /* INCLUDE_xTaskGetIdleTaskHandle */
2588:Source/tasks.c **** /*----------------------------------------------------------*/
2589:Source/tasks.c **** 
2590:Source/tasks.c **** /* This conditional compilation should use inequality to 0, not equality to 1.
2591:Source/tasks.c **** This is to ensure vTaskStepTick() is available when user defined low power mode
2592:Source/tasks.c **** implementations require configUSE_TICKLESS_IDLE to be set to a value other than
2593:Source/tasks.c **** 1. */
2594:Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
2595:Source/tasks.c **** 
2596:Source/tasks.c **** 	void vTaskStepTick( const TickType_t xTicksToJump )
2597:Source/tasks.c **** 	{
2598:Source/tasks.c **** 		/* Correct the tick count value after a period during which the tick
2599:Source/tasks.c **** 		was suppressed.  Note this does *not* call the tick hook function for
2600:Source/tasks.c **** 		each stepped tick. */
2601:Source/tasks.c **** 		configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );
2602:Source/tasks.c **** 		xTickCount += xTicksToJump;
2603:Source/tasks.c **** 		traceINCREASE_TICK_COUNT( xTicksToJump );
2604:Source/tasks.c **** 	}
2605:Source/tasks.c **** 
2606:Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
2607:Source/tasks.c **** /*----------------------------------------------------------*/
2608:Source/tasks.c **** 
2609:Source/tasks.c **** BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )
2610:Source/tasks.c **** {
 2462              		.loc 1 2610 0
 2463              		.cfi_startproc
 2464              		@ args = 0, pretend = 0, frame = 16
 2465              		@ frame_needed = 1, uses_anonymous_args = 0
 2466 0000 80B5     		push	{r7, lr}
 2467              		.cfi_def_cfa_offset 8
 2468              		.cfi_offset 7, -8
 2469              		.cfi_offset 14, -4
 2470 0002 84B0     		sub	sp, sp, #16
 2471              		.cfi_def_cfa_offset 24
 2472 0004 00AF     		add	r7, sp, #0
 2473              		.cfi_def_cfa_register 7
 2474 0006 7860     		str	r0, [r7, #4]
2611:Source/tasks.c **** BaseType_t xYieldRequired = pdFALSE;
 2475              		.loc 1 2611 0
 2476 0008 0023     		movs	r3, #0
 2477 000a FB60     		str	r3, [r7, #12]
2612:Source/tasks.c **** 
2613:Source/tasks.c **** 	/* Must not be called with the scheduler suspended as the implementation
2614:Source/tasks.c **** 	relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */
2615:Source/tasks.c **** 	configASSERT( uxSchedulerSuspended == 0 );
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 95
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 95
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


2616:Source/tasks.c **** 
2617:Source/tasks.c **** 	/* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
2618:Source/tasks.c **** 	the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
2619:Source/tasks.c **** 	vTaskSuspendAll();
 2478              		.loc 1 2619 0
 2479 000c FFF7FEFF 		bl	vTaskSuspendAll
2620:Source/tasks.c **** 	xPendedTicks += xTicksToCatchUp;
 2480              		.loc 1 2620 0
 2481 0010 064B     		ldr	r3, .L172
 2482 0012 1A68     		ldr	r2, [r3]
 2483 0014 7B68     		ldr	r3, [r7, #4]
 2484 0016 1344     		add	r3, r3, r2
 2485 0018 044A     		ldr	r2, .L172
 2486 001a 1360     		str	r3, [r2]
2621:Source/tasks.c **** 	xYieldRequired = xTaskResumeAll();
 2487              		.loc 1 2621 0
 2488 001c FFF7FEFF 		bl	xTaskResumeAll
 2489 0020 F860     		str	r0, [r7, #12]
2622:Source/tasks.c **** 
2623:Source/tasks.c **** 	return xYieldRequired;
 2490              		.loc 1 2623 0
 2491 0022 FB68     		ldr	r3, [r7, #12]
2624:Source/tasks.c **** }
 2492              		.loc 1 2624 0
 2493 0024 1846     		mov	r0, r3
 2494 0026 1037     		adds	r7, r7, #16
 2495              		.cfi_def_cfa_offset 8
 2496 0028 BD46     		mov	sp, r7
 2497              		.cfi_def_cfa_register 13
 2498              		@ sp needed
 2499 002a 80BD     		pop	{r7, pc}
 2500              	.L173:
 2501              		.align	2
 2502              	.L172:
 2503 002c E8000000 		.word	xPendedTicks
 2504              		.cfi_endproc
 2505              	.LFE90:
 2506              		.size	xTaskCatchUpTicks, .-xTaskCatchUpTicks
 2507              		.section	.text.xTaskIncrementTick,"ax",%progbits
 2508              		.align	2
 2509              		.global	xTaskIncrementTick
 2510              		.thumb
 2511              		.thumb_func
 2512              		.type	xTaskIncrementTick, %function
 2513              	xTaskIncrementTick:
 2514              	.LFB91:
2625:Source/tasks.c **** /*----------------------------------------------------------*/
2626:Source/tasks.c **** 
2627:Source/tasks.c **** #if ( INCLUDE_xTaskAbortDelay == 1 )
2628:Source/tasks.c **** 
2629:Source/tasks.c **** 	BaseType_t xTaskAbortDelay( TaskHandle_t xTask )
2630:Source/tasks.c **** 	{
2631:Source/tasks.c **** 	TCB_t *pxTCB = xTask;
2632:Source/tasks.c **** 	BaseType_t xReturn;
2633:Source/tasks.c **** 
2634:Source/tasks.c **** 		configASSERT( pxTCB );
2635:Source/tasks.c **** 
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 96
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 96
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


2636:Source/tasks.c **** 		vTaskSuspendAll();
2637:Source/tasks.c **** 		{
2638:Source/tasks.c **** 			/* A task can only be prematurely removed from the Blocked state if
2639:Source/tasks.c **** 			it is actually in the Blocked state. */
2640:Source/tasks.c **** 			if( eTaskGetState( xTask ) == eBlocked )
2641:Source/tasks.c **** 			{
2642:Source/tasks.c **** 				xReturn = pdPASS;
2643:Source/tasks.c **** 
2644:Source/tasks.c **** 				/* Remove the reference to the task from the blocked list.  An
2645:Source/tasks.c **** 				interrupt won't touch the xStateListItem because the
2646:Source/tasks.c **** 				scheduler is suspended. */
2647:Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
2648:Source/tasks.c **** 
2649:Source/tasks.c **** 				/* Is the task waiting on an event also?  If so remove it from
2650:Source/tasks.c **** 				the event list too.  Interrupts can touch the event list item,
2651:Source/tasks.c **** 				even though the scheduler is suspended, so a critical section
2652:Source/tasks.c **** 				is used. */
2653:Source/tasks.c **** 				taskENTER_CRITICAL();
2654:Source/tasks.c **** 				{
2655:Source/tasks.c **** 					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
2656:Source/tasks.c **** 					{
2657:Source/tasks.c **** 						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
2658:Source/tasks.c **** 
2659:Source/tasks.c **** 						/* This lets the task know it was forcibly removed from the
2660:Source/tasks.c **** 						blocked state so it should not re-evaluate its block time and
2661:Source/tasks.c **** 						then block again. */
2662:Source/tasks.c **** 						pxTCB->ucDelayAborted = pdTRUE;
2663:Source/tasks.c **** 					}
2664:Source/tasks.c **** 					else
2665:Source/tasks.c **** 					{
2666:Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2667:Source/tasks.c **** 					}
2668:Source/tasks.c **** 				}
2669:Source/tasks.c **** 				taskEXIT_CRITICAL();
2670:Source/tasks.c **** 
2671:Source/tasks.c **** 				/* Place the unblocked task into the appropriate ready list. */
2672:Source/tasks.c **** 				prvAddTaskToReadyList( pxTCB );
2673:Source/tasks.c **** 
2674:Source/tasks.c **** 				/* A task being unblocked cannot cause an immediate context
2675:Source/tasks.c **** 				switch if preemption is turned off. */
2676:Source/tasks.c **** 				#if (  configUSE_PREEMPTION == 1 )
2677:Source/tasks.c **** 				{
2678:Source/tasks.c **** 					/* Preemption is on, but a context switch should only be
2679:Source/tasks.c **** 					performed if the unblocked task has a priority that is
2680:Source/tasks.c **** 					equal to or higher than the currently executing task. */
2681:Source/tasks.c **** 					if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
2682:Source/tasks.c **** 					{
2683:Source/tasks.c **** 						/* Pend the yield to be performed when the scheduler
2684:Source/tasks.c **** 						is unsuspended. */
2685:Source/tasks.c **** 						xYieldPending = pdTRUE;
2686:Source/tasks.c **** 					}
2687:Source/tasks.c **** 					else
2688:Source/tasks.c **** 					{
2689:Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2690:Source/tasks.c **** 					}
2691:Source/tasks.c **** 				}
2692:Source/tasks.c **** 				#endif /* configUSE_PREEMPTION */
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 97
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 97
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


2693:Source/tasks.c **** 			}
2694:Source/tasks.c **** 			else
2695:Source/tasks.c **** 			{
2696:Source/tasks.c **** 				xReturn = pdFAIL;
2697:Source/tasks.c **** 			}
2698:Source/tasks.c **** 		}
2699:Source/tasks.c **** 		( void ) xTaskResumeAll();
2700:Source/tasks.c **** 
2701:Source/tasks.c **** 		return xReturn;
2702:Source/tasks.c **** 	}
2703:Source/tasks.c **** 
2704:Source/tasks.c **** #endif /* INCLUDE_xTaskAbortDelay */
2705:Source/tasks.c **** /*----------------------------------------------------------*/
2706:Source/tasks.c **** 
2707:Source/tasks.c **** BaseType_t xTaskIncrementTick( void )
2708:Source/tasks.c **** {
 2515              		.loc 1 2708 0
 2516              		.cfi_startproc
 2517              		@ args = 0, pretend = 0, frame = 24
 2518              		@ frame_needed = 1, uses_anonymous_args = 0
 2519 0000 80B5     		push	{r7, lr}
 2520              		.cfi_def_cfa_offset 8
 2521              		.cfi_offset 7, -8
 2522              		.cfi_offset 14, -4
 2523 0002 86B0     		sub	sp, sp, #24
 2524              		.cfi_def_cfa_offset 32
 2525 0004 00AF     		add	r7, sp, #0
 2526              		.cfi_def_cfa_register 7
2709:Source/tasks.c **** TCB_t * pxTCB;
2710:Source/tasks.c **** TickType_t xItemValue;
2711:Source/tasks.c **** BaseType_t xSwitchRequired = pdFALSE;
 2527              		.loc 1 2711 0
 2528 0006 0023     		movs	r3, #0
 2529 0008 7B61     		str	r3, [r7, #20]
2712:Source/tasks.c **** 
2713:Source/tasks.c **** 	/* Called by the portable layer each time a tick interrupt occurs.
2714:Source/tasks.c **** 	Increments the tick then checks to see if the new tick value will cause any
2715:Source/tasks.c **** 	tasks to be unblocked. */
2716:Source/tasks.c **** 	traceTASK_INCREMENT_TICK( xTickCount );
2717:Source/tasks.c **** 	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 2530              		.loc 1 2717 0
 2531 000a 464B     		ldr	r3, .L187
 2532 000c 1B68     		ldr	r3, [r3]
 2533 000e 002B     		cmp	r3, #0
 2534 0010 7DD1     		bne	.L175
 2535              	.LBB42:
2718:Source/tasks.c **** 	{
2719:Source/tasks.c **** 		/* Minor optimisation.  The tick count cannot change in this
2720:Source/tasks.c **** 		block. */
2721:Source/tasks.c **** 		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
 2536              		.loc 1 2721 0
 2537 0012 454B     		ldr	r3, .L187+4
 2538 0014 1B68     		ldr	r3, [r3]
 2539 0016 0133     		adds	r3, r3, #1
 2540 0018 3B61     		str	r3, [r7, #16]
2722:Source/tasks.c **** 
2723:Source/tasks.c **** 		/* Increment the RTOS tick, switching the delayed and overflowed
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 98
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 98
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


2724:Source/tasks.c **** 		delayed lists if it wraps to 0. */
2725:Source/tasks.c **** 		xTickCount = xConstTickCount;
 2541              		.loc 1 2725 0
 2542 001a 434A     		ldr	r2, .L187+4
 2543 001c 3B69     		ldr	r3, [r7, #16]
 2544 001e 1360     		str	r3, [r2]
2726:Source/tasks.c **** 
2727:Source/tasks.c **** 		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as
 2545              		.loc 1 2727 0
 2546 0020 3B69     		ldr	r3, [r7, #16]
 2547 0022 002B     		cmp	r3, #0
 2548 0024 10D1     		bne	.L176
 2549              	.LBB43:
2728:Source/tasks.c **** 		{
2729:Source/tasks.c **** 			taskSWITCH_DELAYED_LISTS();
 2550              		.loc 1 2729 0
 2551 0026 414B     		ldr	r3, .L187+8
 2552 0028 1B68     		ldr	r3, [r3]
 2553 002a FB60     		str	r3, [r7, #12]
 2554 002c 404B     		ldr	r3, .L187+12
 2555 002e 1B68     		ldr	r3, [r3]
 2556 0030 3E4A     		ldr	r2, .L187+8
 2557 0032 1360     		str	r3, [r2]
 2558 0034 3E4A     		ldr	r2, .L187+12
 2559 0036 FB68     		ldr	r3, [r7, #12]
 2560 0038 1360     		str	r3, [r2]
 2561 003a 3E4B     		ldr	r3, .L187+16
 2562 003c 1B68     		ldr	r3, [r3]
 2563 003e 0133     		adds	r3, r3, #1
 2564 0040 3C4A     		ldr	r2, .L187+16
 2565 0042 1360     		str	r3, [r2]
 2566 0044 FFF7FEFF 		bl	prvResetNextTaskUnblockTime
 2567              	.L176:
 2568              	.LBE43:
2730:Source/tasks.c **** 		}
2731:Source/tasks.c **** 		else
2732:Source/tasks.c **** 		{
2733:Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2734:Source/tasks.c **** 		}
2735:Source/tasks.c **** 
2736:Source/tasks.c **** 		/* See if this tick has made a timeout expire.  Tasks are stored in
2737:Source/tasks.c **** 		the	queue in the order of their wake time - meaning once one task
2738:Source/tasks.c **** 		has been found whose block time has not expired there is no need to
2739:Source/tasks.c **** 		look any further down the list. */
2740:Source/tasks.c **** 		if( xConstTickCount >= xNextTaskUnblockTime )
 2569              		.loc 1 2740 0
 2570 0048 3B4B     		ldr	r3, .L187+20
 2571 004a 1B68     		ldr	r3, [r3]
 2572 004c 3A69     		ldr	r2, [r7, #16]
 2573 004e 9A42     		cmp	r2, r3
 2574 0050 48D3     		bcc	.L177
 2575              	.L182:
2741:Source/tasks.c **** 		{
2742:Source/tasks.c **** 			for( ;; )
2743:Source/tasks.c **** 			{
2744:Source/tasks.c **** 				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 2576              		.loc 1 2744 0
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 99
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 99
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 2577 0052 364B     		ldr	r3, .L187+8
 2578 0054 1B68     		ldr	r3, [r3]
 2579 0056 1B68     		ldr	r3, [r3]
 2580 0058 002B     		cmp	r3, #0
 2581 005a 04D1     		bne	.L178
2745:Source/tasks.c **** 				{
2746:Source/tasks.c **** 					/* The delayed list is empty.  Set xNextTaskUnblockTime
2747:Source/tasks.c **** 					to the maximum possible value so it is extremely
2748:Source/tasks.c **** 					unlikely that the
2749:Source/tasks.c **** 					if( xTickCount >= xNextTaskUnblockTime ) test will pass
2750:Source/tasks.c **** 					next time through. */
2751:Source/tasks.c **** 					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redun
 2582              		.loc 1 2751 0
 2583 005c 364B     		ldr	r3, .L187+20
 2584 005e 4FF0FF32 		mov	r2, #-1
 2585 0062 1A60     		str	r2, [r3]
2752:Source/tasks.c **** 					break;
 2586              		.loc 1 2752 0
 2587 0064 3EE0     		b	.L177
 2588              	.L178:
2753:Source/tasks.c **** 				}
2754:Source/tasks.c **** 				else
2755:Source/tasks.c **** 				{
2756:Source/tasks.c **** 					/* The delayed list is not empty, get the value of the
2757:Source/tasks.c **** 					item at the head of the delayed list.  This is the time
2758:Source/tasks.c **** 					at which the task at the head of the delayed list must
2759:Source/tasks.c **** 					be removed from the Blocked state. */
2760:Source/tasks.c **** 					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this
 2589              		.loc 1 2760 0
 2590 0066 314B     		ldr	r3, .L187+8
 2591 0068 1B68     		ldr	r3, [r3]
 2592 006a DB68     		ldr	r3, [r3, #12]
 2593 006c DB68     		ldr	r3, [r3, #12]
 2594 006e BB60     		str	r3, [r7, #8]
2761:Source/tasks.c **** 					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 2595              		.loc 1 2761 0
 2596 0070 BB68     		ldr	r3, [r7, #8]
 2597 0072 5B68     		ldr	r3, [r3, #4]
 2598 0074 7B60     		str	r3, [r7, #4]
2762:Source/tasks.c **** 
2763:Source/tasks.c **** 					if( xConstTickCount < xItemValue )
 2599              		.loc 1 2763 0
 2600 0076 3A69     		ldr	r2, [r7, #16]
 2601 0078 7B68     		ldr	r3, [r7, #4]
 2602 007a 9A42     		cmp	r2, r3
 2603 007c 03D2     		bcs	.L179
2764:Source/tasks.c **** 					{
2765:Source/tasks.c **** 						/* It is not time to unblock this item yet, but the
2766:Source/tasks.c **** 						item value is the time at which the task at the head
2767:Source/tasks.c **** 						of the blocked list must be removed from the Blocked
2768:Source/tasks.c **** 						state -	so record the item value in
2769:Source/tasks.c **** 						xNextTaskUnblockTime. */
2770:Source/tasks.c **** 						xNextTaskUnblockTime = xItemValue;
 2604              		.loc 1 2770 0
 2605 007e 2E4A     		ldr	r2, .L187+20
 2606 0080 7B68     		ldr	r3, [r7, #4]
 2607 0082 1360     		str	r3, [r2]
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 100
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 100
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


2771:Source/tasks.c **** 						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks
 2608              		.loc 1 2771 0
 2609 0084 2EE0     		b	.L177
 2610              	.L179:
2772:Source/tasks.c **** 					}
2773:Source/tasks.c **** 					else
2774:Source/tasks.c **** 					{
2775:Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2776:Source/tasks.c **** 					}
2777:Source/tasks.c **** 
2778:Source/tasks.c **** 					/* It is time to remove the item from the Blocked state. */
2779:Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 2611              		.loc 1 2779 0
 2612 0086 BB68     		ldr	r3, [r7, #8]
 2613 0088 0433     		adds	r3, r3, #4
 2614 008a 1846     		mov	r0, r3
 2615 008c FFF7FEFF 		bl	uxListRemove
2780:Source/tasks.c **** 
2781:Source/tasks.c **** 					/* Is the task waiting on an event also?  If so remove
2782:Source/tasks.c **** 					it from the event list. */
2783:Source/tasks.c **** 					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 2616              		.loc 1 2783 0
 2617 0090 BB68     		ldr	r3, [r7, #8]
 2618 0092 9B6A     		ldr	r3, [r3, #40]
 2619 0094 002B     		cmp	r3, #0
 2620 0096 04D0     		beq	.L180
2784:Source/tasks.c **** 					{
2785:Source/tasks.c **** 						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 2621              		.loc 1 2785 0
 2622 0098 BB68     		ldr	r3, [r7, #8]
 2623 009a 1833     		adds	r3, r3, #24
 2624 009c 1846     		mov	r0, r3
 2625 009e FFF7FEFF 		bl	uxListRemove
 2626              	.L180:
2786:Source/tasks.c **** 					}
2787:Source/tasks.c **** 					else
2788:Source/tasks.c **** 					{
2789:Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2790:Source/tasks.c **** 					}
2791:Source/tasks.c **** 
2792:Source/tasks.c **** 					/* Place the unblocked task into the appropriate ready
2793:Source/tasks.c **** 					list. */
2794:Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 2627              		.loc 1 2794 0
 2628 00a2 BB68     		ldr	r3, [r7, #8]
 2629 00a4 DB6A     		ldr	r3, [r3, #44]
 2630 00a6 0122     		movs	r2, #1
 2631 00a8 9A40     		lsls	r2, r2, r3
 2632 00aa 244B     		ldr	r3, .L187+24
 2633 00ac 1B68     		ldr	r3, [r3]
 2634 00ae 1343     		orrs	r3, r3, r2
 2635 00b0 224A     		ldr	r2, .L187+24
 2636 00b2 1360     		str	r3, [r2]
 2637 00b4 BB68     		ldr	r3, [r7, #8]
 2638 00b6 DA6A     		ldr	r2, [r3, #44]
 2639 00b8 1346     		mov	r3, r2
 2640 00ba 9B00     		lsls	r3, r3, #2
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 101
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 101
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 2641 00bc 1344     		add	r3, r3, r2
 2642 00be 9B00     		lsls	r3, r3, #2
 2643 00c0 1F4A     		ldr	r2, .L187+28
 2644 00c2 1A44     		add	r2, r2, r3
 2645 00c4 BB68     		ldr	r3, [r7, #8]
 2646 00c6 0433     		adds	r3, r3, #4
 2647 00c8 1946     		mov	r1, r3
 2648 00ca 1046     		mov	r0, r2
 2649 00cc FFF7FEFF 		bl	vListInsertEnd
2795:Source/tasks.c **** 
2796:Source/tasks.c **** 					/* A task being unblocked cannot cause an immediate
2797:Source/tasks.c **** 					context switch if preemption is turned off. */
2798:Source/tasks.c **** 					#if (  configUSE_PREEMPTION == 1 )
2799:Source/tasks.c **** 					{
2800:Source/tasks.c **** 						/* Preemption is on, but a context switch should
2801:Source/tasks.c **** 						only be performed if the unblocked task has a
2802:Source/tasks.c **** 						priority that is equal to or higher than the
2803:Source/tasks.c **** 						currently executing task. */
2804:Source/tasks.c **** 						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 2650              		.loc 1 2804 0
 2651 00d0 BB68     		ldr	r3, [r7, #8]
 2652 00d2 DA6A     		ldr	r2, [r3, #44]
 2653 00d4 1B4B     		ldr	r3, .L187+32
 2654 00d6 1B68     		ldr	r3, [r3]
 2655 00d8 DB6A     		ldr	r3, [r3, #44]
 2656 00da 9A42     		cmp	r2, r3
 2657 00dc B9D3     		bcc	.L182
2805:Source/tasks.c **** 						{
2806:Source/tasks.c **** 							xSwitchRequired = pdTRUE;
 2658              		.loc 1 2806 0
 2659 00de 0123     		movs	r3, #1
 2660 00e0 7B61     		str	r3, [r7, #20]
2807:Source/tasks.c **** 						}
2808:Source/tasks.c **** 						else
2809:Source/tasks.c **** 						{
2810:Source/tasks.c **** 							mtCOVERAGE_TEST_MARKER();
2811:Source/tasks.c **** 						}
2812:Source/tasks.c **** 					}
2813:Source/tasks.c **** 					#endif /* configUSE_PREEMPTION */
2814:Source/tasks.c **** 				}
2815:Source/tasks.c **** 			}
 2661              		.loc 1 2815 0
 2662 00e2 B6E7     		b	.L182
 2663              	.L177:
2816:Source/tasks.c **** 		}
2817:Source/tasks.c **** 
2818:Source/tasks.c **** 		/* Tasks of equal priority to the currently running task will share
2819:Source/tasks.c **** 		processing time (time slice) if preemption is on, and the application
2820:Source/tasks.c **** 		writer has not explicitly turned time slicing off. */
2821:Source/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
2822:Source/tasks.c **** 		{
2823:Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_
 2664              		.loc 1 2823 0
 2665 00e4 174B     		ldr	r3, .L187+32
 2666 00e6 1B68     		ldr	r3, [r3]
 2667 00e8 DA6A     		ldr	r2, [r3, #44]
 2668 00ea 1549     		ldr	r1, .L187+28
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 102
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 102
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 2669 00ec 1346     		mov	r3, r2
 2670 00ee 9B00     		lsls	r3, r3, #2
 2671 00f0 1344     		add	r3, r3, r2
 2672 00f2 9B00     		lsls	r3, r3, #2
 2673 00f4 0B44     		add	r3, r3, r1
 2674 00f6 1B68     		ldr	r3, [r3]
 2675 00f8 012B     		cmp	r3, #1
 2676 00fa 01D9     		bls	.L183
2824:Source/tasks.c **** 			{
2825:Source/tasks.c **** 				xSwitchRequired = pdTRUE;
 2677              		.loc 1 2825 0
 2678 00fc 0123     		movs	r3, #1
 2679 00fe 7B61     		str	r3, [r7, #20]
 2680              	.L183:
2826:Source/tasks.c **** 			}
2827:Source/tasks.c **** 			else
2828:Source/tasks.c **** 			{
2829:Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2830:Source/tasks.c **** 			}
2831:Source/tasks.c **** 		}
2832:Source/tasks.c **** 		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
2833:Source/tasks.c **** 
2834:Source/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
2835:Source/tasks.c **** 		{
2836:Source/tasks.c **** 			/* Guard against the tick hook being called when the pended tick
2837:Source/tasks.c **** 			count is being unwound (when the scheduler is being unlocked). */
2838:Source/tasks.c **** 			if( xPendedTicks == ( TickType_t ) 0 )
2839:Source/tasks.c **** 			{
2840:Source/tasks.c **** 				vApplicationTickHook();
2841:Source/tasks.c **** 			}
2842:Source/tasks.c **** 			else
2843:Source/tasks.c **** 			{
2844:Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2845:Source/tasks.c **** 			}
2846:Source/tasks.c **** 		}
2847:Source/tasks.c **** 		#endif /* configUSE_TICK_HOOK */
2848:Source/tasks.c **** 
2849:Source/tasks.c **** 		#if ( configUSE_PREEMPTION == 1 )
2850:Source/tasks.c **** 		{
2851:Source/tasks.c **** 			if( xYieldPending != pdFALSE )
 2681              		.loc 1 2851 0
 2682 0100 114B     		ldr	r3, .L187+36
 2683 0102 1B68     		ldr	r3, [r3]
 2684 0104 002B     		cmp	r3, #0
 2685 0106 07D0     		beq	.L185
2852:Source/tasks.c **** 			{
2853:Source/tasks.c **** 				xSwitchRequired = pdTRUE;
 2686              		.loc 1 2853 0
 2687 0108 0123     		movs	r3, #1
 2688 010a 7B61     		str	r3, [r7, #20]
 2689 010c 04E0     		b	.L185
 2690              	.L175:
 2691              	.LBE42:
2854:Source/tasks.c **** 			}
2855:Source/tasks.c **** 			else
2856:Source/tasks.c **** 			{
2857:Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 103
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 103
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


2858:Source/tasks.c **** 			}
2859:Source/tasks.c **** 		}
2860:Source/tasks.c **** 		#endif /* configUSE_PREEMPTION */
2861:Source/tasks.c **** 	}
2862:Source/tasks.c **** 	else
2863:Source/tasks.c **** 	{
2864:Source/tasks.c **** 		++xPendedTicks;
 2692              		.loc 1 2864 0
 2693 010e 0F4B     		ldr	r3, .L187+40
 2694 0110 1B68     		ldr	r3, [r3]
 2695 0112 0133     		adds	r3, r3, #1
 2696 0114 0D4A     		ldr	r2, .L187+40
 2697 0116 1360     		str	r3, [r2]
 2698              	.L185:
2865:Source/tasks.c **** 
2866:Source/tasks.c **** 		/* The tick hook gets called at regular intervals, even if the
2867:Source/tasks.c **** 		scheduler is locked. */
2868:Source/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
2869:Source/tasks.c **** 		{
2870:Source/tasks.c **** 			vApplicationTickHook();
2871:Source/tasks.c **** 		}
2872:Source/tasks.c **** 		#endif
2873:Source/tasks.c **** 	}
2874:Source/tasks.c **** 
2875:Source/tasks.c **** 	return xSwitchRequired;
 2699              		.loc 1 2875 0
 2700 0118 7B69     		ldr	r3, [r7, #20]
2876:Source/tasks.c **** }
 2701              		.loc 1 2876 0
 2702 011a 1846     		mov	r0, r3
 2703 011c 1837     		adds	r7, r7, #24
 2704              		.cfi_def_cfa_offset 8
 2705 011e BD46     		mov	sp, r7
 2706              		.cfi_def_cfa_register 13
 2707              		@ sp needed
 2708 0120 80BD     		pop	{r7, pc}
 2709              	.L188:
 2710 0122 00BF     		.align	2
 2711              	.L187:
 2712 0124 00010000 		.word	uxSchedulerSuspended
 2713 0128 DC000000 		.word	xTickCount
 2714 012c 90000000 		.word	pxDelayedTaskList
 2715 0130 94000000 		.word	pxOverflowDelayedTaskList
 2716 0134 F0000000 		.word	xNumOfOverflows
 2717 0138 F8000000 		.word	xNextTaskUnblockTime
 2718 013c E0000000 		.word	uxTopReadyPriority
 2719 0140 04000000 		.word	pxReadyTasksLists
 2720 0144 00000000 		.word	pxCurrentTCB
 2721 0148 EC000000 		.word	xYieldPending
 2722 014c E8000000 		.word	xPendedTicks
 2723              		.cfi_endproc
 2724              	.LFE91:
 2725              		.size	xTaskIncrementTick, .-xTaskIncrementTick
 2726              		.section	.text.vTaskSwitchContext,"ax",%progbits
 2727              		.align	2
 2728              		.global	vTaskSwitchContext
 2729              		.thumb
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 104
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 104
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 2730              		.thumb_func
 2731              		.type	vTaskSwitchContext, %function
 2732              	vTaskSwitchContext:
 2733              	.LFB92:
2877:Source/tasks.c **** /*-----------------------------------------------------------*/
2878:Source/tasks.c **** 
2879:Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2880:Source/tasks.c **** 
2881:Source/tasks.c **** 	void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction )
2882:Source/tasks.c **** 	{
2883:Source/tasks.c **** 	TCB_t *xTCB;
2884:Source/tasks.c **** 
2885:Source/tasks.c **** 		/* If xTask is NULL then it is the task hook of the calling task that is
2886:Source/tasks.c **** 		getting set. */
2887:Source/tasks.c **** 		if( xTask == NULL )
2888:Source/tasks.c **** 		{
2889:Source/tasks.c **** 			xTCB = ( TCB_t * ) pxCurrentTCB;
2890:Source/tasks.c **** 		}
2891:Source/tasks.c **** 		else
2892:Source/tasks.c **** 		{
2893:Source/tasks.c **** 			xTCB = xTask;
2894:Source/tasks.c **** 		}
2895:Source/tasks.c **** 
2896:Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
2897:Source/tasks.c **** 		the value can be accessed from an interrupt. */
2898:Source/tasks.c **** 		taskENTER_CRITICAL();
2899:Source/tasks.c **** 		{
2900:Source/tasks.c **** 			xTCB->pxTaskTag = pxHookFunction;
2901:Source/tasks.c **** 		}
2902:Source/tasks.c **** 		taskEXIT_CRITICAL();
2903:Source/tasks.c **** 	}
2904:Source/tasks.c **** 
2905:Source/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2906:Source/tasks.c **** /*-----------------------------------------------------------*/
2907:Source/tasks.c **** 
2908:Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2909:Source/tasks.c **** 
2910:Source/tasks.c **** 	TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask )
2911:Source/tasks.c **** 	{
2912:Source/tasks.c **** 	TCB_t *pxTCB;
2913:Source/tasks.c **** 	TaskHookFunction_t xReturn;
2914:Source/tasks.c **** 
2915:Source/tasks.c **** 		/* If xTask is NULL then set the calling task's hook. */
2916:Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
2917:Source/tasks.c **** 
2918:Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
2919:Source/tasks.c **** 		the value can be accessed from an interrupt. */
2920:Source/tasks.c **** 		taskENTER_CRITICAL();
2921:Source/tasks.c **** 		{
2922:Source/tasks.c **** 			xReturn = pxTCB->pxTaskTag;
2923:Source/tasks.c **** 		}
2924:Source/tasks.c **** 		taskEXIT_CRITICAL();
2925:Source/tasks.c **** 
2926:Source/tasks.c **** 		return xReturn;
2927:Source/tasks.c **** 	}
2928:Source/tasks.c **** 
2929:Source/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 105
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 105
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


2930:Source/tasks.c **** /*-----------------------------------------------------------*/
2931:Source/tasks.c **** 
2932:Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2933:Source/tasks.c **** 
2934:Source/tasks.c **** 	TaskHookFunction_t xTaskGetApplicationTaskTagFromISR( TaskHandle_t xTask )
2935:Source/tasks.c **** 	{
2936:Source/tasks.c **** 	TCB_t *pxTCB;
2937:Source/tasks.c **** 	TaskHookFunction_t xReturn;
2938:Source/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
2939:Source/tasks.c **** 
2940:Source/tasks.c **** 		/* If xTask is NULL then set the calling task's hook. */
2941:Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
2942:Source/tasks.c **** 
2943:Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
2944:Source/tasks.c **** 		the value can be accessed from an interrupt. */
2945:Source/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
2946:Source/tasks.c **** 		{
2947:Source/tasks.c **** 			xReturn = pxTCB->pxTaskTag;
2948:Source/tasks.c **** 		}
2949:Source/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
2950:Source/tasks.c **** 
2951:Source/tasks.c **** 		return xReturn;
2952:Source/tasks.c **** 	}
2953:Source/tasks.c **** 
2954:Source/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2955:Source/tasks.c **** /*-----------------------------------------------------------*/
2956:Source/tasks.c **** 
2957:Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2958:Source/tasks.c **** 
2959:Source/tasks.c **** 	BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter )
2960:Source/tasks.c **** 	{
2961:Source/tasks.c **** 	TCB_t *xTCB;
2962:Source/tasks.c **** 	BaseType_t xReturn;
2963:Source/tasks.c **** 
2964:Source/tasks.c **** 		/* If xTask is NULL then we are calling our own task hook. */
2965:Source/tasks.c **** 		if( xTask == NULL )
2966:Source/tasks.c **** 		{
2967:Source/tasks.c **** 			xTCB = pxCurrentTCB;
2968:Source/tasks.c **** 		}
2969:Source/tasks.c **** 		else
2970:Source/tasks.c **** 		{
2971:Source/tasks.c **** 			xTCB = xTask;
2972:Source/tasks.c **** 		}
2973:Source/tasks.c **** 
2974:Source/tasks.c **** 		if( xTCB->pxTaskTag != NULL )
2975:Source/tasks.c **** 		{
2976:Source/tasks.c **** 			xReturn = xTCB->pxTaskTag( pvParameter );
2977:Source/tasks.c **** 		}
2978:Source/tasks.c **** 		else
2979:Source/tasks.c **** 		{
2980:Source/tasks.c **** 			xReturn = pdFAIL;
2981:Source/tasks.c **** 		}
2982:Source/tasks.c **** 
2983:Source/tasks.c **** 		return xReturn;
2984:Source/tasks.c **** 	}
2985:Source/tasks.c **** 
2986:Source/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 106
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 106
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


2987:Source/tasks.c **** /*-----------------------------------------------------------*/
2988:Source/tasks.c **** 
2989:Source/tasks.c **** void vTaskSwitchContext( void )
2990:Source/tasks.c **** {
 2734              		.loc 1 2990 0
 2735              		.cfi_startproc
 2736              		@ args = 0, pretend = 0, frame = 24
 2737              		@ frame_needed = 1, uses_anonymous_args = 0
 2738 0000 80B5     		push	{r7, lr}
 2739              		.cfi_def_cfa_offset 8
 2740              		.cfi_offset 7, -8
 2741              		.cfi_offset 14, -4
 2742 0002 86B0     		sub	sp, sp, #24
 2743              		.cfi_def_cfa_offset 32
 2744 0004 00AF     		add	r7, sp, #0
 2745              		.cfi_def_cfa_register 7
2991:Source/tasks.c **** 	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 2746              		.loc 1 2991 0
 2747 0006 2F4B     		ldr	r3, .L197
 2748 0008 1B68     		ldr	r3, [r3]
 2749 000a 002B     		cmp	r3, #0
 2750 000c 03D0     		beq	.L190
2992:Source/tasks.c **** 	{
2993:Source/tasks.c **** 		/* The scheduler is currently suspended - do not allow a context
2994:Source/tasks.c **** 		switch. */
2995:Source/tasks.c **** 		xYieldPending = pdTRUE;
 2751              		.loc 1 2995 0
 2752 000e 2E4B     		ldr	r3, .L197+4
 2753 0010 0122     		movs	r2, #1
 2754 0012 1A60     		str	r2, [r3]
2996:Source/tasks.c **** 	}
2997:Source/tasks.c **** 	else
2998:Source/tasks.c **** 	{
2999:Source/tasks.c **** 		xYieldPending = pdFALSE;
3000:Source/tasks.c **** 		traceTASK_SWITCHED_OUT();
3001:Source/tasks.c **** 
3002:Source/tasks.c **** 		#if ( configGENERATE_RUN_TIME_STATS == 1 )
3003:Source/tasks.c **** 		{
3004:Source/tasks.c **** 			#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
3005:Source/tasks.c **** 				portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
3006:Source/tasks.c **** 			#else
3007:Source/tasks.c **** 				ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
3008:Source/tasks.c **** 			#endif
3009:Source/tasks.c **** 
3010:Source/tasks.c **** 			/* Add the amount of time the task has been running to the
3011:Source/tasks.c **** 			accumulated time so far.  The time the task started running was
3012:Source/tasks.c **** 			stored in ulTaskSwitchedInTime.  Note that there is no overflow
3013:Source/tasks.c **** 			protection here so count values are only valid until the timer
3014:Source/tasks.c **** 			overflows.  The guard against negative values is to protect
3015:Source/tasks.c **** 			against suspect run time stat counter implementations - which
3016:Source/tasks.c **** 			are provided by the application, not the kernel. */
3017:Source/tasks.c **** 			if( ulTotalRunTime > ulTaskSwitchedInTime )
3018:Source/tasks.c **** 			{
3019:Source/tasks.c **** 				pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
3020:Source/tasks.c **** 			}
3021:Source/tasks.c **** 			else
3022:Source/tasks.c **** 			{
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 107
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 107
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


3023:Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3024:Source/tasks.c **** 			}
3025:Source/tasks.c **** 			ulTaskSwitchedInTime = ulTotalRunTime;
3026:Source/tasks.c **** 		}
3027:Source/tasks.c **** 		#endif /* configGENERATE_RUN_TIME_STATS */
3028:Source/tasks.c **** 
3029:Source/tasks.c **** 		/* Check for stack overflow, if configured. */
3030:Source/tasks.c **** 		taskCHECK_FOR_STACK_OVERFLOW();
3031:Source/tasks.c **** 
3032:Source/tasks.c **** 		/* Before the currently running task is switched out, save its errno. */
3033:Source/tasks.c **** 		#if( configUSE_POSIX_ERRNO == 1 )
3034:Source/tasks.c **** 		{
3035:Source/tasks.c **** 			pxCurrentTCB->iTaskErrno = FreeRTOS_errno;
3036:Source/tasks.c **** 		}
3037:Source/tasks.c **** 		#endif
3038:Source/tasks.c **** 
3039:Source/tasks.c **** 		/* Select a new task to run using either the generic C or port
3040:Source/tasks.c **** 		optimised asm code. */
3041:Source/tasks.c **** 		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timer
3042:Source/tasks.c **** 		traceTASK_SWITCHED_IN();
3043:Source/tasks.c **** 
3044:Source/tasks.c **** 		/* After the new task is switched in, update the global errno. */
3045:Source/tasks.c **** 		#if( configUSE_POSIX_ERRNO == 1 )
3046:Source/tasks.c **** 		{
3047:Source/tasks.c **** 			FreeRTOS_errno = pxCurrentTCB->iTaskErrno;
3048:Source/tasks.c **** 		}
3049:Source/tasks.c **** 		#endif
3050:Source/tasks.c **** 
3051:Source/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
3052:Source/tasks.c **** 		{
3053:Source/tasks.c **** 			/* Switch Newlib's _impure_ptr variable to point to the _reent
3054:Source/tasks.c **** 			structure specific to this task.
3055:Source/tasks.c **** 			See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html
3056:Source/tasks.c **** 			for additional information. */
3057:Source/tasks.c **** 			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
3058:Source/tasks.c **** 		}
3059:Source/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
3060:Source/tasks.c **** 	}
3061:Source/tasks.c **** }
 2755              		.loc 1 3061 0
 2756 0014 51E0     		b	.L196
 2757              	.L190:
2999:Source/tasks.c **** 		traceTASK_SWITCHED_OUT();
 2758              		.loc 1 2999 0
 2759 0016 2C4B     		ldr	r3, .L197+4
 2760 0018 0022     		movs	r2, #0
 2761 001a 1A60     		str	r2, [r3]
 2762              	.LBB44:
3030:Source/tasks.c **** 
 2763              		.loc 1 3030 0
 2764 001c 2B4B     		ldr	r3, .L197+8
 2765 001e 1B68     		ldr	r3, [r3]
 2766 0020 1B6B     		ldr	r3, [r3, #48]
 2767 0022 7B61     		str	r3, [r7, #20]
 2768 0024 4FF0A533 		mov	r3, #-1515870811
 2769 0028 3B61     		str	r3, [r7, #16]
 2770 002a 7B69     		ldr	r3, [r7, #20]
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 108
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 108
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 2771 002c 1A68     		ldr	r2, [r3]
 2772 002e 3B69     		ldr	r3, [r7, #16]
 2773 0030 9A42     		cmp	r2, r3
 2774 0032 11D1     		bne	.L192
3030:Source/tasks.c **** 
 2775              		.loc 1 3030 0 is_stmt 0 discriminator 2
 2776 0034 7B69     		ldr	r3, [r7, #20]
 2777 0036 0433     		adds	r3, r3, #4
 2778 0038 1A68     		ldr	r2, [r3]
 2779 003a 3B69     		ldr	r3, [r7, #16]
 2780 003c 9A42     		cmp	r2, r3
 2781 003e 0BD1     		bne	.L192
3030:Source/tasks.c **** 
 2782              		.loc 1 3030 0 discriminator 4
 2783 0040 7B69     		ldr	r3, [r7, #20]
 2784 0042 0833     		adds	r3, r3, #8
 2785 0044 1A68     		ldr	r2, [r3]
 2786 0046 3B69     		ldr	r3, [r7, #16]
 2787 0048 9A42     		cmp	r2, r3
 2788 004a 05D1     		bne	.L192
3030:Source/tasks.c **** 
 2789              		.loc 1 3030 0 discriminator 6
 2790 004c 7B69     		ldr	r3, [r7, #20]
 2791 004e 0C33     		adds	r3, r3, #12
 2792 0050 1A68     		ldr	r2, [r3]
 2793 0052 3B69     		ldr	r3, [r7, #16]
 2794 0054 9A42     		cmp	r2, r3
 2795 0056 08D0     		beq	.L193
 2796              	.L192:
3030:Source/tasks.c **** 
 2797              		.loc 1 3030 0 discriminator 7
 2798 0058 1C4B     		ldr	r3, .L197+8
 2799 005a 1A68     		ldr	r2, [r3]
 2800 005c 1B4B     		ldr	r3, .L197+8
 2801 005e 1B68     		ldr	r3, [r3]
 2802 0060 3433     		adds	r3, r3, #52
 2803 0062 1946     		mov	r1, r3
 2804 0064 1046     		mov	r0, r2
 2805 0066 FFF7FEFF 		bl	vApplicationStackOverflowHook
 2806              	.L193:
 2807              	.LBE44:
 2808              	.LBB45:
3041:Source/tasks.c **** 		traceTASK_SWITCHED_IN();
 2809              		.loc 1 3041 0 is_stmt 1
 2810 006a 194B     		ldr	r3, .L197+12
 2811 006c 1B68     		ldr	r3, [r3]
 2812 006e 7B60     		str	r3, [r7, #4]
 2813              	.LBB46:
 2814              	.LBB47:
 134:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 		return ucReturn;
 2815              		.loc 2 134 0
 2816 0070 7B68     		ldr	r3, [r7, #4]
 2817              		.syntax unified
 2818              	@ 134 ".\Source\portable\GCC\ARM_CM3/portmacro.h" 1
 2819 0072 B3FA83F3 		clz r3, r3
 2820              	@ 0 "" 2
 2821              		.thumb
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 109
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 109
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 2822              		.syntax unified
 2823 0076 FB70     		strb	r3, [r7, #3]
 135:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	}
 2824              		.loc 2 135 0
 2825 0078 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 2826              	.LBE47:
 2827              	.LBE46:
3041:Source/tasks.c **** 		traceTASK_SWITCHED_IN();
 2828              		.loc 1 3041 0
 2829 007a C3F11F03 		rsb	r3, r3, #31
 2830 007e FB60     		str	r3, [r7, #12]
 2831              	.LBB48:
 2832 0080 FA68     		ldr	r2, [r7, #12]
 2833 0082 1346     		mov	r3, r2
 2834 0084 9B00     		lsls	r3, r3, #2
 2835 0086 1344     		add	r3, r3, r2
 2836 0088 9B00     		lsls	r3, r3, #2
 2837 008a 124A     		ldr	r2, .L197+16
 2838 008c 1344     		add	r3, r3, r2
 2839 008e BB60     		str	r3, [r7, #8]
 2840 0090 BB68     		ldr	r3, [r7, #8]
 2841 0092 5B68     		ldr	r3, [r3, #4]
 2842 0094 5A68     		ldr	r2, [r3, #4]
 2843 0096 BB68     		ldr	r3, [r7, #8]
 2844 0098 5A60     		str	r2, [r3, #4]
 2845 009a BB68     		ldr	r3, [r7, #8]
 2846 009c 5A68     		ldr	r2, [r3, #4]
 2847 009e BB68     		ldr	r3, [r7, #8]
 2848 00a0 0833     		adds	r3, r3, #8
 2849 00a2 9A42     		cmp	r2, r3
 2850 00a4 04D1     		bne	.L195
3041:Source/tasks.c **** 		traceTASK_SWITCHED_IN();
 2851              		.loc 1 3041 0 is_stmt 0 discriminator 1
 2852 00a6 BB68     		ldr	r3, [r7, #8]
 2853 00a8 5B68     		ldr	r3, [r3, #4]
 2854 00aa 5A68     		ldr	r2, [r3, #4]
 2855 00ac BB68     		ldr	r3, [r7, #8]
 2856 00ae 5A60     		str	r2, [r3, #4]
 2857              	.L195:
3041:Source/tasks.c **** 		traceTASK_SWITCHED_IN();
 2858              		.loc 1 3041 0 discriminator 3
 2859 00b0 BB68     		ldr	r3, [r7, #8]
 2860 00b2 5B68     		ldr	r3, [r3, #4]
 2861 00b4 DB68     		ldr	r3, [r3, #12]
 2862 00b6 054A     		ldr	r2, .L197+8
 2863 00b8 1360     		str	r3, [r2]
 2864              	.L196:
 2865              	.LBE48:
 2866              	.LBE45:
 2867              		.loc 1 3061 0 is_stmt 1
 2868 00ba 00BF     		nop
 2869 00bc 1837     		adds	r7, r7, #24
 2870              		.cfi_def_cfa_offset 8
 2871 00be BD46     		mov	sp, r7
 2872              		.cfi_def_cfa_register 13
 2873              		@ sp needed
 2874 00c0 80BD     		pop	{r7, pc}
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 110
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 110
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 2875              	.L198:
 2876 00c2 00BF     		.align	2
 2877              	.L197:
 2878 00c4 00010000 		.word	uxSchedulerSuspended
 2879 00c8 EC000000 		.word	xYieldPending
 2880 00cc 00000000 		.word	pxCurrentTCB
 2881 00d0 E0000000 		.word	uxTopReadyPriority
 2882 00d4 04000000 		.word	pxReadyTasksLists
 2883              		.cfi_endproc
 2884              	.LFE92:
 2885              		.size	vTaskSwitchContext, .-vTaskSwitchContext
 2886              		.section	.text.vTaskPlaceOnEventList,"ax",%progbits
 2887              		.align	2
 2888              		.global	vTaskPlaceOnEventList
 2889              		.thumb
 2890              		.thumb_func
 2891              		.type	vTaskPlaceOnEventList, %function
 2892              	vTaskPlaceOnEventList:
 2893              	.LFB93:
3062:Source/tasks.c **** /*-----------------------------------------------------------*/
3063:Source/tasks.c **** 
3064:Source/tasks.c **** void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
3065:Source/tasks.c **** {
 2894              		.loc 1 3065 0
 2895              		.cfi_startproc
 2896              		@ args = 0, pretend = 0, frame = 8
 2897              		@ frame_needed = 1, uses_anonymous_args = 0
 2898 0000 80B5     		push	{r7, lr}
 2899              		.cfi_def_cfa_offset 8
 2900              		.cfi_offset 7, -8
 2901              		.cfi_offset 14, -4
 2902 0002 82B0     		sub	sp, sp, #8
 2903              		.cfi_def_cfa_offset 16
 2904 0004 00AF     		add	r7, sp, #0
 2905              		.cfi_def_cfa_register 7
 2906 0006 7860     		str	r0, [r7, #4]
 2907 0008 3960     		str	r1, [r7]
3066:Source/tasks.c **** 	configASSERT( pxEventList );
3067:Source/tasks.c **** 
3068:Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE
3069:Source/tasks.c **** 	SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */
3070:Source/tasks.c **** 
3071:Source/tasks.c **** 	/* Place the event list item of the TCB in the appropriate event list.
3072:Source/tasks.c **** 	This is placed in the list in priority order so the highest priority task
3073:Source/tasks.c **** 	is the first to be woken by the event.  The queue that contains the event
3074:Source/tasks.c **** 	list is locked, preventing simultaneous access from interrupts. */
3075:Source/tasks.c **** 	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 2908              		.loc 1 3075 0
 2909 000a 074B     		ldr	r3, .L200
 2910 000c 1B68     		ldr	r3, [r3]
 2911 000e 1833     		adds	r3, r3, #24
 2912 0010 1946     		mov	r1, r3
 2913 0012 7868     		ldr	r0, [r7, #4]
 2914 0014 FFF7FEFF 		bl	vListInsert
3076:Source/tasks.c **** 
3077:Source/tasks.c **** 	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 2915              		.loc 1 3077 0
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 111
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 111
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 2916 0018 0121     		movs	r1, #1
 2917 001a 3868     		ldr	r0, [r7]
 2918 001c FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
3078:Source/tasks.c **** }
 2919              		.loc 1 3078 0
 2920 0020 00BF     		nop
 2921 0022 0837     		adds	r7, r7, #8
 2922              		.cfi_def_cfa_offset 8
 2923 0024 BD46     		mov	sp, r7
 2924              		.cfi_def_cfa_register 13
 2925              		@ sp needed
 2926 0026 80BD     		pop	{r7, pc}
 2927              	.L201:
 2928              		.align	2
 2929              	.L200:
 2930 0028 00000000 		.word	pxCurrentTCB
 2931              		.cfi_endproc
 2932              	.LFE93:
 2933              		.size	vTaskPlaceOnEventList, .-vTaskPlaceOnEventList
 2934              		.section	.text.vTaskPlaceOnUnorderedEventList,"ax",%progbits
 2935              		.align	2
 2936              		.global	vTaskPlaceOnUnorderedEventList
 2937              		.thumb
 2938              		.thumb_func
 2939              		.type	vTaskPlaceOnUnorderedEventList, %function
 2940              	vTaskPlaceOnUnorderedEventList:
 2941              	.LFB94:
3079:Source/tasks.c **** /*-----------------------------------------------------------*/
3080:Source/tasks.c **** 
3081:Source/tasks.c **** void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickT
3082:Source/tasks.c **** {
 2942              		.loc 1 3082 0
 2943              		.cfi_startproc
 2944              		@ args = 0, pretend = 0, frame = 16
 2945              		@ frame_needed = 1, uses_anonymous_args = 0
 2946 0000 80B5     		push	{r7, lr}
 2947              		.cfi_def_cfa_offset 8
 2948              		.cfi_offset 7, -8
 2949              		.cfi_offset 14, -4
 2950 0002 84B0     		sub	sp, sp, #16
 2951              		.cfi_def_cfa_offset 24
 2952 0004 00AF     		add	r7, sp, #0
 2953              		.cfi_def_cfa_register 7
 2954 0006 F860     		str	r0, [r7, #12]
 2955 0008 B960     		str	r1, [r7, #8]
 2956 000a 7A60     		str	r2, [r7, #4]
3083:Source/tasks.c **** 	configASSERT( pxEventList );
3084:Source/tasks.c **** 
3085:Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
3086:Source/tasks.c **** 	the event groups implementation. */
3087:Source/tasks.c **** 	configASSERT( uxSchedulerSuspended != 0 );
3088:Source/tasks.c **** 
3089:Source/tasks.c **** 	/* Store the item value in the event list item.  It is safe to access the
3090:Source/tasks.c **** 	event list item here as interrupts won't access the event list item of a
3091:Source/tasks.c **** 	task that is not in the Blocked state. */
3092:Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE
 2957              		.loc 1 3092 0
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 112
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 112
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 2958 000c 0A4B     		ldr	r3, .L203
 2959 000e 1B68     		ldr	r3, [r3]
 2960 0010 BA68     		ldr	r2, [r7, #8]
 2961 0012 42F00042 		orr	r2, r2, #-2147483648
 2962 0016 9A61     		str	r2, [r3, #24]
3093:Source/tasks.c **** 
3094:Source/tasks.c **** 	/* Place the event list item of the TCB at the end of the appropriate event
3095:Source/tasks.c **** 	list.  It is safe to access the event list here because it is part of an
3096:Source/tasks.c **** 	event group implementation - and interrupts don't access event groups
3097:Source/tasks.c **** 	directly (instead they access them indirectly by pending function calls to
3098:Source/tasks.c **** 	the task level). */
3099:Source/tasks.c **** 	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 2963              		.loc 1 3099 0
 2964 0018 074B     		ldr	r3, .L203
 2965 001a 1B68     		ldr	r3, [r3]
 2966 001c 1833     		adds	r3, r3, #24
 2967 001e 1946     		mov	r1, r3
 2968 0020 F868     		ldr	r0, [r7, #12]
 2969 0022 FFF7FEFF 		bl	vListInsertEnd
3100:Source/tasks.c **** 
3101:Source/tasks.c **** 	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 2970              		.loc 1 3101 0
 2971 0026 0121     		movs	r1, #1
 2972 0028 7868     		ldr	r0, [r7, #4]
 2973 002a FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
3102:Source/tasks.c **** }
 2974              		.loc 1 3102 0
 2975 002e 00BF     		nop
 2976 0030 1037     		adds	r7, r7, #16
 2977              		.cfi_def_cfa_offset 8
 2978 0032 BD46     		mov	sp, r7
 2979              		.cfi_def_cfa_register 13
 2980              		@ sp needed
 2981 0034 80BD     		pop	{r7, pc}
 2982              	.L204:
 2983 0036 00BF     		.align	2
 2984              	.L203:
 2985 0038 00000000 		.word	pxCurrentTCB
 2986              		.cfi_endproc
 2987              	.LFE94:
 2988              		.size	vTaskPlaceOnUnorderedEventList, .-vTaskPlaceOnUnorderedEventList
 2989              		.section	.text.xTaskRemoveFromEventList,"ax",%progbits
 2990              		.align	2
 2991              		.global	xTaskRemoveFromEventList
 2992              		.thumb
 2993              		.thumb_func
 2994              		.type	xTaskRemoveFromEventList, %function
 2995              	xTaskRemoveFromEventList:
 2996              	.LFB95:
3103:Source/tasks.c **** /*-----------------------------------------------------------*/
3104:Source/tasks.c **** 
3105:Source/tasks.c **** #if( configUSE_TIMERS == 1 )
3106:Source/tasks.c **** 
3107:Source/tasks.c **** 	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const B
3108:Source/tasks.c **** 	{
3109:Source/tasks.c **** 		configASSERT( pxEventList );
3110:Source/tasks.c **** 
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 113
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 113
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


3111:Source/tasks.c **** 		/* This function should not be called by application code hence the
3112:Source/tasks.c **** 		'Restricted' in its name.  It is not part of the public API.  It is
3113:Source/tasks.c **** 		designed for use by kernel code, and has special calling requirements -
3114:Source/tasks.c **** 		it should be called with the scheduler suspended. */
3115:Source/tasks.c **** 
3116:Source/tasks.c **** 
3117:Source/tasks.c **** 		/* Place the event list item of the TCB in the appropriate event list.
3118:Source/tasks.c **** 		In this case it is assume that this is the only task that is going to
3119:Source/tasks.c **** 		be waiting on this event list, so the faster vListInsertEnd() function
3120:Source/tasks.c **** 		can be used in place of vListInsert. */
3121:Source/tasks.c **** 		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
3122:Source/tasks.c **** 
3123:Source/tasks.c **** 		/* If the task should block indefinitely then set the block time to a
3124:Source/tasks.c **** 		value that will be recognised as an indefinite delay inside the
3125:Source/tasks.c **** 		prvAddCurrentTaskToDelayedList() function. */
3126:Source/tasks.c **** 		if( xWaitIndefinitely != pdFALSE )
3127:Source/tasks.c **** 		{
3128:Source/tasks.c **** 			xTicksToWait = portMAX_DELAY;
3129:Source/tasks.c **** 		}
3130:Source/tasks.c **** 
3131:Source/tasks.c **** 		traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
3132:Source/tasks.c **** 		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
3133:Source/tasks.c **** 	}
3134:Source/tasks.c **** 
3135:Source/tasks.c **** #endif /* configUSE_TIMERS */
3136:Source/tasks.c **** /*-----------------------------------------------------------*/
3137:Source/tasks.c **** 
3138:Source/tasks.c **** BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
3139:Source/tasks.c **** {
 2997              		.loc 1 3139 0
 2998              		.cfi_startproc
 2999              		@ args = 0, pretend = 0, frame = 16
 3000              		@ frame_needed = 1, uses_anonymous_args = 0
 3001 0000 80B5     		push	{r7, lr}
 3002              		.cfi_def_cfa_offset 8
 3003              		.cfi_offset 7, -8
 3004              		.cfi_offset 14, -4
 3005 0002 84B0     		sub	sp, sp, #16
 3006              		.cfi_def_cfa_offset 24
 3007 0004 00AF     		add	r7, sp, #0
 3008              		.cfi_def_cfa_register 7
 3009 0006 7860     		str	r0, [r7, #4]
3140:Source/tasks.c **** TCB_t *pxUnblockedTCB;
3141:Source/tasks.c **** BaseType_t xReturn;
3142:Source/tasks.c **** 
3143:Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be
3144:Source/tasks.c **** 	called from a critical section within an ISR. */
3145:Source/tasks.c **** 
3146:Source/tasks.c **** 	/* The event list is sorted in priority order, so the first in the list can
3147:Source/tasks.c **** 	be removed as it is known to be the highest priority.  Remove the TCB from
3148:Source/tasks.c **** 	the delayed list, and add it to the ready list.
3149:Source/tasks.c **** 
3150:Source/tasks.c **** 	If an event is for a queue that is locked then this function will never
3151:Source/tasks.c **** 	get called - the lock count on the queue will get modified instead.  This
3152:Source/tasks.c **** 	means exclusive access to the event list is guaranteed here.
3153:Source/tasks.c **** 
3154:Source/tasks.c **** 	This function assumes that a check has already been made to ensure that
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 114
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 114
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


3155:Source/tasks.c **** 	pxEventList is not empty. */
3156:Source/tasks.c **** 	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this 
 3010              		.loc 1 3156 0
 3011 0008 7B68     		ldr	r3, [r7, #4]
 3012 000a DB68     		ldr	r3, [r3, #12]
 3013 000c DB68     		ldr	r3, [r3, #12]
 3014 000e BB60     		str	r3, [r7, #8]
3157:Source/tasks.c **** 	configASSERT( pxUnblockedTCB );
3158:Source/tasks.c **** 	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 3015              		.loc 1 3158 0
 3016 0010 BB68     		ldr	r3, [r7, #8]
 3017 0012 1833     		adds	r3, r3, #24
 3018 0014 1846     		mov	r0, r3
 3019 0016 FFF7FEFF 		bl	uxListRemove
3159:Source/tasks.c **** 
3160:Source/tasks.c **** 	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 3020              		.loc 1 3160 0
 3021 001a 1D4B     		ldr	r3, .L211
 3022 001c 1B68     		ldr	r3, [r3]
 3023 001e 002B     		cmp	r3, #0
 3024 0020 1CD1     		bne	.L206
3161:Source/tasks.c **** 	{
3162:Source/tasks.c **** 		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 3025              		.loc 1 3162 0
 3026 0022 BB68     		ldr	r3, [r7, #8]
 3027 0024 0433     		adds	r3, r3, #4
 3028 0026 1846     		mov	r0, r3
 3029 0028 FFF7FEFF 		bl	uxListRemove
3163:Source/tasks.c **** 		prvAddTaskToReadyList( pxUnblockedTCB );
 3030              		.loc 1 3163 0
 3031 002c BB68     		ldr	r3, [r7, #8]
 3032 002e DB6A     		ldr	r3, [r3, #44]
 3033 0030 0122     		movs	r2, #1
 3034 0032 9A40     		lsls	r2, r2, r3
 3035 0034 174B     		ldr	r3, .L211+4
 3036 0036 1B68     		ldr	r3, [r3]
 3037 0038 1343     		orrs	r3, r3, r2
 3038 003a 164A     		ldr	r2, .L211+4
 3039 003c 1360     		str	r3, [r2]
 3040 003e BB68     		ldr	r3, [r7, #8]
 3041 0040 DA6A     		ldr	r2, [r3, #44]
 3042 0042 1346     		mov	r3, r2
 3043 0044 9B00     		lsls	r3, r3, #2
 3044 0046 1344     		add	r3, r3, r2
 3045 0048 9B00     		lsls	r3, r3, #2
 3046 004a 134A     		ldr	r2, .L211+8
 3047 004c 1A44     		add	r2, r2, r3
 3048 004e BB68     		ldr	r3, [r7, #8]
 3049 0050 0433     		adds	r3, r3, #4
 3050 0052 1946     		mov	r1, r3
 3051 0054 1046     		mov	r0, r2
 3052 0056 FFF7FEFF 		bl	vListInsertEnd
 3053 005a 05E0     		b	.L207
 3054              	.L206:
3164:Source/tasks.c **** 
3165:Source/tasks.c **** 		#if( configUSE_TICKLESS_IDLE != 0 )
3166:Source/tasks.c **** 		{
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 115
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 115
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


3167:Source/tasks.c **** 			/* If a task is blocked on a kernel object then xNextTaskUnblockTime
3168:Source/tasks.c **** 			might be set to the blocked task's time out time.  If the task is
3169:Source/tasks.c **** 			unblocked for a reason other than a timeout xNextTaskUnblockTime is
3170:Source/tasks.c **** 			normally left unchanged, because it is automatically reset to a new
3171:Source/tasks.c **** 			value when the tick count equals xNextTaskUnblockTime.  However if
3172:Source/tasks.c **** 			tickless idling is used it might be more important to enter sleep mode
3173:Source/tasks.c **** 			at the earliest possible time - so reset xNextTaskUnblockTime here to
3174:Source/tasks.c **** 			ensure it is updated at the earliest possible time. */
3175:Source/tasks.c **** 			prvResetNextTaskUnblockTime();
3176:Source/tasks.c **** 		}
3177:Source/tasks.c **** 		#endif
3178:Source/tasks.c **** 	}
3179:Source/tasks.c **** 	else
3180:Source/tasks.c **** 	{
3181:Source/tasks.c **** 		/* The delayed and ready lists cannot be accessed, so hold this task
3182:Source/tasks.c **** 		pending until the scheduler is resumed. */
3183:Source/tasks.c **** 		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 3055              		.loc 1 3183 0
 3056 005c BB68     		ldr	r3, [r7, #8]
 3057 005e 1833     		adds	r3, r3, #24
 3058 0060 1946     		mov	r1, r3
 3059 0062 0E48     		ldr	r0, .L211+12
 3060 0064 FFF7FEFF 		bl	vListInsertEnd
 3061              	.L207:
3184:Source/tasks.c **** 	}
3185:Source/tasks.c **** 
3186:Source/tasks.c **** 	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 3062              		.loc 1 3186 0
 3063 0068 BB68     		ldr	r3, [r7, #8]
 3064 006a DA6A     		ldr	r2, [r3, #44]
 3065 006c 0C4B     		ldr	r3, .L211+16
 3066 006e 1B68     		ldr	r3, [r3]
 3067 0070 DB6A     		ldr	r3, [r3, #44]
 3068 0072 9A42     		cmp	r2, r3
 3069 0074 05D9     		bls	.L208
3187:Source/tasks.c **** 	{
3188:Source/tasks.c **** 		/* Return true if the task removed from the event list has a higher
3189:Source/tasks.c **** 		priority than the calling task.  This allows the calling task to know if
3190:Source/tasks.c **** 		it should force a context switch now. */
3191:Source/tasks.c **** 		xReturn = pdTRUE;
 3070              		.loc 1 3191 0
 3071 0076 0123     		movs	r3, #1
 3072 0078 FB60     		str	r3, [r7, #12]
3192:Source/tasks.c **** 
3193:Source/tasks.c **** 		/* Mark that a yield is pending in case the user is not using the
3194:Source/tasks.c **** 		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
3195:Source/tasks.c **** 		xYieldPending = pdTRUE;
 3073              		.loc 1 3195 0
 3074 007a 0A4B     		ldr	r3, .L211+20
 3075 007c 0122     		movs	r2, #1
 3076 007e 1A60     		str	r2, [r3]
 3077 0080 01E0     		b	.L209
 3078              	.L208:
3196:Source/tasks.c **** 	}
3197:Source/tasks.c **** 	else
3198:Source/tasks.c **** 	{
3199:Source/tasks.c **** 		xReturn = pdFALSE;
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 116
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 116
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 3079              		.loc 1 3199 0
 3080 0082 0023     		movs	r3, #0
 3081 0084 FB60     		str	r3, [r7, #12]
 3082              	.L209:
3200:Source/tasks.c **** 	}
3201:Source/tasks.c **** 
3202:Source/tasks.c **** 	return xReturn;
 3083              		.loc 1 3202 0
 3084 0086 FB68     		ldr	r3, [r7, #12]
3203:Source/tasks.c **** }
 3085              		.loc 1 3203 0
 3086 0088 1846     		mov	r0, r3
 3087 008a 1037     		adds	r7, r7, #16
 3088              		.cfi_def_cfa_offset 8
 3089 008c BD46     		mov	sp, r7
 3090              		.cfi_def_cfa_register 13
 3091              		@ sp needed
 3092 008e 80BD     		pop	{r7, pc}
 3093              	.L212:
 3094              		.align	2
 3095              	.L211:
 3096 0090 00010000 		.word	uxSchedulerSuspended
 3097 0094 E0000000 		.word	uxTopReadyPriority
 3098 0098 04000000 		.word	pxReadyTasksLists
 3099 009c 98000000 		.word	xPendingReadyList
 3100 00a0 00000000 		.word	pxCurrentTCB
 3101 00a4 EC000000 		.word	xYieldPending
 3102              		.cfi_endproc
 3103              	.LFE95:
 3104              		.size	xTaskRemoveFromEventList, .-xTaskRemoveFromEventList
 3105              		.section	.text.vTaskRemoveFromUnorderedEventList,"ax",%progbits
 3106              		.align	2
 3107              		.global	vTaskRemoveFromUnorderedEventList
 3108              		.thumb
 3109              		.thumb_func
 3110              		.type	vTaskRemoveFromUnorderedEventList, %function
 3111              	vTaskRemoveFromUnorderedEventList:
 3112              	.LFB96:
3204:Source/tasks.c **** /*-----------------------------------------------------------*/
3205:Source/tasks.c **** 
3206:Source/tasks.c **** void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
3207:Source/tasks.c **** {
 3113              		.loc 1 3207 0
 3114              		.cfi_startproc
 3115              		@ args = 0, pretend = 0, frame = 16
 3116              		@ frame_needed = 1, uses_anonymous_args = 0
 3117 0000 80B5     		push	{r7, lr}
 3118              		.cfi_def_cfa_offset 8
 3119              		.cfi_offset 7, -8
 3120              		.cfi_offset 14, -4
 3121 0002 84B0     		sub	sp, sp, #16
 3122              		.cfi_def_cfa_offset 24
 3123 0004 00AF     		add	r7, sp, #0
 3124              		.cfi_def_cfa_register 7
 3125 0006 7860     		str	r0, [r7, #4]
 3126 0008 3960     		str	r1, [r7]
3208:Source/tasks.c **** TCB_t *pxUnblockedTCB;
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 117
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 117
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


3209:Source/tasks.c **** 
3210:Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
3211:Source/tasks.c **** 	the event flags implementation. */
3212:Source/tasks.c **** 	configASSERT( uxSchedulerSuspended != pdFALSE );
3213:Source/tasks.c **** 
3214:Source/tasks.c **** 	/* Store the new item value in the event list. */
3215:Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 3127              		.loc 1 3215 0
 3128 000a 3B68     		ldr	r3, [r7]
 3129 000c 43F00042 		orr	r2, r3, #-2147483648
 3130 0010 7B68     		ldr	r3, [r7, #4]
 3131 0012 1A60     		str	r2, [r3]
3216:Source/tasks.c **** 
3217:Source/tasks.c **** 	/* Remove the event list form the event flag.  Interrupts do not access
3218:Source/tasks.c **** 	event flags. */
3219:Source/tasks.c **** 	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this 
 3132              		.loc 1 3219 0
 3133 0014 7B68     		ldr	r3, [r7, #4]
 3134 0016 DB68     		ldr	r3, [r3, #12]
 3135 0018 FB60     		str	r3, [r7, #12]
3220:Source/tasks.c **** 	configASSERT( pxUnblockedTCB );
3221:Source/tasks.c **** 	( void ) uxListRemove( pxEventListItem );
 3136              		.loc 1 3221 0
 3137 001a 7868     		ldr	r0, [r7, #4]
 3138 001c FFF7FEFF 		bl	uxListRemove
3222:Source/tasks.c **** 
3223:Source/tasks.c **** 	#if( configUSE_TICKLESS_IDLE != 0 )
3224:Source/tasks.c **** 	{
3225:Source/tasks.c **** 		/* If a task is blocked on a kernel object then xNextTaskUnblockTime
3226:Source/tasks.c **** 		might be set to the blocked task's time out time.  If the task is
3227:Source/tasks.c **** 		unblocked for a reason other than a timeout xNextTaskUnblockTime is
3228:Source/tasks.c **** 		normally left unchanged, because it is automatically reset to a new
3229:Source/tasks.c **** 		value when the tick count equals xNextTaskUnblockTime.  However if
3230:Source/tasks.c **** 		tickless idling is used it might be more important to enter sleep mode
3231:Source/tasks.c **** 		at the earliest possible time - so reset xNextTaskUnblockTime here to
3232:Source/tasks.c **** 		ensure it is updated at the earliest possible time. */
3233:Source/tasks.c **** 		prvResetNextTaskUnblockTime();
3234:Source/tasks.c **** 	}
3235:Source/tasks.c **** 	#endif
3236:Source/tasks.c **** 
3237:Source/tasks.c **** 	/* Remove the task from the delayed list and add it to the ready list.  The
3238:Source/tasks.c **** 	scheduler is suspended so interrupts will not be accessing the ready
3239:Source/tasks.c **** 	lists. */
3240:Source/tasks.c **** 	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 3139              		.loc 1 3240 0
 3140 0020 FB68     		ldr	r3, [r7, #12]
 3141 0022 0433     		adds	r3, r3, #4
 3142 0024 1846     		mov	r0, r3
 3143 0026 FFF7FEFF 		bl	uxListRemove
3241:Source/tasks.c **** 	prvAddTaskToReadyList( pxUnblockedTCB );
 3144              		.loc 1 3241 0
 3145 002a FB68     		ldr	r3, [r7, #12]
 3146 002c DB6A     		ldr	r3, [r3, #44]
 3147 002e 0122     		movs	r2, #1
 3148 0030 9A40     		lsls	r2, r2, r3
 3149 0032 104B     		ldr	r3, .L216
 3150 0034 1B68     		ldr	r3, [r3]
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 118
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 118
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 3151 0036 1343     		orrs	r3, r3, r2
 3152 0038 0E4A     		ldr	r2, .L216
 3153 003a 1360     		str	r3, [r2]
 3154 003c FB68     		ldr	r3, [r7, #12]
 3155 003e DA6A     		ldr	r2, [r3, #44]
 3156 0040 1346     		mov	r3, r2
 3157 0042 9B00     		lsls	r3, r3, #2
 3158 0044 1344     		add	r3, r3, r2
 3159 0046 9B00     		lsls	r3, r3, #2
 3160 0048 0B4A     		ldr	r2, .L216+4
 3161 004a 1A44     		add	r2, r2, r3
 3162 004c FB68     		ldr	r3, [r7, #12]
 3163 004e 0433     		adds	r3, r3, #4
 3164 0050 1946     		mov	r1, r3
 3165 0052 1046     		mov	r0, r2
 3166 0054 FFF7FEFF 		bl	vListInsertEnd
3242:Source/tasks.c **** 
3243:Source/tasks.c **** 	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 3167              		.loc 1 3243 0
 3168 0058 FB68     		ldr	r3, [r7, #12]
 3169 005a DA6A     		ldr	r2, [r3, #44]
 3170 005c 074B     		ldr	r3, .L216+8
 3171 005e 1B68     		ldr	r3, [r3]
 3172 0060 DB6A     		ldr	r3, [r3, #44]
 3173 0062 9A42     		cmp	r2, r3
 3174 0064 02D9     		bls	.L215
3244:Source/tasks.c **** 	{
3245:Source/tasks.c **** 		/* The unblocked task has a priority above that of the calling task, so
3246:Source/tasks.c **** 		a context switch is required.  This function is called with the
3247:Source/tasks.c **** 		scheduler suspended so xYieldPending is set so the context switch
3248:Source/tasks.c **** 		occurs immediately that the scheduler is resumed (unsuspended). */
3249:Source/tasks.c **** 		xYieldPending = pdTRUE;
 3175              		.loc 1 3249 0
 3176 0066 064B     		ldr	r3, .L216+12
 3177 0068 0122     		movs	r2, #1
 3178 006a 1A60     		str	r2, [r3]
 3179              	.L215:
3250:Source/tasks.c **** 	}
3251:Source/tasks.c **** }
 3180              		.loc 1 3251 0
 3181 006c 00BF     		nop
 3182 006e 1037     		adds	r7, r7, #16
 3183              		.cfi_def_cfa_offset 8
 3184 0070 BD46     		mov	sp, r7
 3185              		.cfi_def_cfa_register 13
 3186              		@ sp needed
 3187 0072 80BD     		pop	{r7, pc}
 3188              	.L217:
 3189              		.align	2
 3190              	.L216:
 3191 0074 E0000000 		.word	uxTopReadyPriority
 3192 0078 04000000 		.word	pxReadyTasksLists
 3193 007c 00000000 		.word	pxCurrentTCB
 3194 0080 EC000000 		.word	xYieldPending
 3195              		.cfi_endproc
 3196              	.LFE96:
 3197              		.size	vTaskRemoveFromUnorderedEventList, .-vTaskRemoveFromUnorderedEventList
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 119
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 119
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 3198              		.section	.text.vTaskSetTimeOutState,"ax",%progbits
 3199              		.align	2
 3200              		.global	vTaskSetTimeOutState
 3201              		.thumb
 3202              		.thumb_func
 3203              		.type	vTaskSetTimeOutState, %function
 3204              	vTaskSetTimeOutState:
 3205              	.LFB97:
3252:Source/tasks.c **** /*-----------------------------------------------------------*/
3253:Source/tasks.c **** 
3254:Source/tasks.c **** void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
3255:Source/tasks.c **** {
 3206              		.loc 1 3255 0
 3207              		.cfi_startproc
 3208              		@ args = 0, pretend = 0, frame = 8
 3209              		@ frame_needed = 1, uses_anonymous_args = 0
 3210 0000 80B5     		push	{r7, lr}
 3211              		.cfi_def_cfa_offset 8
 3212              		.cfi_offset 7, -8
 3213              		.cfi_offset 14, -4
 3214 0002 82B0     		sub	sp, sp, #8
 3215              		.cfi_def_cfa_offset 16
 3216 0004 00AF     		add	r7, sp, #0
 3217              		.cfi_def_cfa_register 7
 3218 0006 7860     		str	r0, [r7, #4]
3256:Source/tasks.c **** 	configASSERT( pxTimeOut );
3257:Source/tasks.c **** 	taskENTER_CRITICAL();
 3219              		.loc 1 3257 0
 3220 0008 FFF7FEFF 		bl	vPortEnterCritical
3258:Source/tasks.c **** 	{
3259:Source/tasks.c **** 		pxTimeOut->xOverflowCount = xNumOfOverflows;
 3221              		.loc 1 3259 0
 3222 000c 064B     		ldr	r3, .L219
 3223 000e 1A68     		ldr	r2, [r3]
 3224 0010 7B68     		ldr	r3, [r7, #4]
 3225 0012 1A60     		str	r2, [r3]
3260:Source/tasks.c **** 		pxTimeOut->xTimeOnEntering = xTickCount;
 3226              		.loc 1 3260 0
 3227 0014 054B     		ldr	r3, .L219+4
 3228 0016 1A68     		ldr	r2, [r3]
 3229 0018 7B68     		ldr	r3, [r7, #4]
 3230 001a 5A60     		str	r2, [r3, #4]
3261:Source/tasks.c **** 	}
3262:Source/tasks.c **** 	taskEXIT_CRITICAL();
 3231              		.loc 1 3262 0
 3232 001c FFF7FEFF 		bl	vPortExitCritical
3263:Source/tasks.c **** }
 3233              		.loc 1 3263 0
 3234 0020 00BF     		nop
 3235 0022 0837     		adds	r7, r7, #8
 3236              		.cfi_def_cfa_offset 8
 3237 0024 BD46     		mov	sp, r7
 3238              		.cfi_def_cfa_register 13
 3239              		@ sp needed
 3240 0026 80BD     		pop	{r7, pc}
 3241              	.L220:
 3242              		.align	2
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 120
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 120
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 3243              	.L219:
 3244 0028 F0000000 		.word	xNumOfOverflows
 3245 002c DC000000 		.word	xTickCount
 3246              		.cfi_endproc
 3247              	.LFE97:
 3248              		.size	vTaskSetTimeOutState, .-vTaskSetTimeOutState
 3249              		.section	.text.vTaskInternalSetTimeOutState,"ax",%progbits
 3250              		.align	2
 3251              		.global	vTaskInternalSetTimeOutState
 3252              		.thumb
 3253              		.thumb_func
 3254              		.type	vTaskInternalSetTimeOutState, %function
 3255              	vTaskInternalSetTimeOutState:
 3256              	.LFB98:
3264:Source/tasks.c **** /*-----------------------------------------------------------*/
3265:Source/tasks.c **** 
3266:Source/tasks.c **** void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
3267:Source/tasks.c **** {
 3257              		.loc 1 3267 0
 3258              		.cfi_startproc
 3259              		@ args = 0, pretend = 0, frame = 8
 3260              		@ frame_needed = 1, uses_anonymous_args = 0
 3261              		@ link register save eliminated.
 3262 0000 80B4     		push	{r7}
 3263              		.cfi_def_cfa_offset 4
 3264              		.cfi_offset 7, -4
 3265 0002 83B0     		sub	sp, sp, #12
 3266              		.cfi_def_cfa_offset 16
 3267 0004 00AF     		add	r7, sp, #0
 3268              		.cfi_def_cfa_register 7
 3269 0006 7860     		str	r0, [r7, #4]
3268:Source/tasks.c **** 	/* For internal use only as it does not use a critical section. */
3269:Source/tasks.c **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
 3270              		.loc 1 3269 0
 3271 0008 064B     		ldr	r3, .L222
 3272 000a 1A68     		ldr	r2, [r3]
 3273 000c 7B68     		ldr	r3, [r7, #4]
 3274 000e 1A60     		str	r2, [r3]
3270:Source/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
 3275              		.loc 1 3270 0
 3276 0010 054B     		ldr	r3, .L222+4
 3277 0012 1A68     		ldr	r2, [r3]
 3278 0014 7B68     		ldr	r3, [r7, #4]
 3279 0016 5A60     		str	r2, [r3, #4]
3271:Source/tasks.c **** }
 3280              		.loc 1 3271 0
 3281 0018 00BF     		nop
 3282 001a 0C37     		adds	r7, r7, #12
 3283              		.cfi_def_cfa_offset 4
 3284 001c BD46     		mov	sp, r7
 3285              		.cfi_def_cfa_register 13
 3286              		@ sp needed
 3287 001e 80BC     		pop	{r7}
 3288              		.cfi_restore 7
 3289              		.cfi_def_cfa_offset 0
 3290 0020 7047     		bx	lr
 3291              	.L223:
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 121
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 121
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 3292 0022 00BF     		.align	2
 3293              	.L222:
 3294 0024 F0000000 		.word	xNumOfOverflows
 3295 0028 DC000000 		.word	xTickCount
 3296              		.cfi_endproc
 3297              	.LFE98:
 3298              		.size	vTaskInternalSetTimeOutState, .-vTaskInternalSetTimeOutState
 3299              		.section	.text.xTaskCheckForTimeOut,"ax",%progbits
 3300              		.align	2
 3301              		.global	xTaskCheckForTimeOut
 3302              		.thumb
 3303              		.thumb_func
 3304              		.type	xTaskCheckForTimeOut, %function
 3305              	xTaskCheckForTimeOut:
 3306              	.LFB99:
3272:Source/tasks.c **** /*-----------------------------------------------------------*/
3273:Source/tasks.c **** 
3274:Source/tasks.c **** BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
3275:Source/tasks.c **** {
 3307              		.loc 1 3275 0
 3308              		.cfi_startproc
 3309              		@ args = 0, pretend = 0, frame = 24
 3310              		@ frame_needed = 1, uses_anonymous_args = 0
 3311 0000 80B5     		push	{r7, lr}
 3312              		.cfi_def_cfa_offset 8
 3313              		.cfi_offset 7, -8
 3314              		.cfi_offset 14, -4
 3315 0002 86B0     		sub	sp, sp, #24
 3316              		.cfi_def_cfa_offset 32
 3317 0004 00AF     		add	r7, sp, #0
 3318              		.cfi_def_cfa_register 7
 3319 0006 7860     		str	r0, [r7, #4]
 3320 0008 3960     		str	r1, [r7]
3276:Source/tasks.c **** BaseType_t xReturn;
3277:Source/tasks.c **** 
3278:Source/tasks.c **** 	configASSERT( pxTimeOut );
3279:Source/tasks.c **** 	configASSERT( pxTicksToWait );
3280:Source/tasks.c **** 
3281:Source/tasks.c **** 	taskENTER_CRITICAL();
 3321              		.loc 1 3281 0
 3322 000a FFF7FEFF 		bl	vPortEnterCritical
 3323              	.LBB49:
3282:Source/tasks.c **** 	{
3283:Source/tasks.c **** 		/* Minor optimisation.  The tick count cannot change in this block. */
3284:Source/tasks.c **** 		const TickType_t xConstTickCount = xTickCount;
 3324              		.loc 1 3284 0
 3325 000e 1D4B     		ldr	r3, .L230
 3326 0010 1B68     		ldr	r3, [r3]
 3327 0012 3B61     		str	r3, [r7, #16]
3285:Source/tasks.c **** 		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 3328              		.loc 1 3285 0
 3329 0014 7B68     		ldr	r3, [r7, #4]
 3330 0016 5B68     		ldr	r3, [r3, #4]
 3331 0018 3A69     		ldr	r2, [r7, #16]
 3332 001a D31A     		subs	r3, r2, r3
 3333 001c FB60     		str	r3, [r7, #12]
3286:Source/tasks.c **** 
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 122
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 122
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


3287:Source/tasks.c **** 		#if( INCLUDE_xTaskAbortDelay == 1 )
3288:Source/tasks.c **** 			if( pxCurrentTCB->ucDelayAborted != ( uint8_t ) pdFALSE )
3289:Source/tasks.c **** 			{
3290:Source/tasks.c **** 				/* The delay was aborted, which is not the same as a time out,
3291:Source/tasks.c **** 				but has the same result. */
3292:Source/tasks.c **** 				pxCurrentTCB->ucDelayAborted = pdFALSE;
3293:Source/tasks.c **** 				xReturn = pdTRUE;
3294:Source/tasks.c **** 			}
3295:Source/tasks.c **** 			else
3296:Source/tasks.c **** 		#endif
3297:Source/tasks.c **** 
3298:Source/tasks.c **** 		#if ( INCLUDE_vTaskSuspend == 1 )
3299:Source/tasks.c **** 			if( *pxTicksToWait == portMAX_DELAY )
 3334              		.loc 1 3299 0
 3335 001e 3B68     		ldr	r3, [r7]
 3336 0020 1B68     		ldr	r3, [r3]
 3337 0022 B3F1FF3F 		cmp	r3, #-1
 3338 0026 02D1     		bne	.L225
3300:Source/tasks.c **** 			{
3301:Source/tasks.c **** 				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
3302:Source/tasks.c **** 				specified is the maximum block time then the task should block
3303:Source/tasks.c **** 				indefinitely, and therefore never time out. */
3304:Source/tasks.c **** 				xReturn = pdFALSE;
 3339              		.loc 1 3304 0
 3340 0028 0023     		movs	r3, #0
 3341 002a 7B61     		str	r3, [r7, #20]
 3342 002c 23E0     		b	.L226
 3343              	.L225:
3305:Source/tasks.c **** 			}
3306:Source/tasks.c **** 			else
3307:Source/tasks.c **** 		#endif
3308:Source/tasks.c **** 
3309:Source/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEn
 3344              		.loc 1 3309 0
 3345 002e 7B68     		ldr	r3, [r7, #4]
 3346 0030 1A68     		ldr	r2, [r3]
 3347 0032 154B     		ldr	r3, .L230+4
 3348 0034 1B68     		ldr	r3, [r3]
 3349 0036 9A42     		cmp	r2, r3
 3350 0038 07D0     		beq	.L227
 3351              		.loc 1 3309 0 is_stmt 0 discriminator 1
 3352 003a 7B68     		ldr	r3, [r7, #4]
 3353 003c 5A68     		ldr	r2, [r3, #4]
 3354 003e 3B69     		ldr	r3, [r7, #16]
 3355 0040 9A42     		cmp	r2, r3
 3356 0042 02D8     		bhi	.L227
3310:Source/tasks.c **** 		{
3311:Source/tasks.c **** 			/* The tick count is greater than the time at which
3312:Source/tasks.c **** 			vTaskSetTimeout() was called, but has also overflowed since
3313:Source/tasks.c **** 			vTaskSetTimeOut() was called.  It must have wrapped all the way
3314:Source/tasks.c **** 			around and gone past again. This passed since vTaskSetTimeout()
3315:Source/tasks.c **** 			was called. */
3316:Source/tasks.c **** 			xReturn = pdTRUE;
 3357              		.loc 1 3316 0 is_stmt 1
 3358 0044 0123     		movs	r3, #1
 3359 0046 7B61     		str	r3, [r7, #20]
 3360 0048 15E0     		b	.L226
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 123
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 123
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 3361              	.L227:
3317:Source/tasks.c **** 		}
3318:Source/tasks.c **** 		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with som
 3362              		.loc 1 3318 0
 3363 004a 3B68     		ldr	r3, [r7]
 3364 004c 1A68     		ldr	r2, [r3]
 3365 004e FB68     		ldr	r3, [r7, #12]
 3366 0050 9A42     		cmp	r2, r3
 3367 0052 0BD9     		bls	.L228
3319:Source/tasks.c **** 		{
3320:Source/tasks.c **** 			/* Not a genuine timeout. Adjust parameters for time remaining. */
3321:Source/tasks.c **** 			*pxTicksToWait -= xElapsedTime;
 3368              		.loc 1 3321 0
 3369 0054 3B68     		ldr	r3, [r7]
 3370 0056 1A68     		ldr	r2, [r3]
 3371 0058 FB68     		ldr	r3, [r7, #12]
 3372 005a D21A     		subs	r2, r2, r3
 3373 005c 3B68     		ldr	r3, [r7]
 3374 005e 1A60     		str	r2, [r3]
3322:Source/tasks.c **** 			vTaskInternalSetTimeOutState( pxTimeOut );
 3375              		.loc 1 3322 0
 3376 0060 7868     		ldr	r0, [r7, #4]
 3377 0062 FFF7FEFF 		bl	vTaskInternalSetTimeOutState
3323:Source/tasks.c **** 			xReturn = pdFALSE;
 3378              		.loc 1 3323 0
 3379 0066 0023     		movs	r3, #0
 3380 0068 7B61     		str	r3, [r7, #20]
 3381 006a 04E0     		b	.L226
 3382              	.L228:
3324:Source/tasks.c **** 		}
3325:Source/tasks.c **** 		else
3326:Source/tasks.c **** 		{
3327:Source/tasks.c **** 			*pxTicksToWait = 0;
 3383              		.loc 1 3327 0
 3384 006c 3B68     		ldr	r3, [r7]
 3385 006e 0022     		movs	r2, #0
 3386 0070 1A60     		str	r2, [r3]
3328:Source/tasks.c **** 			xReturn = pdTRUE;
 3387              		.loc 1 3328 0
 3388 0072 0123     		movs	r3, #1
 3389 0074 7B61     		str	r3, [r7, #20]
 3390              	.L226:
 3391              	.LBE49:
3329:Source/tasks.c **** 		}
3330:Source/tasks.c **** 	}
3331:Source/tasks.c **** 	taskEXIT_CRITICAL();
 3392              		.loc 1 3331 0
 3393 0076 FFF7FEFF 		bl	vPortExitCritical
3332:Source/tasks.c **** 
3333:Source/tasks.c **** 	return xReturn;
 3394              		.loc 1 3333 0
 3395 007a 7B69     		ldr	r3, [r7, #20]
3334:Source/tasks.c **** }
 3396              		.loc 1 3334 0
 3397 007c 1846     		mov	r0, r3
 3398 007e 1837     		adds	r7, r7, #24
 3399              		.cfi_def_cfa_offset 8
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 124
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 124
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 3400 0080 BD46     		mov	sp, r7
 3401              		.cfi_def_cfa_register 13
 3402              		@ sp needed
 3403 0082 80BD     		pop	{r7, pc}
 3404              	.L231:
 3405              		.align	2
 3406              	.L230:
 3407 0084 DC000000 		.word	xTickCount
 3408 0088 F0000000 		.word	xNumOfOverflows
 3409              		.cfi_endproc
 3410              	.LFE99:
 3411              		.size	xTaskCheckForTimeOut, .-xTaskCheckForTimeOut
 3412              		.section	.text.vTaskMissedYield,"ax",%progbits
 3413              		.align	2
 3414              		.global	vTaskMissedYield
 3415              		.thumb
 3416              		.thumb_func
 3417              		.type	vTaskMissedYield, %function
 3418              	vTaskMissedYield:
 3419              	.LFB100:
3335:Source/tasks.c **** /*-----------------------------------------------------------*/
3336:Source/tasks.c **** 
3337:Source/tasks.c **** void vTaskMissedYield( void )
3338:Source/tasks.c **** {
 3420              		.loc 1 3338 0
 3421              		.cfi_startproc
 3422              		@ args = 0, pretend = 0, frame = 0
 3423              		@ frame_needed = 1, uses_anonymous_args = 0
 3424              		@ link register save eliminated.
 3425 0000 80B4     		push	{r7}
 3426              		.cfi_def_cfa_offset 4
 3427              		.cfi_offset 7, -4
 3428 0002 00AF     		add	r7, sp, #0
 3429              		.cfi_def_cfa_register 7
3339:Source/tasks.c **** 	xYieldPending = pdTRUE;
 3430              		.loc 1 3339 0
 3431 0004 034B     		ldr	r3, .L233
 3432 0006 0122     		movs	r2, #1
 3433 0008 1A60     		str	r2, [r3]
3340:Source/tasks.c **** }
 3434              		.loc 1 3340 0
 3435 000a 00BF     		nop
 3436 000c BD46     		mov	sp, r7
 3437              		.cfi_def_cfa_register 13
 3438              		@ sp needed
 3439 000e 80BC     		pop	{r7}
 3440              		.cfi_restore 7
 3441              		.cfi_def_cfa_offset 0
 3442 0010 7047     		bx	lr
 3443              	.L234:
 3444 0012 00BF     		.align	2
 3445              	.L233:
 3446 0014 EC000000 		.word	xYieldPending
 3447              		.cfi_endproc
 3448              	.LFE100:
 3449              		.size	vTaskMissedYield, .-vTaskMissedYield
 3450              		.section	.text.prvIdleTask,"ax",%progbits
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 125
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 125
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 3451              		.align	2
 3452              		.thumb
 3453              		.thumb_func
 3454              		.type	prvIdleTask, %function
 3455              	prvIdleTask:
 3456              	.LFB101:
3341:Source/tasks.c **** /*-----------------------------------------------------------*/
3342:Source/tasks.c **** 
3343:Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
3344:Source/tasks.c **** 
3345:Source/tasks.c **** 	UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
3346:Source/tasks.c **** 	{
3347:Source/tasks.c **** 	UBaseType_t uxReturn;
3348:Source/tasks.c **** 	TCB_t const *pxTCB;
3349:Source/tasks.c **** 
3350:Source/tasks.c **** 		if( xTask != NULL )
3351:Source/tasks.c **** 		{
3352:Source/tasks.c **** 			pxTCB = xTask;
3353:Source/tasks.c **** 			uxReturn = pxTCB->uxTaskNumber;
3354:Source/tasks.c **** 		}
3355:Source/tasks.c **** 		else
3356:Source/tasks.c **** 		{
3357:Source/tasks.c **** 			uxReturn = 0U;
3358:Source/tasks.c **** 		}
3359:Source/tasks.c **** 
3360:Source/tasks.c **** 		return uxReturn;
3361:Source/tasks.c **** 	}
3362:Source/tasks.c **** 
3363:Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3364:Source/tasks.c **** /*-----------------------------------------------------------*/
3365:Source/tasks.c **** 
3366:Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
3367:Source/tasks.c **** 
3368:Source/tasks.c **** 	void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle )
3369:Source/tasks.c **** 	{
3370:Source/tasks.c **** 	TCB_t * pxTCB;
3371:Source/tasks.c **** 
3372:Source/tasks.c **** 		if( xTask != NULL )
3373:Source/tasks.c **** 		{
3374:Source/tasks.c **** 			pxTCB = xTask;
3375:Source/tasks.c **** 			pxTCB->uxTaskNumber = uxHandle;
3376:Source/tasks.c **** 		}
3377:Source/tasks.c **** 	}
3378:Source/tasks.c **** 
3379:Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3380:Source/tasks.c **** 
3381:Source/tasks.c **** /*
3382:Source/tasks.c ****  * -----------------------------------------------------------
3383:Source/tasks.c ****  * The Idle task.
3384:Source/tasks.c ****  * ----------------------------------------------------------
3385:Source/tasks.c ****  *
3386:Source/tasks.c ****  * The portTASK_FUNCTION() macro is used to allow port/compiler specific
3387:Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
3388:Source/tasks.c ****  *
3389:Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
3390:Source/tasks.c ****  *
3391:Source/tasks.c ****  */
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 126
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 126
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


3392:Source/tasks.c **** static portTASK_FUNCTION( prvIdleTask, pvParameters )
3393:Source/tasks.c **** {
 3457              		.loc 1 3393 0
 3458              		.cfi_startproc
 3459              		@ args = 0, pretend = 0, frame = 8
 3460              		@ frame_needed = 1, uses_anonymous_args = 0
 3461 0000 80B5     		push	{r7, lr}
 3462              		.cfi_def_cfa_offset 8
 3463              		.cfi_offset 7, -8
 3464              		.cfi_offset 14, -4
 3465 0002 82B0     		sub	sp, sp, #8
 3466              		.cfi_def_cfa_offset 16
 3467 0004 00AF     		add	r7, sp, #0
 3468              		.cfi_def_cfa_register 7
 3469 0006 7860     		str	r0, [r7, #4]
 3470              	.L236:
3394:Source/tasks.c **** 	/* Stop warnings. */
3395:Source/tasks.c **** 	( void ) pvParameters;
3396:Source/tasks.c **** 
3397:Source/tasks.c **** 	/** THIS IS THE RTOS IDLE TASK - WHICH IS CREATED AUTOMATICALLY WHEN THE
3398:Source/tasks.c **** 	SCHEDULER IS STARTED. **/
3399:Source/tasks.c **** 
3400:Source/tasks.c **** 	/* In case a task that has a secure context deletes itself, in which case
3401:Source/tasks.c **** 	the idle task is responsible for deleting the task's secure context, if
3402:Source/tasks.c **** 	any. */
3403:Source/tasks.c **** 	portALLOCATE_SECURE_CONTEXT( configMINIMAL_SECURE_STACK_SIZE );
3404:Source/tasks.c **** 
3405:Source/tasks.c **** 	for( ;; )
3406:Source/tasks.c **** 	{
3407:Source/tasks.c **** 		/* See if any tasks have deleted themselves - if so then the idle task
3408:Source/tasks.c **** 		is responsible for freeing the deleted task's TCB and stack. */
3409:Source/tasks.c **** 		prvCheckTasksWaitingTermination();
 3471              		.loc 1 3409 0 discriminator 1
 3472 0008 FFF7FEFF 		bl	prvCheckTasksWaitingTermination
3410:Source/tasks.c **** 
3411:Source/tasks.c **** 		#if ( configUSE_PREEMPTION == 0 )
3412:Source/tasks.c **** 		{
3413:Source/tasks.c **** 			/* If we are not using preemption we keep forcing a task switch to
3414:Source/tasks.c **** 			see if any other task has become available.  If we are using
3415:Source/tasks.c **** 			preemption we don't need to do this as any task becoming available
3416:Source/tasks.c **** 			will automatically get the processor anyway. */
3417:Source/tasks.c **** 			taskYIELD();
3418:Source/tasks.c **** 		}
3419:Source/tasks.c **** 		#endif /* configUSE_PREEMPTION */
3420:Source/tasks.c **** 
3421:Source/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
3422:Source/tasks.c **** 		{
3423:Source/tasks.c **** 			/* When using preemption tasks of equal priority will be
3424:Source/tasks.c **** 			timesliced.  If a task that is sharing the idle priority is ready
3425:Source/tasks.c **** 			to run then the idle task should yield before the end of the
3426:Source/tasks.c **** 			timeslice.
3427:Source/tasks.c **** 
3428:Source/tasks.c **** 			A critical region is not required here as we are just reading from
3429:Source/tasks.c **** 			the list, and an occasional incorrect value will not matter.  If
3430:Source/tasks.c **** 			the ready list at the idle priority contains more than one task
3431:Source/tasks.c **** 			then a task other than the idle task is ready to execute. */
3432:Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 127
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 127
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


3433:Source/tasks.c **** 			{
3434:Source/tasks.c **** 				taskYIELD();
3435:Source/tasks.c **** 			}
3436:Source/tasks.c **** 			else
3437:Source/tasks.c **** 			{
3438:Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3439:Source/tasks.c **** 			}
3440:Source/tasks.c **** 		}
3441:Source/tasks.c **** 		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
3442:Source/tasks.c **** 
3443:Source/tasks.c **** 		#if ( configUSE_IDLE_HOOK == 1 )
3444:Source/tasks.c **** 		{
3445:Source/tasks.c **** 			extern void vApplicationIdleHook( void );
3446:Source/tasks.c **** 
3447:Source/tasks.c **** 			/* Call the user defined function from within the idle task.  This
3448:Source/tasks.c **** 			allows the application designer to add background functionality
3449:Source/tasks.c **** 			without the overhead of a separate task.
3450:Source/tasks.c **** 			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
3451:Source/tasks.c **** 			CALL A FUNCTION THAT MIGHT BLOCK. */
3452:Source/tasks.c **** 			vApplicationIdleHook();
3453:Source/tasks.c **** 		}
3454:Source/tasks.c **** 		#endif /* configUSE_IDLE_HOOK */
3455:Source/tasks.c **** 
3456:Source/tasks.c **** 		/* This conditional compilation should use inequality to 0, not equality
3457:Source/tasks.c **** 		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
3458:Source/tasks.c **** 		user defined low power mode	implementations require
3459:Source/tasks.c **** 		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
3460:Source/tasks.c **** 		#if ( configUSE_TICKLESS_IDLE != 0 )
3461:Source/tasks.c **** 		{
3462:Source/tasks.c **** 		TickType_t xExpectedIdleTime;
3463:Source/tasks.c **** 
3464:Source/tasks.c **** 			/* It is not desirable to suspend then resume the scheduler on
3465:Source/tasks.c **** 			each iteration of the idle task.  Therefore, a preliminary
3466:Source/tasks.c **** 			test of the expected idle time is performed without the
3467:Source/tasks.c **** 			scheduler suspended.  The result here is not necessarily
3468:Source/tasks.c **** 			valid. */
3469:Source/tasks.c **** 			xExpectedIdleTime = prvGetExpectedIdleTime();
3470:Source/tasks.c **** 
3471:Source/tasks.c **** 			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
3472:Source/tasks.c **** 			{
3473:Source/tasks.c **** 				vTaskSuspendAll();
3474:Source/tasks.c **** 				{
3475:Source/tasks.c **** 					/* Now the scheduler is suspended, the expected idle
3476:Source/tasks.c **** 					time can be sampled again, and this time its value can
3477:Source/tasks.c **** 					be used. */
3478:Source/tasks.c **** 					configASSERT( xNextTaskUnblockTime >= xTickCount );
3479:Source/tasks.c **** 					xExpectedIdleTime = prvGetExpectedIdleTime();
3480:Source/tasks.c **** 
3481:Source/tasks.c **** 					/* Define the following macro to set xExpectedIdleTime to 0
3482:Source/tasks.c **** 					if the application does not want
3483:Source/tasks.c **** 					portSUPPRESS_TICKS_AND_SLEEP() to be called. */
3484:Source/tasks.c **** 					configPRE_SUPPRESS_TICKS_AND_SLEEP_PROCESSING( xExpectedIdleTime );
3485:Source/tasks.c **** 
3486:Source/tasks.c **** 					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
3487:Source/tasks.c **** 					{
3488:Source/tasks.c **** 						traceLOW_POWER_IDLE_BEGIN();
3489:Source/tasks.c **** 						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 128
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 128
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


3490:Source/tasks.c **** 						traceLOW_POWER_IDLE_END();
3491:Source/tasks.c **** 					}
3492:Source/tasks.c **** 					else
3493:Source/tasks.c **** 					{
3494:Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
3495:Source/tasks.c **** 					}
3496:Source/tasks.c **** 				}
3497:Source/tasks.c **** 				( void ) xTaskResumeAll();
3498:Source/tasks.c **** 			}
3499:Source/tasks.c **** 			else
3500:Source/tasks.c **** 			{
3501:Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3502:Source/tasks.c **** 			}
3503:Source/tasks.c **** 		}
3504:Source/tasks.c **** 		#endif /* configUSE_TICKLESS_IDLE */
3505:Source/tasks.c **** 	}
 3473              		.loc 1 3505 0 discriminator 1
 3474 000c FCE7     		b	.L236
 3475              		.cfi_endproc
 3476              	.LFE101:
 3477              		.size	prvIdleTask, .-prvIdleTask
 3478 000e 00BF     		.section	.text.prvInitialiseTaskLists,"ax",%progbits
 3479              		.align	2
 3480              		.thumb
 3481              		.thumb_func
 3482              		.type	prvInitialiseTaskLists, %function
 3483              	prvInitialiseTaskLists:
 3484              	.LFB102:
3506:Source/tasks.c **** }
3507:Source/tasks.c **** /*-----------------------------------------------------------*/
3508:Source/tasks.c **** 
3509:Source/tasks.c **** #if( configUSE_TICKLESS_IDLE != 0 )
3510:Source/tasks.c **** 
3511:Source/tasks.c **** 	eSleepModeStatus eTaskConfirmSleepModeStatus( void )
3512:Source/tasks.c **** 	{
3513:Source/tasks.c **** 	/* The idle task exists in addition to the application tasks. */
3514:Source/tasks.c **** 	const UBaseType_t uxNonApplicationTasks = 1;
3515:Source/tasks.c **** 	eSleepModeStatus eReturn = eStandardSleep;
3516:Source/tasks.c **** 
3517:Source/tasks.c **** 		/* This function must be called from a critical section. */
3518:Source/tasks.c **** 
3519:Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( &xPendingReadyList ) != 0 )
3520:Source/tasks.c **** 		{
3521:Source/tasks.c **** 			/* A task was made ready while the scheduler was suspended. */
3522:Source/tasks.c **** 			eReturn = eAbortSleep;
3523:Source/tasks.c **** 		}
3524:Source/tasks.c **** 		else if( xYieldPending != pdFALSE )
3525:Source/tasks.c **** 		{
3526:Source/tasks.c **** 			/* A yield was pended while the scheduler was suspended. */
3527:Source/tasks.c **** 			eReturn = eAbortSleep;
3528:Source/tasks.c **** 		}
3529:Source/tasks.c **** 		else
3530:Source/tasks.c **** 		{
3531:Source/tasks.c **** 			/* If all the tasks are in the suspended list (which might mean they
3532:Source/tasks.c **** 			have an infinite block time rather than actually being suspended)
3533:Source/tasks.c **** 			then it is safe to turn all clocks off and just wait for external
3534:Source/tasks.c **** 			interrupts. */
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 129
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 129
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


3535:Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == ( uxCurrentNumberOfTasks - uxNonApplicatio
3536:Source/tasks.c **** 			{
3537:Source/tasks.c **** 				eReturn = eNoTasksWaitingTimeout;
3538:Source/tasks.c **** 			}
3539:Source/tasks.c **** 			else
3540:Source/tasks.c **** 			{
3541:Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3542:Source/tasks.c **** 			}
3543:Source/tasks.c **** 		}
3544:Source/tasks.c **** 
3545:Source/tasks.c **** 		return eReturn;
3546:Source/tasks.c **** 	}
3547:Source/tasks.c **** 
3548:Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
3549:Source/tasks.c **** /*-----------------------------------------------------------*/
3550:Source/tasks.c **** 
3551:Source/tasks.c **** #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
3552:Source/tasks.c **** 
3553:Source/tasks.c **** 	void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue 
3554:Source/tasks.c **** 	{
3555:Source/tasks.c **** 	TCB_t *pxTCB;
3556:Source/tasks.c **** 
3557:Source/tasks.c **** 		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
3558:Source/tasks.c **** 		{
3559:Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToSet );
3560:Source/tasks.c **** 			configASSERT( pxTCB != NULL );
3561:Source/tasks.c **** 			pxTCB->pvThreadLocalStoragePointers[ xIndex ] = pvValue;
3562:Source/tasks.c **** 		}
3563:Source/tasks.c **** 	}
3564:Source/tasks.c **** 
3565:Source/tasks.c **** #endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
3566:Source/tasks.c **** /*-----------------------------------------------------------*/
3567:Source/tasks.c **** 
3568:Source/tasks.c **** #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
3569:Source/tasks.c **** 
3570:Source/tasks.c **** 	void *pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery, BaseType_t xIndex )
3571:Source/tasks.c **** 	{
3572:Source/tasks.c **** 	void *pvReturn = NULL;
3573:Source/tasks.c **** 	TCB_t *pxTCB;
3574:Source/tasks.c **** 
3575:Source/tasks.c **** 		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
3576:Source/tasks.c **** 		{
3577:Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToQuery );
3578:Source/tasks.c **** 			pvReturn = pxTCB->pvThreadLocalStoragePointers[ xIndex ];
3579:Source/tasks.c **** 		}
3580:Source/tasks.c **** 		else
3581:Source/tasks.c **** 		{
3582:Source/tasks.c **** 			pvReturn = NULL;
3583:Source/tasks.c **** 		}
3584:Source/tasks.c **** 
3585:Source/tasks.c **** 		return pvReturn;
3586:Source/tasks.c **** 	}
3587:Source/tasks.c **** 
3588:Source/tasks.c **** #endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
3589:Source/tasks.c **** /*-----------------------------------------------------------*/
3590:Source/tasks.c **** 
3591:Source/tasks.c **** #if ( portUSING_MPU_WRAPPERS == 1 )
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 130
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 130
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


3592:Source/tasks.c **** 
3593:Source/tasks.c **** 	void vTaskAllocateMPURegions( TaskHandle_t xTaskToModify, const MemoryRegion_t * const xRegions )
3594:Source/tasks.c **** 	{
3595:Source/tasks.c **** 	TCB_t *pxTCB;
3596:Source/tasks.c **** 
3597:Source/tasks.c **** 		/* If null is passed in here then we are modifying the MPU settings of
3598:Source/tasks.c **** 		the calling task. */
3599:Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToModify );
3600:Source/tasks.c **** 
3601:Source/tasks.c **** 		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
3602:Source/tasks.c **** 	}
3603:Source/tasks.c **** 
3604:Source/tasks.c **** #endif /* portUSING_MPU_WRAPPERS */
3605:Source/tasks.c **** /*-----------------------------------------------------------*/
3606:Source/tasks.c **** 
3607:Source/tasks.c **** static void prvInitialiseTaskLists( void )
3608:Source/tasks.c **** {
 3485              		.loc 1 3608 0
 3486              		.cfi_startproc
 3487              		@ args = 0, pretend = 0, frame = 8
 3488              		@ frame_needed = 1, uses_anonymous_args = 0
 3489 0000 80B5     		push	{r7, lr}
 3490              		.cfi_def_cfa_offset 8
 3491              		.cfi_offset 7, -8
 3492              		.cfi_offset 14, -4
 3493 0002 82B0     		sub	sp, sp, #8
 3494              		.cfi_def_cfa_offset 16
 3495 0004 00AF     		add	r7, sp, #0
 3496              		.cfi_def_cfa_register 7
3609:Source/tasks.c **** UBaseType_t uxPriority;
3610:Source/tasks.c **** 
3611:Source/tasks.c **** 	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriorit
 3497              		.loc 1 3611 0
 3498 0006 0023     		movs	r3, #0
 3499 0008 7B60     		str	r3, [r7, #4]
 3500 000a 0CE0     		b	.L238
 3501              	.L239:
3612:Source/tasks.c **** 	{
3613:Source/tasks.c **** 		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 3502              		.loc 1 3613 0 discriminator 3
 3503 000c 7A68     		ldr	r2, [r7, #4]
 3504 000e 1346     		mov	r3, r2
 3505 0010 9B00     		lsls	r3, r3, #2
 3506 0012 1344     		add	r3, r3, r2
 3507 0014 9B00     		lsls	r3, r3, #2
 3508 0016 124A     		ldr	r2, .L240
 3509 0018 1344     		add	r3, r3, r2
 3510 001a 1846     		mov	r0, r3
 3511 001c FFF7FEFF 		bl	vListInitialise
3611:Source/tasks.c **** 	{
 3512              		.loc 1 3611 0 discriminator 3
 3513 0020 7B68     		ldr	r3, [r7, #4]
 3514 0022 0133     		adds	r3, r3, #1
 3515 0024 7B60     		str	r3, [r7, #4]
 3516              	.L238:
3611:Source/tasks.c **** 	{
 3517              		.loc 1 3611 0 is_stmt 0 discriminator 1
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 131
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 131
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 3518 0026 7B68     		ldr	r3, [r7, #4]
 3519 0028 042B     		cmp	r3, #4
 3520 002a EFD9     		bls	.L239
3614:Source/tasks.c **** 	}
3615:Source/tasks.c **** 
3616:Source/tasks.c **** 	vListInitialise( &xDelayedTaskList1 );
 3521              		.loc 1 3616 0 is_stmt 1
 3522 002c 0D48     		ldr	r0, .L240+4
 3523 002e FFF7FEFF 		bl	vListInitialise
3617:Source/tasks.c **** 	vListInitialise( &xDelayedTaskList2 );
 3524              		.loc 1 3617 0
 3525 0032 0D48     		ldr	r0, .L240+8
 3526 0034 FFF7FEFF 		bl	vListInitialise
3618:Source/tasks.c **** 	vListInitialise( &xPendingReadyList );
 3527              		.loc 1 3618 0
 3528 0038 0C48     		ldr	r0, .L240+12
 3529 003a FFF7FEFF 		bl	vListInitialise
3619:Source/tasks.c **** 
3620:Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
3621:Source/tasks.c **** 	{
3622:Source/tasks.c **** 		vListInitialise( &xTasksWaitingTermination );
 3530              		.loc 1 3622 0
 3531 003e 0C48     		ldr	r0, .L240+16
 3532 0040 FFF7FEFF 		bl	vListInitialise
3623:Source/tasks.c **** 	}
3624:Source/tasks.c **** 	#endif /* INCLUDE_vTaskDelete */
3625:Source/tasks.c **** 
3626:Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
3627:Source/tasks.c **** 	{
3628:Source/tasks.c **** 		vListInitialise( &xSuspendedTaskList );
 3533              		.loc 1 3628 0
 3534 0044 0B48     		ldr	r0, .L240+20
 3535 0046 FFF7FEFF 		bl	vListInitialise
3629:Source/tasks.c **** 	}
3630:Source/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
3631:Source/tasks.c **** 
3632:Source/tasks.c **** 	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
3633:Source/tasks.c **** 	using list2. */
3634:Source/tasks.c **** 	pxDelayedTaskList = &xDelayedTaskList1;
 3536              		.loc 1 3634 0
 3537 004a 0B4B     		ldr	r3, .L240+24
 3538 004c 054A     		ldr	r2, .L240+4
 3539 004e 1A60     		str	r2, [r3]
3635:Source/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 3540              		.loc 1 3635 0
 3541 0050 0A4B     		ldr	r3, .L240+28
 3542 0052 054A     		ldr	r2, .L240+8
 3543 0054 1A60     		str	r2, [r3]
3636:Source/tasks.c **** }
 3544              		.loc 1 3636 0
 3545 0056 00BF     		nop
 3546 0058 0837     		adds	r7, r7, #8
 3547              		.cfi_def_cfa_offset 8
 3548 005a BD46     		mov	sp, r7
 3549              		.cfi_def_cfa_register 13
 3550              		@ sp needed
 3551 005c 80BD     		pop	{r7, pc}
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 132
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 132
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 3552              	.L241:
 3553 005e 00BF     		.align	2
 3554              	.L240:
 3555 0060 04000000 		.word	pxReadyTasksLists
 3556 0064 68000000 		.word	xDelayedTaskList1
 3557 0068 7C000000 		.word	xDelayedTaskList2
 3558 006c 98000000 		.word	xPendingReadyList
 3559 0070 AC000000 		.word	xTasksWaitingTermination
 3560 0074 C4000000 		.word	xSuspendedTaskList
 3561 0078 90000000 		.word	pxDelayedTaskList
 3562 007c 94000000 		.word	pxOverflowDelayedTaskList
 3563              		.cfi_endproc
 3564              	.LFE102:
 3565              		.size	prvInitialiseTaskLists, .-prvInitialiseTaskLists
 3566              		.section	.text.prvCheckTasksWaitingTermination,"ax",%progbits
 3567              		.align	2
 3568              		.thumb
 3569              		.thumb_func
 3570              		.type	prvCheckTasksWaitingTermination, %function
 3571              	prvCheckTasksWaitingTermination:
 3572              	.LFB103:
3637:Source/tasks.c **** /*-----------------------------------------------------------*/
3638:Source/tasks.c **** 
3639:Source/tasks.c **** static void prvCheckTasksWaitingTermination( void )
3640:Source/tasks.c **** {
 3573              		.loc 1 3640 0
 3574              		.cfi_startproc
 3575              		@ args = 0, pretend = 0, frame = 8
 3576              		@ frame_needed = 1, uses_anonymous_args = 0
 3577 0000 80B5     		push	{r7, lr}
 3578              		.cfi_def_cfa_offset 8
 3579              		.cfi_offset 7, -8
 3580              		.cfi_offset 14, -4
 3581 0002 82B0     		sub	sp, sp, #8
 3582              		.cfi_def_cfa_offset 16
 3583 0004 00AF     		add	r7, sp, #0
 3584              		.cfi_def_cfa_register 7
 3585              	.LBB50:
3641:Source/tasks.c **** 
3642:Source/tasks.c **** 	/** THIS FUNCTION IS CALLED FROM THE RTOS IDLE TASK **/
3643:Source/tasks.c **** 
3644:Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
3645:Source/tasks.c **** 	{
3646:Source/tasks.c **** 		TCB_t *pxTCB;
3647:Source/tasks.c **** 
3648:Source/tasks.c **** 		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
3649:Source/tasks.c **** 		being called too often in the idle task. */
3650:Source/tasks.c **** 		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 3586              		.loc 1 3650 0
 3587 0006 19E0     		b	.L243
 3588              	.L244:
3651:Source/tasks.c **** 		{
3652:Source/tasks.c **** 			taskENTER_CRITICAL();
 3589              		.loc 1 3652 0
 3590 0008 FFF7FEFF 		bl	vPortEnterCritical
3653:Source/tasks.c **** 			{
3654:Source/tasks.c **** 				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is u
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 133
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 133
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 3591              		.loc 1 3654 0
 3592 000c 0F4B     		ldr	r3, .L245
 3593 000e DB68     		ldr	r3, [r3, #12]
 3594 0010 DB68     		ldr	r3, [r3, #12]
 3595 0012 7B60     		str	r3, [r7, #4]
3655:Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 3596              		.loc 1 3655 0
 3597 0014 7B68     		ldr	r3, [r7, #4]
 3598 0016 0433     		adds	r3, r3, #4
 3599 0018 1846     		mov	r0, r3
 3600 001a FFF7FEFF 		bl	uxListRemove
3656:Source/tasks.c **** 				--uxCurrentNumberOfTasks;
 3601              		.loc 1 3656 0
 3602 001e 0C4B     		ldr	r3, .L245+4
 3603 0020 1B68     		ldr	r3, [r3]
 3604 0022 013B     		subs	r3, r3, #1
 3605 0024 0A4A     		ldr	r2, .L245+4
 3606 0026 1360     		str	r3, [r2]
3657:Source/tasks.c **** 				--uxDeletedTasksWaitingCleanUp;
 3607              		.loc 1 3657 0
 3608 0028 0A4B     		ldr	r3, .L245+8
 3609 002a 1B68     		ldr	r3, [r3]
 3610 002c 013B     		subs	r3, r3, #1
 3611 002e 094A     		ldr	r2, .L245+8
 3612 0030 1360     		str	r3, [r2]
3658:Source/tasks.c **** 			}
3659:Source/tasks.c **** 			taskEXIT_CRITICAL();
 3613              		.loc 1 3659 0
 3614 0032 FFF7FEFF 		bl	vPortExitCritical
3660:Source/tasks.c **** 
3661:Source/tasks.c **** 			prvDeleteTCB( pxTCB );
 3615              		.loc 1 3661 0
 3616 0036 7868     		ldr	r0, [r7, #4]
 3617 0038 FFF7FEFF 		bl	prvDeleteTCB
 3618              	.L243:
3650:Source/tasks.c **** 		{
 3619              		.loc 1 3650 0
 3620 003c 054B     		ldr	r3, .L245+8
 3621 003e 1B68     		ldr	r3, [r3]
 3622 0040 002B     		cmp	r3, #0
 3623 0042 E1D1     		bne	.L244
 3624              	.LBE50:
3662:Source/tasks.c **** 		}
3663:Source/tasks.c **** 	}
3664:Source/tasks.c **** 	#endif /* INCLUDE_vTaskDelete */
3665:Source/tasks.c **** }
 3625              		.loc 1 3665 0
 3626 0044 00BF     		nop
 3627 0046 0837     		adds	r7, r7, #8
 3628              		.cfi_def_cfa_offset 8
 3629 0048 BD46     		mov	sp, r7
 3630              		.cfi_def_cfa_register 13
 3631              		@ sp needed
 3632 004a 80BD     		pop	{r7, pc}
 3633              	.L246:
 3634              		.align	2
 3635              	.L245:
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 134
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 134
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 3636 004c AC000000 		.word	xTasksWaitingTermination
 3637 0050 D8000000 		.word	uxCurrentNumberOfTasks
 3638 0054 C0000000 		.word	uxDeletedTasksWaitingCleanUp
 3639              		.cfi_endproc
 3640              	.LFE103:
 3641              		.size	prvCheckTasksWaitingTermination, .-prvCheckTasksWaitingTermination
 3642              		.section	.text.prvTaskCheckFreeStackSpace,"ax",%progbits
 3643              		.align	2
 3644              		.thumb
 3645              		.thumb_func
 3646              		.type	prvTaskCheckFreeStackSpace, %function
 3647              	prvTaskCheckFreeStackSpace:
 3648              	.LFB104:
3666:Source/tasks.c **** /*-----------------------------------------------------------*/
3667:Source/tasks.c **** 
3668:Source/tasks.c **** #if( configUSE_TRACE_FACILITY == 1 )
3669:Source/tasks.c **** 
3670:Source/tasks.c **** 	void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, 
3671:Source/tasks.c **** 	{
3672:Source/tasks.c **** 	TCB_t *pxTCB;
3673:Source/tasks.c **** 
3674:Source/tasks.c **** 		/* xTask is NULL then get the state of the calling task. */
3675:Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
3676:Source/tasks.c **** 
3677:Source/tasks.c **** 		pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
3678:Source/tasks.c **** 		pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName [ 0 ] );
3679:Source/tasks.c **** 		pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
3680:Source/tasks.c **** 		pxTaskStatus->pxStackBase = pxTCB->pxStack;
3681:Source/tasks.c **** 		pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
3682:Source/tasks.c **** 
3683:Source/tasks.c **** 		#if ( configUSE_MUTEXES == 1 )
3684:Source/tasks.c **** 		{
3685:Source/tasks.c **** 			pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
3686:Source/tasks.c **** 		}
3687:Source/tasks.c **** 		#else
3688:Source/tasks.c **** 		{
3689:Source/tasks.c **** 			pxTaskStatus->uxBasePriority = 0;
3690:Source/tasks.c **** 		}
3691:Source/tasks.c **** 		#endif
3692:Source/tasks.c **** 
3693:Source/tasks.c **** 		#if ( configGENERATE_RUN_TIME_STATS == 1 )
3694:Source/tasks.c **** 		{
3695:Source/tasks.c **** 			pxTaskStatus->ulRunTimeCounter = pxTCB->ulRunTimeCounter;
3696:Source/tasks.c **** 		}
3697:Source/tasks.c **** 		#else
3698:Source/tasks.c **** 		{
3699:Source/tasks.c **** 			pxTaskStatus->ulRunTimeCounter = 0;
3700:Source/tasks.c **** 		}
3701:Source/tasks.c **** 		#endif
3702:Source/tasks.c **** 
3703:Source/tasks.c **** 		/* Obtaining the task state is a little fiddly, so is only done if the
3704:Source/tasks.c **** 		value of eState passed into this function is eInvalid - otherwise the
3705:Source/tasks.c **** 		state is just set to whatever is passed in. */
3706:Source/tasks.c **** 		if( eState != eInvalid )
3707:Source/tasks.c **** 		{
3708:Source/tasks.c **** 			if( pxTCB == pxCurrentTCB )
3709:Source/tasks.c **** 			{
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 135
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 135
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


3710:Source/tasks.c **** 				pxTaskStatus->eCurrentState = eRunning;
3711:Source/tasks.c **** 			}
3712:Source/tasks.c **** 			else
3713:Source/tasks.c **** 			{
3714:Source/tasks.c **** 				pxTaskStatus->eCurrentState = eState;
3715:Source/tasks.c **** 
3716:Source/tasks.c **** 				#if ( INCLUDE_vTaskSuspend == 1 )
3717:Source/tasks.c **** 				{
3718:Source/tasks.c **** 					/* If the task is in the suspended list then there is a
3719:Source/tasks.c **** 					chance it is actually just blocked indefinitely - so really
3720:Source/tasks.c **** 					it should be reported as being in the Blocked state. */
3721:Source/tasks.c **** 					if( eState == eSuspended )
3722:Source/tasks.c **** 					{
3723:Source/tasks.c **** 						vTaskSuspendAll();
3724:Source/tasks.c **** 						{
3725:Source/tasks.c **** 							if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
3726:Source/tasks.c **** 							{
3727:Source/tasks.c **** 								pxTaskStatus->eCurrentState = eBlocked;
3728:Source/tasks.c **** 							}
3729:Source/tasks.c **** 						}
3730:Source/tasks.c **** 						( void ) xTaskResumeAll();
3731:Source/tasks.c **** 					}
3732:Source/tasks.c **** 				}
3733:Source/tasks.c **** 				#endif /* INCLUDE_vTaskSuspend */
3734:Source/tasks.c **** 			}
3735:Source/tasks.c **** 		}
3736:Source/tasks.c **** 		else
3737:Source/tasks.c **** 		{
3738:Source/tasks.c **** 			pxTaskStatus->eCurrentState = eTaskGetState( pxTCB );
3739:Source/tasks.c **** 		}
3740:Source/tasks.c **** 
3741:Source/tasks.c **** 		/* Obtaining the stack space takes some time, so the xGetFreeStackSpace
3742:Source/tasks.c **** 		parameter is provided to allow it to be skipped. */
3743:Source/tasks.c **** 		if( xGetFreeStackSpace != pdFALSE )
3744:Source/tasks.c **** 		{
3745:Source/tasks.c **** 			#if ( portSTACK_GROWTH > 0 )
3746:Source/tasks.c **** 			{
3747:Source/tasks.c **** 				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxEndOfSt
3748:Source/tasks.c **** 			}
3749:Source/tasks.c **** 			#else
3750:Source/tasks.c **** 			{
3751:Source/tasks.c **** 				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack )
3752:Source/tasks.c **** 			}
3753:Source/tasks.c **** 			#endif
3754:Source/tasks.c **** 		}
3755:Source/tasks.c **** 		else
3756:Source/tasks.c **** 		{
3757:Source/tasks.c **** 			pxTaskStatus->usStackHighWaterMark = 0;
3758:Source/tasks.c **** 		}
3759:Source/tasks.c **** 	}
3760:Source/tasks.c **** 
3761:Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3762:Source/tasks.c **** /*-----------------------------------------------------------*/
3763:Source/tasks.c **** 
3764:Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
3765:Source/tasks.c **** 
3766:Source/tasks.c **** 	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, 
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 136
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 136
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


3767:Source/tasks.c **** 	{
3768:Source/tasks.c **** 	configLIST_VOLATILE TCB_t *pxNextTCB, *pxFirstTCB;
3769:Source/tasks.c **** 	UBaseType_t uxTask = 0;
3770:Source/tasks.c **** 
3771:Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
3772:Source/tasks.c **** 		{
3773:Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList ); /*lint !e9079 void * is used as this macro is
3774:Source/tasks.c **** 
3775:Source/tasks.c **** 			/* Populate an TaskStatus_t structure within the
3776:Source/tasks.c **** 			pxTaskStatusArray array for each task that is referenced from
3777:Source/tasks.c **** 			pxList.  See the definition of TaskStatus_t in task.h for the
3778:Source/tasks.c **** 			meaning of each TaskStatus_t structure member. */
3779:Source/tasks.c **** 			do
3780:Source/tasks.c **** 			{
3781:Source/tasks.c **** 				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList ); /*lint !e9079 void * is used as this macro is
3782:Source/tasks.c **** 				vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );
3783:Source/tasks.c **** 				uxTask++;
3784:Source/tasks.c **** 			} while( pxNextTCB != pxFirstTCB );
3785:Source/tasks.c **** 		}
3786:Source/tasks.c **** 		else
3787:Source/tasks.c **** 		{
3788:Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3789:Source/tasks.c **** 		}
3790:Source/tasks.c **** 
3791:Source/tasks.c **** 		return uxTask;
3792:Source/tasks.c **** 	}
3793:Source/tasks.c **** 
3794:Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3795:Source/tasks.c **** /*-----------------------------------------------------------*/
3796:Source/tasks.c **** 
3797:Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUD
3798:Source/tasks.c **** 
3799:Source/tasks.c **** 	static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
3800:Source/tasks.c **** 	{
 3649              		.loc 1 3800 0
 3650              		.cfi_startproc
 3651              		@ args = 0, pretend = 0, frame = 16
 3652              		@ frame_needed = 1, uses_anonymous_args = 0
 3653              		@ link register save eliminated.
 3654 0000 80B4     		push	{r7}
 3655              		.cfi_def_cfa_offset 4
 3656              		.cfi_offset 7, -4
 3657 0002 85B0     		sub	sp, sp, #20
 3658              		.cfi_def_cfa_offset 24
 3659 0004 00AF     		add	r7, sp, #0
 3660              		.cfi_def_cfa_register 7
 3661 0006 7860     		str	r0, [r7, #4]
3801:Source/tasks.c **** 	uint32_t ulCount = 0U;
 3662              		.loc 1 3801 0
 3663 0008 0023     		movs	r3, #0
 3664 000a FB60     		str	r3, [r7, #12]
3802:Source/tasks.c **** 
3803:Source/tasks.c **** 		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
 3665              		.loc 1 3803 0
 3666 000c 05E0     		b	.L248
 3667              	.L249:
3804:Source/tasks.c **** 		{
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 137
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 137
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


3805:Source/tasks.c **** 			pucStackByte -= portSTACK_GROWTH;
 3668              		.loc 1 3805 0
 3669 000e 7B68     		ldr	r3, [r7, #4]
 3670 0010 0133     		adds	r3, r3, #1
 3671 0012 7B60     		str	r3, [r7, #4]
3806:Source/tasks.c **** 			ulCount++;
 3672              		.loc 1 3806 0
 3673 0014 FB68     		ldr	r3, [r7, #12]
 3674 0016 0133     		adds	r3, r3, #1
 3675 0018 FB60     		str	r3, [r7, #12]
 3676              	.L248:
3803:Source/tasks.c **** 		{
 3677              		.loc 1 3803 0
 3678 001a 7B68     		ldr	r3, [r7, #4]
 3679 001c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 3680 001e A52B     		cmp	r3, #165
 3681 0020 F5D0     		beq	.L249
3807:Source/tasks.c **** 		}
3808:Source/tasks.c **** 
3809:Source/tasks.c **** 		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller a
 3682              		.loc 1 3809 0
 3683 0022 FB68     		ldr	r3, [r7, #12]
 3684 0024 9B08     		lsrs	r3, r3, #2
 3685 0026 FB60     		str	r3, [r7, #12]
3810:Source/tasks.c **** 
3811:Source/tasks.c **** 		return ( configSTACK_DEPTH_TYPE ) ulCount;
 3686              		.loc 1 3811 0
 3687 0028 FB68     		ldr	r3, [r7, #12]
 3688 002a 9BB2     		uxth	r3, r3
3812:Source/tasks.c **** 	}
 3689              		.loc 1 3812 0
 3690 002c 1846     		mov	r0, r3
 3691 002e 1437     		adds	r7, r7, #20
 3692              		.cfi_def_cfa_offset 4
 3693 0030 BD46     		mov	sp, r7
 3694              		.cfi_def_cfa_register 13
 3695              		@ sp needed
 3696 0032 80BC     		pop	{r7}
 3697              		.cfi_restore 7
 3698              		.cfi_def_cfa_offset 0
 3699 0034 7047     		bx	lr
 3700              		.cfi_endproc
 3701              	.LFE104:
 3702              		.size	prvTaskCheckFreeStackSpace, .-prvTaskCheckFreeStackSpace
 3703 0036 00BF     		.section	.text.uxTaskGetStackHighWaterMark,"ax",%progbits
 3704              		.align	2
 3705              		.global	uxTaskGetStackHighWaterMark
 3706              		.thumb
 3707              		.thumb_func
 3708              		.type	uxTaskGetStackHighWaterMark, %function
 3709              	uxTaskGetStackHighWaterMark:
 3710              	.LFB105:
3813:Source/tasks.c **** 
3814:Source/tasks.c **** #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( 
3815:Source/tasks.c **** /*-----------------------------------------------------------*/
3816:Source/tasks.c **** 
3817:Source/tasks.c **** #if ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 )
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 138
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 138
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


3818:Source/tasks.c **** 
3819:Source/tasks.c **** 	/* uxTaskGetStackHighWaterMark() and uxTaskGetStackHighWaterMark2() are the
3820:Source/tasks.c **** 	same except for their return type.  Using configSTACK_DEPTH_TYPE allows the
3821:Source/tasks.c **** 	user to determine the return type.  It gets around the problem of the value
3822:Source/tasks.c **** 	overflowing on 8-bit types without breaking backward compatibility for
3823:Source/tasks.c **** 	applications that expect an 8-bit return type. */
3824:Source/tasks.c **** 	configSTACK_DEPTH_TYPE uxTaskGetStackHighWaterMark2( TaskHandle_t xTask )
3825:Source/tasks.c **** 	{
3826:Source/tasks.c **** 	TCB_t *pxTCB;
3827:Source/tasks.c **** 	uint8_t *pucEndOfStack;
3828:Source/tasks.c **** 	configSTACK_DEPTH_TYPE uxReturn;
3829:Source/tasks.c **** 
3830:Source/tasks.c **** 		/* uxTaskGetStackHighWaterMark() and uxTaskGetStackHighWaterMark2() are
3831:Source/tasks.c **** 		the same except for their return type.  Using configSTACK_DEPTH_TYPE
3832:Source/tasks.c **** 		allows the user to determine the return type.  It gets around the
3833:Source/tasks.c **** 		problem of the value overflowing on 8-bit types without breaking
3834:Source/tasks.c **** 		backward compatibility for applications that expect an 8-bit return
3835:Source/tasks.c **** 		type. */
3836:Source/tasks.c **** 
3837:Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
3838:Source/tasks.c **** 
3839:Source/tasks.c **** 		#if portSTACK_GROWTH < 0
3840:Source/tasks.c **** 		{
3841:Source/tasks.c **** 			pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
3842:Source/tasks.c **** 		}
3843:Source/tasks.c **** 		#else
3844:Source/tasks.c **** 		{
3845:Source/tasks.c **** 			pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
3846:Source/tasks.c **** 		}
3847:Source/tasks.c **** 		#endif
3848:Source/tasks.c **** 
3849:Source/tasks.c **** 		uxReturn = prvTaskCheckFreeStackSpace( pucEndOfStack );
3850:Source/tasks.c **** 
3851:Source/tasks.c **** 		return uxReturn;
3852:Source/tasks.c **** 	}
3853:Source/tasks.c **** 
3854:Source/tasks.c **** #endif /* INCLUDE_uxTaskGetStackHighWaterMark2 */
3855:Source/tasks.c **** /*-----------------------------------------------------------*/
3856:Source/tasks.c **** 
3857:Source/tasks.c **** #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
3858:Source/tasks.c **** 
3859:Source/tasks.c **** 	UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
3860:Source/tasks.c **** 	{
 3711              		.loc 1 3860 0
 3712              		.cfi_startproc
 3713              		@ args = 0, pretend = 0, frame = 24
 3714              		@ frame_needed = 1, uses_anonymous_args = 0
 3715 0000 80B5     		push	{r7, lr}
 3716              		.cfi_def_cfa_offset 8
 3717              		.cfi_offset 7, -8
 3718              		.cfi_offset 14, -4
 3719 0002 86B0     		sub	sp, sp, #24
 3720              		.cfi_def_cfa_offset 32
 3721 0004 00AF     		add	r7, sp, #0
 3722              		.cfi_def_cfa_register 7
 3723 0006 7860     		str	r0, [r7, #4]
3861:Source/tasks.c **** 	TCB_t *pxTCB;
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 139
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 139
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


3862:Source/tasks.c **** 	uint8_t *pucEndOfStack;
3863:Source/tasks.c **** 	UBaseType_t uxReturn;
3864:Source/tasks.c **** 
3865:Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
 3724              		.loc 1 3865 0
 3725 0008 7B68     		ldr	r3, [r7, #4]
 3726 000a 002B     		cmp	r3, #0
 3727 000c 02D1     		bne	.L252
 3728              		.loc 1 3865 0 is_stmt 0 discriminator 1
 3729 000e 094B     		ldr	r3, .L255
 3730 0010 1B68     		ldr	r3, [r3]
 3731 0012 00E0     		b	.L253
 3732              	.L252:
 3733              		.loc 1 3865 0 discriminator 2
 3734 0014 7B68     		ldr	r3, [r7, #4]
 3735              	.L253:
 3736              		.loc 1 3865 0 discriminator 4
 3737 0016 7B61     		str	r3, [r7, #20]
3866:Source/tasks.c **** 
3867:Source/tasks.c **** 		#if portSTACK_GROWTH < 0
3868:Source/tasks.c **** 		{
3869:Source/tasks.c **** 			pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
 3738              		.loc 1 3869 0 is_stmt 1 discriminator 4
 3739 0018 7B69     		ldr	r3, [r7, #20]
 3740 001a 1B6B     		ldr	r3, [r3, #48]
 3741 001c 3B61     		str	r3, [r7, #16]
3870:Source/tasks.c **** 		}
3871:Source/tasks.c **** 		#else
3872:Source/tasks.c **** 		{
3873:Source/tasks.c **** 			pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
3874:Source/tasks.c **** 		}
3875:Source/tasks.c **** 		#endif
3876:Source/tasks.c **** 
3877:Source/tasks.c **** 		uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
 3742              		.loc 1 3877 0 discriminator 4
 3743 001e 3869     		ldr	r0, [r7, #16]
 3744 0020 FFF7FEFF 		bl	prvTaskCheckFreeStackSpace
 3745 0024 0346     		mov	r3, r0
 3746 0026 FB60     		str	r3, [r7, #12]
3878:Source/tasks.c **** 
3879:Source/tasks.c **** 		return uxReturn;
 3747              		.loc 1 3879 0 discriminator 4
 3748 0028 FB68     		ldr	r3, [r7, #12]
3880:Source/tasks.c **** 	}
 3749              		.loc 1 3880 0 discriminator 4
 3750 002a 1846     		mov	r0, r3
 3751 002c 1837     		adds	r7, r7, #24
 3752              		.cfi_def_cfa_offset 8
 3753 002e BD46     		mov	sp, r7
 3754              		.cfi_def_cfa_register 13
 3755              		@ sp needed
 3756 0030 80BD     		pop	{r7, pc}
 3757              	.L256:
 3758 0032 00BF     		.align	2
 3759              	.L255:
 3760 0034 00000000 		.word	pxCurrentTCB
 3761              		.cfi_endproc
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 140
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 140
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 3762              	.LFE105:
 3763              		.size	uxTaskGetStackHighWaterMark, .-uxTaskGetStackHighWaterMark
 3764              		.section	.text.prvDeleteTCB,"ax",%progbits
 3765              		.align	2
 3766              		.thumb
 3767              		.thumb_func
 3768              		.type	prvDeleteTCB, %function
 3769              	prvDeleteTCB:
 3770              	.LFB106:
3881:Source/tasks.c **** 
3882:Source/tasks.c **** #endif /* INCLUDE_uxTaskGetStackHighWaterMark */
3883:Source/tasks.c **** /*-----------------------------------------------------------*/
3884:Source/tasks.c **** 
3885:Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
3886:Source/tasks.c **** 
3887:Source/tasks.c **** 	static void prvDeleteTCB( TCB_t *pxTCB )
3888:Source/tasks.c **** 	{
 3771              		.loc 1 3888 0
 3772              		.cfi_startproc
 3773              		@ args = 0, pretend = 0, frame = 8
 3774              		@ frame_needed = 1, uses_anonymous_args = 0
 3775 0000 80B5     		push	{r7, lr}
 3776              		.cfi_def_cfa_offset 8
 3777              		.cfi_offset 7, -8
 3778              		.cfi_offset 14, -4
 3779 0002 82B0     		sub	sp, sp, #8
 3780              		.cfi_def_cfa_offset 16
 3781 0004 00AF     		add	r7, sp, #0
 3782              		.cfi_def_cfa_register 7
 3783 0006 7860     		str	r0, [r7, #4]
3889:Source/tasks.c **** 		/* This call is required specifically for the TriCore port.  It must be
3890:Source/tasks.c **** 		above the vPortFree() calls.  The call is also used by ports/demos that
3891:Source/tasks.c **** 		want to allocate and clean RAM statically. */
3892:Source/tasks.c **** 		portCLEAN_UP_TCB( pxTCB );
3893:Source/tasks.c **** 
3894:Source/tasks.c **** 		/* Free up the memory allocated by the scheduler for the task.  It is up
3895:Source/tasks.c **** 		to the task to free any memory allocated at the application level.
3896:Source/tasks.c **** 		See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html
3897:Source/tasks.c **** 		for additional information. */
3898:Source/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
3899:Source/tasks.c **** 		{
3900:Source/tasks.c **** 			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
3901:Source/tasks.c **** 		}
3902:Source/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
3903:Source/tasks.c **** 
3904:Source/tasks.c **** 		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( p
3905:Source/tasks.c **** 		{
3906:Source/tasks.c **** 			/* The task can only have been allocated dynamically - free both
3907:Source/tasks.c **** 			the stack and TCB. */
3908:Source/tasks.c **** 			vPortFree( pxTCB->pxStack );
 3784              		.loc 1 3908 0
 3785 0008 7B68     		ldr	r3, [r7, #4]
 3786 000a 1B6B     		ldr	r3, [r3, #48]
 3787 000c 1846     		mov	r0, r3
 3788 000e FFF7FEFF 		bl	vPortFree
3909:Source/tasks.c **** 			vPortFree( pxTCB );
 3789              		.loc 1 3909 0
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 141
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 141
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 3790 0012 7868     		ldr	r0, [r7, #4]
 3791 0014 FFF7FEFF 		bl	vPortFree
3910:Source/tasks.c **** 		}
3911:Source/tasks.c **** 		#elif( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consol
3912:Source/tasks.c **** 		{
3913:Source/tasks.c **** 			/* The task could have been allocated statically or dynamically, so
3914:Source/tasks.c **** 			check what was statically allocated before trying to free the
3915:Source/tasks.c **** 			memory. */
3916:Source/tasks.c **** 			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
3917:Source/tasks.c **** 			{
3918:Source/tasks.c **** 				/* Both the stack and TCB were allocated dynamically, so both
3919:Source/tasks.c **** 				must be freed. */
3920:Source/tasks.c **** 				vPortFree( pxTCB->pxStack );
3921:Source/tasks.c **** 				vPortFree( pxTCB );
3922:Source/tasks.c **** 			}
3923:Source/tasks.c **** 			else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
3924:Source/tasks.c **** 			{
3925:Source/tasks.c **** 				/* Only the stack was statically allocated, so the TCB is the
3926:Source/tasks.c **** 				only memory that must be freed. */
3927:Source/tasks.c **** 				vPortFree( pxTCB );
3928:Source/tasks.c **** 			}
3929:Source/tasks.c **** 			else
3930:Source/tasks.c **** 			{
3931:Source/tasks.c **** 				/* Neither the stack nor the TCB were allocated dynamically, so
3932:Source/tasks.c **** 				nothing needs to be freed. */
3933:Source/tasks.c **** 				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
3934:Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3935:Source/tasks.c **** 			}
3936:Source/tasks.c **** 		}
3937:Source/tasks.c **** 		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
3938:Source/tasks.c **** 	}
 3792              		.loc 1 3938 0
 3793 0018 00BF     		nop
 3794 001a 0837     		adds	r7, r7, #8
 3795              		.cfi_def_cfa_offset 8
 3796 001c BD46     		mov	sp, r7
 3797              		.cfi_def_cfa_register 13
 3798              		@ sp needed
 3799 001e 80BD     		pop	{r7, pc}
 3800              		.cfi_endproc
 3801              	.LFE106:
 3802              		.size	prvDeleteTCB, .-prvDeleteTCB
 3803              		.section	.text.prvResetNextTaskUnblockTime,"ax",%progbits
 3804              		.align	2
 3805              		.thumb
 3806              		.thumb_func
 3807              		.type	prvResetNextTaskUnblockTime, %function
 3808              	prvResetNextTaskUnblockTime:
 3809              	.LFB107:
3939:Source/tasks.c **** 
3940:Source/tasks.c **** #endif /* INCLUDE_vTaskDelete */
3941:Source/tasks.c **** /*-----------------------------------------------------------*/
3942:Source/tasks.c **** 
3943:Source/tasks.c **** static void prvResetNextTaskUnblockTime( void )
3944:Source/tasks.c **** {
 3810              		.loc 1 3944 0
 3811              		.cfi_startproc
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 142
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 142
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 3812              		@ args = 0, pretend = 0, frame = 8
 3813              		@ frame_needed = 1, uses_anonymous_args = 0
 3814              		@ link register save eliminated.
 3815 0000 80B4     		push	{r7}
 3816              		.cfi_def_cfa_offset 4
 3817              		.cfi_offset 7, -4
 3818 0002 83B0     		sub	sp, sp, #12
 3819              		.cfi_def_cfa_offset 16
 3820 0004 00AF     		add	r7, sp, #0
 3821              		.cfi_def_cfa_register 7
3945:Source/tasks.c **** TCB_t *pxTCB;
3946:Source/tasks.c **** 
3947:Source/tasks.c **** 	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 3822              		.loc 1 3947 0
 3823 0006 0C4B     		ldr	r3, .L262
 3824 0008 1B68     		ldr	r3, [r3]
 3825 000a 1B68     		ldr	r3, [r3]
 3826 000c 002B     		cmp	r3, #0
 3827 000e 04D1     		bne	.L259
3948:Source/tasks.c **** 	{
3949:Source/tasks.c **** 		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
3950:Source/tasks.c **** 		the maximum possible value so it is	extremely unlikely that the
3951:Source/tasks.c **** 		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
3952:Source/tasks.c **** 		there is an item in the delayed list. */
3953:Source/tasks.c **** 		xNextTaskUnblockTime = portMAX_DELAY;
 3828              		.loc 1 3953 0
 3829 0010 0A4B     		ldr	r3, .L262+4
 3830 0012 4FF0FF32 		mov	r2, #-1
 3831 0016 1A60     		str	r2, [r3]
3954:Source/tasks.c **** 	}
3955:Source/tasks.c **** 	else
3956:Source/tasks.c **** 	{
3957:Source/tasks.c **** 		/* The new current delayed list is not empty, get the value of
3958:Source/tasks.c **** 		the item at the head of the delayed list.  This is the time at
3959:Source/tasks.c **** 		which the task at the head of the delayed list should be removed
3960:Source/tasks.c **** 		from the Blocked state. */
3961:Source/tasks.c **** 		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as thi
3962:Source/tasks.c **** 		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
3963:Source/tasks.c **** 	}
3964:Source/tasks.c **** }
 3832              		.loc 1 3964 0
 3833 0018 08E0     		b	.L261
 3834              	.L259:
3961:Source/tasks.c **** 		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 3835              		.loc 1 3961 0
 3836 001a 074B     		ldr	r3, .L262
 3837 001c 1B68     		ldr	r3, [r3]
 3838 001e DB68     		ldr	r3, [r3, #12]
 3839 0020 DB68     		ldr	r3, [r3, #12]
 3840 0022 7B60     		str	r3, [r7, #4]
3962:Source/tasks.c **** 	}
 3841              		.loc 1 3962 0
 3842 0024 7B68     		ldr	r3, [r7, #4]
 3843 0026 5B68     		ldr	r3, [r3, #4]
 3844 0028 044A     		ldr	r2, .L262+4
 3845 002a 1360     		str	r3, [r2]
 3846              	.L261:
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 143
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 143
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 3847              		.loc 1 3964 0
 3848 002c 00BF     		nop
 3849 002e 0C37     		adds	r7, r7, #12
 3850              		.cfi_def_cfa_offset 4
 3851 0030 BD46     		mov	sp, r7
 3852              		.cfi_def_cfa_register 13
 3853              		@ sp needed
 3854 0032 80BC     		pop	{r7}
 3855              		.cfi_restore 7
 3856              		.cfi_def_cfa_offset 0
 3857 0034 7047     		bx	lr
 3858              	.L263:
 3859 0036 00BF     		.align	2
 3860              	.L262:
 3861 0038 90000000 		.word	pxDelayedTaskList
 3862 003c F8000000 		.word	xNextTaskUnblockTime
 3863              		.cfi_endproc
 3864              	.LFE107:
 3865              		.size	prvResetNextTaskUnblockTime, .-prvResetNextTaskUnblockTime
 3866              		.section	.text.xTaskGetCurrentTaskHandle,"ax",%progbits
 3867              		.align	2
 3868              		.global	xTaskGetCurrentTaskHandle
 3869              		.thumb
 3870              		.thumb_func
 3871              		.type	xTaskGetCurrentTaskHandle, %function
 3872              	xTaskGetCurrentTaskHandle:
 3873              	.LFB108:
3965:Source/tasks.c **** /*-----------------------------------------------------------*/
3966:Source/tasks.c **** 
3967:Source/tasks.c **** #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
3968:Source/tasks.c **** 
3969:Source/tasks.c **** 	TaskHandle_t xTaskGetCurrentTaskHandle( void )
3970:Source/tasks.c **** 	{
 3874              		.loc 1 3970 0
 3875              		.cfi_startproc
 3876              		@ args = 0, pretend = 0, frame = 8
 3877              		@ frame_needed = 1, uses_anonymous_args = 0
 3878              		@ link register save eliminated.
 3879 0000 80B4     		push	{r7}
 3880              		.cfi_def_cfa_offset 4
 3881              		.cfi_offset 7, -4
 3882 0002 83B0     		sub	sp, sp, #12
 3883              		.cfi_def_cfa_offset 16
 3884 0004 00AF     		add	r7, sp, #0
 3885              		.cfi_def_cfa_register 7
3971:Source/tasks.c **** 	TaskHandle_t xReturn;
3972:Source/tasks.c **** 
3973:Source/tasks.c **** 		/* A critical section is not required as this is not called from
3974:Source/tasks.c **** 		an interrupt and the current TCB will always be the same for any
3975:Source/tasks.c **** 		individual execution thread. */
3976:Source/tasks.c **** 		xReturn = pxCurrentTCB;
 3886              		.loc 1 3976 0
 3887 0006 044B     		ldr	r3, .L266
 3888 0008 1B68     		ldr	r3, [r3]
 3889 000a 7B60     		str	r3, [r7, #4]
3977:Source/tasks.c **** 
3978:Source/tasks.c **** 		return xReturn;
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 144
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 144
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 3890              		.loc 1 3978 0
 3891 000c 7B68     		ldr	r3, [r7, #4]
3979:Source/tasks.c **** 	}
 3892              		.loc 1 3979 0
 3893 000e 1846     		mov	r0, r3
 3894 0010 0C37     		adds	r7, r7, #12
 3895              		.cfi_def_cfa_offset 4
 3896 0012 BD46     		mov	sp, r7
 3897              		.cfi_def_cfa_register 13
 3898              		@ sp needed
 3899 0014 80BC     		pop	{r7}
 3900              		.cfi_restore 7
 3901              		.cfi_def_cfa_offset 0
 3902 0016 7047     		bx	lr
 3903              	.L267:
 3904              		.align	2
 3905              	.L266:
 3906 0018 00000000 		.word	pxCurrentTCB
 3907              		.cfi_endproc
 3908              	.LFE108:
 3909              		.size	xTaskGetCurrentTaskHandle, .-xTaskGetCurrentTaskHandle
 3910              		.section	.text.xTaskPriorityInherit,"ax",%progbits
 3911              		.align	2
 3912              		.global	xTaskPriorityInherit
 3913              		.thumb
 3914              		.thumb_func
 3915              		.type	xTaskPriorityInherit, %function
 3916              	xTaskPriorityInherit:
 3917              	.LFB109:
3980:Source/tasks.c **** 
3981:Source/tasks.c **** #endif /* ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) ) */
3982:Source/tasks.c **** /*-----------------------------------------------------------*/
3983:Source/tasks.c **** 
3984:Source/tasks.c **** #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
3985:Source/tasks.c **** 
3986:Source/tasks.c **** 	BaseType_t xTaskGetSchedulerState( void )
3987:Source/tasks.c **** 	{
3988:Source/tasks.c **** 	BaseType_t xReturn;
3989:Source/tasks.c **** 
3990:Source/tasks.c **** 		if( xSchedulerRunning == pdFALSE )
3991:Source/tasks.c **** 		{
3992:Source/tasks.c **** 			xReturn = taskSCHEDULER_NOT_STARTED;
3993:Source/tasks.c **** 		}
3994:Source/tasks.c **** 		else
3995:Source/tasks.c **** 		{
3996:Source/tasks.c **** 			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
3997:Source/tasks.c **** 			{
3998:Source/tasks.c **** 				xReturn = taskSCHEDULER_RUNNING;
3999:Source/tasks.c **** 			}
4000:Source/tasks.c **** 			else
4001:Source/tasks.c **** 			{
4002:Source/tasks.c **** 				xReturn = taskSCHEDULER_SUSPENDED;
4003:Source/tasks.c **** 			}
4004:Source/tasks.c **** 		}
4005:Source/tasks.c **** 
4006:Source/tasks.c **** 		return xReturn;
4007:Source/tasks.c **** 	}
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 145
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 145
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


4008:Source/tasks.c **** 
4009:Source/tasks.c **** #endif /* ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) ) */
4010:Source/tasks.c **** /*-----------------------------------------------------------*/
4011:Source/tasks.c **** 
4012:Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
4013:Source/tasks.c **** 
4014:Source/tasks.c **** 	BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
4015:Source/tasks.c **** 	{
 3918              		.loc 1 4015 0
 3919              		.cfi_startproc
 3920              		@ args = 0, pretend = 0, frame = 16
 3921              		@ frame_needed = 1, uses_anonymous_args = 0
 3922 0000 80B5     		push	{r7, lr}
 3923              		.cfi_def_cfa_offset 8
 3924              		.cfi_offset 7, -8
 3925              		.cfi_offset 14, -4
 3926 0002 84B0     		sub	sp, sp, #16
 3927              		.cfi_def_cfa_offset 24
 3928 0004 00AF     		add	r7, sp, #0
 3929              		.cfi_def_cfa_register 7
 3930 0006 7860     		str	r0, [r7, #4]
4016:Source/tasks.c **** 	TCB_t * const pxMutexHolderTCB = pxMutexHolder;
 3931              		.loc 1 4016 0
 3932 0008 7B68     		ldr	r3, [r7, #4]
 3933 000a BB60     		str	r3, [r7, #8]
4017:Source/tasks.c **** 	BaseType_t xReturn = pdFALSE;
 3934              		.loc 1 4017 0
 3935 000c 0023     		movs	r3, #0
 3936 000e FB60     		str	r3, [r7, #12]
4018:Source/tasks.c **** 
4019:Source/tasks.c **** 		/* If the mutex was given back by an interrupt while the queue was
4020:Source/tasks.c **** 		locked then the mutex holder might now be NULL.  _RB_ Is this still
4021:Source/tasks.c **** 		needed as interrupts can no longer use mutexes? */
4022:Source/tasks.c **** 		if( pxMutexHolder != NULL )
 3937              		.loc 1 4022 0
 3938 0010 7B68     		ldr	r3, [r7, #4]
 3939 0012 002B     		cmp	r3, #0
 3940 0014 5ED0     		beq	.L269
4023:Source/tasks.c **** 		{
4024:Source/tasks.c **** 			/* If the holder of the mutex has a priority below the priority of
4025:Source/tasks.c **** 			the task attempting to obtain the mutex then it will temporarily
4026:Source/tasks.c **** 			inherit the priority of the task attempting to obtain the mutex. */
4027:Source/tasks.c **** 			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
 3941              		.loc 1 4027 0
 3942 0016 BB68     		ldr	r3, [r7, #8]
 3943 0018 DA6A     		ldr	r2, [r3, #44]
 3944 001a 314B     		ldr	r3, .L276
 3945 001c 1B68     		ldr	r3, [r3]
 3946 001e DB6A     		ldr	r3, [r3, #44]
 3947 0020 9A42     		cmp	r2, r3
 3948 0022 4ED2     		bcs	.L270
4028:Source/tasks.c **** 			{
4029:Source/tasks.c **** 				/* Adjust the mutex holder state to account for its new
4030:Source/tasks.c **** 				priority.  Only reset the event list item value if the value is
4031:Source/tasks.c **** 				not being used for anything else. */
4032:Source/tasks.c **** 				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VA
 3949              		.loc 1 4032 0
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 146
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 146
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 3950 0024 BB68     		ldr	r3, [r7, #8]
 3951 0026 9B69     		ldr	r3, [r3, #24]
 3952 0028 002B     		cmp	r3, #0
 3953 002a 06DB     		blt	.L271
4033:Source/tasks.c **** 				{
4034:Source/tasks.c **** 					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIOR
 3954              		.loc 1 4034 0
 3955 002c 2C4B     		ldr	r3, .L276
 3956 002e 1B68     		ldr	r3, [r3]
 3957 0030 DB6A     		ldr	r3, [r3, #44]
 3958 0032 C3F10502 		rsb	r2, r3, #5
 3959 0036 BB68     		ldr	r3, [r7, #8]
 3960 0038 9A61     		str	r2, [r3, #24]
 3961              	.L271:
4035:Source/tasks.c **** 				}
4036:Source/tasks.c **** 				else
4037:Source/tasks.c **** 				{
4038:Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4039:Source/tasks.c **** 				}
4040:Source/tasks.c **** 
4041:Source/tasks.c **** 				/* If the task being modified is in the ready state it will need
4042:Source/tasks.c **** 				to be moved into a new list. */
4043:Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutex
 3962              		.loc 1 4043 0
 3963 003a BB68     		ldr	r3, [r7, #8]
 3964 003c 5969     		ldr	r1, [r3, #20]
 3965 003e BB68     		ldr	r3, [r7, #8]
 3966 0040 DA6A     		ldr	r2, [r3, #44]
 3967 0042 1346     		mov	r3, r2
 3968 0044 9B00     		lsls	r3, r3, #2
 3969 0046 1344     		add	r3, r3, r2
 3970 0048 9B00     		lsls	r3, r3, #2
 3971 004a 264A     		ldr	r2, .L276+4
 3972 004c 1344     		add	r3, r3, r2
 3973 004e 9942     		cmp	r1, r3
 3974 0050 2FD1     		bne	.L272
4044:Source/tasks.c **** 				{
4045:Source/tasks.c **** 					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 3975              		.loc 1 4045 0
 3976 0052 BB68     		ldr	r3, [r7, #8]
 3977 0054 0433     		adds	r3, r3, #4
 3978 0056 1846     		mov	r0, r3
 3979 0058 FFF7FEFF 		bl	uxListRemove
 3980 005c 0346     		mov	r3, r0
 3981 005e 002B     		cmp	r3, #0
 3982 0060 0AD1     		bne	.L273
4046:Source/tasks.c **** 					{
4047:Source/tasks.c **** 						/* It is known that the task is in its ready list so
4048:Source/tasks.c **** 						there is no need to check again and the port level
4049:Source/tasks.c **** 						reset macro can be called directly. */
4050:Source/tasks.c **** 						portRESET_READY_PRIORITY( pxMutexHolderTCB->uxPriority, uxTopReadyPriority );
 3983              		.loc 1 4050 0
 3984 0062 BB68     		ldr	r3, [r7, #8]
 3985 0064 DB6A     		ldr	r3, [r3, #44]
 3986 0066 0122     		movs	r2, #1
 3987 0068 02FA03F3 		lsl	r3, r2, r3
 3988 006c DA43     		mvns	r2, r3
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 147
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 147
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 3989 006e 1E4B     		ldr	r3, .L276+8
 3990 0070 1B68     		ldr	r3, [r3]
 3991 0072 1340     		ands	r3, r3, r2
 3992 0074 1C4A     		ldr	r2, .L276+8
 3993 0076 1360     		str	r3, [r2]
 3994              	.L273:
4051:Source/tasks.c **** 					}
4052:Source/tasks.c **** 					else
4053:Source/tasks.c **** 					{
4054:Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
4055:Source/tasks.c **** 					}
4056:Source/tasks.c **** 
4057:Source/tasks.c **** 					/* Inherit the priority before being moved into the new list. */
4058:Source/tasks.c **** 					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 3995              		.loc 1 4058 0
 3996 0078 194B     		ldr	r3, .L276
 3997 007a 1B68     		ldr	r3, [r3]
 3998 007c DA6A     		ldr	r2, [r3, #44]
 3999 007e BB68     		ldr	r3, [r7, #8]
 4000 0080 DA62     		str	r2, [r3, #44]
4059:Source/tasks.c **** 					prvAddTaskToReadyList( pxMutexHolderTCB );
 4001              		.loc 1 4059 0
 4002 0082 BB68     		ldr	r3, [r7, #8]
 4003 0084 DB6A     		ldr	r3, [r3, #44]
 4004 0086 0122     		movs	r2, #1
 4005 0088 9A40     		lsls	r2, r2, r3
 4006 008a 174B     		ldr	r3, .L276+8
 4007 008c 1B68     		ldr	r3, [r3]
 4008 008e 1343     		orrs	r3, r3, r2
 4009 0090 154A     		ldr	r2, .L276+8
 4010 0092 1360     		str	r3, [r2]
 4011 0094 BB68     		ldr	r3, [r7, #8]
 4012 0096 DA6A     		ldr	r2, [r3, #44]
 4013 0098 1346     		mov	r3, r2
 4014 009a 9B00     		lsls	r3, r3, #2
 4015 009c 1344     		add	r3, r3, r2
 4016 009e 9B00     		lsls	r3, r3, #2
 4017 00a0 104A     		ldr	r2, .L276+4
 4018 00a2 1A44     		add	r2, r2, r3
 4019 00a4 BB68     		ldr	r3, [r7, #8]
 4020 00a6 0433     		adds	r3, r3, #4
 4021 00a8 1946     		mov	r1, r3
 4022 00aa 1046     		mov	r0, r2
 4023 00ac FFF7FEFF 		bl	vListInsertEnd
 4024 00b0 04E0     		b	.L274
 4025              	.L272:
4060:Source/tasks.c **** 				}
4061:Source/tasks.c **** 				else
4062:Source/tasks.c **** 				{
4063:Source/tasks.c **** 					/* Just inherit the priority. */
4064:Source/tasks.c **** 					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 4026              		.loc 1 4064 0
 4027 00b2 0B4B     		ldr	r3, .L276
 4028 00b4 1B68     		ldr	r3, [r3]
 4029 00b6 DA6A     		ldr	r2, [r3, #44]
 4030 00b8 BB68     		ldr	r3, [r7, #8]
 4031 00ba DA62     		str	r2, [r3, #44]
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 148
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 148
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 4032              	.L274:
4065:Source/tasks.c **** 				}
4066:Source/tasks.c **** 
4067:Source/tasks.c **** 				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );
4068:Source/tasks.c **** 
4069:Source/tasks.c **** 				/* Inheritance occurred. */
4070:Source/tasks.c **** 				xReturn = pdTRUE;
 4033              		.loc 1 4070 0
 4034 00bc 0123     		movs	r3, #1
 4035 00be FB60     		str	r3, [r7, #12]
 4036 00c0 08E0     		b	.L269
 4037              	.L270:
4071:Source/tasks.c **** 			}
4072:Source/tasks.c **** 			else
4073:Source/tasks.c **** 			{
4074:Source/tasks.c **** 				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
 4038              		.loc 1 4074 0
 4039 00c2 BB68     		ldr	r3, [r7, #8]
 4040 00c4 1A6C     		ldr	r2, [r3, #64]
 4041 00c6 064B     		ldr	r3, .L276
 4042 00c8 1B68     		ldr	r3, [r3]
 4043 00ca DB6A     		ldr	r3, [r3, #44]
 4044 00cc 9A42     		cmp	r2, r3
 4045 00ce 01D2     		bcs	.L269
4075:Source/tasks.c **** 				{
4076:Source/tasks.c **** 					/* The base priority of the mutex holder is lower than the
4077:Source/tasks.c **** 					priority of the task attempting to take the mutex, but the
4078:Source/tasks.c **** 					current priority of the mutex holder is not lower than the
4079:Source/tasks.c **** 					priority of the task attempting to take the mutex.
4080:Source/tasks.c **** 					Therefore the mutex holder must have already inherited a
4081:Source/tasks.c **** 					priority, but inheritance would have occurred if that had
4082:Source/tasks.c **** 					not been the case. */
4083:Source/tasks.c **** 					xReturn = pdTRUE;
 4046              		.loc 1 4083 0
 4047 00d0 0123     		movs	r3, #1
 4048 00d2 FB60     		str	r3, [r7, #12]
 4049              	.L269:
4084:Source/tasks.c **** 				}
4085:Source/tasks.c **** 				else
4086:Source/tasks.c **** 				{
4087:Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4088:Source/tasks.c **** 				}
4089:Source/tasks.c **** 			}
4090:Source/tasks.c **** 		}
4091:Source/tasks.c **** 		else
4092:Source/tasks.c **** 		{
4093:Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4094:Source/tasks.c **** 		}
4095:Source/tasks.c **** 
4096:Source/tasks.c **** 		return xReturn;
 4050              		.loc 1 4096 0
 4051 00d4 FB68     		ldr	r3, [r7, #12]
4097:Source/tasks.c **** 	}
 4052              		.loc 1 4097 0
 4053 00d6 1846     		mov	r0, r3
 4054 00d8 1037     		adds	r7, r7, #16
 4055              		.cfi_def_cfa_offset 8
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 149
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 149
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 4056 00da BD46     		mov	sp, r7
 4057              		.cfi_def_cfa_register 13
 4058              		@ sp needed
 4059 00dc 80BD     		pop	{r7, pc}
 4060              	.L277:
 4061 00de 00BF     		.align	2
 4062              	.L276:
 4063 00e0 00000000 		.word	pxCurrentTCB
 4064 00e4 04000000 		.word	pxReadyTasksLists
 4065 00e8 E0000000 		.word	uxTopReadyPriority
 4066              		.cfi_endproc
 4067              	.LFE109:
 4068              		.size	xTaskPriorityInherit, .-xTaskPriorityInherit
 4069              		.section	.text.xTaskPriorityDisinherit,"ax",%progbits
 4070              		.align	2
 4071              		.global	xTaskPriorityDisinherit
 4072              		.thumb
 4073              		.thumb_func
 4074              		.type	xTaskPriorityDisinherit, %function
 4075              	xTaskPriorityDisinherit:
 4076              	.LFB110:
4098:Source/tasks.c **** 
4099:Source/tasks.c **** #endif /* configUSE_MUTEXES */
4100:Source/tasks.c **** /*-----------------------------------------------------------*/
4101:Source/tasks.c **** 
4102:Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
4103:Source/tasks.c **** 
4104:Source/tasks.c **** 	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
4105:Source/tasks.c **** 	{
 4077              		.loc 1 4105 0
 4078              		.cfi_startproc
 4079              		@ args = 0, pretend = 0, frame = 16
 4080              		@ frame_needed = 1, uses_anonymous_args = 0
 4081 0000 80B5     		push	{r7, lr}
 4082              		.cfi_def_cfa_offset 8
 4083              		.cfi_offset 7, -8
 4084              		.cfi_offset 14, -4
 4085 0002 84B0     		sub	sp, sp, #16
 4086              		.cfi_def_cfa_offset 24
 4087 0004 00AF     		add	r7, sp, #0
 4088              		.cfi_def_cfa_register 7
 4089 0006 7860     		str	r0, [r7, #4]
4106:Source/tasks.c **** 	TCB_t * const pxTCB = pxMutexHolder;
 4090              		.loc 1 4106 0
 4091 0008 7B68     		ldr	r3, [r7, #4]
 4092 000a BB60     		str	r3, [r7, #8]
4107:Source/tasks.c **** 	BaseType_t xReturn = pdFALSE;
 4093              		.loc 1 4107 0
 4094 000c 0023     		movs	r3, #0
 4095 000e FB60     		str	r3, [r7, #12]
4108:Source/tasks.c **** 
4109:Source/tasks.c **** 		if( pxMutexHolder != NULL )
 4096              		.loc 1 4109 0
 4097 0010 7B68     		ldr	r3, [r7, #4]
 4098 0012 002B     		cmp	r3, #0
 4099 0014 4FD0     		beq	.L279
4110:Source/tasks.c **** 		{
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 150
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 150
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


4111:Source/tasks.c **** 			/* A task can only have an inherited priority if it holds the mutex.
4112:Source/tasks.c **** 			If the mutex is held by a task then it cannot be given from an
4113:Source/tasks.c **** 			interrupt, and if a mutex is given by the holding task then it must
4114:Source/tasks.c **** 			be the running state task. */
4115:Source/tasks.c **** 			configASSERT( pxTCB == pxCurrentTCB );
4116:Source/tasks.c **** 			configASSERT( pxTCB->uxMutexesHeld );
4117:Source/tasks.c **** 			( pxTCB->uxMutexesHeld )--;
 4100              		.loc 1 4117 0
 4101 0016 BB68     		ldr	r3, [r7, #8]
 4102 0018 5B6C     		ldr	r3, [r3, #68]
 4103 001a 5A1E     		subs	r2, r3, #1
 4104 001c BB68     		ldr	r3, [r7, #8]
 4105 001e 5A64     		str	r2, [r3, #68]
4118:Source/tasks.c **** 
4119:Source/tasks.c **** 			/* Has the holder of the mutex inherited the priority of another
4120:Source/tasks.c **** 			task? */
4121:Source/tasks.c **** 			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 4106              		.loc 1 4121 0
 4107 0020 BB68     		ldr	r3, [r7, #8]
 4108 0022 DA6A     		ldr	r2, [r3, #44]
 4109 0024 BB68     		ldr	r3, [r7, #8]
 4110 0026 1B6C     		ldr	r3, [r3, #64]
 4111 0028 9A42     		cmp	r2, r3
 4112 002a 44D0     		beq	.L279
4122:Source/tasks.c **** 			{
4123:Source/tasks.c **** 				/* Only disinherit if no other mutexes are held. */
4124:Source/tasks.c **** 				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 4113              		.loc 1 4124 0
 4114 002c BB68     		ldr	r3, [r7, #8]
 4115 002e 5B6C     		ldr	r3, [r3, #68]
 4116 0030 002B     		cmp	r3, #0
 4117 0032 40D1     		bne	.L279
4125:Source/tasks.c **** 				{
4126:Source/tasks.c **** 					/* A task can only have an inherited priority if it holds
4127:Source/tasks.c **** 					the mutex.  If the mutex is held by a task then it cannot be
4128:Source/tasks.c **** 					given from an interrupt, and if a mutex is given by the
4129:Source/tasks.c **** 					holding task then it must be the running state task.  Remove
4130:Source/tasks.c **** 					the holding task from the ready/delayed list. */
4131:Source/tasks.c **** 					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 4118              		.loc 1 4131 0
 4119 0034 BB68     		ldr	r3, [r7, #8]
 4120 0036 0433     		adds	r3, r3, #4
 4121 0038 1846     		mov	r0, r3
 4122 003a FFF7FEFF 		bl	uxListRemove
 4123 003e 0346     		mov	r3, r0
 4124 0040 002B     		cmp	r3, #0
 4125 0042 15D1     		bne	.L280
4132:Source/tasks.c **** 					{
4133:Source/tasks.c **** 						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 4126              		.loc 1 4133 0
 4127 0044 BB68     		ldr	r3, [r7, #8]
 4128 0046 DA6A     		ldr	r2, [r3, #44]
 4129 0048 1D49     		ldr	r1, .L283
 4130 004a 1346     		mov	r3, r2
 4131 004c 9B00     		lsls	r3, r3, #2
 4132 004e 1344     		add	r3, r3, r2
 4133 0050 9B00     		lsls	r3, r3, #2
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 151
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 151
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 4134 0052 0B44     		add	r3, r3, r1
 4135 0054 1B68     		ldr	r3, [r3]
 4136 0056 002B     		cmp	r3, #0
 4137 0058 0AD1     		bne	.L280
 4138              		.loc 1 4133 0 is_stmt 0 discriminator 1
 4139 005a BB68     		ldr	r3, [r7, #8]
 4140 005c DB6A     		ldr	r3, [r3, #44]
 4141 005e 0122     		movs	r2, #1
 4142 0060 02FA03F3 		lsl	r3, r2, r3
 4143 0064 DA43     		mvns	r2, r3
 4144 0066 174B     		ldr	r3, .L283+4
 4145 0068 1B68     		ldr	r3, [r3]
 4146 006a 1340     		ands	r3, r3, r2
 4147 006c 154A     		ldr	r2, .L283+4
 4148 006e 1360     		str	r3, [r2]
 4149              	.L280:
4134:Source/tasks.c **** 					}
4135:Source/tasks.c **** 					else
4136:Source/tasks.c **** 					{
4137:Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
4138:Source/tasks.c **** 					}
4139:Source/tasks.c **** 
4140:Source/tasks.c **** 					/* Disinherit the priority before adding the task into the
4141:Source/tasks.c **** 					new	ready list. */
4142:Source/tasks.c **** 					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
4143:Source/tasks.c **** 					pxTCB->uxPriority = pxTCB->uxBasePriority;
 4150              		.loc 1 4143 0 is_stmt 1
 4151 0070 BB68     		ldr	r3, [r7, #8]
 4152 0072 1A6C     		ldr	r2, [r3, #64]
 4153 0074 BB68     		ldr	r3, [r7, #8]
 4154 0076 DA62     		str	r2, [r3, #44]
4144:Source/tasks.c **** 
4145:Source/tasks.c **** 					/* Reset the event list item value.  It cannot be in use for
4146:Source/tasks.c **** 					any other purpose if this task is running, and it must be
4147:Source/tasks.c **** 					running to give back the mutex. */
4148:Source/tasks.c **** 					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( T
 4155              		.loc 1 4148 0
 4156 0078 BB68     		ldr	r3, [r7, #8]
 4157 007a DB6A     		ldr	r3, [r3, #44]
 4158 007c C3F10502 		rsb	r2, r3, #5
 4159 0080 BB68     		ldr	r3, [r7, #8]
 4160 0082 9A61     		str	r2, [r3, #24]
4149:Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 4161              		.loc 1 4149 0
 4162 0084 BB68     		ldr	r3, [r7, #8]
 4163 0086 DB6A     		ldr	r3, [r3, #44]
 4164 0088 0122     		movs	r2, #1
 4165 008a 9A40     		lsls	r2, r2, r3
 4166 008c 0D4B     		ldr	r3, .L283+4
 4167 008e 1B68     		ldr	r3, [r3]
 4168 0090 1343     		orrs	r3, r3, r2
 4169 0092 0C4A     		ldr	r2, .L283+4
 4170 0094 1360     		str	r3, [r2]
 4171 0096 BB68     		ldr	r3, [r7, #8]
 4172 0098 DA6A     		ldr	r2, [r3, #44]
 4173 009a 1346     		mov	r3, r2
 4174 009c 9B00     		lsls	r3, r3, #2
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 152
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 152
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 4175 009e 1344     		add	r3, r3, r2
 4176 00a0 9B00     		lsls	r3, r3, #2
 4177 00a2 074A     		ldr	r2, .L283
 4178 00a4 1A44     		add	r2, r2, r3
 4179 00a6 BB68     		ldr	r3, [r7, #8]
 4180 00a8 0433     		adds	r3, r3, #4
 4181 00aa 1946     		mov	r1, r3
 4182 00ac 1046     		mov	r0, r2
 4183 00ae FFF7FEFF 		bl	vListInsertEnd
4150:Source/tasks.c **** 
4151:Source/tasks.c **** 					/* Return true to indicate that a context switch is required.
4152:Source/tasks.c **** 					This is only actually required in the corner case whereby
4153:Source/tasks.c **** 					multiple mutexes were held and the mutexes were given back
4154:Source/tasks.c **** 					in an order different to that in which they were taken.
4155:Source/tasks.c **** 					If a context switch did not occur when the first mutex was
4156:Source/tasks.c **** 					returned, even if a task was waiting on it, then a context
4157:Source/tasks.c **** 					switch should occur when the last mutex is returned whether
4158:Source/tasks.c **** 					a task is waiting on it or not. */
4159:Source/tasks.c **** 					xReturn = pdTRUE;
 4184              		.loc 1 4159 0
 4185 00b2 0123     		movs	r3, #1
 4186 00b4 FB60     		str	r3, [r7, #12]
 4187              	.L279:
4160:Source/tasks.c **** 				}
4161:Source/tasks.c **** 				else
4162:Source/tasks.c **** 				{
4163:Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4164:Source/tasks.c **** 				}
4165:Source/tasks.c **** 			}
4166:Source/tasks.c **** 			else
4167:Source/tasks.c **** 			{
4168:Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4169:Source/tasks.c **** 			}
4170:Source/tasks.c **** 		}
4171:Source/tasks.c **** 		else
4172:Source/tasks.c **** 		{
4173:Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4174:Source/tasks.c **** 		}
4175:Source/tasks.c **** 
4176:Source/tasks.c **** 		return xReturn;
 4188              		.loc 1 4176 0
 4189 00b6 FB68     		ldr	r3, [r7, #12]
4177:Source/tasks.c **** 	}
 4190              		.loc 1 4177 0
 4191 00b8 1846     		mov	r0, r3
 4192 00ba 1037     		adds	r7, r7, #16
 4193              		.cfi_def_cfa_offset 8
 4194 00bc BD46     		mov	sp, r7
 4195              		.cfi_def_cfa_register 13
 4196              		@ sp needed
 4197 00be 80BD     		pop	{r7, pc}
 4198              	.L284:
 4199              		.align	2
 4200              	.L283:
 4201 00c0 04000000 		.word	pxReadyTasksLists
 4202 00c4 E0000000 		.word	uxTopReadyPriority
 4203              		.cfi_endproc
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 153
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 153
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 4204              	.LFE110:
 4205              		.size	xTaskPriorityDisinherit, .-xTaskPriorityDisinherit
 4206              		.section	.text.vTaskPriorityDisinheritAfterTimeout,"ax",%progbits
 4207              		.align	2
 4208              		.global	vTaskPriorityDisinheritAfterTimeout
 4209              		.thumb
 4210              		.thumb_func
 4211              		.type	vTaskPriorityDisinheritAfterTimeout, %function
 4212              	vTaskPriorityDisinheritAfterTimeout:
 4213              	.LFB111:
4178:Source/tasks.c **** 
4179:Source/tasks.c **** #endif /* configUSE_MUTEXES */
4180:Source/tasks.c **** /*-----------------------------------------------------------*/
4181:Source/tasks.c **** 
4182:Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
4183:Source/tasks.c **** 
4184:Source/tasks.c **** 	void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestP
4185:Source/tasks.c **** 	{
 4214              		.loc 1 4185 0
 4215              		.cfi_startproc
 4216              		@ args = 0, pretend = 0, frame = 24
 4217              		@ frame_needed = 1, uses_anonymous_args = 0
 4218 0000 80B5     		push	{r7, lr}
 4219              		.cfi_def_cfa_offset 8
 4220              		.cfi_offset 7, -8
 4221              		.cfi_offset 14, -4
 4222 0002 86B0     		sub	sp, sp, #24
 4223              		.cfi_def_cfa_offset 32
 4224 0004 00AF     		add	r7, sp, #0
 4225              		.cfi_def_cfa_register 7
 4226 0006 7860     		str	r0, [r7, #4]
 4227 0008 3960     		str	r1, [r7]
4186:Source/tasks.c **** 	TCB_t * const pxTCB = pxMutexHolder;
 4228              		.loc 1 4186 0
 4229 000a 7B68     		ldr	r3, [r7, #4]
 4230 000c 3B61     		str	r3, [r7, #16]
4187:Source/tasks.c **** 	UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
4188:Source/tasks.c **** 	const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
 4231              		.loc 1 4188 0
 4232 000e 0123     		movs	r3, #1
 4233 0010 FB60     		str	r3, [r7, #12]
4189:Source/tasks.c **** 
4190:Source/tasks.c **** 		if( pxMutexHolder != NULL )
 4234              		.loc 1 4190 0
 4235 0012 7B68     		ldr	r3, [r7, #4]
 4236 0014 002B     		cmp	r3, #0
 4237 0016 58D0     		beq	.L291
4191:Source/tasks.c **** 		{
4192:Source/tasks.c **** 			/* If pxMutexHolder is not NULL then the holder must hold at least
4193:Source/tasks.c **** 			one mutex. */
4194:Source/tasks.c **** 			configASSERT( pxTCB->uxMutexesHeld );
4195:Source/tasks.c **** 
4196:Source/tasks.c **** 			/* Determine the priority to which the priority of the task that
4197:Source/tasks.c **** 			holds the mutex should be set.  This will be the greater of the
4198:Source/tasks.c **** 			holding task's base priority and the priority of the highest
4199:Source/tasks.c **** 			priority task that is waiting to obtain the mutex. */
4200:Source/tasks.c **** 			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 154
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 154
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 4238              		.loc 1 4200 0
 4239 0018 3B69     		ldr	r3, [r7, #16]
 4240 001a 1A6C     		ldr	r2, [r3, #64]
 4241 001c 3B68     		ldr	r3, [r7]
 4242 001e 9A42     		cmp	r2, r3
 4243 0020 02D2     		bcs	.L287
4201:Source/tasks.c **** 			{
4202:Source/tasks.c **** 				uxPriorityToUse = uxHighestPriorityWaitingTask;
 4244              		.loc 1 4202 0
 4245 0022 3B68     		ldr	r3, [r7]
 4246 0024 7B61     		str	r3, [r7, #20]
 4247 0026 02E0     		b	.L288
 4248              	.L287:
4203:Source/tasks.c **** 			}
4204:Source/tasks.c **** 			else
4205:Source/tasks.c **** 			{
4206:Source/tasks.c **** 				uxPriorityToUse = pxTCB->uxBasePriority;
 4249              		.loc 1 4206 0
 4250 0028 3B69     		ldr	r3, [r7, #16]
 4251 002a 1B6C     		ldr	r3, [r3, #64]
 4252 002c 7B61     		str	r3, [r7, #20]
 4253              	.L288:
4207:Source/tasks.c **** 			}
4208:Source/tasks.c **** 
4209:Source/tasks.c **** 			/* Does the priority need to change? */
4210:Source/tasks.c **** 			if( pxTCB->uxPriority != uxPriorityToUse )
 4254              		.loc 1 4210 0
 4255 002e 3B69     		ldr	r3, [r7, #16]
 4256 0030 DA6A     		ldr	r2, [r3, #44]
 4257 0032 7B69     		ldr	r3, [r7, #20]
 4258 0034 9A42     		cmp	r2, r3
 4259 0036 48D0     		beq	.L291
4211:Source/tasks.c **** 			{
4212:Source/tasks.c **** 				/* Only disinherit if no other mutexes are held.  This is a
4213:Source/tasks.c **** 				simplification in the priority inheritance implementation.  If
4214:Source/tasks.c **** 				the task that holds the mutex is also holding other mutexes then
4215:Source/tasks.c **** 				the other mutexes may have caused the priority inheritance. */
4216:Source/tasks.c **** 				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
 4260              		.loc 1 4216 0
 4261 0038 3B69     		ldr	r3, [r7, #16]
 4262 003a 5A6C     		ldr	r2, [r3, #68]
 4263 003c FB68     		ldr	r3, [r7, #12]
 4264 003e 9A42     		cmp	r2, r3
 4265 0040 43D1     		bne	.L291
4217:Source/tasks.c **** 				{
4218:Source/tasks.c **** 					/* If a task has timed out because it already holds the
4219:Source/tasks.c **** 					mutex it was trying to obtain then it cannot of inherited
4220:Source/tasks.c **** 					its own priority. */
4221:Source/tasks.c **** 					configASSERT( pxTCB != pxCurrentTCB );
4222:Source/tasks.c **** 
4223:Source/tasks.c **** 					/* Disinherit the priority, remembering the previous
4224:Source/tasks.c **** 					priority to facilitate determining the subject task's
4225:Source/tasks.c **** 					state. */
4226:Source/tasks.c **** 					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
4227:Source/tasks.c **** 					uxPriorityUsedOnEntry = pxTCB->uxPriority;
 4266              		.loc 1 4227 0
 4267 0042 3B69     		ldr	r3, [r7, #16]
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 155
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 155
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 4268 0044 DB6A     		ldr	r3, [r3, #44]
 4269 0046 BB60     		str	r3, [r7, #8]
4228:Source/tasks.c **** 					pxTCB->uxPriority = uxPriorityToUse;
 4270              		.loc 1 4228 0
 4271 0048 3B69     		ldr	r3, [r7, #16]
 4272 004a 7A69     		ldr	r2, [r7, #20]
 4273 004c DA62     		str	r2, [r3, #44]
4229:Source/tasks.c **** 
4230:Source/tasks.c **** 					/* Only reset the event list item value if the value is not
4231:Source/tasks.c **** 					being used for anything else. */
4232:Source/tasks.c **** 					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE
 4274              		.loc 1 4232 0
 4275 004e 3B69     		ldr	r3, [r7, #16]
 4276 0050 9B69     		ldr	r3, [r3, #24]
 4277 0052 002B     		cmp	r3, #0
 4278 0054 04DB     		blt	.L289
4233:Source/tasks.c **** 					{
4234:Source/tasks.c **** 						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( 
 4279              		.loc 1 4234 0
 4280 0056 7B69     		ldr	r3, [r7, #20]
 4281 0058 C3F10502 		rsb	r2, r3, #5
 4282 005c 3B69     		ldr	r3, [r7, #16]
 4283 005e 9A61     		str	r2, [r3, #24]
 4284              	.L289:
4235:Source/tasks.c **** 					}
4236:Source/tasks.c **** 					else
4237:Source/tasks.c **** 					{
4238:Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
4239:Source/tasks.c **** 					}
4240:Source/tasks.c **** 
4241:Source/tasks.c **** 					/* If the running task is not the task that holds the mutex
4242:Source/tasks.c **** 					then the task that holds the mutex could be in either the
4243:Source/tasks.c **** 					Ready, Blocked or Suspended states.  Only remove the task
4244:Source/tasks.c **** 					from its current state list if it is in the Ready state as
4245:Source/tasks.c **** 					the task's priority is going to change and there is one
4246:Source/tasks.c **** 					Ready list per priority. */
4247:Source/tasks.c **** 					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xState
 4285              		.loc 1 4247 0
 4286 0060 3B69     		ldr	r3, [r7, #16]
 4287 0062 5969     		ldr	r1, [r3, #20]
 4288 0064 BA68     		ldr	r2, [r7, #8]
 4289 0066 1346     		mov	r3, r2
 4290 0068 9B00     		lsls	r3, r3, #2
 4291 006a 1344     		add	r3, r3, r2
 4292 006c 9B00     		lsls	r3, r3, #2
 4293 006e 194A     		ldr	r2, .L292
 4294 0070 1344     		add	r3, r3, r2
 4295 0072 9942     		cmp	r1, r3
 4296 0074 29D1     		bne	.L291
4248:Source/tasks.c **** 					{
4249:Source/tasks.c **** 						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 4297              		.loc 1 4249 0
 4298 0076 3B69     		ldr	r3, [r7, #16]
 4299 0078 0433     		adds	r3, r3, #4
 4300 007a 1846     		mov	r0, r3
 4301 007c FFF7FEFF 		bl	uxListRemove
 4302 0080 0346     		mov	r3, r0
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 156
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 156
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 4303 0082 002B     		cmp	r3, #0
 4304 0084 0AD1     		bne	.L290
4250:Source/tasks.c **** 						{
4251:Source/tasks.c **** 							/* It is known that the task is in its ready list so
4252:Source/tasks.c **** 							there is no need to check again and the port level
4253:Source/tasks.c **** 							reset macro can be called directly. */
4254:Source/tasks.c **** 							portRESET_READY_PRIORITY( pxTCB->uxPriority, uxTopReadyPriority );
 4305              		.loc 1 4254 0
 4306 0086 3B69     		ldr	r3, [r7, #16]
 4307 0088 DB6A     		ldr	r3, [r3, #44]
 4308 008a 0122     		movs	r2, #1
 4309 008c 02FA03F3 		lsl	r3, r2, r3
 4310 0090 DA43     		mvns	r2, r3
 4311 0092 114B     		ldr	r3, .L292+4
 4312 0094 1B68     		ldr	r3, [r3]
 4313 0096 1340     		ands	r3, r3, r2
 4314 0098 0F4A     		ldr	r2, .L292+4
 4315 009a 1360     		str	r3, [r2]
 4316              	.L290:
4255:Source/tasks.c **** 						}
4256:Source/tasks.c **** 						else
4257:Source/tasks.c **** 						{
4258:Source/tasks.c **** 							mtCOVERAGE_TEST_MARKER();
4259:Source/tasks.c **** 						}
4260:Source/tasks.c **** 
4261:Source/tasks.c **** 						prvAddTaskToReadyList( pxTCB );
 4317              		.loc 1 4261 0
 4318 009c 3B69     		ldr	r3, [r7, #16]
 4319 009e DB6A     		ldr	r3, [r3, #44]
 4320 00a0 0122     		movs	r2, #1
 4321 00a2 9A40     		lsls	r2, r2, r3
 4322 00a4 0C4B     		ldr	r3, .L292+4
 4323 00a6 1B68     		ldr	r3, [r3]
 4324 00a8 1343     		orrs	r3, r3, r2
 4325 00aa 0B4A     		ldr	r2, .L292+4
 4326 00ac 1360     		str	r3, [r2]
 4327 00ae 3B69     		ldr	r3, [r7, #16]
 4328 00b0 DA6A     		ldr	r2, [r3, #44]
 4329 00b2 1346     		mov	r3, r2
 4330 00b4 9B00     		lsls	r3, r3, #2
 4331 00b6 1344     		add	r3, r3, r2
 4332 00b8 9B00     		lsls	r3, r3, #2
 4333 00ba 064A     		ldr	r2, .L292
 4334 00bc 1A44     		add	r2, r2, r3
 4335 00be 3B69     		ldr	r3, [r7, #16]
 4336 00c0 0433     		adds	r3, r3, #4
 4337 00c2 1946     		mov	r1, r3
 4338 00c4 1046     		mov	r0, r2
 4339 00c6 FFF7FEFF 		bl	vListInsertEnd
 4340              	.L291:
4262:Source/tasks.c **** 					}
4263:Source/tasks.c **** 					else
4264:Source/tasks.c **** 					{
4265:Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
4266:Source/tasks.c **** 					}
4267:Source/tasks.c **** 				}
4268:Source/tasks.c **** 				else
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 157
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 157
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


4269:Source/tasks.c **** 				{
4270:Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4271:Source/tasks.c **** 				}
4272:Source/tasks.c **** 			}
4273:Source/tasks.c **** 			else
4274:Source/tasks.c **** 			{
4275:Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4276:Source/tasks.c **** 			}
4277:Source/tasks.c **** 		}
4278:Source/tasks.c **** 		else
4279:Source/tasks.c **** 		{
4280:Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4281:Source/tasks.c **** 		}
4282:Source/tasks.c **** 	}
 4341              		.loc 1 4282 0
 4342 00ca 00BF     		nop
 4343 00cc 1837     		adds	r7, r7, #24
 4344              		.cfi_def_cfa_offset 8
 4345 00ce BD46     		mov	sp, r7
 4346              		.cfi_def_cfa_register 13
 4347              		@ sp needed
 4348 00d0 80BD     		pop	{r7, pc}
 4349              	.L293:
 4350 00d2 00BF     		.align	2
 4351              	.L292:
 4352 00d4 04000000 		.word	pxReadyTasksLists
 4353 00d8 E0000000 		.word	uxTopReadyPriority
 4354              		.cfi_endproc
 4355              	.LFE111:
 4356              		.size	vTaskPriorityDisinheritAfterTimeout, .-vTaskPriorityDisinheritAfterTimeout
 4357              		.section	.text.uxTaskResetEventItemValue,"ax",%progbits
 4358              		.align	2
 4359              		.global	uxTaskResetEventItemValue
 4360              		.thumb
 4361              		.thumb_func
 4362              		.type	uxTaskResetEventItemValue, %function
 4363              	uxTaskResetEventItemValue:
 4364              	.LFB112:
4283:Source/tasks.c **** 
4284:Source/tasks.c **** #endif /* configUSE_MUTEXES */
4285:Source/tasks.c **** /*-----------------------------------------------------------*/
4286:Source/tasks.c **** 
4287:Source/tasks.c **** #if ( portCRITICAL_NESTING_IN_TCB == 1 )
4288:Source/tasks.c **** 
4289:Source/tasks.c **** 	void vTaskEnterCritical( void )
4290:Source/tasks.c **** 	{
4291:Source/tasks.c **** 		portDISABLE_INTERRUPTS();
4292:Source/tasks.c **** 
4293:Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
4294:Source/tasks.c **** 		{
4295:Source/tasks.c **** 			( pxCurrentTCB->uxCriticalNesting )++;
4296:Source/tasks.c **** 
4297:Source/tasks.c **** 			/* This is not the interrupt safe version of the enter critical
4298:Source/tasks.c **** 			function so	assert() if it is being called from an interrupt
4299:Source/tasks.c **** 			context.  Only API functions that end in "FromISR" can be used in an
4300:Source/tasks.c **** 			interrupt.  Only assert if the critical nesting count is 1 to
4301:Source/tasks.c **** 			protect against recursive calls if the assert function also uses a
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 158
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 158
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


4302:Source/tasks.c **** 			critical section. */
4303:Source/tasks.c **** 			if( pxCurrentTCB->uxCriticalNesting == 1 )
4304:Source/tasks.c **** 			{
4305:Source/tasks.c **** 				portASSERT_IF_IN_ISR();
4306:Source/tasks.c **** 			}
4307:Source/tasks.c **** 		}
4308:Source/tasks.c **** 		else
4309:Source/tasks.c **** 		{
4310:Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4311:Source/tasks.c **** 		}
4312:Source/tasks.c **** 	}
4313:Source/tasks.c **** 
4314:Source/tasks.c **** #endif /* portCRITICAL_NESTING_IN_TCB */
4315:Source/tasks.c **** /*-----------------------------------------------------------*/
4316:Source/tasks.c **** 
4317:Source/tasks.c **** #if ( portCRITICAL_NESTING_IN_TCB == 1 )
4318:Source/tasks.c **** 
4319:Source/tasks.c **** 	void vTaskExitCritical( void )
4320:Source/tasks.c **** 	{
4321:Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
4322:Source/tasks.c **** 		{
4323:Source/tasks.c **** 			if( pxCurrentTCB->uxCriticalNesting > 0U )
4324:Source/tasks.c **** 			{
4325:Source/tasks.c **** 				( pxCurrentTCB->uxCriticalNesting )--;
4326:Source/tasks.c **** 
4327:Source/tasks.c **** 				if( pxCurrentTCB->uxCriticalNesting == 0U )
4328:Source/tasks.c **** 				{
4329:Source/tasks.c **** 					portENABLE_INTERRUPTS();
4330:Source/tasks.c **** 				}
4331:Source/tasks.c **** 				else
4332:Source/tasks.c **** 				{
4333:Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4334:Source/tasks.c **** 				}
4335:Source/tasks.c **** 			}
4336:Source/tasks.c **** 			else
4337:Source/tasks.c **** 			{
4338:Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4339:Source/tasks.c **** 			}
4340:Source/tasks.c **** 		}
4341:Source/tasks.c **** 		else
4342:Source/tasks.c **** 		{
4343:Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4344:Source/tasks.c **** 		}
4345:Source/tasks.c **** 	}
4346:Source/tasks.c **** 
4347:Source/tasks.c **** #endif /* portCRITICAL_NESTING_IN_TCB */
4348:Source/tasks.c **** /*-----------------------------------------------------------*/
4349:Source/tasks.c **** 
4350:Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
4351:Source/tasks.c **** 
4352:Source/tasks.c **** 	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName )
4353:Source/tasks.c **** 	{
4354:Source/tasks.c **** 	size_t x;
4355:Source/tasks.c **** 
4356:Source/tasks.c **** 		/* Start by copying the entire string. */
4357:Source/tasks.c **** 		strcpy( pcBuffer, pcTaskName );
4358:Source/tasks.c **** 
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 159
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 159
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


4359:Source/tasks.c **** 		/* Pad the end of the string with spaces to ensure columns line up when
4360:Source/tasks.c **** 		printed out. */
4361:Source/tasks.c **** 		for( x = strlen( pcBuffer ); x < ( size_t ) ( configMAX_TASK_NAME_LEN - 1 ); x++ )
4362:Source/tasks.c **** 		{
4363:Source/tasks.c **** 			pcBuffer[ x ] = ' ';
4364:Source/tasks.c **** 		}
4365:Source/tasks.c **** 
4366:Source/tasks.c **** 		/* Terminate. */
4367:Source/tasks.c **** 		pcBuffer[ x ] = ( char ) 0x00;
4368:Source/tasks.c **** 
4369:Source/tasks.c **** 		/* Return the new end of string. */
4370:Source/tasks.c **** 		return &( pcBuffer[ x ] );
4371:Source/tasks.c **** 	}
4372:Source/tasks.c **** 
4373:Source/tasks.c **** #endif /* ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) */
4374:Source/tasks.c **** /*-----------------------------------------------------------*/
4375:Source/tasks.c **** 
4376:Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( config
4377:Source/tasks.c **** 
4378:Source/tasks.c **** 	void vTaskList( char * pcWriteBuffer )
4379:Source/tasks.c **** 	{
4380:Source/tasks.c **** 	TaskStatus_t *pxTaskStatusArray;
4381:Source/tasks.c **** 	UBaseType_t uxArraySize, x;
4382:Source/tasks.c **** 	char cStatus;
4383:Source/tasks.c **** 
4384:Source/tasks.c **** 		/*
4385:Source/tasks.c **** 		 * PLEASE NOTE:
4386:Source/tasks.c **** 		 *
4387:Source/tasks.c **** 		 * This function is provided for convenience only, and is used by many
4388:Source/tasks.c **** 		 * of the demo applications.  Do not consider it to be part of the
4389:Source/tasks.c **** 		 * scheduler.
4390:Source/tasks.c **** 		 *
4391:Source/tasks.c **** 		 * vTaskList() calls uxTaskGetSystemState(), then formats part of the
4392:Source/tasks.c **** 		 * uxTaskGetSystemState() output into a human readable table that
4393:Source/tasks.c **** 		 * displays task names, states and stack usage.
4394:Source/tasks.c **** 		 *
4395:Source/tasks.c **** 		 * vTaskList() has a dependency on the sprintf() C library function that
4396:Source/tasks.c **** 		 * might bloat the code size, use a lot of stack, and provide different
4397:Source/tasks.c **** 		 * results on different platforms.  An alternative, tiny, third party,
4398:Source/tasks.c **** 		 * and limited functionality implementation of sprintf() is provided in
4399:Source/tasks.c **** 		 * many of the FreeRTOS/Demo sub-directories in a file called
4400:Source/tasks.c **** 		 * printf-stdarg.c (note printf-stdarg.c does not provide a full
4401:Source/tasks.c **** 		 * snprintf() implementation!).
4402:Source/tasks.c **** 		 *
4403:Source/tasks.c **** 		 * It is recommended that production systems call uxTaskGetSystemState()
4404:Source/tasks.c **** 		 * directly to get access to raw stats data, rather than indirectly
4405:Source/tasks.c **** 		 * through a call to vTaskList().
4406:Source/tasks.c **** 		 */
4407:Source/tasks.c **** 
4408:Source/tasks.c **** 
4409:Source/tasks.c **** 		/* Make sure the write buffer does not contain a string. */
4410:Source/tasks.c **** 		*pcWriteBuffer = ( char ) 0x00;
4411:Source/tasks.c **** 
4412:Source/tasks.c **** 		/* Take a snapshot of the number of tasks in case it changes while this
4413:Source/tasks.c **** 		function is executing. */
4414:Source/tasks.c **** 		uxArraySize = uxCurrentNumberOfTasks;
4415:Source/tasks.c **** 
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 160
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 160
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


4416:Source/tasks.c **** 		/* Allocate an array index for each task.  NOTE!  if
4417:Source/tasks.c **** 		configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
4418:Source/tasks.c **** 		equate to NULL. */
4419:Source/tasks.c **** 		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) ); /*lint !e907
4420:Source/tasks.c **** 
4421:Source/tasks.c **** 		if( pxTaskStatusArray != NULL )
4422:Source/tasks.c **** 		{
4423:Source/tasks.c **** 			/* Generate the (binary) data. */
4424:Source/tasks.c **** 			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );
4425:Source/tasks.c **** 
4426:Source/tasks.c **** 			/* Create a human readable table from the binary data. */
4427:Source/tasks.c **** 			for( x = 0; x < uxArraySize; x++ )
4428:Source/tasks.c **** 			{
4429:Source/tasks.c **** 				switch( pxTaskStatusArray[ x ].eCurrentState )
4430:Source/tasks.c **** 				{
4431:Source/tasks.c **** 					case eRunning:		cStatus = tskRUNNING_CHAR;
4432:Source/tasks.c **** 										break;
4433:Source/tasks.c **** 
4434:Source/tasks.c **** 					case eReady:		cStatus = tskREADY_CHAR;
4435:Source/tasks.c **** 										break;
4436:Source/tasks.c **** 
4437:Source/tasks.c **** 					case eBlocked:		cStatus = tskBLOCKED_CHAR;
4438:Source/tasks.c **** 										break;
4439:Source/tasks.c **** 
4440:Source/tasks.c **** 					case eSuspended:	cStatus = tskSUSPENDED_CHAR;
4441:Source/tasks.c **** 										break;
4442:Source/tasks.c **** 
4443:Source/tasks.c **** 					case eDeleted:		cStatus = tskDELETED_CHAR;
4444:Source/tasks.c **** 										break;
4445:Source/tasks.c **** 
4446:Source/tasks.c **** 					case eInvalid:		/* Fall through. */
4447:Source/tasks.c **** 					default:			/* Should not get here, but it is included
4448:Source/tasks.c **** 										to prevent static checking errors. */
4449:Source/tasks.c **** 										cStatus = ( char ) 0x00;
4450:Source/tasks.c **** 										break;
4451:Source/tasks.c **** 				}
4452:Source/tasks.c **** 
4453:Source/tasks.c **** 				/* Write the task name to the string, padding with spaces so it
4454:Source/tasks.c **** 				can be printed in tabular form more easily. */
4455:Source/tasks.c **** 				pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
4456:Source/tasks.c **** 
4457:Source/tasks.c **** 				/* Write the rest of the string. */
4458:Source/tasks.c **** 				sprintf( pcWriteBuffer, "\t%c\t%u\t%u\t%u\r\n", cStatus, ( unsigned int ) pxTaskStatusArray[ x 
4459:Source/tasks.c **** 				pcWriteBuffer += strlen( pcWriteBuffer ); /*lint !e9016 Pointer arithmetic ok on char pointers 
4460:Source/tasks.c **** 			}
4461:Source/tasks.c **** 
4462:Source/tasks.c **** 			/* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
4463:Source/tasks.c **** 			is 0 then vPortFree() will be #defined to nothing. */
4464:Source/tasks.c **** 			vPortFree( pxTaskStatusArray );
4465:Source/tasks.c **** 		}
4466:Source/tasks.c **** 		else
4467:Source/tasks.c **** 		{
4468:Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4469:Source/tasks.c **** 		}
4470:Source/tasks.c **** 	}
4471:Source/tasks.c **** 
4472:Source/tasks.c **** #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( 
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 161
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 161
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


4473:Source/tasks.c **** /*----------------------------------------------------------*/
4474:Source/tasks.c **** 
4475:Source/tasks.c **** #if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( c
4476:Source/tasks.c **** 
4477:Source/tasks.c **** 	void vTaskGetRunTimeStats( char *pcWriteBuffer )
4478:Source/tasks.c **** 	{
4479:Source/tasks.c **** 	TaskStatus_t *pxTaskStatusArray;
4480:Source/tasks.c **** 	UBaseType_t uxArraySize, x;
4481:Source/tasks.c **** 	uint32_t ulTotalTime, ulStatsAsPercentage;
4482:Source/tasks.c **** 
4483:Source/tasks.c **** 		#if( configUSE_TRACE_FACILITY != 1 )
4484:Source/tasks.c **** 		{
4485:Source/tasks.c **** 			#error configUSE_TRACE_FACILITY must also be set to 1 in FreeRTOSConfig.h to use vTaskGetRunTime
4486:Source/tasks.c **** 		}
4487:Source/tasks.c **** 		#endif
4488:Source/tasks.c **** 
4489:Source/tasks.c **** 		/*
4490:Source/tasks.c **** 		 * PLEASE NOTE:
4491:Source/tasks.c **** 		 *
4492:Source/tasks.c **** 		 * This function is provided for convenience only, and is used by many
4493:Source/tasks.c **** 		 * of the demo applications.  Do not consider it to be part of the
4494:Source/tasks.c **** 		 * scheduler.
4495:Source/tasks.c **** 		 *
4496:Source/tasks.c **** 		 * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part
4497:Source/tasks.c **** 		 * of the uxTaskGetSystemState() output into a human readable table that
4498:Source/tasks.c **** 		 * displays the amount of time each task has spent in the Running state
4499:Source/tasks.c **** 		 * in both absolute and percentage terms.
4500:Source/tasks.c **** 		 *
4501:Source/tasks.c **** 		 * vTaskGetRunTimeStats() has a dependency on the sprintf() C library
4502:Source/tasks.c **** 		 * function that might bloat the code size, use a lot of stack, and
4503:Source/tasks.c **** 		 * provide different results on different platforms.  An alternative,
4504:Source/tasks.c **** 		 * tiny, third party, and limited functionality implementation of
4505:Source/tasks.c **** 		 * sprintf() is provided in many of the FreeRTOS/Demo sub-directories in
4506:Source/tasks.c **** 		 * a file called printf-stdarg.c (note printf-stdarg.c does not provide
4507:Source/tasks.c **** 		 * a full snprintf() implementation!).
4508:Source/tasks.c **** 		 *
4509:Source/tasks.c **** 		 * It is recommended that production systems call uxTaskGetSystemState()
4510:Source/tasks.c **** 		 * directly to get access to raw stats data, rather than indirectly
4511:Source/tasks.c **** 		 * through a call to vTaskGetRunTimeStats().
4512:Source/tasks.c **** 		 */
4513:Source/tasks.c **** 
4514:Source/tasks.c **** 		/* Make sure the write buffer does not contain a string. */
4515:Source/tasks.c **** 		*pcWriteBuffer = ( char ) 0x00;
4516:Source/tasks.c **** 
4517:Source/tasks.c **** 		/* Take a snapshot of the number of tasks in case it changes while this
4518:Source/tasks.c **** 		function is executing. */
4519:Source/tasks.c **** 		uxArraySize = uxCurrentNumberOfTasks;
4520:Source/tasks.c **** 
4521:Source/tasks.c **** 		/* Allocate an array index for each task.  NOTE!  If
4522:Source/tasks.c **** 		configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
4523:Source/tasks.c **** 		equate to NULL. */
4524:Source/tasks.c **** 		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) ); /*lint !e907
4525:Source/tasks.c **** 
4526:Source/tasks.c **** 		if( pxTaskStatusArray != NULL )
4527:Source/tasks.c **** 		{
4528:Source/tasks.c **** 			/* Generate the (binary) data. */
4529:Source/tasks.c **** 			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalTime );
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 162
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 162
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


4530:Source/tasks.c **** 
4531:Source/tasks.c **** 			/* For percentage calculations. */
4532:Source/tasks.c **** 			ulTotalTime /= 100UL;
4533:Source/tasks.c **** 
4534:Source/tasks.c **** 			/* Avoid divide by zero errors. */
4535:Source/tasks.c **** 			if( ulTotalTime > 0UL )
4536:Source/tasks.c **** 			{
4537:Source/tasks.c **** 				/* Create a human readable table from the binary data. */
4538:Source/tasks.c **** 				for( x = 0; x < uxArraySize; x++ )
4539:Source/tasks.c **** 				{
4540:Source/tasks.c **** 					/* What percentage of the total run time has the task used?
4541:Source/tasks.c **** 					This will always be rounded down to the nearest integer.
4542:Source/tasks.c **** 					ulTotalRunTimeDiv100 has already been divided by 100. */
4543:Source/tasks.c **** 					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;
4544:Source/tasks.c **** 
4545:Source/tasks.c **** 					/* Write the task name to the string, padding with
4546:Source/tasks.c **** 					spaces so it can be printed in tabular form more
4547:Source/tasks.c **** 					easily. */
4548:Source/tasks.c **** 					pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
4549:Source/tasks.c **** 
4550:Source/tasks.c **** 					if( ulStatsAsPercentage > 0UL )
4551:Source/tasks.c **** 					{
4552:Source/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
4553:Source/tasks.c **** 						{
4554:Source/tasks.c **** 							sprintf( pcWriteBuffer, "\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter, ulSta
4555:Source/tasks.c **** 						}
4556:Source/tasks.c **** 						#else
4557:Source/tasks.c **** 						{
4558:Source/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
4559:Source/tasks.c **** 							printf() library can be used. */
4560:Source/tasks.c **** 							sprintf( pcWriteBuffer, "\t%u\t\t%u%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTim
4561:Source/tasks.c **** 						}
4562:Source/tasks.c **** 						#endif
4563:Source/tasks.c **** 					}
4564:Source/tasks.c **** 					else
4565:Source/tasks.c **** 					{
4566:Source/tasks.c **** 						/* If the percentage is zero here then the task has
4567:Source/tasks.c **** 						consumed less than 1% of the total run time. */
4568:Source/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
4569:Source/tasks.c **** 						{
4570:Source/tasks.c **** 							sprintf( pcWriteBuffer, "\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter );
4571:Source/tasks.c **** 						}
4572:Source/tasks.c **** 						#else
4573:Source/tasks.c **** 						{
4574:Source/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
4575:Source/tasks.c **** 							printf() library can be used. */
4576:Source/tasks.c **** 							sprintf( pcWriteBuffer, "\t%u\t\t<1%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTim
4577:Source/tasks.c **** 						}
4578:Source/tasks.c **** 						#endif
4579:Source/tasks.c **** 					}
4580:Source/tasks.c **** 
4581:Source/tasks.c **** 					pcWriteBuffer += strlen( pcWriteBuffer ); /*lint !e9016 Pointer arithmetic ok on char pointers
4582:Source/tasks.c **** 				}
4583:Source/tasks.c **** 			}
4584:Source/tasks.c **** 			else
4585:Source/tasks.c **** 			{
4586:Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 163
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 163
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


4587:Source/tasks.c **** 			}
4588:Source/tasks.c **** 
4589:Source/tasks.c **** 			/* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
4590:Source/tasks.c **** 			is 0 then vPortFree() will be #defined to nothing. */
4591:Source/tasks.c **** 			vPortFree( pxTaskStatusArray );
4592:Source/tasks.c **** 		}
4593:Source/tasks.c **** 		else
4594:Source/tasks.c **** 		{
4595:Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4596:Source/tasks.c **** 		}
4597:Source/tasks.c **** 	}
4598:Source/tasks.c **** 
4599:Source/tasks.c **** #endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) 
4600:Source/tasks.c **** /*-----------------------------------------------------------*/
4601:Source/tasks.c **** 
4602:Source/tasks.c **** TickType_t uxTaskResetEventItemValue( void )
4603:Source/tasks.c **** {
 4365              		.loc 1 4603 0
 4366              		.cfi_startproc
 4367              		@ args = 0, pretend = 0, frame = 8
 4368              		@ frame_needed = 1, uses_anonymous_args = 0
 4369              		@ link register save eliminated.
 4370 0000 80B4     		push	{r7}
 4371              		.cfi_def_cfa_offset 4
 4372              		.cfi_offset 7, -4
 4373 0002 83B0     		sub	sp, sp, #12
 4374              		.cfi_def_cfa_offset 16
 4375 0004 00AF     		add	r7, sp, #0
 4376              		.cfi_def_cfa_register 7
4604:Source/tasks.c **** TickType_t uxReturn;
4605:Source/tasks.c **** 
4606:Source/tasks.c **** 	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
 4377              		.loc 1 4606 0
 4378 0006 094B     		ldr	r3, .L296
 4379 0008 1B68     		ldr	r3, [r3]
 4380 000a 9B69     		ldr	r3, [r3, #24]
 4381 000c 7B60     		str	r3, [r7, #4]
4607:Source/tasks.c **** 
4608:Source/tasks.c **** 	/* Reset the event list item to its normal value - so it can be used with
4609:Source/tasks.c **** 	queues and semaphores. */
4610:Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES 
 4382              		.loc 1 4610 0
 4383 000e 074B     		ldr	r3, .L296
 4384 0010 1B68     		ldr	r3, [r3]
 4385 0012 064A     		ldr	r2, .L296
 4386 0014 1268     		ldr	r2, [r2]
 4387 0016 D26A     		ldr	r2, [r2, #44]
 4388 0018 C2F10502 		rsb	r2, r2, #5
 4389 001c 9A61     		str	r2, [r3, #24]
4611:Source/tasks.c **** 
4612:Source/tasks.c **** 	return uxReturn;
 4390              		.loc 1 4612 0
 4391 001e 7B68     		ldr	r3, [r7, #4]
4613:Source/tasks.c **** }
 4392              		.loc 1 4613 0
 4393 0020 1846     		mov	r0, r3
 4394 0022 0C37     		adds	r7, r7, #12
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 164
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 164
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 4395              		.cfi_def_cfa_offset 4
 4396 0024 BD46     		mov	sp, r7
 4397              		.cfi_def_cfa_register 13
 4398              		@ sp needed
 4399 0026 80BC     		pop	{r7}
 4400              		.cfi_restore 7
 4401              		.cfi_def_cfa_offset 0
 4402 0028 7047     		bx	lr
 4403              	.L297:
 4404 002a 00BF     		.align	2
 4405              	.L296:
 4406 002c 00000000 		.word	pxCurrentTCB
 4407              		.cfi_endproc
 4408              	.LFE112:
 4409              		.size	uxTaskResetEventItemValue, .-uxTaskResetEventItemValue
 4410              		.section	.text.pvTaskIncrementMutexHeldCount,"ax",%progbits
 4411              		.align	2
 4412              		.global	pvTaskIncrementMutexHeldCount
 4413              		.thumb
 4414              		.thumb_func
 4415              		.type	pvTaskIncrementMutexHeldCount, %function
 4416              	pvTaskIncrementMutexHeldCount:
 4417              	.LFB113:
4614:Source/tasks.c **** /*-----------------------------------------------------------*/
4615:Source/tasks.c **** 
4616:Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
4617:Source/tasks.c **** 
4618:Source/tasks.c **** 	TaskHandle_t pvTaskIncrementMutexHeldCount( void )
4619:Source/tasks.c **** 	{
 4418              		.loc 1 4619 0
 4419              		.cfi_startproc
 4420              		@ args = 0, pretend = 0, frame = 0
 4421              		@ frame_needed = 1, uses_anonymous_args = 0
 4422              		@ link register save eliminated.
 4423 0000 80B4     		push	{r7}
 4424              		.cfi_def_cfa_offset 4
 4425              		.cfi_offset 7, -4
 4426 0002 00AF     		add	r7, sp, #0
 4427              		.cfi_def_cfa_register 7
4620:Source/tasks.c **** 		/* If xSemaphoreCreateMutex() is called before any tasks have been created
4621:Source/tasks.c **** 		then pxCurrentTCB will be NULL. */
4622:Source/tasks.c **** 		if( pxCurrentTCB != NULL )
 4428              		.loc 1 4622 0
 4429 0004 074B     		ldr	r3, .L301
 4430 0006 1B68     		ldr	r3, [r3]
 4431 0008 002B     		cmp	r3, #0
 4432 000a 04D0     		beq	.L299
4623:Source/tasks.c **** 		{
4624:Source/tasks.c **** 			( pxCurrentTCB->uxMutexesHeld )++;
 4433              		.loc 1 4624 0
 4434 000c 054B     		ldr	r3, .L301
 4435 000e 1B68     		ldr	r3, [r3]
 4436 0010 5A6C     		ldr	r2, [r3, #68]
 4437 0012 0132     		adds	r2, r2, #1
 4438 0014 5A64     		str	r2, [r3, #68]
 4439              	.L299:
4625:Source/tasks.c **** 		}
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 165
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 165
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


4626:Source/tasks.c **** 
4627:Source/tasks.c **** 		return pxCurrentTCB;
 4440              		.loc 1 4627 0
 4441 0016 034B     		ldr	r3, .L301
 4442 0018 1B68     		ldr	r3, [r3]
4628:Source/tasks.c **** 	}
 4443              		.loc 1 4628 0
 4444 001a 1846     		mov	r0, r3
 4445 001c BD46     		mov	sp, r7
 4446              		.cfi_def_cfa_register 13
 4447              		@ sp needed
 4448 001e 80BC     		pop	{r7}
 4449              		.cfi_restore 7
 4450              		.cfi_def_cfa_offset 0
 4451 0020 7047     		bx	lr
 4452              	.L302:
 4453 0022 00BF     		.align	2
 4454              	.L301:
 4455 0024 00000000 		.word	pxCurrentTCB
 4456              		.cfi_endproc
 4457              	.LFE113:
 4458              		.size	pvTaskIncrementMutexHeldCount, .-pvTaskIncrementMutexHeldCount
 4459              		.section	.text.ulTaskNotifyTake,"ax",%progbits
 4460              		.align	2
 4461              		.global	ulTaskNotifyTake
 4462              		.thumb
 4463              		.thumb_func
 4464              		.type	ulTaskNotifyTake, %function
 4465              	ulTaskNotifyTake:
 4466              	.LFB114:
4629:Source/tasks.c **** 
4630:Source/tasks.c **** #endif /* configUSE_MUTEXES */
4631:Source/tasks.c **** /*-----------------------------------------------------------*/
4632:Source/tasks.c **** 
4633:Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4634:Source/tasks.c **** 
4635:Source/tasks.c **** 	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
4636:Source/tasks.c **** 	{
 4467              		.loc 1 4636 0
 4468              		.cfi_startproc
 4469              		@ args = 0, pretend = 0, frame = 16
 4470              		@ frame_needed = 1, uses_anonymous_args = 0
 4471 0000 80B5     		push	{r7, lr}
 4472              		.cfi_def_cfa_offset 8
 4473              		.cfi_offset 7, -8
 4474              		.cfi_offset 14, -4
 4475 0002 84B0     		sub	sp, sp, #16
 4476              		.cfi_def_cfa_offset 24
 4477 0004 00AF     		add	r7, sp, #0
 4478              		.cfi_def_cfa_register 7
 4479 0006 7860     		str	r0, [r7, #4]
 4480 0008 3960     		str	r1, [r7]
4637:Source/tasks.c **** 	uint32_t ulReturn;
4638:Source/tasks.c **** 
4639:Source/tasks.c **** 		taskENTER_CRITICAL();
 4481              		.loc 1 4639 0
 4482 000a FFF7FEFF 		bl	vPortEnterCritical
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 166
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 166
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


4640:Source/tasks.c **** 		{
4641:Source/tasks.c **** 			/* Only block if the notification count is not already non-zero. */
4642:Source/tasks.c **** 			if( pxCurrentTCB->ulNotifiedValue == 0UL )
 4483              		.loc 1 4642 0
 4484 000e 1E4B     		ldr	r3, .L309
 4485 0010 1B68     		ldr	r3, [r3]
 4486 0012 9B6C     		ldr	r3, [r3, #72]
 4487 0014 002B     		cmp	r3, #0
 4488 0016 13D1     		bne	.L304
4643:Source/tasks.c **** 			{
4644:Source/tasks.c **** 				/* Mark this task as waiting for a notification. */
4645:Source/tasks.c **** 				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
 4489              		.loc 1 4645 0
 4490 0018 1B4B     		ldr	r3, .L309
 4491 001a 1B68     		ldr	r3, [r3]
 4492 001c 0122     		movs	r2, #1
 4493 001e 83F84C20 		strb	r2, [r3, #76]
4646:Source/tasks.c **** 
4647:Source/tasks.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
 4494              		.loc 1 4647 0
 4495 0022 3B68     		ldr	r3, [r7]
 4496 0024 002B     		cmp	r3, #0
 4497 0026 0BD0     		beq	.L304
4648:Source/tasks.c **** 				{
4649:Source/tasks.c **** 					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 4498              		.loc 1 4649 0
 4499 0028 0121     		movs	r1, #1
 4500 002a 3868     		ldr	r0, [r7]
 4501 002c FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
4650:Source/tasks.c **** 					traceTASK_NOTIFY_TAKE_BLOCK();
4651:Source/tasks.c **** 
4652:Source/tasks.c **** 					/* All ports are written to allow a yield in a critical
4653:Source/tasks.c **** 					section (some will yield immediately, others wait until the
4654:Source/tasks.c **** 					critical section exits) - but it is not something that
4655:Source/tasks.c **** 					application code should ever do. */
4656:Source/tasks.c **** 					portYIELD_WITHIN_API();
 4502              		.loc 1 4656 0
 4503 0030 164B     		ldr	r3, .L309+4
 4504 0032 4FF08052 		mov	r2, #268435456
 4505 0036 1A60     		str	r2, [r3]
 4506              		.syntax unified
 4507              	@ 4656 "Source\tasks.c" 1
 4508 0038 BFF34F8F 		dsb
 4509              	@ 0 "" 2
 4510              	@ 4656 "Source\tasks.c" 1
 4511 003c BFF36F8F 		isb
 4512              	@ 0 "" 2
 4513              		.thumb
 4514              		.syntax unified
 4515              	.L304:
4657:Source/tasks.c **** 				}
4658:Source/tasks.c **** 				else
4659:Source/tasks.c **** 				{
4660:Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4661:Source/tasks.c **** 				}
4662:Source/tasks.c **** 			}
4663:Source/tasks.c **** 			else
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 167
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 167
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


4664:Source/tasks.c **** 			{
4665:Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4666:Source/tasks.c **** 			}
4667:Source/tasks.c **** 		}
4668:Source/tasks.c **** 		taskEXIT_CRITICAL();
 4516              		.loc 1 4668 0
 4517 0040 FFF7FEFF 		bl	vPortExitCritical
4669:Source/tasks.c **** 
4670:Source/tasks.c **** 		taskENTER_CRITICAL();
 4518              		.loc 1 4670 0
 4519 0044 FFF7FEFF 		bl	vPortEnterCritical
4671:Source/tasks.c **** 		{
4672:Source/tasks.c **** 			traceTASK_NOTIFY_TAKE();
4673:Source/tasks.c **** 			ulReturn = pxCurrentTCB->ulNotifiedValue;
 4520              		.loc 1 4673 0
 4521 0048 0F4B     		ldr	r3, .L309
 4522 004a 1B68     		ldr	r3, [r3]
 4523 004c 9B6C     		ldr	r3, [r3, #72]
 4524 004e FB60     		str	r3, [r7, #12]
4674:Source/tasks.c **** 
4675:Source/tasks.c **** 			if( ulReturn != 0UL )
 4525              		.loc 1 4675 0
 4526 0050 FB68     		ldr	r3, [r7, #12]
 4527 0052 002B     		cmp	r3, #0
 4528 0054 0CD0     		beq	.L305
4676:Source/tasks.c **** 			{
4677:Source/tasks.c **** 				if( xClearCountOnExit != pdFALSE )
 4529              		.loc 1 4677 0
 4530 0056 7B68     		ldr	r3, [r7, #4]
 4531 0058 002B     		cmp	r3, #0
 4532 005a 04D0     		beq	.L306
4678:Source/tasks.c **** 				{
4679:Source/tasks.c **** 					pxCurrentTCB->ulNotifiedValue = 0UL;
 4533              		.loc 1 4679 0
 4534 005c 0A4B     		ldr	r3, .L309
 4535 005e 1B68     		ldr	r3, [r3]
 4536 0060 0022     		movs	r2, #0
 4537 0062 9A64     		str	r2, [r3, #72]
 4538 0064 04E0     		b	.L305
 4539              	.L306:
4680:Source/tasks.c **** 				}
4681:Source/tasks.c **** 				else
4682:Source/tasks.c **** 				{
4683:Source/tasks.c **** 					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
 4540              		.loc 1 4683 0
 4541 0066 084B     		ldr	r3, .L309
 4542 0068 1B68     		ldr	r3, [r3]
 4543 006a FA68     		ldr	r2, [r7, #12]
 4544 006c 013A     		subs	r2, r2, #1
 4545 006e 9A64     		str	r2, [r3, #72]
 4546              	.L305:
4684:Source/tasks.c **** 				}
4685:Source/tasks.c **** 			}
4686:Source/tasks.c **** 			else
4687:Source/tasks.c **** 			{
4688:Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4689:Source/tasks.c **** 			}
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 168
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 168
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


4690:Source/tasks.c **** 
4691:Source/tasks.c **** 			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 4547              		.loc 1 4691 0
 4548 0070 054B     		ldr	r3, .L309
 4549 0072 1B68     		ldr	r3, [r3]
 4550 0074 0022     		movs	r2, #0
 4551 0076 83F84C20 		strb	r2, [r3, #76]
4692:Source/tasks.c **** 		}
4693:Source/tasks.c **** 		taskEXIT_CRITICAL();
 4552              		.loc 1 4693 0
 4553 007a FFF7FEFF 		bl	vPortExitCritical
4694:Source/tasks.c **** 
4695:Source/tasks.c **** 		return ulReturn;
 4554              		.loc 1 4695 0
 4555 007e FB68     		ldr	r3, [r7, #12]
4696:Source/tasks.c **** 	}
 4556              		.loc 1 4696 0
 4557 0080 1846     		mov	r0, r3
 4558 0082 1037     		adds	r7, r7, #16
 4559              		.cfi_def_cfa_offset 8
 4560 0084 BD46     		mov	sp, r7
 4561              		.cfi_def_cfa_register 13
 4562              		@ sp needed
 4563 0086 80BD     		pop	{r7, pc}
 4564              	.L310:
 4565              		.align	2
 4566              	.L309:
 4567 0088 00000000 		.word	pxCurrentTCB
 4568 008c 04ED00E0 		.word	-536810236
 4569              		.cfi_endproc
 4570              	.LFE114:
 4571              		.size	ulTaskNotifyTake, .-ulTaskNotifyTake
 4572              		.section	.text.xTaskNotifyWait,"ax",%progbits
 4573              		.align	2
 4574              		.global	xTaskNotifyWait
 4575              		.thumb
 4576              		.thumb_func
 4577              		.type	xTaskNotifyWait, %function
 4578              	xTaskNotifyWait:
 4579              	.LFB115:
4697:Source/tasks.c **** 
4698:Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4699:Source/tasks.c **** /*-----------------------------------------------------------*/
4700:Source/tasks.c **** 
4701:Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4702:Source/tasks.c **** 
4703:Source/tasks.c **** 	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t 
4704:Source/tasks.c **** 	{
 4580              		.loc 1 4704 0
 4581              		.cfi_startproc
 4582              		@ args = 0, pretend = 0, frame = 24
 4583              		@ frame_needed = 1, uses_anonymous_args = 0
 4584 0000 80B5     		push	{r7, lr}
 4585              		.cfi_def_cfa_offset 8
 4586              		.cfi_offset 7, -8
 4587              		.cfi_offset 14, -4
 4588 0002 86B0     		sub	sp, sp, #24
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 169
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 169
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 4589              		.cfi_def_cfa_offset 32
 4590 0004 00AF     		add	r7, sp, #0
 4591              		.cfi_def_cfa_register 7
 4592 0006 F860     		str	r0, [r7, #12]
 4593 0008 B960     		str	r1, [r7, #8]
 4594 000a 7A60     		str	r2, [r7, #4]
 4595 000c 3B60     		str	r3, [r7]
4705:Source/tasks.c **** 	BaseType_t xReturn;
4706:Source/tasks.c **** 
4707:Source/tasks.c **** 		taskENTER_CRITICAL();
 4596              		.loc 1 4707 0
 4597 000e FFF7FEFF 		bl	vPortEnterCritical
4708:Source/tasks.c **** 		{
4709:Source/tasks.c **** 			/* Only block if a notification is not already pending. */
4710:Source/tasks.c **** 			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
 4598              		.loc 1 4710 0
 4599 0012 264B     		ldr	r3, .L317
 4600 0014 1B68     		ldr	r3, [r3]
 4601 0016 93F84C30 		ldrb	r3, [r3, #76]
 4602 001a DBB2     		uxtb	r3, r3
 4603 001c 022B     		cmp	r3, #2
 4604 001e 1AD0     		beq	.L312
4711:Source/tasks.c **** 			{
4712:Source/tasks.c **** 				/* Clear bits in the task's notification value as bits may get
4713:Source/tasks.c **** 				set	by the notifying task or interrupt.  This can be used to
4714:Source/tasks.c **** 				clear the value to zero. */
4715:Source/tasks.c **** 				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
 4605              		.loc 1 4715 0
 4606 0020 224B     		ldr	r3, .L317
 4607 0022 1B68     		ldr	r3, [r3]
 4608 0024 996C     		ldr	r1, [r3, #72]
 4609 0026 FA68     		ldr	r2, [r7, #12]
 4610 0028 D243     		mvns	r2, r2
 4611 002a 0A40     		ands	r2, r2, r1
 4612 002c 9A64     		str	r2, [r3, #72]
4716:Source/tasks.c **** 
4717:Source/tasks.c **** 				/* Mark this task as waiting for a notification. */
4718:Source/tasks.c **** 				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
 4613              		.loc 1 4718 0
 4614 002e 1F4B     		ldr	r3, .L317
 4615 0030 1B68     		ldr	r3, [r3]
 4616 0032 0122     		movs	r2, #1
 4617 0034 83F84C20 		strb	r2, [r3, #76]
4719:Source/tasks.c **** 
4720:Source/tasks.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
 4618              		.loc 1 4720 0
 4619 0038 3B68     		ldr	r3, [r7]
 4620 003a 002B     		cmp	r3, #0
 4621 003c 0BD0     		beq	.L312
4721:Source/tasks.c **** 				{
4722:Source/tasks.c **** 					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 4622              		.loc 1 4722 0
 4623 003e 0121     		movs	r1, #1
 4624 0040 3868     		ldr	r0, [r7]
 4625 0042 FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
4723:Source/tasks.c **** 					traceTASK_NOTIFY_WAIT_BLOCK();
4724:Source/tasks.c **** 
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 170
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 170
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


4725:Source/tasks.c **** 					/* All ports are written to allow a yield in a critical
4726:Source/tasks.c **** 					section (some will yield immediately, others wait until the
4727:Source/tasks.c **** 					critical section exits) - but it is not something that
4728:Source/tasks.c **** 					application code should ever do. */
4729:Source/tasks.c **** 					portYIELD_WITHIN_API();
 4626              		.loc 1 4729 0
 4627 0046 1A4B     		ldr	r3, .L317+4
 4628 0048 4FF08052 		mov	r2, #268435456
 4629 004c 1A60     		str	r2, [r3]
 4630              		.syntax unified
 4631              	@ 4729 "Source\tasks.c" 1
 4632 004e BFF34F8F 		dsb
 4633              	@ 0 "" 2
 4634              	@ 4729 "Source\tasks.c" 1
 4635 0052 BFF36F8F 		isb
 4636              	@ 0 "" 2
 4637              		.thumb
 4638              		.syntax unified
 4639              	.L312:
4730:Source/tasks.c **** 				}
4731:Source/tasks.c **** 				else
4732:Source/tasks.c **** 				{
4733:Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4734:Source/tasks.c **** 				}
4735:Source/tasks.c **** 			}
4736:Source/tasks.c **** 			else
4737:Source/tasks.c **** 			{
4738:Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4739:Source/tasks.c **** 			}
4740:Source/tasks.c **** 		}
4741:Source/tasks.c **** 		taskEXIT_CRITICAL();
 4640              		.loc 1 4741 0
 4641 0056 FFF7FEFF 		bl	vPortExitCritical
4742:Source/tasks.c **** 
4743:Source/tasks.c **** 		taskENTER_CRITICAL();
 4642              		.loc 1 4743 0
 4643 005a FFF7FEFF 		bl	vPortEnterCritical
4744:Source/tasks.c **** 		{
4745:Source/tasks.c **** 			traceTASK_NOTIFY_WAIT();
4746:Source/tasks.c **** 
4747:Source/tasks.c **** 			if( pulNotificationValue != NULL )
 4644              		.loc 1 4747 0
 4645 005e 7B68     		ldr	r3, [r7, #4]
 4646 0060 002B     		cmp	r3, #0
 4647 0062 04D0     		beq	.L313
4748:Source/tasks.c **** 			{
4749:Source/tasks.c **** 				/* Output the current notification value, which may or may not
4750:Source/tasks.c **** 				have changed. */
4751:Source/tasks.c **** 				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
 4648              		.loc 1 4751 0
 4649 0064 114B     		ldr	r3, .L317
 4650 0066 1B68     		ldr	r3, [r3]
 4651 0068 9A6C     		ldr	r2, [r3, #72]
 4652 006a 7B68     		ldr	r3, [r7, #4]
 4653 006c 1A60     		str	r2, [r3]
 4654              	.L313:
4752:Source/tasks.c **** 			}
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 171
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 171
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


4753:Source/tasks.c **** 
4754:Source/tasks.c **** 			/* If ucNotifyValue is set then either the task never entered the
4755:Source/tasks.c **** 			blocked state (because a notification was already pending) or the
4756:Source/tasks.c **** 			task unblocked because of a notification.  Otherwise the task
4757:Source/tasks.c **** 			unblocked because of a timeout. */
4758:Source/tasks.c **** 			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
 4655              		.loc 1 4758 0
 4656 006e 0F4B     		ldr	r3, .L317
 4657 0070 1B68     		ldr	r3, [r3]
 4658 0072 93F84C30 		ldrb	r3, [r3, #76]
 4659 0076 DBB2     		uxtb	r3, r3
 4660 0078 022B     		cmp	r3, #2
 4661 007a 02D0     		beq	.L314
4759:Source/tasks.c **** 			{
4760:Source/tasks.c **** 				/* A notification was not received. */
4761:Source/tasks.c **** 				xReturn = pdFALSE;
 4662              		.loc 1 4761 0
 4663 007c 0023     		movs	r3, #0
 4664 007e 7B61     		str	r3, [r7, #20]
 4665 0080 08E0     		b	.L315
 4666              	.L314:
4762:Source/tasks.c **** 			}
4763:Source/tasks.c **** 			else
4764:Source/tasks.c **** 			{
4765:Source/tasks.c **** 				/* A notification was already pending or a notification was
4766:Source/tasks.c **** 				received while the task was waiting. */
4767:Source/tasks.c **** 				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
 4667              		.loc 1 4767 0
 4668 0082 0A4B     		ldr	r3, .L317
 4669 0084 1B68     		ldr	r3, [r3]
 4670 0086 996C     		ldr	r1, [r3, #72]
 4671 0088 BA68     		ldr	r2, [r7, #8]
 4672 008a D243     		mvns	r2, r2
 4673 008c 0A40     		ands	r2, r2, r1
 4674 008e 9A64     		str	r2, [r3, #72]
4768:Source/tasks.c **** 				xReturn = pdTRUE;
 4675              		.loc 1 4768 0
 4676 0090 0123     		movs	r3, #1
 4677 0092 7B61     		str	r3, [r7, #20]
 4678              	.L315:
4769:Source/tasks.c **** 			}
4770:Source/tasks.c **** 
4771:Source/tasks.c **** 			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 4679              		.loc 1 4771 0
 4680 0094 054B     		ldr	r3, .L317
 4681 0096 1B68     		ldr	r3, [r3]
 4682 0098 0022     		movs	r2, #0
 4683 009a 83F84C20 		strb	r2, [r3, #76]
4772:Source/tasks.c **** 		}
4773:Source/tasks.c **** 		taskEXIT_CRITICAL();
 4684              		.loc 1 4773 0
 4685 009e FFF7FEFF 		bl	vPortExitCritical
4774:Source/tasks.c **** 
4775:Source/tasks.c **** 		return xReturn;
 4686              		.loc 1 4775 0
 4687 00a2 7B69     		ldr	r3, [r7, #20]
4776:Source/tasks.c **** 	}
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 172
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 172
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 4688              		.loc 1 4776 0
 4689 00a4 1846     		mov	r0, r3
 4690 00a6 1837     		adds	r7, r7, #24
 4691              		.cfi_def_cfa_offset 8
 4692 00a8 BD46     		mov	sp, r7
 4693              		.cfi_def_cfa_register 13
 4694              		@ sp needed
 4695 00aa 80BD     		pop	{r7, pc}
 4696              	.L318:
 4697              		.align	2
 4698              	.L317:
 4699 00ac 00000000 		.word	pxCurrentTCB
 4700 00b0 04ED00E0 		.word	-536810236
 4701              		.cfi_endproc
 4702              	.LFE115:
 4703              		.size	xTaskNotifyWait, .-xTaskNotifyWait
 4704              		.section	.text.xTaskGenericNotify,"ax",%progbits
 4705              		.align	2
 4706              		.global	xTaskGenericNotify
 4707              		.thumb
 4708              		.thumb_func
 4709              		.type	xTaskGenericNotify, %function
 4710              	xTaskGenericNotify:
 4711              	.LFB116:
4777:Source/tasks.c **** 
4778:Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4779:Source/tasks.c **** /*-----------------------------------------------------------*/
4780:Source/tasks.c **** 
4781:Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4782:Source/tasks.c **** 
4783:Source/tasks.c **** 	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction
4784:Source/tasks.c **** 	{
 4712              		.loc 1 4784 0
 4713              		.cfi_startproc
 4714              		@ args = 0, pretend = 0, frame = 32
 4715              		@ frame_needed = 1, uses_anonymous_args = 0
 4716 0000 80B5     		push	{r7, lr}
 4717              		.cfi_def_cfa_offset 8
 4718              		.cfi_offset 7, -8
 4719              		.cfi_offset 14, -4
 4720 0002 88B0     		sub	sp, sp, #32
 4721              		.cfi_def_cfa_offset 40
 4722 0004 00AF     		add	r7, sp, #0
 4723              		.cfi_def_cfa_register 7
 4724 0006 F860     		str	r0, [r7, #12]
 4725 0008 B960     		str	r1, [r7, #8]
 4726 000a 3B60     		str	r3, [r7]
 4727 000c 1346     		mov	r3, r2
 4728 000e FB71     		strb	r3, [r7, #7]
4785:Source/tasks.c **** 	TCB_t * pxTCB;
4786:Source/tasks.c **** 	BaseType_t xReturn = pdPASS;
 4729              		.loc 1 4786 0
 4730 0010 0123     		movs	r3, #1
 4731 0012 FB61     		str	r3, [r7, #28]
4787:Source/tasks.c **** 	uint8_t ucOriginalNotifyState;
4788:Source/tasks.c **** 
4789:Source/tasks.c **** 		configASSERT( xTaskToNotify );
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 173
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 173
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


4790:Source/tasks.c **** 		pxTCB = xTaskToNotify;
 4732              		.loc 1 4790 0
 4733 0014 FB68     		ldr	r3, [r7, #12]
 4734 0016 BB61     		str	r3, [r7, #24]
4791:Source/tasks.c **** 
4792:Source/tasks.c **** 		taskENTER_CRITICAL();
 4735              		.loc 1 4792 0
 4736 0018 FFF7FEFF 		bl	vPortEnterCritical
4793:Source/tasks.c **** 		{
4794:Source/tasks.c **** 			if( pulPreviousNotificationValue != NULL )
 4737              		.loc 1 4794 0
 4738 001c 3B68     		ldr	r3, [r7]
 4739 001e 002B     		cmp	r3, #0
 4740 0020 03D0     		beq	.L320
4795:Source/tasks.c **** 			{
4796:Source/tasks.c **** 				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
 4741              		.loc 1 4796 0
 4742 0022 BB69     		ldr	r3, [r7, #24]
 4743 0024 9A6C     		ldr	r2, [r3, #72]
 4744 0026 3B68     		ldr	r3, [r7]
 4745 0028 1A60     		str	r2, [r3]
 4746              	.L320:
4797:Source/tasks.c **** 			}
4798:Source/tasks.c **** 
4799:Source/tasks.c **** 			ucOriginalNotifyState = pxTCB->ucNotifyState;
 4747              		.loc 1 4799 0
 4748 002a BB69     		ldr	r3, [r7, #24]
 4749 002c 93F84C30 		ldrb	r3, [r3, #76]
 4750 0030 FB75     		strb	r3, [r7, #23]
4800:Source/tasks.c **** 
4801:Source/tasks.c **** 			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 4751              		.loc 1 4801 0
 4752 0032 BB69     		ldr	r3, [r7, #24]
 4753 0034 0222     		movs	r2, #2
 4754 0036 83F84C20 		strb	r2, [r3, #76]
4802:Source/tasks.c **** 
4803:Source/tasks.c **** 			switch( eAction )
 4755              		.loc 1 4803 0
 4756 003a FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 4757 003c 042B     		cmp	r3, #4
 4758 003e 28D8     		bhi	.L333
 4759 0040 01A2     		adr	r2, .L323
 4760 0042 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 4761 0046 00BF     		.p2align 2
 4762              	.L323:
 4763 0048 93000000 		.word	.L333+1
 4764 004c 5D000000 		.word	.L324+1
 4765 0050 6B000000 		.word	.L325+1
 4766 0054 77000000 		.word	.L326+1
 4767 0058 7F000000 		.word	.L327+1
 4768              		.p2align 1
 4769              	.L324:
4804:Source/tasks.c **** 			{
4805:Source/tasks.c **** 				case eSetBits	:
4806:Source/tasks.c **** 					pxTCB->ulNotifiedValue |= ulValue;
 4770              		.loc 1 4806 0
 4771 005c BB69     		ldr	r3, [r7, #24]
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 174
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 174
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 4772 005e 9A6C     		ldr	r2, [r3, #72]
 4773 0060 BB68     		ldr	r3, [r7, #8]
 4774 0062 1A43     		orrs	r2, r2, r3
 4775 0064 BB69     		ldr	r3, [r7, #24]
 4776 0066 9A64     		str	r2, [r3, #72]
4807:Source/tasks.c **** 					break;
 4777              		.loc 1 4807 0
 4778 0068 14E0     		b	.L328
 4779              	.L325:
4808:Source/tasks.c **** 
4809:Source/tasks.c **** 				case eIncrement	:
4810:Source/tasks.c **** 					( pxTCB->ulNotifiedValue )++;
 4780              		.loc 1 4810 0
 4781 006a BB69     		ldr	r3, [r7, #24]
 4782 006c 9B6C     		ldr	r3, [r3, #72]
 4783 006e 5A1C     		adds	r2, r3, #1
 4784 0070 BB69     		ldr	r3, [r7, #24]
 4785 0072 9A64     		str	r2, [r3, #72]
4811:Source/tasks.c **** 					break;
 4786              		.loc 1 4811 0
 4787 0074 0EE0     		b	.L328
 4788              	.L326:
4812:Source/tasks.c **** 
4813:Source/tasks.c **** 				case eSetValueWithOverwrite	:
4814:Source/tasks.c **** 					pxTCB->ulNotifiedValue = ulValue;
 4789              		.loc 1 4814 0
 4790 0076 BB69     		ldr	r3, [r7, #24]
 4791 0078 BA68     		ldr	r2, [r7, #8]
 4792 007a 9A64     		str	r2, [r3, #72]
4815:Source/tasks.c **** 					break;
 4793              		.loc 1 4815 0
 4794 007c 0AE0     		b	.L328
 4795              	.L327:
4816:Source/tasks.c **** 
4817:Source/tasks.c **** 				case eSetValueWithoutOverwrite :
4818:Source/tasks.c **** 					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
 4796              		.loc 1 4818 0
 4797 007e FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 4798 0080 022B     		cmp	r3, #2
 4799 0082 03D0     		beq	.L329
4819:Source/tasks.c **** 					{
4820:Source/tasks.c **** 						pxTCB->ulNotifiedValue = ulValue;
 4800              		.loc 1 4820 0
 4801 0084 BB69     		ldr	r3, [r7, #24]
 4802 0086 BA68     		ldr	r2, [r7, #8]
 4803 0088 9A64     		str	r2, [r3, #72]
4821:Source/tasks.c **** 					}
4822:Source/tasks.c **** 					else
4823:Source/tasks.c **** 					{
4824:Source/tasks.c **** 						/* The value could not be written to the task. */
4825:Source/tasks.c **** 						xReturn = pdFAIL;
4826:Source/tasks.c **** 					}
4827:Source/tasks.c **** 					break;
 4804              		.loc 1 4827 0
 4805 008a 03E0     		b	.L328
 4806              	.L329:
4825:Source/tasks.c **** 					}
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 175
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 175
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 4807              		.loc 1 4825 0
 4808 008c 0023     		movs	r3, #0
 4809 008e FB61     		str	r3, [r7, #28]
 4810              		.loc 1 4827 0
 4811 0090 00E0     		b	.L328
 4812              	.L333:
4828:Source/tasks.c **** 
4829:Source/tasks.c **** 				case eNoAction:
4830:Source/tasks.c **** 					/* The task is being notified without its notify value being
4831:Source/tasks.c **** 					updated. */
4832:Source/tasks.c **** 					break;
4833:Source/tasks.c **** 
4834:Source/tasks.c **** 				default:
4835:Source/tasks.c **** 					/* Should not get here if all enums are handled.
4836:Source/tasks.c **** 					Artificially force an assert by testing a value the
4837:Source/tasks.c **** 					compiler can't assume is const. */
4838:Source/tasks.c **** 					configASSERT( pxTCB->ulNotifiedValue == ~0UL );
4839:Source/tasks.c **** 
4840:Source/tasks.c **** 					break;
 4813              		.loc 1 4840 0
 4814 0092 00BF     		nop
 4815              	.L328:
4841:Source/tasks.c **** 			}
4842:Source/tasks.c **** 
4843:Source/tasks.c **** 			traceTASK_NOTIFY();
4844:Source/tasks.c **** 
4845:Source/tasks.c **** 			/* If the task is in the blocked state specifically to wait for a
4846:Source/tasks.c **** 			notification then unblock it now. */
4847:Source/tasks.c **** 			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 4816              		.loc 1 4847 0
 4817 0094 FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 4818 0096 012B     		cmp	r3, #1
 4819 0098 2AD1     		bne	.L331
4848:Source/tasks.c **** 			{
4849:Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 4820              		.loc 1 4849 0
 4821 009a BB69     		ldr	r3, [r7, #24]
 4822 009c 0433     		adds	r3, r3, #4
 4823 009e 1846     		mov	r0, r3
 4824 00a0 FFF7FEFF 		bl	uxListRemove
4850:Source/tasks.c **** 				prvAddTaskToReadyList( pxTCB );
 4825              		.loc 1 4850 0
 4826 00a4 BB69     		ldr	r3, [r7, #24]
 4827 00a6 DB6A     		ldr	r3, [r3, #44]
 4828 00a8 0122     		movs	r2, #1
 4829 00aa 9A40     		lsls	r2, r2, r3
 4830 00ac 144B     		ldr	r3, .L334
 4831 00ae 1B68     		ldr	r3, [r3]
 4832 00b0 1343     		orrs	r3, r3, r2
 4833 00b2 134A     		ldr	r2, .L334
 4834 00b4 1360     		str	r3, [r2]
 4835 00b6 BB69     		ldr	r3, [r7, #24]
 4836 00b8 DA6A     		ldr	r2, [r3, #44]
 4837 00ba 1346     		mov	r3, r2
 4838 00bc 9B00     		lsls	r3, r3, #2
 4839 00be 1344     		add	r3, r3, r2
 4840 00c0 9B00     		lsls	r3, r3, #2
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 176
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 176
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 4841 00c2 104A     		ldr	r2, .L334+4
 4842 00c4 1A44     		add	r2, r2, r3
 4843 00c6 BB69     		ldr	r3, [r7, #24]
 4844 00c8 0433     		adds	r3, r3, #4
 4845 00ca 1946     		mov	r1, r3
 4846 00cc 1046     		mov	r0, r2
 4847 00ce FFF7FEFF 		bl	vListInsertEnd
4851:Source/tasks.c **** 
4852:Source/tasks.c **** 				/* The task should not have been on an event list. */
4853:Source/tasks.c **** 				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
4854:Source/tasks.c **** 
4855:Source/tasks.c **** 				#if( configUSE_TICKLESS_IDLE != 0 )
4856:Source/tasks.c **** 				{
4857:Source/tasks.c **** 					/* If a task is blocked waiting for a notification then
4858:Source/tasks.c **** 					xNextTaskUnblockTime might be set to the blocked task's time
4859:Source/tasks.c **** 					out time.  If the task is unblocked for a reason other than
4860:Source/tasks.c **** 					a timeout xNextTaskUnblockTime is normally left unchanged,
4861:Source/tasks.c **** 					because it will automatically get reset to a new value when
4862:Source/tasks.c **** 					the tick count equals xNextTaskUnblockTime.  However if
4863:Source/tasks.c **** 					tickless idling is used it might be more important to enter
4864:Source/tasks.c **** 					sleep mode at the earliest possible time - so reset
4865:Source/tasks.c **** 					xNextTaskUnblockTime here to ensure it is updated at the
4866:Source/tasks.c **** 					earliest possible time. */
4867:Source/tasks.c **** 					prvResetNextTaskUnblockTime();
4868:Source/tasks.c **** 				}
4869:Source/tasks.c **** 				#endif
4870:Source/tasks.c **** 
4871:Source/tasks.c **** 				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 4848              		.loc 1 4871 0
 4849 00d2 BB69     		ldr	r3, [r7, #24]
 4850 00d4 DA6A     		ldr	r2, [r3, #44]
 4851 00d6 0C4B     		ldr	r3, .L334+8
 4852 00d8 1B68     		ldr	r3, [r3]
 4853 00da DB6A     		ldr	r3, [r3, #44]
 4854 00dc 9A42     		cmp	r2, r3
 4855 00de 07D9     		bls	.L331
4872:Source/tasks.c **** 				{
4873:Source/tasks.c **** 					/* The notified task has a priority above the currently
4874:Source/tasks.c **** 					executing task so a yield is required. */
4875:Source/tasks.c **** 					taskYIELD_IF_USING_PREEMPTION();
 4856              		.loc 1 4875 0
 4857 00e0 0A4B     		ldr	r3, .L334+12
 4858 00e2 4FF08052 		mov	r2, #268435456
 4859 00e6 1A60     		str	r2, [r3]
 4860              		.syntax unified
 4861              	@ 4875 "Source\tasks.c" 1
 4862 00e8 BFF34F8F 		dsb
 4863              	@ 0 "" 2
 4864              	@ 4875 "Source\tasks.c" 1
 4865 00ec BFF36F8F 		isb
 4866              	@ 0 "" 2
 4867              		.thumb
 4868              		.syntax unified
 4869              	.L331:
4876:Source/tasks.c **** 				}
4877:Source/tasks.c **** 				else
4878:Source/tasks.c **** 				{
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 177
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 177
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


4879:Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4880:Source/tasks.c **** 				}
4881:Source/tasks.c **** 			}
4882:Source/tasks.c **** 			else
4883:Source/tasks.c **** 			{
4884:Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4885:Source/tasks.c **** 			}
4886:Source/tasks.c **** 		}
4887:Source/tasks.c **** 		taskEXIT_CRITICAL();
 4870              		.loc 1 4887 0
 4871 00f0 FFF7FEFF 		bl	vPortExitCritical
4888:Source/tasks.c **** 
4889:Source/tasks.c **** 		return xReturn;
 4872              		.loc 1 4889 0
 4873 00f4 FB69     		ldr	r3, [r7, #28]
4890:Source/tasks.c **** 	}
 4874              		.loc 1 4890 0
 4875 00f6 1846     		mov	r0, r3
 4876 00f8 2037     		adds	r7, r7, #32
 4877              		.cfi_def_cfa_offset 8
 4878 00fa BD46     		mov	sp, r7
 4879              		.cfi_def_cfa_register 13
 4880              		@ sp needed
 4881 00fc 80BD     		pop	{r7, pc}
 4882              	.L335:
 4883 00fe 00BF     		.align	2
 4884              	.L334:
 4885 0100 E0000000 		.word	uxTopReadyPriority
 4886 0104 04000000 		.word	pxReadyTasksLists
 4887 0108 00000000 		.word	pxCurrentTCB
 4888 010c 04ED00E0 		.word	-536810236
 4889              		.cfi_endproc
 4890              	.LFE116:
 4891              		.size	xTaskGenericNotify, .-xTaskGenericNotify
 4892              		.section	.text.xTaskGenericNotifyFromISR,"ax",%progbits
 4893              		.align	2
 4894              		.global	xTaskGenericNotifyFromISR
 4895              		.thumb
 4896              		.thumb_func
 4897              		.type	xTaskGenericNotifyFromISR, %function
 4898              	xTaskGenericNotifyFromISR:
 4899              	.LFB117:
4891:Source/tasks.c **** 
4892:Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4893:Source/tasks.c **** /*-----------------------------------------------------------*/
4894:Source/tasks.c **** 
4895:Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4896:Source/tasks.c **** 
4897:Source/tasks.c **** 	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction 
4898:Source/tasks.c **** 	{
 4900              		.loc 1 4898 0
 4901              		.cfi_startproc
 4902              		@ args = 4, pretend = 0, frame = 48
 4903              		@ frame_needed = 1, uses_anonymous_args = 0
 4904 0000 80B5     		push	{r7, lr}
 4905              		.cfi_def_cfa_offset 8
 4906              		.cfi_offset 7, -8
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 178
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 178
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 4907              		.cfi_offset 14, -4
 4908 0002 8CB0     		sub	sp, sp, #48
 4909              		.cfi_def_cfa_offset 56
 4910 0004 00AF     		add	r7, sp, #0
 4911              		.cfi_def_cfa_register 7
 4912 0006 F860     		str	r0, [r7, #12]
 4913 0008 B960     		str	r1, [r7, #8]
 4914 000a 3B60     		str	r3, [r7]
 4915 000c 1346     		mov	r3, r2
 4916 000e FB71     		strb	r3, [r7, #7]
4899:Source/tasks.c **** 	TCB_t * pxTCB;
4900:Source/tasks.c **** 	uint8_t ucOriginalNotifyState;
4901:Source/tasks.c **** 	BaseType_t xReturn = pdPASS;
 4917              		.loc 1 4901 0
 4918 0010 0123     		movs	r3, #1
 4919 0012 FB62     		str	r3, [r7, #44]
4902:Source/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
4903:Source/tasks.c **** 
4904:Source/tasks.c **** 		configASSERT( xTaskToNotify );
4905:Source/tasks.c **** 
4906:Source/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
4907:Source/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
4908:Source/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
4909:Source/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
4910:Source/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
4911:Source/tasks.c **** 		is defined in FreeRTOSConfig.h then
4912:Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
4913:Source/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
4914:Source/tasks.c **** 		been assigned a priority above the configured maximum system call
4915:Source/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
4916:Source/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
4917:Source/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
4918:Source/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
4919:Source/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
4920:Source/tasks.c **** 		provided on the following link:
4921:Source/tasks.c **** 		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
4922:Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
4923:Source/tasks.c **** 
4924:Source/tasks.c **** 		pxTCB = xTaskToNotify;
 4920              		.loc 1 4924 0
 4921 0014 FB68     		ldr	r3, [r7, #12]
 4922 0016 BB62     		str	r3, [r7, #40]
 4923              	.LBB51:
 4924              	.LBB52:
 213:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	(
 4925              		.loc 2 213 0
 4926              		.syntax unified
 4927              	@ 213 ".\Source\portable\GCC\ARM_CM3/portmacro.h" 1
 4928 0018 EFF31182 			mrs r2, basepri											
 4929 001c 4FF0A003 		mov r3, #160												
 4930 0020 83F31188 		msr basepri, r3											
 4931 0024 BFF36F8F 		isb														
 4932 0028 BFF34F8F 		dsb														
 4933              	
 4934              	@ 0 "" 2
 4935              		.thumb
 4936              		.syntax unified
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 179
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 179
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 4937 002c BA61     		str	r2, [r7, #24]
 4938 002e 7B61     		str	r3, [r7, #20]
 225:.\Source\portable\GCC\ARM_CM3/portmacro.h **** }
 4939              		.loc 2 225 0
 4940 0030 BB69     		ldr	r3, [r7, #24]
 4941              	.LBE52:
 4942              	.LBE51:
4925:Source/tasks.c **** 
4926:Source/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 4943              		.loc 1 4926 0
 4944 0032 3B62     		str	r3, [r7, #32]
4927:Source/tasks.c **** 		{
4928:Source/tasks.c **** 			if( pulPreviousNotificationValue != NULL )
 4945              		.loc 1 4928 0
 4946 0034 3B68     		ldr	r3, [r7]
 4947 0036 002B     		cmp	r3, #0
 4948 0038 03D0     		beq	.L338
4929:Source/tasks.c **** 			{
4930:Source/tasks.c **** 				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
 4949              		.loc 1 4930 0
 4950 003a BB6A     		ldr	r3, [r7, #40]
 4951 003c 9A6C     		ldr	r2, [r3, #72]
 4952 003e 3B68     		ldr	r3, [r7]
 4953 0040 1A60     		str	r2, [r3]
 4954              	.L338:
4931:Source/tasks.c **** 			}
4932:Source/tasks.c **** 
4933:Source/tasks.c **** 			ucOriginalNotifyState = pxTCB->ucNotifyState;
 4955              		.loc 1 4933 0
 4956 0042 BB6A     		ldr	r3, [r7, #40]
 4957 0044 93F84C30 		ldrb	r3, [r3, #76]
 4958 0048 FB77     		strb	r3, [r7, #31]
4934:Source/tasks.c **** 			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 4959              		.loc 1 4934 0
 4960 004a BB6A     		ldr	r3, [r7, #40]
 4961 004c 0222     		movs	r2, #2
 4962 004e 83F84C20 		strb	r2, [r3, #76]
4935:Source/tasks.c **** 
4936:Source/tasks.c **** 			switch( eAction )
 4963              		.loc 1 4936 0
 4964 0052 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 4965 0054 042B     		cmp	r3, #4
 4966 0056 28D8     		bhi	.L354
 4967 0058 01A2     		adr	r2, .L341
 4968 005a 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 4969 005e 00BF     		.p2align 2
 4970              	.L341:
 4971 0060 AB000000 		.word	.L354+1
 4972 0064 75000000 		.word	.L342+1
 4973 0068 83000000 		.word	.L343+1
 4974 006c 8F000000 		.word	.L344+1
 4975 0070 97000000 		.word	.L345+1
 4976              		.p2align 1
 4977              	.L342:
4937:Source/tasks.c **** 			{
4938:Source/tasks.c **** 				case eSetBits	:
4939:Source/tasks.c **** 					pxTCB->ulNotifiedValue |= ulValue;
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 180
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 180
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 4978              		.loc 1 4939 0
 4979 0074 BB6A     		ldr	r3, [r7, #40]
 4980 0076 9A6C     		ldr	r2, [r3, #72]
 4981 0078 BB68     		ldr	r3, [r7, #8]
 4982 007a 1A43     		orrs	r2, r2, r3
 4983 007c BB6A     		ldr	r3, [r7, #40]
 4984 007e 9A64     		str	r2, [r3, #72]
4940:Source/tasks.c **** 					break;
 4985              		.loc 1 4940 0
 4986 0080 14E0     		b	.L346
 4987              	.L343:
4941:Source/tasks.c **** 
4942:Source/tasks.c **** 				case eIncrement	:
4943:Source/tasks.c **** 					( pxTCB->ulNotifiedValue )++;
 4988              		.loc 1 4943 0
 4989 0082 BB6A     		ldr	r3, [r7, #40]
 4990 0084 9B6C     		ldr	r3, [r3, #72]
 4991 0086 5A1C     		adds	r2, r3, #1
 4992 0088 BB6A     		ldr	r3, [r7, #40]
 4993 008a 9A64     		str	r2, [r3, #72]
4944:Source/tasks.c **** 					break;
 4994              		.loc 1 4944 0
 4995 008c 0EE0     		b	.L346
 4996              	.L344:
4945:Source/tasks.c **** 
4946:Source/tasks.c **** 				case eSetValueWithOverwrite	:
4947:Source/tasks.c **** 					pxTCB->ulNotifiedValue = ulValue;
 4997              		.loc 1 4947 0
 4998 008e BB6A     		ldr	r3, [r7, #40]
 4999 0090 BA68     		ldr	r2, [r7, #8]
 5000 0092 9A64     		str	r2, [r3, #72]
4948:Source/tasks.c **** 					break;
 5001              		.loc 1 4948 0
 5002 0094 0AE0     		b	.L346
 5003              	.L345:
4949:Source/tasks.c **** 
4950:Source/tasks.c **** 				case eSetValueWithoutOverwrite :
4951:Source/tasks.c **** 					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
 5004              		.loc 1 4951 0
 5005 0096 FB7F     		ldrb	r3, [r7, #31]	@ zero_extendqisi2
 5006 0098 022B     		cmp	r3, #2
 5007 009a 03D0     		beq	.L347
4952:Source/tasks.c **** 					{
4953:Source/tasks.c **** 						pxTCB->ulNotifiedValue = ulValue;
 5008              		.loc 1 4953 0
 5009 009c BB6A     		ldr	r3, [r7, #40]
 5010 009e BA68     		ldr	r2, [r7, #8]
 5011 00a0 9A64     		str	r2, [r3, #72]
4954:Source/tasks.c **** 					}
4955:Source/tasks.c **** 					else
4956:Source/tasks.c **** 					{
4957:Source/tasks.c **** 						/* The value could not be written to the task. */
4958:Source/tasks.c **** 						xReturn = pdFAIL;
4959:Source/tasks.c **** 					}
4960:Source/tasks.c **** 					break;
 5012              		.loc 1 4960 0
 5013 00a2 03E0     		b	.L346
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 181
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 181
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 5014              	.L347:
4958:Source/tasks.c **** 					}
 5015              		.loc 1 4958 0
 5016 00a4 0023     		movs	r3, #0
 5017 00a6 FB62     		str	r3, [r7, #44]
 5018              		.loc 1 4960 0
 5019 00a8 00E0     		b	.L346
 5020              	.L354:
4961:Source/tasks.c **** 
4962:Source/tasks.c **** 				case eNoAction :
4963:Source/tasks.c **** 					/* The task is being notified without its notify value being
4964:Source/tasks.c **** 					updated. */
4965:Source/tasks.c **** 					break;
4966:Source/tasks.c **** 
4967:Source/tasks.c **** 				default:
4968:Source/tasks.c **** 					/* Should not get here if all enums are handled.
4969:Source/tasks.c **** 					Artificially force an assert by testing a value the
4970:Source/tasks.c **** 					compiler can't assume is const. */
4971:Source/tasks.c **** 					configASSERT( pxTCB->ulNotifiedValue == ~0UL );
4972:Source/tasks.c **** 					break;
 5021              		.loc 1 4972 0
 5022 00aa 00BF     		nop
 5023              	.L346:
4973:Source/tasks.c **** 			}
4974:Source/tasks.c **** 
4975:Source/tasks.c **** 			traceTASK_NOTIFY_FROM_ISR();
4976:Source/tasks.c **** 
4977:Source/tasks.c **** 			/* If the task is in the blocked state specifically to wait for a
4978:Source/tasks.c **** 			notification then unblock it now. */
4979:Source/tasks.c **** 			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 5024              		.loc 1 4979 0
 5025 00ac FB7F     		ldrb	r3, [r7, #31]	@ zero_extendqisi2
 5026 00ae 012B     		cmp	r3, #1
 5027 00b0 36D1     		bne	.L349
4980:Source/tasks.c **** 			{
4981:Source/tasks.c **** 				/* The task should not have been on an event list. */
4982:Source/tasks.c **** 				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
4983:Source/tasks.c **** 
4984:Source/tasks.c **** 				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 5028              		.loc 1 4984 0
 5029 00b2 204B     		ldr	r3, .L355
 5030 00b4 1B68     		ldr	r3, [r3]
 5031 00b6 002B     		cmp	r3, #0
 5032 00b8 1CD1     		bne	.L350
4985:Source/tasks.c **** 				{
4986:Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 5033              		.loc 1 4986 0
 5034 00ba BB6A     		ldr	r3, [r7, #40]
 5035 00bc 0433     		adds	r3, r3, #4
 5036 00be 1846     		mov	r0, r3
 5037 00c0 FFF7FEFF 		bl	uxListRemove
4987:Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 5038              		.loc 1 4987 0
 5039 00c4 BB6A     		ldr	r3, [r7, #40]
 5040 00c6 DB6A     		ldr	r3, [r3, #44]
 5041 00c8 0122     		movs	r2, #1
 5042 00ca 9A40     		lsls	r2, r2, r3
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 182
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 182
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 5043 00cc 1A4B     		ldr	r3, .L355+4
 5044 00ce 1B68     		ldr	r3, [r3]
 5045 00d0 1343     		orrs	r3, r3, r2
 5046 00d2 194A     		ldr	r2, .L355+4
 5047 00d4 1360     		str	r3, [r2]
 5048 00d6 BB6A     		ldr	r3, [r7, #40]
 5049 00d8 DA6A     		ldr	r2, [r3, #44]
 5050 00da 1346     		mov	r3, r2
 5051 00dc 9B00     		lsls	r3, r3, #2
 5052 00de 1344     		add	r3, r3, r2
 5053 00e0 9B00     		lsls	r3, r3, #2
 5054 00e2 164A     		ldr	r2, .L355+8
 5055 00e4 1A44     		add	r2, r2, r3
 5056 00e6 BB6A     		ldr	r3, [r7, #40]
 5057 00e8 0433     		adds	r3, r3, #4
 5058 00ea 1946     		mov	r1, r3
 5059 00ec 1046     		mov	r0, r2
 5060 00ee FFF7FEFF 		bl	vListInsertEnd
 5061 00f2 05E0     		b	.L351
 5062              	.L350:
4988:Source/tasks.c **** 				}
4989:Source/tasks.c **** 				else
4990:Source/tasks.c **** 				{
4991:Source/tasks.c **** 					/* The delayed and ready lists cannot be accessed, so hold
4992:Source/tasks.c **** 					this task pending until the scheduler is resumed. */
4993:Source/tasks.c **** 					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 5063              		.loc 1 4993 0
 5064 00f4 BB6A     		ldr	r3, [r7, #40]
 5065 00f6 1833     		adds	r3, r3, #24
 5066 00f8 1946     		mov	r1, r3
 5067 00fa 1148     		ldr	r0, .L355+12
 5068 00fc FFF7FEFF 		bl	vListInsertEnd
 5069              	.L351:
4994:Source/tasks.c **** 				}
4995:Source/tasks.c **** 
4996:Source/tasks.c **** 				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 5070              		.loc 1 4996 0
 5071 0100 BB6A     		ldr	r3, [r7, #40]
 5072 0102 DA6A     		ldr	r2, [r3, #44]
 5073 0104 0F4B     		ldr	r3, .L355+16
 5074 0106 1B68     		ldr	r3, [r3]
 5075 0108 DB6A     		ldr	r3, [r3, #44]
 5076 010a 9A42     		cmp	r2, r3
 5077 010c 08D9     		bls	.L349
4997:Source/tasks.c **** 				{
4998:Source/tasks.c **** 					/* The notified task has a priority above the currently
4999:Source/tasks.c **** 					executing task so a yield is required. */
5000:Source/tasks.c **** 					if( pxHigherPriorityTaskWoken != NULL )
 5078              		.loc 1 5000 0
 5079 010e BB6B     		ldr	r3, [r7, #56]
 5080 0110 002B     		cmp	r3, #0
 5081 0112 02D0     		beq	.L352
5001:Source/tasks.c **** 					{
5002:Source/tasks.c **** 						*pxHigherPriorityTaskWoken = pdTRUE;
 5082              		.loc 1 5002 0
 5083 0114 BB6B     		ldr	r3, [r7, #56]
 5084 0116 0122     		movs	r2, #1
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 183
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 183
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 5085 0118 1A60     		str	r2, [r3]
 5086              	.L352:
5003:Source/tasks.c **** 					}
5004:Source/tasks.c **** 
5005:Source/tasks.c **** 					/* Mark that a yield is pending in case the user is not
5006:Source/tasks.c **** 					using the "xHigherPriorityTaskWoken" parameter to an ISR
5007:Source/tasks.c **** 					safe FreeRTOS function. */
5008:Source/tasks.c **** 					xYieldPending = pdTRUE;
 5087              		.loc 1 5008 0
 5088 011a 0B4B     		ldr	r3, .L355+20
 5089 011c 0122     		movs	r2, #1
 5090 011e 1A60     		str	r2, [r3]
 5091              	.L349:
 5092 0120 3B6A     		ldr	r3, [r7, #32]
 5093 0122 7B62     		str	r3, [r7, #36]
 5094              	.LBB53:
 5095              	.LBB54:
 5096              		.loc 2 231 0
 5097 0124 7B6A     		ldr	r3, [r7, #36]
 5098              		.syntax unified
 5099              	@ 231 ".\Source\portable\GCC\ARM_CM3/portmacro.h" 1
 5100 0126 83F31188 			msr basepri, r3	
 5101              	@ 0 "" 2
 5102              		.thumb
 5103              		.syntax unified
 5104              	.LBE54:
 5105              	.LBE53:
5009:Source/tasks.c **** 				}
5010:Source/tasks.c **** 				else
5011:Source/tasks.c **** 				{
5012:Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
5013:Source/tasks.c **** 				}
5014:Source/tasks.c **** 			}
5015:Source/tasks.c **** 		}
5016:Source/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
5017:Source/tasks.c **** 
5018:Source/tasks.c **** 		return xReturn;
 5106              		.loc 1 5018 0
 5107 012a FB6A     		ldr	r3, [r7, #44]
5019:Source/tasks.c **** 	}
 5108              		.loc 1 5019 0
 5109 012c 1846     		mov	r0, r3
 5110 012e 3037     		adds	r7, r7, #48
 5111              		.cfi_def_cfa_offset 8
 5112 0130 BD46     		mov	sp, r7
 5113              		.cfi_def_cfa_register 13
 5114              		@ sp needed
 5115 0132 80BD     		pop	{r7, pc}
 5116              	.L356:
 5117              		.align	2
 5118              	.L355:
 5119 0134 00010000 		.word	uxSchedulerSuspended
 5120 0138 E0000000 		.word	uxTopReadyPriority
 5121 013c 04000000 		.word	pxReadyTasksLists
 5122 0140 98000000 		.word	xPendingReadyList
 5123 0144 00000000 		.word	pxCurrentTCB
 5124 0148 EC000000 		.word	xYieldPending
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 184
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 184
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 5125              		.cfi_endproc
 5126              	.LFE117:
 5127              		.size	xTaskGenericNotifyFromISR, .-xTaskGenericNotifyFromISR
 5128              		.section	.text.vTaskNotifyGiveFromISR,"ax",%progbits
 5129              		.align	2
 5130              		.global	vTaskNotifyGiveFromISR
 5131              		.thumb
 5132              		.thumb_func
 5133              		.type	vTaskNotifyGiveFromISR, %function
 5134              	vTaskNotifyGiveFromISR:
 5135              	.LFB118:
5020:Source/tasks.c **** 
5021:Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
5022:Source/tasks.c **** /*-----------------------------------------------------------*/
5023:Source/tasks.c **** 
5024:Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
5025:Source/tasks.c **** 
5026:Source/tasks.c **** 	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
5027:Source/tasks.c **** 	{
 5136              		.loc 1 5027 0
 5137              		.cfi_startproc
 5138              		@ args = 0, pretend = 0, frame = 32
 5139              		@ frame_needed = 1, uses_anonymous_args = 0
 5140 0000 80B5     		push	{r7, lr}
 5141              		.cfi_def_cfa_offset 8
 5142              		.cfi_offset 7, -8
 5143              		.cfi_offset 14, -4
 5144 0002 88B0     		sub	sp, sp, #32
 5145              		.cfi_def_cfa_offset 40
 5146 0004 00AF     		add	r7, sp, #0
 5147              		.cfi_def_cfa_register 7
 5148 0006 7860     		str	r0, [r7, #4]
 5149 0008 3960     		str	r1, [r7]
5028:Source/tasks.c **** 	TCB_t * pxTCB;
5029:Source/tasks.c **** 	uint8_t ucOriginalNotifyState;
5030:Source/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
5031:Source/tasks.c **** 
5032:Source/tasks.c **** 		configASSERT( xTaskToNotify );
5033:Source/tasks.c **** 
5034:Source/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
5035:Source/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
5036:Source/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
5037:Source/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
5038:Source/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
5039:Source/tasks.c **** 		is defined in FreeRTOSConfig.h then
5040:Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
5041:Source/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
5042:Source/tasks.c **** 		been assigned a priority above the configured maximum system call
5043:Source/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
5044:Source/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
5045:Source/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
5046:Source/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
5047:Source/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
5048:Source/tasks.c **** 		provided on the following link:
5049:Source/tasks.c **** 		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
5050:Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
5051:Source/tasks.c **** 
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 185
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 185
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


5052:Source/tasks.c **** 		pxTCB = xTaskToNotify;
 5150              		.loc 1 5052 0
 5151 000a 7B68     		ldr	r3, [r7, #4]
 5152 000c FB61     		str	r3, [r7, #28]
 5153              	.LBB55:
 5154              	.LBB56:
 213:.\Source\portable\GCC\ARM_CM3/portmacro.h **** 	(
 5155              		.loc 2 213 0
 5156              		.syntax unified
 5157              	@ 213 ".\Source\portable\GCC\ARM_CM3/portmacro.h" 1
 5158 000e EFF31182 			mrs r2, basepri											
 5159 0012 4FF0A003 		mov r3, #160												
 5160 0016 83F31188 		msr basepri, r3											
 5161 001a BFF36F8F 		isb														
 5162 001e BFF34F8F 		dsb														
 5163              	
 5164              	@ 0 "" 2
 5165              		.thumb
 5166              		.syntax unified
 5167 0022 FA60     		str	r2, [r7, #12]
 5168 0024 BB60     		str	r3, [r7, #8]
 225:.\Source\portable\GCC\ARM_CM3/portmacro.h **** }
 5169              		.loc 2 225 0
 5170 0026 FB68     		ldr	r3, [r7, #12]
 5171              	.LBE56:
 5172              	.LBE55:
5053:Source/tasks.c **** 
5054:Source/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 5173              		.loc 1 5054 0
 5174 0028 7B61     		str	r3, [r7, #20]
5055:Source/tasks.c **** 		{
5056:Source/tasks.c **** 			ucOriginalNotifyState = pxTCB->ucNotifyState;
 5175              		.loc 1 5056 0
 5176 002a FB69     		ldr	r3, [r7, #28]
 5177 002c 93F84C30 		ldrb	r3, [r3, #76]
 5178 0030 FB74     		strb	r3, [r7, #19]
5057:Source/tasks.c **** 			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 5179              		.loc 1 5057 0
 5180 0032 FB69     		ldr	r3, [r7, #28]
 5181 0034 0222     		movs	r2, #2
 5182 0036 83F84C20 		strb	r2, [r3, #76]
5058:Source/tasks.c **** 
5059:Source/tasks.c **** 			/* 'Giving' is equivalent to incrementing a count in a counting
5060:Source/tasks.c **** 			semaphore. */
5061:Source/tasks.c **** 			( pxTCB->ulNotifiedValue )++;
 5183              		.loc 1 5061 0
 5184 003a FB69     		ldr	r3, [r7, #28]
 5185 003c 9B6C     		ldr	r3, [r3, #72]
 5186 003e 5A1C     		adds	r2, r3, #1
 5187 0040 FB69     		ldr	r3, [r7, #28]
 5188 0042 9A64     		str	r2, [r3, #72]
5062:Source/tasks.c **** 
5063:Source/tasks.c **** 			traceTASK_NOTIFY_GIVE_FROM_ISR();
5064:Source/tasks.c **** 
5065:Source/tasks.c **** 			/* If the task is in the blocked state specifically to wait for a
5066:Source/tasks.c **** 			notification then unblock it now. */
5067:Source/tasks.c **** 			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 186
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 186
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 5189              		.loc 1 5067 0
 5190 0044 FB7C     		ldrb	r3, [r7, #19]	@ zero_extendqisi2
 5191 0046 012B     		cmp	r3, #1
 5192 0048 36D1     		bne	.L359
5068:Source/tasks.c **** 			{
5069:Source/tasks.c **** 				/* The task should not have been on an event list. */
5070:Source/tasks.c **** 				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
5071:Source/tasks.c **** 
5072:Source/tasks.c **** 				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 5193              		.loc 1 5072 0
 5194 004a 204B     		ldr	r3, .L363
 5195 004c 1B68     		ldr	r3, [r3]
 5196 004e 002B     		cmp	r3, #0
 5197 0050 1CD1     		bne	.L360
5073:Source/tasks.c **** 				{
5074:Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 5198              		.loc 1 5074 0
 5199 0052 FB69     		ldr	r3, [r7, #28]
 5200 0054 0433     		adds	r3, r3, #4
 5201 0056 1846     		mov	r0, r3
 5202 0058 FFF7FEFF 		bl	uxListRemove
5075:Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 5203              		.loc 1 5075 0
 5204 005c FB69     		ldr	r3, [r7, #28]
 5205 005e DB6A     		ldr	r3, [r3, #44]
 5206 0060 0122     		movs	r2, #1
 5207 0062 9A40     		lsls	r2, r2, r3
 5208 0064 1A4B     		ldr	r3, .L363+4
 5209 0066 1B68     		ldr	r3, [r3]
 5210 0068 1343     		orrs	r3, r3, r2
 5211 006a 194A     		ldr	r2, .L363+4
 5212 006c 1360     		str	r3, [r2]
 5213 006e FB69     		ldr	r3, [r7, #28]
 5214 0070 DA6A     		ldr	r2, [r3, #44]
 5215 0072 1346     		mov	r3, r2
 5216 0074 9B00     		lsls	r3, r3, #2
 5217 0076 1344     		add	r3, r3, r2
 5218 0078 9B00     		lsls	r3, r3, #2
 5219 007a 164A     		ldr	r2, .L363+8
 5220 007c 1A44     		add	r2, r2, r3
 5221 007e FB69     		ldr	r3, [r7, #28]
 5222 0080 0433     		adds	r3, r3, #4
 5223 0082 1946     		mov	r1, r3
 5224 0084 1046     		mov	r0, r2
 5225 0086 FFF7FEFF 		bl	vListInsertEnd
 5226 008a 05E0     		b	.L361
 5227              	.L360:
5076:Source/tasks.c **** 				}
5077:Source/tasks.c **** 				else
5078:Source/tasks.c **** 				{
5079:Source/tasks.c **** 					/* The delayed and ready lists cannot be accessed, so hold
5080:Source/tasks.c **** 					this task pending until the scheduler is resumed. */
5081:Source/tasks.c **** 					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 5228              		.loc 1 5081 0
 5229 008c FB69     		ldr	r3, [r7, #28]
 5230 008e 1833     		adds	r3, r3, #24
 5231 0090 1946     		mov	r1, r3
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 187
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 187
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 5232 0092 1148     		ldr	r0, .L363+12
 5233 0094 FFF7FEFF 		bl	vListInsertEnd
 5234              	.L361:
5082:Source/tasks.c **** 				}
5083:Source/tasks.c **** 
5084:Source/tasks.c **** 				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 5235              		.loc 1 5084 0
 5236 0098 FB69     		ldr	r3, [r7, #28]
 5237 009a DA6A     		ldr	r2, [r3, #44]
 5238 009c 0F4B     		ldr	r3, .L363+16
 5239 009e 1B68     		ldr	r3, [r3]
 5240 00a0 DB6A     		ldr	r3, [r3, #44]
 5241 00a2 9A42     		cmp	r2, r3
 5242 00a4 08D9     		bls	.L359
5085:Source/tasks.c **** 				{
5086:Source/tasks.c **** 					/* The notified task has a priority above the currently
5087:Source/tasks.c **** 					executing task so a yield is required. */
5088:Source/tasks.c **** 					if( pxHigherPriorityTaskWoken != NULL )
 5243              		.loc 1 5088 0
 5244 00a6 3B68     		ldr	r3, [r7]
 5245 00a8 002B     		cmp	r3, #0
 5246 00aa 02D0     		beq	.L362
5089:Source/tasks.c **** 					{
5090:Source/tasks.c **** 						*pxHigherPriorityTaskWoken = pdTRUE;
 5247              		.loc 1 5090 0
 5248 00ac 3B68     		ldr	r3, [r7]
 5249 00ae 0122     		movs	r2, #1
 5250 00b0 1A60     		str	r2, [r3]
 5251              	.L362:
5091:Source/tasks.c **** 					}
5092:Source/tasks.c **** 
5093:Source/tasks.c **** 					/* Mark that a yield is pending in case the user is not
5094:Source/tasks.c **** 					using the "xHigherPriorityTaskWoken" parameter in an ISR
5095:Source/tasks.c **** 					safe FreeRTOS function. */
5096:Source/tasks.c **** 					xYieldPending = pdTRUE;
 5252              		.loc 1 5096 0
 5253 00b2 0B4B     		ldr	r3, .L363+20
 5254 00b4 0122     		movs	r2, #1
 5255 00b6 1A60     		str	r2, [r3]
 5256              	.L359:
 5257 00b8 7B69     		ldr	r3, [r7, #20]
 5258 00ba BB61     		str	r3, [r7, #24]
 5259              	.LBB57:
 5260              	.LBB58:
 5261              		.loc 2 231 0
 5262 00bc BB69     		ldr	r3, [r7, #24]
 5263              		.syntax unified
 5264              	@ 231 ".\Source\portable\GCC\ARM_CM3/portmacro.h" 1
 5265 00be 83F31188 			msr basepri, r3	
 5266              	@ 0 "" 2
 5267              		.thumb
 5268              		.syntax unified
 5269              	.LBE58:
 5270              	.LBE57:
5097:Source/tasks.c **** 				}
5098:Source/tasks.c **** 				else
5099:Source/tasks.c **** 				{
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 188
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 188
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


5100:Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
5101:Source/tasks.c **** 				}
5102:Source/tasks.c **** 			}
5103:Source/tasks.c **** 		}
5104:Source/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
5105:Source/tasks.c **** 	}
 5271              		.loc 1 5105 0
 5272 00c2 00BF     		nop
 5273 00c4 2037     		adds	r7, r7, #32
 5274              		.cfi_def_cfa_offset 8
 5275 00c6 BD46     		mov	sp, r7
 5276              		.cfi_def_cfa_register 13
 5277              		@ sp needed
 5278 00c8 80BD     		pop	{r7, pc}
 5279              	.L364:
 5280 00ca 00BF     		.align	2
 5281              	.L363:
 5282 00cc 00010000 		.word	uxSchedulerSuspended
 5283 00d0 E0000000 		.word	uxTopReadyPriority
 5284 00d4 04000000 		.word	pxReadyTasksLists
 5285 00d8 98000000 		.word	xPendingReadyList
 5286 00dc 00000000 		.word	pxCurrentTCB
 5287 00e0 EC000000 		.word	xYieldPending
 5288              		.cfi_endproc
 5289              	.LFE118:
 5290              		.size	vTaskNotifyGiveFromISR, .-vTaskNotifyGiveFromISR
 5291              		.section	.text.xTaskNotifyStateClear,"ax",%progbits
 5292              		.align	2
 5293              		.global	xTaskNotifyStateClear
 5294              		.thumb
 5295              		.thumb_func
 5296              		.type	xTaskNotifyStateClear, %function
 5297              	xTaskNotifyStateClear:
 5298              	.LFB119:
5106:Source/tasks.c **** 
5107:Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
5108:Source/tasks.c **** /*-----------------------------------------------------------*/
5109:Source/tasks.c **** 
5110:Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
5111:Source/tasks.c **** 
5112:Source/tasks.c **** 	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
5113:Source/tasks.c **** 	{
 5299              		.loc 1 5113 0
 5300              		.cfi_startproc
 5301              		@ args = 0, pretend = 0, frame = 16
 5302              		@ frame_needed = 1, uses_anonymous_args = 0
 5303 0000 80B5     		push	{r7, lr}
 5304              		.cfi_def_cfa_offset 8
 5305              		.cfi_offset 7, -8
 5306              		.cfi_offset 14, -4
 5307 0002 84B0     		sub	sp, sp, #16
 5308              		.cfi_def_cfa_offset 24
 5309 0004 00AF     		add	r7, sp, #0
 5310              		.cfi_def_cfa_register 7
 5311 0006 7860     		str	r0, [r7, #4]
5114:Source/tasks.c **** 	TCB_t *pxTCB;
5115:Source/tasks.c **** 	BaseType_t xReturn;
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 189
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 189
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


5116:Source/tasks.c **** 
5117:Source/tasks.c **** 		/* If null is passed in here then it is the calling task that is having
5118:Source/tasks.c **** 		its notification state cleared. */
5119:Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
 5312              		.loc 1 5119 0
 5313 0008 7B68     		ldr	r3, [r7, #4]
 5314 000a 002B     		cmp	r3, #0
 5315 000c 02D1     		bne	.L366
 5316              		.loc 1 5119 0 is_stmt 0 discriminator 1
 5317 000e 0E4B     		ldr	r3, .L371
 5318 0010 1B68     		ldr	r3, [r3]
 5319 0012 00E0     		b	.L367
 5320              	.L366:
 5321              		.loc 1 5119 0 discriminator 2
 5322 0014 7B68     		ldr	r3, [r7, #4]
 5323              	.L367:
 5324              		.loc 1 5119 0 discriminator 4
 5325 0016 BB60     		str	r3, [r7, #8]
5120:Source/tasks.c **** 
5121:Source/tasks.c **** 		taskENTER_CRITICAL();
 5326              		.loc 1 5121 0 is_stmt 1 discriminator 4
 5327 0018 FFF7FEFF 		bl	vPortEnterCritical
5122:Source/tasks.c **** 		{
5123:Source/tasks.c **** 			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
 5328              		.loc 1 5123 0 discriminator 4
 5329 001c BB68     		ldr	r3, [r7, #8]
 5330 001e 93F84C30 		ldrb	r3, [r3, #76]
 5331 0022 DBB2     		uxtb	r3, r3
 5332 0024 022B     		cmp	r3, #2
 5333 0026 06D1     		bne	.L368
5124:Source/tasks.c **** 			{
5125:Source/tasks.c **** 				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 5334              		.loc 1 5125 0
 5335 0028 BB68     		ldr	r3, [r7, #8]
 5336 002a 0022     		movs	r2, #0
 5337 002c 83F84C20 		strb	r2, [r3, #76]
5126:Source/tasks.c **** 				xReturn = pdPASS;
 5338              		.loc 1 5126 0
 5339 0030 0123     		movs	r3, #1
 5340 0032 FB60     		str	r3, [r7, #12]
 5341 0034 01E0     		b	.L369
 5342              	.L368:
5127:Source/tasks.c **** 			}
5128:Source/tasks.c **** 			else
5129:Source/tasks.c **** 			{
5130:Source/tasks.c **** 				xReturn = pdFAIL;
 5343              		.loc 1 5130 0
 5344 0036 0023     		movs	r3, #0
 5345 0038 FB60     		str	r3, [r7, #12]
 5346              	.L369:
5131:Source/tasks.c **** 			}
5132:Source/tasks.c **** 		}
5133:Source/tasks.c **** 		taskEXIT_CRITICAL();
 5347              		.loc 1 5133 0
 5348 003a FFF7FEFF 		bl	vPortExitCritical
5134:Source/tasks.c **** 
5135:Source/tasks.c **** 		return xReturn;
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 190
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 190
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 5349              		.loc 1 5135 0
 5350 003e FB68     		ldr	r3, [r7, #12]
5136:Source/tasks.c **** 	}
 5351              		.loc 1 5136 0
 5352 0040 1846     		mov	r0, r3
 5353 0042 1037     		adds	r7, r7, #16
 5354              		.cfi_def_cfa_offset 8
 5355 0044 BD46     		mov	sp, r7
 5356              		.cfi_def_cfa_register 13
 5357              		@ sp needed
 5358 0046 80BD     		pop	{r7, pc}
 5359              	.L372:
 5360              		.align	2
 5361              	.L371:
 5362 0048 00000000 		.word	pxCurrentTCB
 5363              		.cfi_endproc
 5364              	.LFE119:
 5365              		.size	xTaskNotifyStateClear, .-xTaskNotifyStateClear
 5366              		.section	.text.ulTaskNotifyValueClear,"ax",%progbits
 5367              		.align	2
 5368              		.global	ulTaskNotifyValueClear
 5369              		.thumb
 5370              		.thumb_func
 5371              		.type	ulTaskNotifyValueClear, %function
 5372              	ulTaskNotifyValueClear:
 5373              	.LFB120:
5137:Source/tasks.c **** 
5138:Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
5139:Source/tasks.c **** /*-----------------------------------------------------------*/
5140:Source/tasks.c **** 
5141:Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
5142:Source/tasks.c **** 
5143:Source/tasks.c **** 	uint32_t ulTaskNotifyValueClear( TaskHandle_t xTask, uint32_t ulBitsToClear )
5144:Source/tasks.c **** 	{
 5374              		.loc 1 5144 0
 5375              		.cfi_startproc
 5376              		@ args = 0, pretend = 0, frame = 16
 5377              		@ frame_needed = 1, uses_anonymous_args = 0
 5378 0000 80B5     		push	{r7, lr}
 5379              		.cfi_def_cfa_offset 8
 5380              		.cfi_offset 7, -8
 5381              		.cfi_offset 14, -4
 5382 0002 84B0     		sub	sp, sp, #16
 5383              		.cfi_def_cfa_offset 24
 5384 0004 00AF     		add	r7, sp, #0
 5385              		.cfi_def_cfa_register 7
 5386 0006 7860     		str	r0, [r7, #4]
 5387 0008 3960     		str	r1, [r7]
5145:Source/tasks.c **** 	TCB_t *pxTCB;
5146:Source/tasks.c **** 	uint32_t ulReturn;
5147:Source/tasks.c **** 
5148:Source/tasks.c **** 		/* If null is passed in here then it is the calling task that is having
5149:Source/tasks.c **** 		its notification state cleared. */
5150:Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
 5388              		.loc 1 5150 0
 5389 000a 7B68     		ldr	r3, [r7, #4]
 5390 000c 002B     		cmp	r3, #0
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 191
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 191
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 5391 000e 02D1     		bne	.L374
 5392              		.loc 1 5150 0 is_stmt 0 discriminator 1
 5393 0010 0C4B     		ldr	r3, .L377
 5394 0012 1B68     		ldr	r3, [r3]
 5395 0014 00E0     		b	.L375
 5396              	.L374:
 5397              		.loc 1 5150 0 discriminator 2
 5398 0016 7B68     		ldr	r3, [r7, #4]
 5399              	.L375:
 5400              		.loc 1 5150 0 discriminator 4
 5401 0018 FB60     		str	r3, [r7, #12]
5151:Source/tasks.c **** 
5152:Source/tasks.c **** 		taskENTER_CRITICAL();
 5402              		.loc 1 5152 0 is_stmt 1 discriminator 4
 5403 001a FFF7FEFF 		bl	vPortEnterCritical
5153:Source/tasks.c **** 		{
5154:Source/tasks.c **** 			/* Return the notification as it was before the bits were cleared,
5155:Source/tasks.c **** 			then clear the bit mask. */
5156:Source/tasks.c **** 			ulReturn = pxCurrentTCB->ulNotifiedValue;
 5404              		.loc 1 5156 0 discriminator 4
 5405 001e 094B     		ldr	r3, .L377
 5406 0020 1B68     		ldr	r3, [r3]
 5407 0022 9B6C     		ldr	r3, [r3, #72]
 5408 0024 BB60     		str	r3, [r7, #8]
5157:Source/tasks.c **** 			pxTCB->ulNotifiedValue &= ~ulBitsToClear;
 5409              		.loc 1 5157 0 discriminator 4
 5410 0026 FB68     		ldr	r3, [r7, #12]
 5411 0028 9A6C     		ldr	r2, [r3, #72]
 5412 002a 3B68     		ldr	r3, [r7]
 5413 002c DB43     		mvns	r3, r3
 5414 002e 1A40     		ands	r2, r2, r3
 5415 0030 FB68     		ldr	r3, [r7, #12]
 5416 0032 9A64     		str	r2, [r3, #72]
5158:Source/tasks.c **** 		}
5159:Source/tasks.c **** 		taskEXIT_CRITICAL();
 5417              		.loc 1 5159 0 discriminator 4
 5418 0034 FFF7FEFF 		bl	vPortExitCritical
5160:Source/tasks.c **** 
5161:Source/tasks.c **** 		return ulReturn;
 5419              		.loc 1 5161 0 discriminator 4
 5420 0038 BB68     		ldr	r3, [r7, #8]
5162:Source/tasks.c **** 	}
 5421              		.loc 1 5162 0 discriminator 4
 5422 003a 1846     		mov	r0, r3
 5423 003c 1037     		adds	r7, r7, #16
 5424              		.cfi_def_cfa_offset 8
 5425 003e BD46     		mov	sp, r7
 5426              		.cfi_def_cfa_register 13
 5427              		@ sp needed
 5428 0040 80BD     		pop	{r7, pc}
 5429              	.L378:
 5430 0042 00BF     		.align	2
 5431              	.L377:
 5432 0044 00000000 		.word	pxCurrentTCB
 5433              		.cfi_endproc
 5434              	.LFE120:
 5435              		.size	ulTaskNotifyValueClear, .-ulTaskNotifyValueClear
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 192
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 192
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 5436              		.section	.text.prvAddCurrentTaskToDelayedList,"ax",%progbits
 5437              		.align	2
 5438              		.thumb
 5439              		.thumb_func
 5440              		.type	prvAddCurrentTaskToDelayedList, %function
 5441              	prvAddCurrentTaskToDelayedList:
 5442              	.LFB121:
5163:Source/tasks.c **** 
5164:Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
5165:Source/tasks.c **** /*-----------------------------------------------------------*/
5166:Source/tasks.c **** 
5167:Source/tasks.c **** #if( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) )
5168:Source/tasks.c **** 
5169:Source/tasks.c **** 	uint32_t ulTaskGetIdleRunTimeCounter( void )
5170:Source/tasks.c **** 	{
5171:Source/tasks.c **** 		return xIdleTaskHandle->ulRunTimeCounter;
5172:Source/tasks.c **** 	}
5173:Source/tasks.c **** 
5174:Source/tasks.c **** #endif
5175:Source/tasks.c **** /*-----------------------------------------------------------*/
5176:Source/tasks.c **** 
5177:Source/tasks.c **** static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockInde
5178:Source/tasks.c **** {
 5443              		.loc 1 5178 0
 5444              		.cfi_startproc
 5445              		@ args = 0, pretend = 0, frame = 16
 5446              		@ frame_needed = 1, uses_anonymous_args = 0
 5447 0000 80B5     		push	{r7, lr}
 5448              		.cfi_def_cfa_offset 8
 5449              		.cfi_offset 7, -8
 5450              		.cfi_offset 14, -4
 5451 0002 84B0     		sub	sp, sp, #16
 5452              		.cfi_def_cfa_offset 24
 5453 0004 00AF     		add	r7, sp, #0
 5454              		.cfi_def_cfa_register 7
 5455 0006 7860     		str	r0, [r7, #4]
 5456 0008 3960     		str	r1, [r7]
5179:Source/tasks.c **** TickType_t xTimeToWake;
5180:Source/tasks.c **** const TickType_t xConstTickCount = xTickCount;
 5457              		.loc 1 5180 0
 5458 000a 294B     		ldr	r3, .L385
 5459 000c 1B68     		ldr	r3, [r3]
 5460 000e FB60     		str	r3, [r7, #12]
5181:Source/tasks.c **** 
5182:Source/tasks.c **** 	#if( INCLUDE_xTaskAbortDelay == 1 )
5183:Source/tasks.c **** 	{
5184:Source/tasks.c **** 		/* About to enter a delayed list, so ensure the ucDelayAborted flag is
5185:Source/tasks.c **** 		reset to pdFALSE so it can be detected as having been set to pdTRUE
5186:Source/tasks.c **** 		when the task leaves the Blocked state. */
5187:Source/tasks.c **** 		pxCurrentTCB->ucDelayAborted = pdFALSE;
5188:Source/tasks.c **** 	}
5189:Source/tasks.c **** 	#endif
5190:Source/tasks.c **** 
5191:Source/tasks.c **** 	/* Remove the task from the ready list before adding it to the blocked list
5192:Source/tasks.c **** 	as the same list item is used for both lists. */
5193:Source/tasks.c **** 	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 5461              		.loc 1 5193 0
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 193
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 193
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 5462 0010 284B     		ldr	r3, .L385+4
 5463 0012 1B68     		ldr	r3, [r3]
 5464 0014 0433     		adds	r3, r3, #4
 5465 0016 1846     		mov	r0, r3
 5466 0018 FFF7FEFF 		bl	uxListRemove
 5467 001c 0346     		mov	r3, r0
 5468 001e 002B     		cmp	r3, #0
 5469 0020 0BD1     		bne	.L380
5194:Source/tasks.c **** 	{
5195:Source/tasks.c **** 		/* The current task must be in a ready list, so there is no need to
5196:Source/tasks.c **** 		check, and the port reset macro can be called directly. */
5197:Source/tasks.c **** 		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority ); /*lint !e931 pxCurrentT
 5470              		.loc 1 5197 0
 5471 0022 244B     		ldr	r3, .L385+4
 5472 0024 1B68     		ldr	r3, [r3]
 5473 0026 DB6A     		ldr	r3, [r3, #44]
 5474 0028 0122     		movs	r2, #1
 5475 002a 02FA03F3 		lsl	r3, r2, r3
 5476 002e DA43     		mvns	r2, r3
 5477 0030 214B     		ldr	r3, .L385+8
 5478 0032 1B68     		ldr	r3, [r3]
 5479 0034 1340     		ands	r3, r3, r2
 5480 0036 204A     		ldr	r2, .L385+8
 5481 0038 1360     		str	r3, [r2]
 5482              	.L380:
5198:Source/tasks.c **** 	}
5199:Source/tasks.c **** 	else
5200:Source/tasks.c **** 	{
5201:Source/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
5202:Source/tasks.c **** 	}
5203:Source/tasks.c **** 
5204:Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
5205:Source/tasks.c **** 	{
5206:Source/tasks.c **** 		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 5483              		.loc 1 5206 0
 5484 003a 7B68     		ldr	r3, [r7, #4]
 5485 003c B3F1FF3F 		cmp	r3, #-1
 5486 0040 0AD1     		bne	.L381
 5487              		.loc 1 5206 0 is_stmt 0 discriminator 1
 5488 0042 3B68     		ldr	r3, [r7]
 5489 0044 002B     		cmp	r3, #0
 5490 0046 07D0     		beq	.L381
5207:Source/tasks.c **** 		{
5208:Source/tasks.c **** 			/* Add the task to the suspended task list instead of a delayed task
5209:Source/tasks.c **** 			list to ensure it is not woken by a timing event.  It will block
5210:Source/tasks.c **** 			indefinitely. */
5211:Source/tasks.c **** 			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 5491              		.loc 1 5211 0 is_stmt 1
 5492 0048 1A4B     		ldr	r3, .L385+4
 5493 004a 1B68     		ldr	r3, [r3]
 5494 004c 0433     		adds	r3, r3, #4
 5495 004e 1946     		mov	r1, r3
 5496 0050 1A48     		ldr	r0, .L385+12
 5497 0052 FFF7FEFF 		bl	vListInsertEnd
5212:Source/tasks.c **** 		}
5213:Source/tasks.c **** 		else
5214:Source/tasks.c **** 		{
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 194
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 194
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


5215:Source/tasks.c **** 			/* Calculate the time at which the task should be woken if the event
5216:Source/tasks.c **** 			does not occur.  This may overflow but this doesn't matter, the
5217:Source/tasks.c **** 			kernel will manage it correctly. */
5218:Source/tasks.c **** 			xTimeToWake = xConstTickCount + xTicksToWait;
5219:Source/tasks.c **** 
5220:Source/tasks.c **** 			/* The list item will be inserted in wake time order. */
5221:Source/tasks.c **** 			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
5222:Source/tasks.c **** 
5223:Source/tasks.c **** 			if( xTimeToWake < xConstTickCount )
5224:Source/tasks.c **** 			{
5225:Source/tasks.c **** 				/* Wake time has overflowed.  Place this item in the overflow
5226:Source/tasks.c **** 				list. */
5227:Source/tasks.c **** 				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
5228:Source/tasks.c **** 			}
5229:Source/tasks.c **** 			else
5230:Source/tasks.c **** 			{
5231:Source/tasks.c **** 				/* The wake time has not overflowed, so the current block list
5232:Source/tasks.c **** 				is used. */
5233:Source/tasks.c **** 				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
5234:Source/tasks.c **** 
5235:Source/tasks.c **** 				/* If the task entering the blocked state was placed at the
5236:Source/tasks.c **** 				head of the list of blocked tasks then xNextTaskUnblockTime
5237:Source/tasks.c **** 				needs to be updated too. */
5238:Source/tasks.c **** 				if( xTimeToWake < xNextTaskUnblockTime )
5239:Source/tasks.c **** 				{
5240:Source/tasks.c **** 					xNextTaskUnblockTime = xTimeToWake;
5241:Source/tasks.c **** 				}
5242:Source/tasks.c **** 				else
5243:Source/tasks.c **** 				{
5244:Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
5245:Source/tasks.c **** 				}
5246:Source/tasks.c **** 			}
5247:Source/tasks.c **** 		}
5248:Source/tasks.c **** 	}
5249:Source/tasks.c **** 	#else /* INCLUDE_vTaskSuspend */
5250:Source/tasks.c **** 	{
5251:Source/tasks.c **** 		/* Calculate the time at which the task should be woken if the event
5252:Source/tasks.c **** 		does not occur.  This may overflow but this doesn't matter, the kernel
5253:Source/tasks.c **** 		will manage it correctly. */
5254:Source/tasks.c **** 		xTimeToWake = xConstTickCount + xTicksToWait;
5255:Source/tasks.c **** 
5256:Source/tasks.c **** 		/* The list item will be inserted in wake time order. */
5257:Source/tasks.c **** 		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
5258:Source/tasks.c **** 
5259:Source/tasks.c **** 		if( xTimeToWake < xConstTickCount )
5260:Source/tasks.c **** 		{
5261:Source/tasks.c **** 			/* Wake time has overflowed.  Place this item in the overflow list. */
5262:Source/tasks.c **** 			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
5263:Source/tasks.c **** 		}
5264:Source/tasks.c **** 		else
5265:Source/tasks.c **** 		{
5266:Source/tasks.c **** 			/* The wake time has not overflowed, so the current block list is used. */
5267:Source/tasks.c **** 			vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
5268:Source/tasks.c **** 
5269:Source/tasks.c **** 			/* If the task entering the blocked state was placed at the head of the
5270:Source/tasks.c **** 			list of blocked tasks then xNextTaskUnblockTime needs to be updated
5271:Source/tasks.c **** 			too. */
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 195
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 195
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


5272:Source/tasks.c **** 			if( xTimeToWake < xNextTaskUnblockTime )
5273:Source/tasks.c **** 			{
5274:Source/tasks.c **** 				xNextTaskUnblockTime = xTimeToWake;
5275:Source/tasks.c **** 			}
5276:Source/tasks.c **** 			else
5277:Source/tasks.c **** 			{
5278:Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
5279:Source/tasks.c **** 			}
5280:Source/tasks.c **** 		}
5281:Source/tasks.c **** 
5282:Source/tasks.c **** 		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
5283:Source/tasks.c **** 		( void ) xCanBlockIndefinitely;
5284:Source/tasks.c **** 	}
5285:Source/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
5286:Source/tasks.c **** }
 5498              		.loc 1 5286 0
 5499 0056 26E0     		b	.L384
 5500              	.L381:
5218:Source/tasks.c **** 
 5501              		.loc 1 5218 0
 5502 0058 FA68     		ldr	r2, [r7, #12]
 5503 005a 7B68     		ldr	r3, [r7, #4]
 5504 005c 1344     		add	r3, r3, r2
 5505 005e BB60     		str	r3, [r7, #8]
5221:Source/tasks.c **** 
 5506              		.loc 1 5221 0
 5507 0060 144B     		ldr	r3, .L385+4
 5508 0062 1B68     		ldr	r3, [r3]
 5509 0064 BA68     		ldr	r2, [r7, #8]
 5510 0066 5A60     		str	r2, [r3, #4]
5223:Source/tasks.c **** 			{
 5511              		.loc 1 5223 0
 5512 0068 BA68     		ldr	r2, [r7, #8]
 5513 006a FB68     		ldr	r3, [r7, #12]
 5514 006c 9A42     		cmp	r2, r3
 5515 006e 09D2     		bcs	.L383
5227:Source/tasks.c **** 			}
 5516              		.loc 1 5227 0
 5517 0070 134B     		ldr	r3, .L385+16
 5518 0072 1A68     		ldr	r2, [r3]
 5519 0074 0F4B     		ldr	r3, .L385+4
 5520 0076 1B68     		ldr	r3, [r3]
 5521 0078 0433     		adds	r3, r3, #4
 5522 007a 1946     		mov	r1, r3
 5523 007c 1046     		mov	r0, r2
 5524 007e FFF7FEFF 		bl	vListInsert
 5525              		.loc 1 5286 0
 5526 0082 10E0     		b	.L384
 5527              	.L383:
5233:Source/tasks.c **** 
 5528              		.loc 1 5233 0
 5529 0084 0F4B     		ldr	r3, .L385+20
 5530 0086 1A68     		ldr	r2, [r3]
 5531 0088 0A4B     		ldr	r3, .L385+4
 5532 008a 1B68     		ldr	r3, [r3]
 5533 008c 0433     		adds	r3, r3, #4
 5534 008e 1946     		mov	r1, r3
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 196
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 196
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 5535 0090 1046     		mov	r0, r2
 5536 0092 FFF7FEFF 		bl	vListInsert
5238:Source/tasks.c **** 				{
 5537              		.loc 1 5238 0
 5538 0096 0C4B     		ldr	r3, .L385+24
 5539 0098 1B68     		ldr	r3, [r3]
 5540 009a BA68     		ldr	r2, [r7, #8]
 5541 009c 9A42     		cmp	r2, r3
 5542 009e 02D2     		bcs	.L384
5240:Source/tasks.c **** 				}
 5543              		.loc 1 5240 0
 5544 00a0 094A     		ldr	r2, .L385+24
 5545 00a2 BB68     		ldr	r3, [r7, #8]
 5546 00a4 1360     		str	r3, [r2]
 5547              	.L384:
 5548              		.loc 1 5286 0
 5549 00a6 00BF     		nop
 5550 00a8 1037     		adds	r7, r7, #16
 5551              		.cfi_def_cfa_offset 8
 5552 00aa BD46     		mov	sp, r7
 5553              		.cfi_def_cfa_register 13
 5554              		@ sp needed
 5555 00ac 80BD     		pop	{r7, pc}
 5556              	.L386:
 5557 00ae 00BF     		.align	2
 5558              	.L385:
 5559 00b0 DC000000 		.word	xTickCount
 5560 00b4 00000000 		.word	pxCurrentTCB
 5561 00b8 E0000000 		.word	uxTopReadyPriority
 5562 00bc C4000000 		.word	xSuspendedTaskList
 5563 00c0 94000000 		.word	pxOverflowDelayedTaskList
 5564 00c4 90000000 		.word	pxDelayedTaskList
 5565 00c8 F8000000 		.word	xNextTaskUnblockTime
 5566              		.cfi_endproc
 5567              	.LFE121:
 5568              		.size	prvAddCurrentTaskToDelayedList, .-prvAddCurrentTaskToDelayedList
 5569              		.text
 5570              	.Letext0:
 5571              		.file 3 "c:\\program files (x86)\\cypress\\psoc creator\\4.3\\psoc creator\\import\\gnu\\arm\\5.4.
 5572              		.file 4 "c:\\program files (x86)\\cypress\\psoc creator\\4.3\\psoc creator\\import\\gnu\\arm\\5.4.
 5573              		.file 5 "c:\\program files (x86)\\cypress\\psoc creator\\4.3\\psoc creator\\import\\gnu\\arm\\5.4.
 5574              		.file 6 "Generated_Source\\PSoC5/cytypes.h"
 5575              		.file 7 "Generated_Source\\PSoC5/DS18x8.h"
 5576              		.file 8 ".\\Source\\include/projdefs.h"
 5577              		.file 9 ".\\Source\\include/list.h"
 5578              		.file 10 ".\\Source\\include/task.h"
 5579              		.file 11 "Generated_Source\\PSoC5/core_cm3.h"
 5580              		.section	.debug_info,"",%progbits
 5581              	.Ldebug_info0:
 5582 0000 02180000 		.4byte	0x1802
 5583 0004 0400     		.2byte	0x4
 5584 0006 00000000 		.4byte	.Ldebug_abbrev0
 5585 000a 04       		.byte	0x4
 5586 000b 01       		.uleb128 0x1
 5587 000c ED000000 		.4byte	.LASF240
 5588 0010 0C       		.byte	0xc
 5589 0011 32030000 		.4byte	.LASF241
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 197
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 197
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 5590 0015 6B030000 		.4byte	.LASF242
 5591 0019 00000000 		.4byte	.Ldebug_ranges0+0
 5592 001d 00000000 		.4byte	0
 5593 0021 00000000 		.4byte	.Ldebug_line0
 5594 0025 02       		.uleb128 0x2
 5595 0026 50000000 		.4byte	.LASF4
 5596 002a 03       		.byte	0x3
 5597 002b D8       		.byte	0xd8
 5598 002c 30000000 		.4byte	0x30
 5599 0030 03       		.uleb128 0x3
 5600 0031 04       		.byte	0x4
 5601 0032 07       		.byte	0x7
 5602 0033 20050000 		.4byte	.LASF0
 5603 0037 04       		.uleb128 0x4
 5604 0038 04       		.byte	0x4
 5605 0039 05       		.byte	0x5
 5606 003a 696E7400 		.ascii	"int\000"
 5607 003e 03       		.uleb128 0x3
 5608 003f 08       		.byte	0x8
 5609 0040 05       		.byte	0x5
 5610 0041 0E020000 		.4byte	.LASF1
 5611 0045 03       		.uleb128 0x3
 5612 0046 08       		.byte	0x8
 5613 0047 04       		.byte	0x4
 5614 0048 D3070000 		.4byte	.LASF2
 5615 004c 03       		.uleb128 0x3
 5616 004d 01       		.byte	0x1
 5617 004e 06       		.byte	0x6
 5618 004f 1C020000 		.4byte	.LASF3
 5619 0053 02       		.uleb128 0x2
 5620 0054 B7000000 		.4byte	.LASF5
 5621 0058 04       		.byte	0x4
 5622 0059 1D       		.byte	0x1d
 5623 005a 5E000000 		.4byte	0x5e
 5624 005e 03       		.uleb128 0x3
 5625 005f 01       		.byte	0x1
 5626 0060 08       		.byte	0x8
 5627 0061 0E0A0000 		.4byte	.LASF6
 5628 0065 03       		.uleb128 0x3
 5629 0066 02       		.byte	0x2
 5630 0067 05       		.byte	0x5
 5631 0068 52030000 		.4byte	.LASF7
 5632 006c 02       		.uleb128 0x2
 5633 006d 43040000 		.4byte	.LASF8
 5634 0071 04       		.byte	0x4
 5635 0072 2B       		.byte	0x2b
 5636 0073 77000000 		.4byte	0x77
 5637 0077 03       		.uleb128 0x3
 5638 0078 02       		.byte	0x2
 5639 0079 07       		.byte	0x7
 5640 007a 1C060000 		.4byte	.LASF9
 5641 007e 02       		.uleb128 0x2
 5642 007f 7A0C0000 		.4byte	.LASF10
 5643 0083 04       		.byte	0x4
 5644 0084 3F       		.byte	0x3f
 5645 0085 89000000 		.4byte	0x89
 5646 0089 03       		.uleb128 0x3
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 198
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 198
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 5647 008a 04       		.byte	0x4
 5648 008b 05       		.byte	0x5
 5649 008c A0020000 		.4byte	.LASF11
 5650 0090 02       		.uleb128 0x2
 5651 0091 ED040000 		.4byte	.LASF12
 5652 0095 04       		.byte	0x4
 5653 0096 41       		.byte	0x41
 5654 0097 9B000000 		.4byte	0x9b
 5655 009b 03       		.uleb128 0x3
 5656 009c 04       		.byte	0x4
 5657 009d 07       		.byte	0x7
 5658 009e 94050000 		.4byte	.LASF13
 5659 00a2 03       		.uleb128 0x3
 5660 00a3 08       		.byte	0x8
 5661 00a4 07       		.byte	0x7
 5662 00a5 72020000 		.4byte	.LASF14
 5663 00a9 03       		.uleb128 0x3
 5664 00aa 04       		.byte	0x4
 5665 00ab 07       		.byte	0x7
 5666 00ac AD070000 		.4byte	.LASF15
 5667 00b0 05       		.uleb128 0x5
 5668 00b1 04       		.byte	0x4
 5669 00b2 06       		.uleb128 0x6
 5670 00b3 04       		.byte	0x4
 5671 00b4 B8000000 		.4byte	0xb8
 5672 00b8 03       		.uleb128 0x3
 5673 00b9 01       		.byte	0x1
 5674 00ba 08       		.byte	0x8
 5675 00bb F10B0000 		.4byte	.LASF16
 5676 00bf 06       		.uleb128 0x6
 5677 00c0 04       		.byte	0x4
 5678 00c1 C5000000 		.4byte	0xc5
 5679 00c5 07       		.uleb128 0x7
 5680 00c6 B8000000 		.4byte	0xb8
 5681 00ca 02       		.uleb128 0x2
 5682 00cb 0B0E0000 		.4byte	.LASF17
 5683 00cf 05       		.byte	0x5
 5684 00d0 18       		.byte	0x18
 5685 00d1 53000000 		.4byte	0x53
 5686 00d5 02       		.uleb128 0x2
 5687 00d6 C3060000 		.4byte	.LASF18
 5688 00da 05       		.byte	0x5
 5689 00db 24       		.byte	0x24
 5690 00dc 6C000000 		.4byte	0x6c
 5691 00e0 02       		.uleb128 0x2
 5692 00e1 060A0000 		.4byte	.LASF19
 5693 00e5 05       		.byte	0x5
 5694 00e6 2C       		.byte	0x2c
 5695 00e7 7E000000 		.4byte	0x7e
 5696 00eb 02       		.uleb128 0x2
 5697 00ec 2F0F0000 		.4byte	.LASF20
 5698 00f0 05       		.byte	0x5
 5699 00f1 30       		.byte	0x30
 5700 00f2 90000000 		.4byte	0x90
 5701 00f6 08       		.uleb128 0x8
 5702 00f7 41030000 		.4byte	.LASF21
 5703 00fb 06       		.byte	0x6
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 199
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 199
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 5704 00fc E401     		.2byte	0x1e4
 5705 00fe 5E000000 		.4byte	0x5e
 5706 0102 08       		.uleb128 0x8
 5707 0103 2C0A0000 		.4byte	.LASF22
 5708 0107 06       		.byte	0x6
 5709 0108 E501     		.2byte	0x1e5
 5710 010a 77000000 		.4byte	0x77
 5711 010e 03       		.uleb128 0x3
 5712 010f 04       		.byte	0x4
 5713 0110 04       		.byte	0x4
 5714 0111 6E090000 		.4byte	.LASF23
 5715 0115 03       		.uleb128 0x3
 5716 0116 08       		.byte	0x8
 5717 0117 04       		.byte	0x4
 5718 0118 280F0000 		.4byte	.LASF24
 5719 011c 09       		.uleb128 0x9
 5720 011d F6000000 		.4byte	0xf6
 5721 0121 0A       		.uleb128 0xa
 5722 0122 960B0000 		.4byte	.LASF32
 5723 0126 04       		.byte	0x4
 5724 0127 07       		.byte	0x7
 5725 0128 30       		.byte	0x30
 5726 0129 46010000 		.4byte	0x146
 5727 012d 0B       		.uleb128 0xb
 5728 012e EB0D0000 		.4byte	.LASF25
 5729 0132 07       		.byte	0x7
 5730 0133 31       		.byte	0x31
 5731 0134 02010000 		.4byte	0x102
 5732 0138 00       		.byte	0
 5733 0139 0B       		.uleb128 0xb
 5734 013a 72060000 		.4byte	.LASF26
 5735 013e 07       		.byte	0x7
 5736 013f 32       		.byte	0x32
 5737 0140 F6000000 		.4byte	0xf6
 5738 0144 02       		.byte	0x2
 5739 0145 00       		.byte	0
 5740 0146 09       		.uleb128 0x9
 5741 0147 EB000000 		.4byte	0xeb
 5742 014b 09       		.uleb128 0x9
 5743 014c CA000000 		.4byte	0xca
 5744 0150 02       		.uleb128 0x2
 5745 0151 C00A0000 		.4byte	.LASF27
 5746 0155 08       		.byte	0x8
 5747 0156 23       		.byte	0x23
 5748 0157 5B010000 		.4byte	0x15b
 5749 015b 06       		.uleb128 0x6
 5750 015c 04       		.byte	0x4
 5751 015d 61010000 		.4byte	0x161
 5752 0161 0C       		.uleb128 0xc
 5753 0162 6C010000 		.4byte	0x16c
 5754 0166 0D       		.uleb128 0xd
 5755 0167 B0000000 		.4byte	0xb0
 5756 016b 00       		.byte	0
 5757 016c 02       		.uleb128 0x2
 5758 016d 2F060000 		.4byte	.LASF28
 5759 0171 02       		.byte	0x2
 5760 0172 37       		.byte	0x37
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 200
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 200
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 5761 0173 EB000000 		.4byte	0xeb
 5762 0177 02       		.uleb128 0x2
 5763 0178 DB030000 		.4byte	.LASF29
 5764 017c 02       		.byte	0x2
 5765 017d 38       		.byte	0x38
 5766 017e 89000000 		.4byte	0x89
 5767 0182 02       		.uleb128 0x2
 5768 0183 1C0F0000 		.4byte	.LASF30
 5769 0187 02       		.byte	0x2
 5770 0188 39       		.byte	0x39
 5771 0189 9B000000 		.4byte	0x9b
 5772 018d 02       		.uleb128 0x2
 5773 018e 47030000 		.4byte	.LASF31
 5774 0192 02       		.byte	0x2
 5775 0193 3F       		.byte	0x3f
 5776 0194 EB000000 		.4byte	0xeb
 5777 0198 06       		.uleb128 0x6
 5778 0199 04       		.byte	0x4
 5779 019a CA000000 		.4byte	0xca
 5780 019e 0A       		.uleb128 0xa
 5781 019f E20C0000 		.4byte	.LASF33
 5782 01a3 14       		.byte	0x14
 5783 01a4 09       		.byte	0x9
 5784 01a5 8C       		.byte	0x8c
 5785 01a6 E7010000 		.4byte	0x1e7
 5786 01aa 0B       		.uleb128 0xb
 5787 01ab AB0D0000 		.4byte	.LASF34
 5788 01af 09       		.byte	0x9
 5789 01b0 8F       		.byte	0x8f
 5790 01b1 8D010000 		.4byte	0x18d
 5791 01b5 00       		.byte	0
 5792 01b6 0B       		.uleb128 0xb
 5793 01b7 420E0000 		.4byte	.LASF35
 5794 01bb 09       		.byte	0x9
 5795 01bc 90       		.byte	0x90
 5796 01bd E7010000 		.4byte	0x1e7
 5797 01c1 04       		.byte	0x4
 5798 01c2 0B       		.uleb128 0xb
 5799 01c3 47090000 		.4byte	.LASF36
 5800 01c7 09       		.byte	0x9
 5801 01c8 91       		.byte	0x91
 5802 01c9 E7010000 		.4byte	0x1e7
 5803 01cd 08       		.byte	0x8
 5804 01ce 0B       		.uleb128 0xb
 5805 01cf A30D0000 		.4byte	.LASF37
 5806 01d3 09       		.byte	0x9
 5807 01d4 92       		.byte	0x92
 5808 01d5 B0000000 		.4byte	0xb0
 5809 01d9 0C       		.byte	0xc
 5810 01da 0B       		.uleb128 0xb
 5811 01db 9B090000 		.4byte	.LASF38
 5812 01df 09       		.byte	0x9
 5813 01e0 93       		.byte	0x93
 5814 01e1 1E020000 		.4byte	0x21e
 5815 01e5 10       		.byte	0x10
 5816 01e6 00       		.byte	0
 5817 01e7 06       		.uleb128 0x6
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 201
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 201
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 5818 01e8 04       		.byte	0x4
 5819 01e9 9E010000 		.4byte	0x19e
 5820 01ed 0A       		.uleb128 0xa
 5821 01ee CF0A0000 		.4byte	.LASF39
 5822 01f2 14       		.byte	0x14
 5823 01f3 09       		.byte	0x9
 5824 01f4 A4       		.byte	0xa4
 5825 01f5 1E020000 		.4byte	0x21e
 5826 01f9 0B       		.uleb128 0xb
 5827 01fa 84050000 		.4byte	.LASF40
 5828 01fe 09       		.byte	0x9
 5829 01ff A7       		.byte	0xa7
 5830 0200 6B020000 		.4byte	0x26b
 5831 0204 00       		.byte	0
 5832 0205 0B       		.uleb128 0xb
 5833 0206 93090000 		.4byte	.LASF41
 5834 020a 09       		.byte	0x9
 5835 020b A8       		.byte	0xa8
 5836 020c 70020000 		.4byte	0x270
 5837 0210 04       		.byte	0x4
 5838 0211 0B       		.uleb128 0xb
 5839 0212 CD010000 		.4byte	.LASF42
 5840 0216 09       		.byte	0x9
 5841 0217 A9       		.byte	0xa9
 5842 0218 60020000 		.4byte	0x260
 5843 021c 08       		.byte	0x8
 5844 021d 00       		.byte	0
 5845 021e 06       		.uleb128 0x6
 5846 021f 04       		.byte	0x4
 5847 0220 ED010000 		.4byte	0x1ed
 5848 0224 02       		.uleb128 0x2
 5849 0225 F5080000 		.4byte	.LASF43
 5850 0229 09       		.byte	0x9
 5851 022a 96       		.byte	0x96
 5852 022b 9E010000 		.4byte	0x19e
 5853 022f 0A       		.uleb128 0xa
 5854 0230 ED010000 		.4byte	.LASF44
 5855 0234 0C       		.byte	0xc
 5856 0235 09       		.byte	0x9
 5857 0236 98       		.byte	0x98
 5858 0237 60020000 		.4byte	0x260
 5859 023b 0B       		.uleb128 0xb
 5860 023c AB0D0000 		.4byte	.LASF34
 5861 0240 09       		.byte	0x9
 5862 0241 9B       		.byte	0x9b
 5863 0242 8D010000 		.4byte	0x18d
 5864 0246 00       		.byte	0
 5865 0247 0B       		.uleb128 0xb
 5866 0248 420E0000 		.4byte	.LASF35
 5867 024c 09       		.byte	0x9
 5868 024d 9C       		.byte	0x9c
 5869 024e E7010000 		.4byte	0x1e7
 5870 0252 04       		.byte	0x4
 5871 0253 0B       		.uleb128 0xb
 5872 0254 47090000 		.4byte	.LASF36
 5873 0258 09       		.byte	0x9
 5874 0259 9D       		.byte	0x9d
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 202
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 202
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 5875 025a E7010000 		.4byte	0x1e7
 5876 025e 08       		.byte	0x8
 5877 025f 00       		.byte	0
 5878 0260 02       		.uleb128 0x2
 5879 0261 57000000 		.4byte	.LASF45
 5880 0265 09       		.byte	0x9
 5881 0266 9F       		.byte	0x9f
 5882 0267 2F020000 		.4byte	0x22f
 5883 026b 09       		.uleb128 0x9
 5884 026c 82010000 		.4byte	0x182
 5885 0270 06       		.uleb128 0x6
 5886 0271 04       		.byte	0x4
 5887 0272 24020000 		.4byte	0x224
 5888 0276 02       		.uleb128 0x2
 5889 0277 0E070000 		.4byte	.LASF46
 5890 027b 09       		.byte	0x9
 5891 027c AB       		.byte	0xab
 5892 027d ED010000 		.4byte	0x1ed
 5893 0281 02       		.uleb128 0x2
 5894 0282 25030000 		.4byte	.LASF47
 5895 0286 0A       		.byte	0xa
 5896 0287 46       		.byte	0x46
 5897 0288 8C020000 		.4byte	0x28c
 5898 028c 06       		.uleb128 0x6
 5899 028d 04       		.byte	0x4
 5900 028e 92020000 		.4byte	0x292
 5901 0292 0A       		.uleb128 0xa
 5902 0293 A9020000 		.4byte	.LASF48
 5903 0297 50       		.byte	0x50
 5904 0298 01       		.byte	0x1
 5905 0299 FC       		.byte	0xfc
 5906 029a 20030000 		.4byte	0x320
 5907 029e 0B       		.uleb128 0xb
 5908 029f BB050000 		.4byte	.LASF49
 5909 02a3 01       		.byte	0x1
 5910 02a4 FE       		.byte	0xfe
 5911 02a5 09040000 		.4byte	0x409
 5912 02a9 00       		.byte	0
 5913 02aa 0E       		.uleb128 0xe
 5914 02ab 89020000 		.4byte	.LASF50
 5915 02af 01       		.byte	0x1
 5916 02b0 0401     		.2byte	0x104
 5917 02b2 24020000 		.4byte	0x224
 5918 02b6 04       		.byte	0x4
 5919 02b7 0E       		.uleb128 0xe
 5920 02b8 71080000 		.4byte	.LASF51
 5921 02bc 01       		.byte	0x1
 5922 02bd 0501     		.2byte	0x105
 5923 02bf 24020000 		.4byte	0x224
 5924 02c3 18       		.byte	0x18
 5925 02c4 0E       		.uleb128 0xe
 5926 02c5 A30E0000 		.4byte	.LASF52
 5927 02c9 01       		.byte	0x1
 5928 02ca 0601     		.2byte	0x106
 5929 02cc 82010000 		.4byte	0x182
 5930 02d0 2C       		.byte	0x2c
 5931 02d1 0E       		.uleb128 0xe
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 203
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 203
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 5932 02d2 8B070000 		.4byte	.LASF53
 5933 02d6 01       		.byte	0x1
 5934 02d7 0701     		.2byte	0x107
 5935 02d9 03040000 		.4byte	0x403
 5936 02dd 30       		.byte	0x30
 5937 02de 0E       		.uleb128 0xe
 5938 02df 000E0000 		.4byte	.LASF54
 5939 02e3 01       		.byte	0x1
 5940 02e4 0801     		.2byte	0x108
 5941 02e6 14040000 		.4byte	0x414
 5942 02ea 34       		.byte	0x34
 5943 02eb 0E       		.uleb128 0xe
 5944 02ec FF0A0000 		.4byte	.LASF55
 5945 02f0 01       		.byte	0x1
 5946 02f1 1801     		.2byte	0x118
 5947 02f3 82010000 		.4byte	0x182
 5948 02f7 40       		.byte	0x40
 5949 02f8 0E       		.uleb128 0xe
 5950 02f9 B50B0000 		.4byte	.LASF56
 5951 02fd 01       		.byte	0x1
 5952 02fe 1901     		.2byte	0x119
 5953 0300 82010000 		.4byte	0x182
 5954 0304 44       		.byte	0x44
 5955 0305 0E       		.uleb128 0xe
 5956 0306 1C0A0000 		.4byte	.LASF57
 5957 030a 01       		.byte	0x1
 5958 030b 3701     		.2byte	0x137
 5959 030d 46010000 		.4byte	0x146
 5960 0311 48       		.byte	0x48
 5961 0312 0E       		.uleb128 0xe
 5962 0313 DF040000 		.4byte	.LASF58
 5963 0317 01       		.byte	0x1
 5964 0318 3801     		.2byte	0x138
 5965 031a 4B010000 		.4byte	0x14b
 5966 031e 4C       		.byte	0x4c
 5967 031f 00       		.byte	0
 5968 0320 0F       		.uleb128 0xf
 5969 0321 01       		.byte	0x1
 5970 0322 5E000000 		.4byte	0x5e
 5971 0326 0A       		.byte	0xa
 5972 0327 50       		.byte	0x50
 5973 0328 51030000 		.4byte	0x351
 5974 032c 10       		.uleb128 0x10
 5975 032d 5A0B0000 		.4byte	.LASF59
 5976 0331 00       		.byte	0
 5977 0332 10       		.uleb128 0x10
 5978 0333 A6050000 		.4byte	.LASF60
 5979 0337 01       		.byte	0x1
 5980 0338 10       		.uleb128 0x10
 5981 0339 9E010000 		.4byte	.LASF61
 5982 033d 02       		.byte	0x2
 5983 033e 10       		.uleb128 0x10
 5984 033f 00000000 		.4byte	.LASF62
 5985 0343 03       		.byte	0x3
 5986 0344 10       		.uleb128 0x10
 5987 0345 A7090000 		.4byte	.LASF63
 5988 0349 04       		.byte	0x4
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 204
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 204
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 5989 034a 10       		.uleb128 0x10
 5990 034b F70D0000 		.4byte	.LASF64
 5991 034f 05       		.byte	0x5
 5992 0350 00       		.byte	0
 5993 0351 02       		.uleb128 0x2
 5994 0352 490E0000 		.4byte	.LASF65
 5995 0356 0A       		.byte	0xa
 5996 0357 57       		.byte	0x57
 5997 0358 20030000 		.4byte	0x320
 5998 035c 0F       		.uleb128 0xf
 5999 035d 01       		.byte	0x1
 6000 035e 5E000000 		.4byte	0x5e
 6001 0362 0A       		.byte	0xa
 6002 0363 5B       		.byte	0x5b
 6003 0364 87030000 		.4byte	0x387
 6004 0368 10       		.uleb128 0x10
 6005 0369 380E0000 		.4byte	.LASF66
 6006 036d 00       		.byte	0
 6007 036e 10       		.uleb128 0x10
 6008 036f DF020000 		.4byte	.LASF67
 6009 0373 01       		.byte	0x1
 6010 0374 10       		.uleb128 0x10
 6011 0375 72070000 		.4byte	.LASF68
 6012 0379 02       		.byte	0x2
 6013 037a 10       		.uleb128 0x10
 6014 037b 88080000 		.4byte	.LASF69
 6015 037f 03       		.byte	0x3
 6016 0380 10       		.uleb128 0x10
 6017 0381 F6050000 		.4byte	.LASF70
 6018 0385 04       		.byte	0x4
 6019 0386 00       		.byte	0
 6020 0387 02       		.uleb128 0x2
 6021 0388 540E0000 		.4byte	.LASF71
 6022 038c 0A       		.byte	0xa
 6023 038d 61       		.byte	0x61
 6024 038e 5C030000 		.4byte	0x35c
 6025 0392 0A       		.uleb128 0xa
 6026 0393 E3010000 		.4byte	.LASF72
 6027 0397 08       		.byte	0x8
 6028 0398 0A       		.byte	0xa
 6029 0399 66       		.byte	0x66
 6030 039a B7030000 		.4byte	0x3b7
 6031 039e 0B       		.uleb128 0xb
 6032 039f 79040000 		.4byte	.LASF73
 6033 03a3 0A       		.byte	0xa
 6034 03a4 68       		.byte	0x68
 6035 03a5 77010000 		.4byte	0x177
 6036 03a9 00       		.byte	0
 6037 03aa 0B       		.uleb128 0xb
 6038 03ab 7B0E0000 		.4byte	.LASF74
 6039 03af 0A       		.byte	0xa
 6040 03b0 69       		.byte	0x69
 6041 03b1 8D010000 		.4byte	0x18d
 6042 03b5 04       		.byte	0x4
 6043 03b6 00       		.byte	0
 6044 03b7 02       		.uleb128 0x2
 6045 03b8 66000000 		.4byte	.LASF75
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 205
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 205
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 6046 03bc 0A       		.byte	0xa
 6047 03bd 6A       		.byte	0x6a
 6048 03be 92030000 		.4byte	0x392
 6049 03c2 0A       		.uleb128 0xa
 6050 03c3 BE090000 		.4byte	.LASF76
 6051 03c7 0C       		.byte	0xc
 6052 03c8 0A       		.byte	0xa
 6053 03c9 6F       		.byte	0x6f
 6054 03ca F3030000 		.4byte	0x3f3
 6055 03ce 0B       		.uleb128 0xb
 6056 03cf C1000000 		.4byte	.LASF77
 6057 03d3 0A       		.byte	0xa
 6058 03d4 71       		.byte	0x71
 6059 03d5 B0000000 		.4byte	0xb0
 6060 03d9 00       		.byte	0
 6061 03da 0B       		.uleb128 0xb
 6062 03db D5080000 		.4byte	.LASF78
 6063 03df 0A       		.byte	0xa
 6064 03e0 72       		.byte	0x72
 6065 03e1 EB000000 		.4byte	0xeb
 6066 03e5 04       		.byte	0x4
 6067 03e6 0B       		.uleb128 0xb
 6068 03e7 890B0000 		.4byte	.LASF79
 6069 03eb 0A       		.byte	0xa
 6070 03ec 73       		.byte	0x73
 6071 03ed EB000000 		.4byte	0xeb
 6072 03f1 08       		.byte	0x8
 6073 03f2 00       		.byte	0
 6074 03f3 02       		.uleb128 0x2
 6075 03f4 5C030000 		.4byte	.LASF80
 6076 03f8 0A       		.byte	0xa
 6077 03f9 74       		.byte	0x74
 6078 03fa C2030000 		.4byte	0x3c2
 6079 03fe 07       		.uleb128 0x7
 6080 03ff BF000000 		.4byte	0xbf
 6081 0403 06       		.uleb128 0x6
 6082 0404 04       		.byte	0x4
 6083 0405 6C010000 		.4byte	0x16c
 6084 0409 06       		.uleb128 0x6
 6085 040a 04       		.byte	0x4
 6086 040b 0F040000 		.4byte	0x40f
 6087 040f 09       		.uleb128 0x9
 6088 0410 6C010000 		.4byte	0x16c
 6089 0414 11       		.uleb128 0x11
 6090 0415 B8000000 		.4byte	0xb8
 6091 0419 24040000 		.4byte	0x424
 6092 041d 12       		.uleb128 0x12
 6093 041e A9000000 		.4byte	0xa9
 6094 0422 0B       		.byte	0xb
 6095 0423 00       		.byte	0
 6096 0424 08       		.uleb128 0x8
 6097 0425 EF050000 		.4byte	.LASF81
 6098 0429 01       		.byte	0x1
 6099 042a 4901     		.2byte	0x149
 6100 042c 92020000 		.4byte	0x292
 6101 0430 08       		.uleb128 0x8
<<<<<<< HEAD
 6102 0431 490A0000 		.4byte	.LASF82
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 206
=======
 6102 0431 F7090000 		.4byte	.LASF82
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 206
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 6103 0435 01       		.byte	0x1
 6104 0436 4D01     		.2byte	0x14d
 6105 0438 24040000 		.4byte	0x424
 6106 043c 13       		.uleb128 0x13
 6107 043d 5E080000 		.4byte	.LASF87
 6108 0441 02       		.byte	0x2
 6109 0442 D1       		.byte	0xd1
 6110 0443 EB000000 		.4byte	0xeb
 6111 0447 03       		.byte	0x3
 6112 0448 63040000 		.4byte	0x463
 6113 044c 14       		.uleb128 0x14
 6114 044d 2A000000 		.4byte	.LASF83
 6115 0451 02       		.byte	0x2
 6116 0452 D3       		.byte	0xd3
 6117 0453 EB000000 		.4byte	0xeb
 6118 0457 14       		.uleb128 0x14
 6119 0458 91010000 		.4byte	.LASF84
 6120 045c 02       		.byte	0x2
 6121 045d D3       		.byte	0xd3
 6122 045e EB000000 		.4byte	0xeb
 6123 0462 00       		.byte	0
 6124 0463 15       		.uleb128 0x15
 6125 0464 E5080000 		.4byte	.LASF85
 6126 0468 02       		.byte	0x2
 6127 0469 E5       		.byte	0xe5
 6128 046a 03       		.byte	0x3
 6129 046b 7B040000 		.4byte	0x47b
 6130 046f 16       		.uleb128 0x16
 6131 0470 C30B0000 		.4byte	.LASF89
 6132 0474 02       		.byte	0x2
 6133 0475 E5       		.byte	0xe5
 6134 0476 EB000000 		.4byte	0xeb
 6135 047a 00       		.byte	0
 6136 047b 15       		.uleb128 0x15
 6137 047c FC060000 		.4byte	.LASF86
 6138 0480 02       		.byte	0x2
 6139 0481 C1       		.byte	0xc1
 6140 0482 03       		.byte	0x3
 6141 0483 93040000 		.4byte	0x493
 6142 0487 14       		.uleb128 0x14
 6143 0488 91010000 		.4byte	.LASF84
 6144 048c 02       		.byte	0x2
 6145 048d C3       		.byte	0xc3
 6146 048e EB000000 		.4byte	0xeb
 6147 0492 00       		.byte	0
 6148 0493 13       		.uleb128 0x13
 6149 0494 B60D0000 		.4byte	.LASF88
 6150 0498 02       		.byte	0x2
 6151 0499 82       		.byte	0x82
 6152 049a CA000000 		.4byte	0xca
 6153 049e 03       		.byte	0x3
 6154 049f BA040000 		.4byte	0x4ba
 6155 04a3 16       		.uleb128 0x16
 6156 04a4 5E0A0000 		.4byte	.LASF90
 6157 04a8 02       		.byte	0x2
 6158 04a9 82       		.byte	0x82
 6159 04aa EB000000 		.4byte	0xeb
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 207
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 207
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 6160 04ae 14       		.uleb128 0x14
 6161 04af 21000000 		.4byte	.LASF91
 6162 04b3 02       		.byte	0x2
 6163 04b4 84       		.byte	0x84
 6164 04b5 CA000000 		.4byte	0xca
 6165 04b9 00       		.byte	0
 6166 04ba 17       		.uleb128 0x17
 6167 04bb 11080000 		.4byte	.LASF115
 6168 04bf 01       		.byte	0x1
 6169 04c0 DD02     		.2byte	0x2dd
 6170 04c2 77010000 		.4byte	0x177
 6171 04c6 00000000 		.4byte	.LFB68
 6172 04ca 82000000 		.4byte	.LFE68-.LFB68
 6173 04ce 01       		.uleb128 0x1
 6174 04cf 9C       		.byte	0x9c
 6175 04d0 66050000 		.4byte	0x566
 6176 04d4 18       		.uleb128 0x18
 6177 04d5 46080000 		.4byte	.LASF92
 6178 04d9 01       		.byte	0x1
 6179 04da DD02     		.2byte	0x2dd
 6180 04dc 50010000 		.4byte	0x150
 6181 04e0 02       		.uleb128 0x2
 6182 04e1 91       		.byte	0x91
 6183 04e2 64       		.sleb128 -28
 6184 04e3 18       		.uleb128 0x18
 6185 04e4 DA0E0000 		.4byte	.LASF93
 6186 04e8 01       		.byte	0x1
 6187 04e9 DE02     		.2byte	0x2de
 6188 04eb FE030000 		.4byte	0x3fe
 6189 04ef 02       		.uleb128 0x2
 6190 04f0 91       		.byte	0x91
 6191 04f1 60       		.sleb128 -32
 6192 04f2 18       		.uleb128 0x18
 6193 04f3 4E040000 		.4byte	.LASF94
 6194 04f7 01       		.byte	0x1
 6195 04f8 DF02     		.2byte	0x2df
 6196 04fa 66050000 		.4byte	0x566
 6197 04fe 02       		.uleb128 0x2
 6198 04ff 91       		.byte	0x91
 6199 0500 5E       		.sleb128 -34
 6200 0501 18       		.uleb128 0x18
 6201 0502 C8050000 		.4byte	.LASF95
 6202 0506 01       		.byte	0x1
 6203 0507 E002     		.2byte	0x2e0
 6204 0509 6B050000 		.4byte	0x56b
 6205 050d 02       		.uleb128 0x2
 6206 050e 91       		.byte	0x91
 6207 050f 58       		.sleb128 -40
 6208 0510 18       		.uleb128 0x18
 6209 0511 A30E0000 		.4byte	.LASF52
 6210 0515 01       		.byte	0x1
 6211 0516 E102     		.2byte	0x2e1
 6212 0518 82010000 		.4byte	0x182
 6213 051c 02       		.uleb128 0x2
 6214 051d 91       		.byte	0x91
 6215 051e 00       		.sleb128 0
 6216 051f 18       		.uleb128 0x18
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 208
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 208
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 6217 0520 76050000 		.4byte	.LASF96
 6218 0524 01       		.byte	0x1
 6219 0525 E202     		.2byte	0x2e2
 6220 0527 76050000 		.4byte	0x576
 6221 052b 02       		.uleb128 0x2
 6222 052c 91       		.byte	0x91
 6223 052d 04       		.sleb128 4
 6224 052e 19       		.uleb128 0x19
 6225 052f D6020000 		.4byte	.LASF97
 6226 0533 01       		.byte	0x1
 6227 0534 E402     		.2byte	0x2e4
 6228 0536 7B050000 		.4byte	0x57b
 6229 053a 02       		.uleb128 0x2
 6230 053b 91       		.byte	0x91
 6231 053c 74       		.sleb128 -12
 6232 053d 19       		.uleb128 0x19
 6233 053e 2D050000 		.4byte	.LASF98
 6234 0542 01       		.byte	0x1
 6235 0543 E502     		.2byte	0x2e5
 6236 0545 77010000 		.4byte	0x177
 6237 0549 02       		.uleb128 0x2
 6238 054a 91       		.byte	0x91
 6239 054b 70       		.sleb128 -16
 6240 054c 1A       		.uleb128 0x1a
 6241 054d 10000000 		.4byte	.LBB27
 6242 0551 34000000 		.4byte	.LBE27-.LBB27
 6243 0555 19       		.uleb128 0x19
 6244 0556 8B070000 		.4byte	.LASF53
 6245 055a 01       		.byte	0x1
 6246 055b 0203     		.2byte	0x302
 6247 055d 03040000 		.4byte	0x403
 6248 0561 02       		.uleb128 0x2
 6249 0562 91       		.byte	0x91
 6250 0563 6C       		.sleb128 -20
 6251 0564 00       		.byte	0
 6252 0565 00       		.byte	0
 6253 0566 07       		.uleb128 0x7
 6254 0567 D5000000 		.4byte	0xd5
 6255 056b 07       		.uleb128 0x7
 6256 056c B0000000 		.4byte	0xb0
 6257 0570 06       		.uleb128 0x6
 6258 0571 04       		.byte	0x4
 6259 0572 81020000 		.4byte	0x281
 6260 0576 07       		.uleb128 0x7
 6261 0577 70050000 		.4byte	0x570
 6262 057b 06       		.uleb128 0x6
 6263 057c 04       		.byte	0x4
 6264 057d 30040000 		.4byte	0x430
 6265 0581 1B       		.uleb128 0x1b
 6266 0582 210B0000 		.4byte	.LASF101
 6267 0586 01       		.byte	0x1
 6268 0587 3803     		.2byte	0x338
 6269 0589 00000000 		.4byte	.LFB69
 6270 058d FE000000 		.4byte	.LFE69-.LFB69
 6271 0591 01       		.uleb128 0x1
 6272 0592 9C       		.byte	0x9c
 6273 0593 2C060000 		.4byte	0x62c
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 209
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 209
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 6274 0597 18       		.uleb128 0x18
 6275 0598 46080000 		.4byte	.LASF92
 6276 059c 01       		.byte	0x1
 6277 059d 3803     		.2byte	0x338
 6278 059f 50010000 		.4byte	0x150
 6279 05a3 02       		.uleb128 0x2
 6280 05a4 91       		.byte	0x91
 6281 05a5 6C       		.sleb128 -20
 6282 05a6 18       		.uleb128 0x18
 6283 05a7 DA0E0000 		.4byte	.LASF93
 6284 05ab 01       		.byte	0x1
 6285 05ac 3903     		.2byte	0x339
 6286 05ae FE030000 		.4byte	0x3fe
 6287 05b2 02       		.uleb128 0x2
 6288 05b3 91       		.byte	0x91
 6289 05b4 68       		.sleb128 -24
 6290 05b5 18       		.uleb128 0x18
 6291 05b6 51080000 		.4byte	.LASF99
 6292 05ba 01       		.byte	0x1
 6293 05bb 3A03     		.2byte	0x33a
 6294 05bd 2C060000 		.4byte	0x62c
 6295 05c1 02       		.uleb128 0x2
 6296 05c2 91       		.byte	0x91
 6297 05c3 64       		.sleb128 -28
 6298 05c4 18       		.uleb128 0x18
 6299 05c5 C8050000 		.4byte	.LASF95
 6300 05c9 01       		.byte	0x1
 6301 05ca 3B03     		.2byte	0x33b
 6302 05cc 6B050000 		.4byte	0x56b
 6303 05d0 02       		.uleb128 0x2
 6304 05d1 91       		.byte	0x91
 6305 05d2 60       		.sleb128 -32
 6306 05d3 18       		.uleb128 0x18
 6307 05d4 A30E0000 		.4byte	.LASF52
 6308 05d8 01       		.byte	0x1
 6309 05d9 3C03     		.2byte	0x33c
 6310 05db 82010000 		.4byte	0x182
 6311 05df 02       		.uleb128 0x2
 6312 05e0 91       		.byte	0x91
 6313 05e1 00       		.sleb128 0
 6314 05e2 18       		.uleb128 0x18
 6315 05e3 76050000 		.4byte	.LASF96
 6316 05e7 01       		.byte	0x1
 6317 05e8 3D03     		.2byte	0x33d
 6318 05ea 76050000 		.4byte	0x576
 6319 05ee 02       		.uleb128 0x2
 6320 05ef 91       		.byte	0x91
 6321 05f0 04       		.sleb128 4
 6322 05f1 18       		.uleb128 0x18
 6323 05f2 D6020000 		.4byte	.LASF97
 6324 05f6 01       		.byte	0x1
 6325 05f7 3E03     		.2byte	0x33e
 6326 05f9 7B050000 		.4byte	0x57b
 6327 05fd 02       		.uleb128 0x2
 6328 05fe 91       		.byte	0x91
 6329 05ff 08       		.sleb128 8
 6330 0600 18       		.uleb128 0x18
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 210
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 210
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 6331 0601 DF070000 		.4byte	.LASF100
 6332 0605 01       		.byte	0x1
 6333 0606 3F03     		.2byte	0x33f
 6334 0608 3C060000 		.4byte	0x63c
 6335 060c 02       		.uleb128 0x2
 6336 060d 91       		.byte	0x91
 6337 060e 0C       		.sleb128 12
 6338 060f 19       		.uleb128 0x19
 6339 0610 BB050000 		.4byte	.LASF49
 6340 0614 01       		.byte	0x1
 6341 0615 4103     		.2byte	0x341
 6342 0617 03040000 		.4byte	0x403
 6343 061b 02       		.uleb128 0x2
 6344 061c 91       		.byte	0x91
 6345 061d 70       		.sleb128 -16
 6346 061e 1C       		.uleb128 0x1c
 6347 061f 7800     		.ascii	"x\000"
 6348 0621 01       		.byte	0x1
 6349 0622 4203     		.2byte	0x342
 6350 0624 82010000 		.4byte	0x182
 6351 0628 02       		.uleb128 0x2
 6352 0629 91       		.byte	0x91
 6353 062a 74       		.sleb128 -12
 6354 062b 00       		.byte	0
 6355 062c 07       		.uleb128 0x7
 6356 062d EB000000 		.4byte	0xeb
 6357 0631 06       		.uleb128 0x6
 6358 0632 04       		.byte	0x4
 6359 0633 37060000 		.4byte	0x637
 6360 0637 07       		.uleb128 0x7
 6361 0638 F3030000 		.4byte	0x3f3
 6362 063c 07       		.uleb128 0x7
 6363 063d 31060000 		.4byte	0x631
 6364 0641 1B       		.uleb128 0x1b
 6365 0642 7A060000 		.4byte	.LASF102
 6366 0646 01       		.byte	0x1
 6367 0647 3504     		.2byte	0x435
 6368 0649 00000000 		.4byte	.LFB70
 6369 064d D4000000 		.4byte	.LFE70-.LFB70
 6370 0651 01       		.uleb128 0x1
 6371 0652 9C       		.byte	0x9c
 6372 0653 67060000 		.4byte	0x667
 6373 0657 18       		.uleb128 0x18
 6374 0658 D6020000 		.4byte	.LASF97
 6375 065c 01       		.byte	0x1
 6376 065d 3504     		.2byte	0x435
 6377 065f 7B050000 		.4byte	0x57b
 6378 0663 02       		.uleb128 0x2
 6379 0664 91       		.byte	0x91
 6380 0665 74       		.sleb128 -12
 6381 0666 00       		.byte	0
 6382 0667 1D       		.uleb128 0x1d
 6383 0668 580C0000 		.4byte	.LASF105
 6384 066c 01       		.byte	0x1
 6385 066d 8A04     		.2byte	0x48a
 6386 066f 00000000 		.4byte	.LFB71
 6387 0673 FC000000 		.4byte	.LFE71-.LFB71
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 211
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 211
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 6388 0677 01       		.uleb128 0x1
 6389 0678 9C       		.byte	0x9c
 6390 0679 9C060000 		.4byte	0x69c
 6391 067d 18       		.uleb128 0x18
 6392 067e 52090000 		.4byte	.LASF103
 6393 0682 01       		.byte	0x1
 6394 0683 8A04     		.2byte	0x48a
 6395 0685 81020000 		.4byte	0x281
 6396 0689 02       		.uleb128 0x2
 6397 068a 91       		.byte	0x91
 6398 068b 6C       		.sleb128 -20
 6399 068c 19       		.uleb128 0x19
 6400 068d 3B060000 		.4byte	.LASF104
 6401 0691 01       		.byte	0x1
 6402 0692 8C04     		.2byte	0x48c
 6403 0694 7B050000 		.4byte	0x57b
 6404 0698 02       		.uleb128 0x2
 6405 0699 91       		.byte	0x91
 6406 069a 74       		.sleb128 -12
 6407 069b 00       		.byte	0
 6408 069c 1D       		.uleb128 0x1d
 6409 069d CD090000 		.4byte	.LASF106
 6410 06a1 01       		.byte	0x1
 6411 06a2 E904     		.2byte	0x4e9
 6412 06a4 00000000 		.4byte	.LFB72
 6413 06a8 A0000000 		.4byte	.LFE72-.LFB72
 6414 06ac 01       		.uleb128 0x1
 6415 06ad 9C       		.byte	0x9c
 6416 06ae 17070000 		.4byte	0x717
 6417 06b2 18       		.uleb128 0x18
 6418 06b3 C2080000 		.4byte	.LASF107
 6419 06b7 01       		.byte	0x1
 6420 06b8 E904     		.2byte	0x4e9
 6421 06ba 1D070000 		.4byte	0x71d
 6422 06be 02       		.uleb128 0x2
 6423 06bf 91       		.byte	0x91
 6424 06c0 64       		.sleb128 -28
 6425 06c1 18       		.uleb128 0x18
 6426 06c2 DC0D0000 		.4byte	.LASF108
 6427 06c6 01       		.byte	0x1
 6428 06c7 E904     		.2byte	0x4e9
 6429 06c9 22070000 		.4byte	0x722
 6430 06cd 02       		.uleb128 0x2
 6431 06ce 91       		.byte	0x91
 6432 06cf 60       		.sleb128 -32
 6433 06d0 19       		.uleb128 0x19
 6434 06d1 A7010000 		.4byte	.LASF109
 6435 06d5 01       		.byte	0x1
 6436 06d6 EB04     		.2byte	0x4eb
 6437 06d8 8D010000 		.4byte	0x18d
 6438 06dc 02       		.uleb128 0x2
 6439 06dd 91       		.byte	0x91
 6440 06de 6C       		.sleb128 -20
 6441 06df 19       		.uleb128 0x19
 6442 06e0 B3010000 		.4byte	.LASF110
 6443 06e4 01       		.byte	0x1
 6444 06e5 EC04     		.2byte	0x4ec
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 212
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 212
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 6445 06e7 77010000 		.4byte	0x177
 6446 06eb 02       		.uleb128 0x2
 6447 06ec 91       		.byte	0x91
 6448 06ed 68       		.sleb128 -24
 6449 06ee 19       		.uleb128 0x19
 6450 06ef 4D0B0000 		.4byte	.LASF111
 6451 06f3 01       		.byte	0x1
 6452 06f4 EC04     		.2byte	0x4ec
 6453 06f6 77010000 		.4byte	0x177
 6454 06fa 02       		.uleb128 0x2
 6455 06fb 91       		.byte	0x91
 6456 06fc 74       		.sleb128 -12
 6457 06fd 1A       		.uleb128 0x1a
 6458 06fe 12000000 		.4byte	.LBB28
 6459 0702 62000000 		.4byte	.LBE28-.LBB28
 6460 0706 19       		.uleb128 0x19
 6461 0707 35050000 		.4byte	.LASF112
 6462 070b 01       		.byte	0x1
 6463 070c F604     		.2byte	0x4f6
 6464 070e 22070000 		.4byte	0x722
 6465 0712 02       		.uleb128 0x2
 6466 0713 91       		.byte	0x91
 6467 0714 70       		.sleb128 -16
 6468 0715 00       		.byte	0
 6469 0716 00       		.byte	0
 6470 0717 06       		.uleb128 0x6
 6471 0718 04       		.byte	0x4
 6472 0719 8D010000 		.4byte	0x18d
 6473 071d 07       		.uleb128 0x7
 6474 071e 17070000 		.4byte	0x717
 6475 0722 07       		.uleb128 0x7
 6476 0723 8D010000 		.4byte	0x18d
 6477 0727 1D       		.uleb128 0x1d
 6478 0728 E2000000 		.4byte	.LASF113
 6479 072c 01       		.byte	0x1
 6480 072d 3D05     		.2byte	0x53d
 6481 072f 00000000 		.4byte	.LFB73
 6482 0733 48000000 		.4byte	.LFE73-.LFB73
 6483 0737 01       		.uleb128 0x1
 6484 0738 9C       		.byte	0x9c
 6485 0739 5C070000 		.4byte	0x75c
 6486 073d 18       		.uleb128 0x18
 6487 073e CE0D0000 		.4byte	.LASF114
 6488 0742 01       		.byte	0x1
 6489 0743 3D05     		.2byte	0x53d
 6490 0745 22070000 		.4byte	0x722
 6491 0749 02       		.uleb128 0x2
 6492 074a 91       		.byte	0x91
 6493 074b 6C       		.sleb128 -20
 6494 074c 19       		.uleb128 0x19
 6495 074d B3010000 		.4byte	.LASF110
 6496 0751 01       		.byte	0x1
 6497 0752 3F05     		.2byte	0x53f
 6498 0754 77010000 		.4byte	0x177
 6499 0758 02       		.uleb128 0x2
 6500 0759 91       		.byte	0x91
 6501 075a 74       		.sleb128 -12
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 213
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 213
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 6502 075b 00       		.byte	0
 6503 075c 17       		.uleb128 0x17
 6504 075d B0090000 		.4byte	.LASF116
 6505 0761 01       		.byte	0x1
 6506 0762 6A05     		.2byte	0x56a
 6507 0764 51030000 		.4byte	0x351
 6508 0768 00000000 		.4byte	.LFB74
 6509 076c B0000000 		.4byte	.LFE74-.LFB74
 6510 0770 01       		.uleb128 0x1
 6511 0771 9C       		.byte	0x9c
 6512 0772 D1070000 		.4byte	0x7d1
 6513 0776 18       		.uleb128 0x18
 6514 0777 830B0000 		.4byte	.LASF117
 6515 077b 01       		.byte	0x1
 6516 077c 6A05     		.2byte	0x56a
 6517 077e 81020000 		.4byte	0x281
 6518 0782 02       		.uleb128 0x2
 6519 0783 91       		.byte	0x91
 6520 0784 5C       		.sleb128 -36
 6521 0785 19       		.uleb128 0x19
 6522 0786 E6030000 		.4byte	.LASF118
 6523 078a 01       		.byte	0x1
 6524 078b 6C05     		.2byte	0x56c
 6525 078d 51030000 		.4byte	0x351
 6526 0791 02       		.uleb128 0x2
 6527 0792 91       		.byte	0x91
 6528 0793 77       		.sleb128 -9
 6529 0794 19       		.uleb128 0x19
 6530 0795 1B040000 		.4byte	.LASF119
 6531 0799 01       		.byte	0x1
 6532 079a 6D05     		.2byte	0x56d
 6533 079c D1070000 		.4byte	0x7d1
 6534 07a0 02       		.uleb128 0x2
 6535 07a1 91       		.byte	0x91
 6536 07a2 6C       		.sleb128 -20
 6537 07a3 19       		.uleb128 0x19
 6538 07a4 9F060000 		.4byte	.LASF120
 6539 07a8 01       		.byte	0x1
 6540 07a9 6D05     		.2byte	0x56d
 6541 07ab D1070000 		.4byte	0x7d1
 6542 07af 02       		.uleb128 0x2
 6543 07b0 91       		.byte	0x91
 6544 07b1 68       		.sleb128 -24
 6545 07b2 19       		.uleb128 0x19
 6546 07b3 670A0000 		.4byte	.LASF121
 6547 07b7 01       		.byte	0x1
 6548 07b8 6D05     		.2byte	0x56d
 6549 07ba D1070000 		.4byte	0x7d1
 6550 07be 02       		.uleb128 0x2
 6551 07bf 91       		.byte	0x91
 6552 07c0 64       		.sleb128 -28
 6553 07c1 19       		.uleb128 0x19
 6554 07c2 3B060000 		.4byte	.LASF104
 6555 07c6 01       		.byte	0x1
 6556 07c7 6E05     		.2byte	0x56e
 6557 07c9 E7070000 		.4byte	0x7e7
 6558 07cd 02       		.uleb128 0x2
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 214
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 214
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 6559 07ce 91       		.byte	0x91
 6560 07cf 70       		.sleb128 -16
 6561 07d0 00       		.byte	0
 6562 07d1 06       		.uleb128 0x6
 6563 07d2 04       		.byte	0x4
 6564 07d3 D7070000 		.4byte	0x7d7
 6565 07d7 07       		.uleb128 0x7
 6566 07d8 76020000 		.4byte	0x276
 6567 07dc 06       		.uleb128 0x6
 6568 07dd 04       		.byte	0x4
 6569 07de E2070000 		.4byte	0x7e2
 6570 07e2 07       		.uleb128 0x7
 6571 07e3 30040000 		.4byte	0x430
 6572 07e7 07       		.uleb128 0x7
 6573 07e8 DC070000 		.4byte	0x7dc
 6574 07ec 17       		.uleb128 0x17
 6575 07ed E10E0000 		.4byte	.LASF122
 6576 07f1 01       		.byte	0x1
 6577 07f2 C605     		.2byte	0x5c6
 6578 07f4 82010000 		.4byte	0x182
 6579 07f8 00000000 		.4byte	.LFB75
 6580 07fc 34000000 		.4byte	.LFE75-.LFB75
 6581 0800 01       		.uleb128 0x1
 6582 0801 9C       		.byte	0x9c
 6583 0802 34080000 		.4byte	0x834
 6584 0806 18       		.uleb128 0x18
 6585 0807 830B0000 		.4byte	.LASF117
 6586 080b 01       		.byte	0x1
 6587 080c C605     		.2byte	0x5c6
 6588 080e 34080000 		.4byte	0x834
 6589 0812 02       		.uleb128 0x2
 6590 0813 91       		.byte	0x91
 6591 0814 6C       		.sleb128 -20
 6592 0815 19       		.uleb128 0x19
 6593 0816 3B060000 		.4byte	.LASF104
 6594 081a 01       		.byte	0x1
 6595 081b C805     		.2byte	0x5c8
 6596 081d DC070000 		.4byte	0x7dc
 6597 0821 02       		.uleb128 0x2
 6598 0822 91       		.byte	0x91
 6599 0823 74       		.sleb128 -12
 6600 0824 19       		.uleb128 0x19
 6601 0825 BA060000 		.4byte	.LASF123
 6602 0829 01       		.byte	0x1
 6603 082a C905     		.2byte	0x5c9
 6604 082c 82010000 		.4byte	0x182
 6605 0830 02       		.uleb128 0x2
 6606 0831 91       		.byte	0x91
 6607 0832 70       		.sleb128 -16
 6608 0833 00       		.byte	0
 6609 0834 07       		.uleb128 0x7
 6610 0835 81020000 		.4byte	0x281
 6611 0839 1E       		.uleb128 0x1e
 6612 083a D50A0000 		.4byte	.LASF124
 6613 083e 01       		.byte	0x1
 6614 083f DC05     		.2byte	0x5dc
 6615 0841 82010000 		.4byte	0x182
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 215
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 215
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 6616 0845 00000000 		.4byte	.LFB76
 6617 0849 54000000 		.4byte	.LFE76-.LFB76
 6618 084d 01       		.uleb128 0x1
 6619 084e 9C       		.byte	0x9c
 6620 084f D8080000 		.4byte	0x8d8
 6621 0853 18       		.uleb128 0x18
 6622 0854 830B0000 		.4byte	.LASF117
 6623 0858 01       		.byte	0x1
 6624 0859 DC05     		.2byte	0x5dc
 6625 085b 34080000 		.4byte	0x834
 6626 085f 02       		.uleb128 0x2
 6627 0860 91       		.byte	0x91
 6628 0861 5C       		.sleb128 -36
 6629 0862 19       		.uleb128 0x19
 6630 0863 3B060000 		.4byte	.LASF104
 6631 0867 01       		.byte	0x1
 6632 0868 DE05     		.2byte	0x5de
 6633 086a DC070000 		.4byte	0x7dc
 6634 086e 02       		.uleb128 0x2
 6635 086f 91       		.byte	0x91
 6636 0870 6C       		.sleb128 -20
 6637 0871 19       		.uleb128 0x19
 6638 0872 BA060000 		.4byte	.LASF123
 6639 0876 01       		.byte	0x1
 6640 0877 DF05     		.2byte	0x5df
 6641 0879 82010000 		.4byte	0x182
 6642 087d 02       		.uleb128 0x2
 6643 087e 91       		.byte	0x91
 6644 087f 68       		.sleb128 -24
 6645 0880 19       		.uleb128 0x19
 6646 0881 640C0000 		.4byte	.LASF125
 6647 0885 01       		.byte	0x1
 6648 0886 DF05     		.2byte	0x5df
 6649 0888 82010000 		.4byte	0x182
 6650 088c 02       		.uleb128 0x2
 6651 088d 91       		.byte	0x91
 6652 088e 70       		.sleb128 -16
 6653 088f 1F       		.uleb128 0x1f
 6654 0890 3C040000 		.4byte	0x43c
 6655 0894 08000000 		.4byte	.LBB29
 6656 0898 1A000000 		.4byte	.LBE29-.LBB29
 6657 089c 01       		.byte	0x1
 6658 089d F305     		.2byte	0x5f3
 6659 089f BE080000 		.4byte	0x8be
 6660 08a3 1A       		.uleb128 0x1a
 6661 08a4 08000000 		.4byte	.LBB30
 6662 08a8 1A000000 		.4byte	.LBE30-.LBB30
 6663 08ac 20       		.uleb128 0x20
 6664 08ad 4C040000 		.4byte	0x44c
 6665 08b1 02       		.uleb128 0x2
 6666 08b2 91       		.byte	0x91
 6667 08b3 64       		.sleb128 -28
 6668 08b4 20       		.uleb128 0x20
 6669 08b5 57040000 		.4byte	0x457
 6670 08b9 02       		.uleb128 0x2
 6671 08ba 91       		.byte	0x91
 6672 08bb 60       		.sleb128 -32
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 216
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 216
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 6673 08bc 00       		.byte	0
 6674 08bd 00       		.byte	0
 6675 08be 21       		.uleb128 0x21
 6676 08bf 63040000 		.4byte	0x463
 6677 08c3 3E000000 		.4byte	.LBB31
 6678 08c7 06000000 		.4byte	.LBE31-.LBB31
 6679 08cb 01       		.byte	0x1
 6680 08cc FA05     		.2byte	0x5fa
 6681 08ce 22       		.uleb128 0x22
 6682 08cf 6F040000 		.4byte	0x46f
 6683 08d3 02       		.uleb128 0x2
 6684 08d4 91       		.byte	0x91
 6685 08d5 74       		.sleb128 -12
 6686 08d6 00       		.byte	0
 6687 08d7 00       		.byte	0
 6688 08d8 1D       		.uleb128 0x1d
 6689 08d9 68040000 		.4byte	.LASF126
 6690 08dd 01       		.byte	0x1
 6691 08de 0406     		.2byte	0x604
 6692 08e0 00000000 		.4byte	.LFB77
 6693 08e4 38010000 		.4byte	.LFE77-.LFB77
 6694 08e8 01       		.uleb128 0x1
 6695 08e9 9C       		.byte	0x9c
 6696 08ea 49090000 		.4byte	0x949
 6697 08ee 18       		.uleb128 0x18
 6698 08ef 830B0000 		.4byte	.LASF117
 6699 08f3 01       		.byte	0x1
 6700 08f4 0406     		.2byte	0x604
 6701 08f6 81020000 		.4byte	0x281
 6702 08fa 02       		.uleb128 0x2
 6703 08fb 91       		.byte	0x91
 6704 08fc 64       		.sleb128 -28
 6705 08fd 18       		.uleb128 0x18
 6706 08fe 60090000 		.4byte	.LASF127
 6707 0902 01       		.byte	0x1
 6708 0903 0406     		.2byte	0x604
 6709 0905 82010000 		.4byte	0x182
 6710 0909 02       		.uleb128 0x2
 6711 090a 91       		.byte	0x91
 6712 090b 60       		.sleb128 -32
 6713 090c 19       		.uleb128 0x19
 6714 090d 3B060000 		.4byte	.LASF104
 6715 0911 01       		.byte	0x1
 6716 0912 0606     		.2byte	0x606
 6717 0914 7B050000 		.4byte	0x57b
 6718 0918 02       		.uleb128 0x2
 6719 0919 91       		.byte	0x91
 6720 091a 70       		.sleb128 -16
 6721 091b 19       		.uleb128 0x19
 6722 091c 330A0000 		.4byte	.LASF128
 6723 0920 01       		.byte	0x1
 6724 0921 0706     		.2byte	0x607
 6725 0923 82010000 		.4byte	0x182
 6726 0927 02       		.uleb128 0x2
 6727 0928 91       		.byte	0x91
 6728 0929 6C       		.sleb128 -20
 6729 092a 19       		.uleb128 0x19
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 217
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 217
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 6730 092b 28020000 		.4byte	.LASF129
 6731 092f 01       		.byte	0x1
 6732 0930 0706     		.2byte	0x607
 6733 0932 82010000 		.4byte	0x182
 6734 0936 02       		.uleb128 0x2
 6735 0937 91       		.byte	0x91
 6736 0938 68       		.sleb128 -24
 6737 0939 19       		.uleb128 0x19
 6738 093a 41060000 		.4byte	.LASF130
 6739 093e 01       		.byte	0x1
 6740 093f 0806     		.2byte	0x608
 6741 0941 77010000 		.4byte	0x177
 6742 0945 02       		.uleb128 0x2
 6743 0946 91       		.byte	0x91
 6744 0947 74       		.sleb128 -12
 6745 0948 00       		.byte	0
 6746 0949 1D       		.uleb128 0x1d
 6747 094a 43000000 		.4byte	.LASF131
 6748 094e 01       		.byte	0x1
 6749 094f A806     		.2byte	0x6a8
 6750 0951 00000000 		.4byte	.LFB78
 6751 0955 04010000 		.4byte	.LFE78-.LFB78
 6752 0959 01       		.uleb128 0x1
 6753 095a 9C       		.byte	0x9c
 6754 095b 7E090000 		.4byte	0x97e
 6755 095f 18       		.uleb128 0x18
 6756 0960 1D080000 		.4byte	.LASF132
 6757 0964 01       		.byte	0x1
 6758 0965 A806     		.2byte	0x6a8
 6759 0967 81020000 		.4byte	0x281
 6760 096b 02       		.uleb128 0x2
 6761 096c 91       		.byte	0x91
 6762 096d 6C       		.sleb128 -20
 6763 096e 19       		.uleb128 0x19
 6764 096f 3B060000 		.4byte	.LASF104
 6765 0973 01       		.byte	0x1
 6766 0974 AA06     		.2byte	0x6aa
 6767 0976 7B050000 		.4byte	0x57b
 6768 097a 02       		.uleb128 0x2
 6769 097b 91       		.byte	0x91
 6770 097c 74       		.sleb128 -12
 6771 097d 00       		.byte	0
 6772 097e 23       		.uleb128 0x23
 6773 097f 210E0000 		.4byte	.LASF175
 6774 0983 01       		.byte	0x1
 6775 0984 0D07     		.2byte	0x70d
 6776 0986 77010000 		.4byte	0x177
 6777 098a 00000000 		.4byte	.LFB79
 6778 098e 44000000 		.4byte	.LFE79-.LFB79
 6779 0992 01       		.uleb128 0x1
 6780 0993 9C       		.byte	0x9c
 6781 0994 C6090000 		.4byte	0x9c6
 6782 0998 18       		.uleb128 0x18
 6783 0999 830B0000 		.4byte	.LASF117
 6784 099d 01       		.byte	0x1
 6785 099e 0D07     		.2byte	0x70d
 6786 09a0 34080000 		.4byte	0x834
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 218
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 218
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 6787 09a4 02       		.uleb128 0x2
 6788 09a5 91       		.byte	0x91
 6789 09a6 6C       		.sleb128 -20
 6790 09a7 19       		.uleb128 0x19
 6791 09a8 2D050000 		.4byte	.LASF98
 6792 09ac 01       		.byte	0x1
 6793 09ad 0F07     		.2byte	0x70f
 6794 09af 77010000 		.4byte	0x177
 6795 09b3 02       		.uleb128 0x2
 6796 09b4 91       		.byte	0x91
 6797 09b5 74       		.sleb128 -12
 6798 09b6 19       		.uleb128 0x19
 6799 09b7 3B060000 		.4byte	.LASF104
 6800 09bb 01       		.byte	0x1
 6801 09bc 1007     		.2byte	0x710
 6802 09be E7070000 		.4byte	0x7e7
 6803 09c2 02       		.uleb128 0x2
 6804 09c3 91       		.byte	0x91
 6805 09c4 70       		.sleb128 -16
 6806 09c5 00       		.byte	0
 6807 09c6 1D       		.uleb128 0x1d
 6808 09c7 93060000 		.4byte	.LASF133
 6809 09cb 01       		.byte	0x1
 6810 09cc 3B07     		.2byte	0x73b
 6811 09ce 00000000 		.4byte	.LFB80
 6812 09d2 A0000000 		.4byte	.LFE80-.LFB80
 6813 09d6 01       		.uleb128 0x1
 6814 09d7 9C       		.byte	0x9c
 6815 09d8 FB090000 		.4byte	0x9fb
 6816 09dc 18       		.uleb128 0x18
 6817 09dd A30A0000 		.4byte	.LASF134
 6818 09e1 01       		.byte	0x1
 6819 09e2 3B07     		.2byte	0x73b
 6820 09e4 81020000 		.4byte	0x281
 6821 09e8 02       		.uleb128 0x2
 6822 09e9 91       		.byte	0x91
 6823 09ea 6C       		.sleb128 -20
 6824 09eb 19       		.uleb128 0x19
 6825 09ec 3B060000 		.4byte	.LASF104
 6826 09f0 01       		.byte	0x1
 6827 09f1 3D07     		.2byte	0x73d
 6828 09f3 FB090000 		.4byte	0x9fb
 6829 09f7 02       		.uleb128 0x2
 6830 09f8 91       		.byte	0x91
 6831 09f9 74       		.sleb128 -12
 6832 09fa 00       		.byte	0
 6833 09fb 07       		.uleb128 0x7
 6834 09fc 7B050000 		.4byte	0x57b
 6835 0a00 17       		.uleb128 0x17
 6836 0a01 0D050000 		.4byte	.LASF135
 6837 0a05 01       		.byte	0x1
 6838 0a06 7107     		.2byte	0x771
 6839 0a08 77010000 		.4byte	0x177
 6840 0a0c 00000000 		.4byte	.LFB81
 6841 0a10 C0000000 		.4byte	.LFE81-.LFB81
 6842 0a14 01       		.uleb128 0x1
 6843 0a15 9C       		.byte	0x9c
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 219
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 219
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 6844 0a16 9F0A0000 		.4byte	0xa9f
 6845 0a1a 18       		.uleb128 0x18
 6846 0a1b A30A0000 		.4byte	.LASF134
 6847 0a1f 01       		.byte	0x1
 6848 0a20 7107     		.2byte	0x771
 6849 0a22 81020000 		.4byte	0x281
 6850 0a26 02       		.uleb128 0x2
 6851 0a27 91       		.byte	0x91
 6852 0a28 5C       		.sleb128 -36
 6853 0a29 19       		.uleb128 0x19
 6854 0a2a 41060000 		.4byte	.LASF130
 6855 0a2e 01       		.byte	0x1
 6856 0a2f 7307     		.2byte	0x773
 6857 0a31 77010000 		.4byte	0x177
 6858 0a35 02       		.uleb128 0x2
 6859 0a36 91       		.byte	0x91
 6860 0a37 74       		.sleb128 -12
 6861 0a38 19       		.uleb128 0x19
 6862 0a39 3B060000 		.4byte	.LASF104
 6863 0a3d 01       		.byte	0x1
 6864 0a3e 7407     		.2byte	0x774
 6865 0a40 FB090000 		.4byte	0x9fb
 6866 0a44 02       		.uleb128 0x2
 6867 0a45 91       		.byte	0x91
 6868 0a46 70       		.sleb128 -16
 6869 0a47 19       		.uleb128 0x19
 6870 0a48 360B0000 		.4byte	.LASF136
 6871 0a4c 01       		.byte	0x1
 6872 0a4d 7507     		.2byte	0x775
 6873 0a4f 82010000 		.4byte	0x182
 6874 0a53 02       		.uleb128 0x2
 6875 0a54 91       		.byte	0x91
 6876 0a55 68       		.sleb128 -24
 6877 0a56 1F       		.uleb128 0x1f
 6878 0a57 3C040000 		.4byte	0x43c
 6879 0a5b 10000000 		.4byte	.LBB33
 6880 0a5f 1A000000 		.4byte	.LBE33-.LBB33
 6881 0a63 01       		.byte	0x1
 6882 0a64 8B07     		.2byte	0x78b
 6883 0a66 850A0000 		.4byte	0xa85
 6884 0a6a 1A       		.uleb128 0x1a
 6885 0a6b 10000000 		.4byte	.LBB34
 6886 0a6f 1A000000 		.4byte	.LBE34-.LBB34
 6887 0a73 20       		.uleb128 0x20
 6888 0a74 4C040000 		.4byte	0x44c
 6889 0a78 02       		.uleb128 0x2
 6890 0a79 91       		.byte	0x91
 6891 0a7a 64       		.sleb128 -28
 6892 0a7b 20       		.uleb128 0x20
 6893 0a7c 57040000 		.4byte	0x457
 6894 0a80 02       		.uleb128 0x2
 6895 0a81 91       		.byte	0x91
 6896 0a82 60       		.sleb128 -32
 6897 0a83 00       		.byte	0
 6898 0a84 00       		.byte	0
 6899 0a85 21       		.uleb128 0x21
 6900 0a86 63040000 		.4byte	0x463
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 220
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 220
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 6901 0a8a 9C000000 		.4byte	.LBB35
 6902 0a8e 06000000 		.4byte	.LBE35-.LBB35
 6903 0a92 01       		.byte	0x1
 6904 0a93 AF07     		.2byte	0x7af
 6905 0a95 22       		.uleb128 0x22
 6906 0a96 6F040000 		.4byte	0x46f
 6907 0a9a 02       		.uleb128 0x2
 6908 0a9b 91       		.byte	0x91
 6909 0a9c 6C       		.sleb128 -20
 6910 0a9d 00       		.byte	0
 6911 0a9e 00       		.byte	0
 6912 0a9f 1D       		.uleb128 0x1d
 6913 0aa0 88040000 		.4byte	.LASF137
 6914 0aa4 01       		.byte	0x1
 6915 0aa5 B707     		.2byte	0x7b7
 6916 0aa7 00000000 		.4byte	.LFB82
 6917 0aab 6C000000 		.4byte	.LFE82-.LFB82
 6918 0aaf 01       		.uleb128 0x1
 6919 0ab0 9C       		.byte	0x9c
 6920 0ab1 E80A0000 		.4byte	0xae8
 6921 0ab5 19       		.uleb128 0x19
 6922 0ab6 2D050000 		.4byte	.LASF98
 6923 0aba 01       		.byte	0x1
 6924 0abb B907     		.2byte	0x7b9
 6925 0abd 77010000 		.4byte	0x177
 6926 0ac1 02       		.uleb128 0x2
 6927 0ac2 91       		.byte	0x91
 6928 0ac3 74       		.sleb128 -12
 6929 0ac4 21       		.uleb128 0x21
 6930 0ac5 7B040000 		.4byte	0x47b
 6931 0ac9 22000000 		.4byte	.LBB37
 6932 0acd 12000000 		.4byte	.LBE37-.LBB37
 6933 0ad1 01       		.byte	0x1
 6934 0ad2 FF07     		.2byte	0x7ff
 6935 0ad4 1A       		.uleb128 0x1a
 6936 0ad5 22000000 		.4byte	.LBB38
 6937 0ad9 12000000 		.4byte	.LBE38-.LBB38
 6938 0add 20       		.uleb128 0x20
 6939 0ade 87040000 		.4byte	0x487
 6940 0ae2 02       		.uleb128 0x2
 6941 0ae3 91       		.byte	0x91
 6942 0ae4 70       		.sleb128 -16
 6943 0ae5 00       		.byte	0
 6944 0ae6 00       		.byte	0
 6945 0ae7 00       		.byte	0
 6946 0ae8 1D       		.uleb128 0x1d
 6947 0ae9 910A0000 		.4byte	.LASF138
 6948 0aed 01       		.byte	0x1
 6949 0aee 3308     		.2byte	0x833
 6950 0af0 00000000 		.4byte	.LFB83
 6951 0af4 30000000 		.4byte	.LFE83-.LFB83
 6952 0af8 01       		.uleb128 0x1
 6953 0af9 9C       		.byte	0x9c
 6954 0afa 220B0000 		.4byte	0xb22
 6955 0afe 21       		.uleb128 0x21
 6956 0aff 7B040000 		.4byte	0x47b
 6957 0b03 06000000 		.4byte	.LBB39
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 221
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 221
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 6958 0b07 12000000 		.4byte	.LBE39-.LBB39
 6959 0b0b 01       		.byte	0x1
 6960 0b0c 3808     		.2byte	0x838
 6961 0b0e 1A       		.uleb128 0x1a
 6962 0b0f 06000000 		.4byte	.LBB40
 6963 0b13 12000000 		.4byte	.LBE40-.LBB40
 6964 0b17 20       		.uleb128 0x20
 6965 0b18 87040000 		.4byte	0x487
 6966 0b1c 02       		.uleb128 0x2
 6967 0b1d 91       		.byte	0x91
 6968 0b1e 74       		.sleb128 -12
 6969 0b1f 00       		.byte	0
 6970 0b20 00       		.byte	0
 6971 0b21 00       		.byte	0
 6972 0b22 24       		.uleb128 0x24
 6973 0b23 A50B0000 		.4byte	.LASF170
 6974 0b27 01       		.byte	0x1
 6975 0b28 3E08     		.2byte	0x83e
 6976 0b2a 00000000 		.4byte	.LFB84
 6977 0b2e 1C000000 		.4byte	.LFE84-.LFB84
 6978 0b32 01       		.uleb128 0x1
 6979 0b33 9C       		.byte	0x9c
 6980 0b34 17       		.uleb128 0x17
 6981 0b35 B10A0000 		.4byte	.LASF139
 6982 0b39 01       		.byte	0x1
 6983 0b3a 9208     		.2byte	0x892
 6984 0b3c 77010000 		.4byte	0x177
 6985 0b40 00000000 		.4byte	.LFB85
 6986 0b44 1C010000 		.4byte	.LFE85-.LFB85
 6987 0b48 01       		.uleb128 0x1
 6988 0b49 9C       		.byte	0x9c
 6989 0b4a 860B0000 		.4byte	0xb86
 6990 0b4e 19       		.uleb128 0x19
 6991 0b4f 3B060000 		.4byte	.LASF104
 6992 0b53 01       		.byte	0x1
 6993 0b54 9408     		.2byte	0x894
 6994 0b56 7B050000 		.4byte	0x57b
 6995 0b5a 02       		.uleb128 0x2
 6996 0b5b 91       		.byte	0x91
 6997 0b5c 74       		.sleb128 -12
 6998 0b5d 19       		.uleb128 0x19
 6999 0b5e B3010000 		.4byte	.LASF110
 7000 0b62 01       		.byte	0x1
 7001 0b63 9508     		.2byte	0x895
 7002 0b65 77010000 		.4byte	0x177
 7003 0b69 02       		.uleb128 0x2
 7004 0b6a 91       		.byte	0x91
 7005 0b6b 70       		.sleb128 -16
 7006 0b6c 1A       		.uleb128 0x1a
 7007 0b6d 9E000000 		.4byte	.LBB41
 7008 0b71 2E000000 		.4byte	.LBE41-.LBB41
 7009 0b75 19       		.uleb128 0x19
 7010 0b76 74090000 		.4byte	.LASF140
 7011 0b7a 01       		.byte	0x1
 7012 0b7b CD08     		.2byte	0x8cd
 7013 0b7d 8D010000 		.4byte	0x18d
 7014 0b81 02       		.uleb128 0x2
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 222
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 222
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 7015 0b82 91       		.byte	0x91
 7016 0b83 6C       		.sleb128 -20
 7017 0b84 00       		.byte	0
 7018 0b85 00       		.byte	0
 7019 0b86 1E       		.uleb128 0x1e
 7020 0b87 DE060000 		.4byte	.LASF141
 7021 0b8b 01       		.byte	0x1
 7022 0b8c 0009     		.2byte	0x900
 7023 0b8e 8D010000 		.4byte	0x18d
 7024 0b92 00000000 		.4byte	.LFB86
 7025 0b96 1C000000 		.4byte	.LFE86-.LFB86
 7026 0b9a 01       		.uleb128 0x1
 7027 0b9b 9C       		.byte	0x9c
 7028 0b9c B00B0000 		.4byte	0xbb0
 7029 0ba0 19       		.uleb128 0x19
 7030 0ba1 3C000000 		.4byte	.LASF142
 7031 0ba5 01       		.byte	0x1
 7032 0ba6 0209     		.2byte	0x902
 7033 0ba8 8D010000 		.4byte	0x18d
 7034 0bac 02       		.uleb128 0x2
 7035 0bad 91       		.byte	0x91
 7036 0bae 74       		.sleb128 -12
 7037 0baf 00       		.byte	0
 7038 0bb0 1E       		.uleb128 0x1e
 7039 0bb1 0C030000 		.4byte	.LASF143
 7040 0bb5 01       		.byte	0x1
 7041 0bb6 0F09     		.2byte	0x90f
 7042 0bb8 8D010000 		.4byte	0x18d
 7043 0bbc 00000000 		.4byte	.LFB87
 7044 0bc0 20000000 		.4byte	.LFE87-.LFB87
 7045 0bc4 01       		.uleb128 0x1
 7046 0bc5 9C       		.byte	0x9c
 7047 0bc6 E90B0000 		.4byte	0xbe9
 7048 0bca 19       		.uleb128 0x19
 7049 0bcb 2D050000 		.4byte	.LASF98
 7050 0bcf 01       		.byte	0x1
 7051 0bd0 1109     		.2byte	0x911
 7052 0bd2 8D010000 		.4byte	0x18d
 7053 0bd6 02       		.uleb128 0x2
 7054 0bd7 91       		.byte	0x91
 7055 0bd8 70       		.sleb128 -16
 7056 0bd9 19       		.uleb128 0x19
 7057 0bda 360B0000 		.4byte	.LASF136
 7058 0bde 01       		.byte	0x1
 7059 0bdf 1209     		.2byte	0x912
 7060 0be1 82010000 		.4byte	0x182
 7061 0be5 02       		.uleb128 0x2
 7062 0be6 91       		.byte	0x91
 7063 0be7 74       		.sleb128 -12
 7064 0be8 00       		.byte	0
 7065 0be9 25       		.uleb128 0x25
 7066 0bea FF0C0000 		.4byte	.LASF193
 7067 0bee 01       		.byte	0x1
 7068 0bef 2E09     		.2byte	0x92e
 7069 0bf1 82010000 		.4byte	0x182
 7070 0bf5 00000000 		.4byte	.LFB88
 7071 0bf9 14000000 		.4byte	.LFE88-.LFB88
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 223
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 223
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 7072 0bfd 01       		.uleb128 0x1
 7073 0bfe 9C       		.byte	0x9c
 7074 0bff 1E       		.uleb128 0x1e
 7075 0c00 F60B0000 		.4byte	.LASF144
 7076 0c04 01       		.byte	0x1
 7077 0c05 3609     		.2byte	0x936
 7078 0c07 B2000000 		.4byte	0xb2
 7079 0c0b 00000000 		.4byte	.LFB89
 7080 0c0f 2C000000 		.4byte	.LFE89-.LFB89
 7081 0c13 01       		.uleb128 0x1
 7082 0c14 9C       		.byte	0x9c
 7083 0c15 380C0000 		.4byte	0xc38
 7084 0c19 18       		.uleb128 0x18
 7085 0c1a 5B040000 		.4byte	.LASF145
 7086 0c1e 01       		.byte	0x1
 7087 0c1f 3609     		.2byte	0x936
 7088 0c21 81020000 		.4byte	0x281
 7089 0c25 02       		.uleb128 0x2
 7090 0c26 91       		.byte	0x91
 7091 0c27 6C       		.sleb128 -20
 7092 0c28 19       		.uleb128 0x19
 7093 0c29 3B060000 		.4byte	.LASF104
 7094 0c2d 01       		.byte	0x1
 7095 0c2e 3809     		.2byte	0x938
 7096 0c30 7B050000 		.4byte	0x57b
 7097 0c34 02       		.uleb128 0x2
 7098 0c35 91       		.byte	0x91
 7099 0c36 74       		.sleb128 -12
 7100 0c37 00       		.byte	0
 7101 0c38 17       		.uleb128 0x17
 7102 0c39 45050000 		.4byte	.LASF146
 7103 0c3d 01       		.byte	0x1
 7104 0c3e 310A     		.2byte	0xa31
 7105 0c40 77010000 		.4byte	0x177
 7106 0c44 00000000 		.4byte	.LFB90
 7107 0c48 30000000 		.4byte	.LFE90-.LFB90
 7108 0c4c 01       		.uleb128 0x1
 7109 0c4d 9C       		.byte	0x9c
 7110 0c4e 710C0000 		.4byte	0xc71
 7111 0c52 18       		.uleb128 0x18
 7112 0c53 9F080000 		.4byte	.LASF147
 7113 0c57 01       		.byte	0x1
 7114 0c58 310A     		.2byte	0xa31
 7115 0c5a 8D010000 		.4byte	0x18d
 7116 0c5e 02       		.uleb128 0x2
 7117 0c5f 91       		.byte	0x91
 7118 0c60 6C       		.sleb128 -20
 7119 0c61 19       		.uleb128 0x19
 7120 0c62 41060000 		.4byte	.LASF130
 7121 0c66 01       		.byte	0x1
 7122 0c67 330A     		.2byte	0xa33
 7123 0c69 77010000 		.4byte	0x177
 7124 0c6d 02       		.uleb128 0x2
 7125 0c6e 91       		.byte	0x91
 7126 0c6f 74       		.sleb128 -12
 7127 0c70 00       		.byte	0
 7128 0c71 17       		.uleb128 0x17
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 224
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 224
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 7129 0c72 9C040000 		.4byte	.LASF148
 7130 0c76 01       		.byte	0x1
 7131 0c77 930A     		.2byte	0xa93
 7132 0c79 77010000 		.4byte	0x177
 7133 0c7d 00000000 		.4byte	.LFB91
 7134 0c81 50010000 		.4byte	.LFE91-.LFB91
 7135 0c85 01       		.uleb128 0x1
 7136 0c86 9C       		.byte	0x9c
 7137 0c87 EB0C0000 		.4byte	0xceb
 7138 0c8b 19       		.uleb128 0x19
 7139 0c8c 3B060000 		.4byte	.LASF104
 7140 0c90 01       		.byte	0x1
 7141 0c91 950A     		.2byte	0xa95
 7142 0c93 7B050000 		.4byte	0x57b
 7143 0c97 02       		.uleb128 0x2
 7144 0c98 91       		.byte	0x91
 7145 0c99 68       		.sleb128 -24
 7146 0c9a 19       		.uleb128 0x19
 7147 0c9b AB0D0000 		.4byte	.LASF34
 7148 0c9f 01       		.byte	0x1
 7149 0ca0 960A     		.2byte	0xa96
 7150 0ca2 8D010000 		.4byte	0x18d
 7151 0ca6 02       		.uleb128 0x2
 7152 0ca7 91       		.byte	0x91
 7153 0ca8 64       		.sleb128 -28
 7154 0ca9 19       		.uleb128 0x19
 7155 0caa EE030000 		.4byte	.LASF149
 7156 0cae 01       		.byte	0x1
 7157 0caf 970A     		.2byte	0xa97
 7158 0cb1 77010000 		.4byte	0x177
 7159 0cb5 02       		.uleb128 0x2
 7160 0cb6 91       		.byte	0x91
 7161 0cb7 74       		.sleb128 -12
 7162 0cb8 1A       		.uleb128 0x1a
 7163 0cb9 12000000 		.4byte	.LBB42
 7164 0cbd FC000000 		.4byte	.LBE42-.LBB42
 7165 0cc1 19       		.uleb128 0x19
 7166 0cc2 35050000 		.4byte	.LASF112
 7167 0cc6 01       		.byte	0x1
 7168 0cc7 A10A     		.2byte	0xaa1
 7169 0cc9 22070000 		.4byte	0x722
 7170 0ccd 02       		.uleb128 0x2
 7171 0cce 91       		.byte	0x91
 7172 0ccf 70       		.sleb128 -16
 7173 0cd0 1A       		.uleb128 0x1a
 7174 0cd1 26000000 		.4byte	.LBB43
 7175 0cd5 22000000 		.4byte	.LBE43-.LBB43
 7176 0cd9 19       		.uleb128 0x19
 7177 0cda B60C0000 		.4byte	.LASF150
 7178 0cde 01       		.byte	0x1
 7179 0cdf A90A     		.2byte	0xaa9
 7180 0ce1 EB0C0000 		.4byte	0xceb
 7181 0ce5 02       		.uleb128 0x2
 7182 0ce6 91       		.byte	0x91
 7183 0ce7 6C       		.sleb128 -20
 7184 0ce8 00       		.byte	0
 7185 0ce9 00       		.byte	0
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 225
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 225
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 7186 0cea 00       		.byte	0
 7187 0ceb 06       		.uleb128 0x6
 7188 0cec 04       		.byte	0x4
 7189 0ced 76020000 		.4byte	0x276
 7190 0cf1 1D       		.uleb128 0x1d
 7191 0cf2 5F070000 		.4byte	.LASF151
 7192 0cf6 01       		.byte	0x1
 7193 0cf7 AD0B     		.2byte	0xbad
 7194 0cf9 00000000 		.4byte	.LFB92
 7195 0cfd D8000000 		.4byte	.LFE92-.LFB92
 7196 0d01 01       		.uleb128 0x1
 7197 0d02 9C       		.byte	0x9c
 7198 0d03 950D0000 		.4byte	0xd95
 7199 0d07 26       		.uleb128 0x26
 7200 0d08 1C000000 		.4byte	.LBB44
 7201 0d0c 4E000000 		.4byte	.LBE44-.LBB44
 7202 0d10 330D0000 		.4byte	0xd33
 7203 0d14 19       		.uleb128 0x19
 7204 0d15 5A0F0000 		.4byte	.LASF152
 7205 0d19 01       		.byte	0x1
 7206 0d1a D60B     		.2byte	0xbd6
 7207 0d1c 9B0D0000 		.4byte	0xd9b
 7208 0d20 02       		.uleb128 0x2
 7209 0d21 91       		.byte	0x91
 7210 0d22 74       		.sleb128 -12
 7211 0d23 19       		.uleb128 0x19
 7212 0d24 160D0000 		.4byte	.LASF153
 7213 0d28 01       		.byte	0x1
 7214 0d29 D60B     		.2byte	0xbd6
 7215 0d2b 2C060000 		.4byte	0x62c
 7216 0d2f 02       		.uleb128 0x2
 7217 0d30 91       		.byte	0x91
 7218 0d31 70       		.sleb128 -16
 7219 0d32 00       		.byte	0
 7220 0d33 1A       		.uleb128 0x1a
 7221 0d34 6A000000 		.4byte	.LBB45
 7222 0d38 50000000 		.4byte	.LBE45-.LBB45
 7223 0d3c 19       		.uleb128 0x19
 7224 0d3d 24090000 		.4byte	.LASF154
 7225 0d41 01       		.byte	0x1
 7226 0d42 E10B     		.2byte	0xbe1
 7227 0d44 82010000 		.4byte	0x182
 7228 0d48 02       		.uleb128 0x2
 7229 0d49 91       		.byte	0x91
 7230 0d4a 6C       		.sleb128 -20
 7231 0d4b 1F       		.uleb128 0x1f
 7232 0d4c 93040000 		.4byte	0x493
 7233 0d50 70000000 		.4byte	.LBB46
 7234 0d54 0A000000 		.4byte	.LBE46-.LBB46
 7235 0d58 01       		.byte	0x1
 7236 0d59 E10B     		.2byte	0xbe1
 7237 0d5b 7A0D0000 		.4byte	0xd7a
 7238 0d5f 22       		.uleb128 0x22
 7239 0d60 A3040000 		.4byte	0x4a3
 7240 0d64 02       		.uleb128 0x2
 7241 0d65 91       		.byte	0x91
 7242 0d66 64       		.sleb128 -28
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 226
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 226
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 7243 0d67 1A       		.uleb128 0x1a
 7244 0d68 70000000 		.4byte	.LBB47
 7245 0d6c 0A000000 		.4byte	.LBE47-.LBB47
 7246 0d70 20       		.uleb128 0x20
 7247 0d71 AE040000 		.4byte	0x4ae
 7248 0d75 02       		.uleb128 0x2
 7249 0d76 91       		.byte	0x91
 7250 0d77 63       		.sleb128 -29
 7251 0d78 00       		.byte	0
 7252 0d79 00       		.byte	0
 7253 0d7a 1A       		.uleb128 0x1a
 7254 0d7b 80000000 		.4byte	.LBB48
 7255 0d7f 3A000000 		.4byte	.LBE48-.LBB48
 7256 0d83 19       		.uleb128 0x19
 7257 0d84 10060000 		.4byte	.LASF155
 7258 0d88 01       		.byte	0x1
 7259 0d89 E10B     		.2byte	0xbe1
 7260 0d8b A00D0000 		.4byte	0xda0
 7261 0d8f 02       		.uleb128 0x2
 7262 0d90 91       		.byte	0x91
 7263 0d91 68       		.sleb128 -24
 7264 0d92 00       		.byte	0
 7265 0d93 00       		.byte	0
 7266 0d94 00       		.byte	0
 7267 0d95 06       		.uleb128 0x6
 7268 0d96 04       		.byte	0x4
 7269 0d97 2C060000 		.4byte	0x62c
 7270 0d9b 07       		.uleb128 0x7
 7271 0d9c 950D0000 		.4byte	0xd95
 7272 0da0 07       		.uleb128 0x7
 7273 0da1 EB0C0000 		.4byte	0xceb
 7274 0da5 1D       		.uleb128 0x1d
 7275 0da6 C9040000 		.4byte	.LASF156
 7276 0daa 01       		.byte	0x1
 7277 0dab F80B     		.2byte	0xbf8
 7278 0dad 00000000 		.4byte	.LFB93
 7279 0db1 2C000000 		.4byte	.LFE93-.LFB93
 7280 0db5 01       		.uleb128 0x1
 7281 0db6 9C       		.byte	0x9c
 7282 0db7 DA0D0000 		.4byte	0xdda
 7283 0dbb 18       		.uleb128 0x18
 7284 0dbc F0060000 		.4byte	.LASF157
 7285 0dc0 01       		.byte	0x1
 7286 0dc1 F80B     		.2byte	0xbf8
 7287 0dc3 A00D0000 		.4byte	0xda0
 7288 0dc7 02       		.uleb128 0x2
 7289 0dc8 91       		.byte	0x91
 7290 0dc9 74       		.sleb128 -12
 7291 0dca 18       		.uleb128 0x18
 7292 0dcb 3E020000 		.4byte	.LASF158
 7293 0dcf 01       		.byte	0x1
 7294 0dd0 F80B     		.2byte	0xbf8
 7295 0dd2 22070000 		.4byte	0x722
 7296 0dd6 02       		.uleb128 0x2
 7297 0dd7 91       		.byte	0x91
 7298 0dd8 70       		.sleb128 -16
 7299 0dd9 00       		.byte	0
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 227
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 227
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 7300 0dda 1D       		.uleb128 0x1d
 7301 0ddb 57050000 		.4byte	.LASF159
 7302 0ddf 01       		.byte	0x1
 7303 0de0 090C     		.2byte	0xc09
 7304 0de2 00000000 		.4byte	.LFB94
 7305 0de6 3C000000 		.4byte	.LFE94-.LFB94
 7306 0dea 01       		.uleb128 0x1
 7307 0deb 9C       		.byte	0x9c
 7308 0dec 1E0E0000 		.4byte	0xe1e
 7309 0df0 18       		.uleb128 0x18
 7310 0df1 F0060000 		.4byte	.LASF157
 7311 0df5 01       		.byte	0x1
 7312 0df6 090C     		.2byte	0xc09
 7313 0df8 EB0C0000 		.4byte	0xceb
 7314 0dfc 02       		.uleb128 0x2
 7315 0dfd 91       		.byte	0x91
 7316 0dfe 74       		.sleb128 -12
 7317 0dff 18       		.uleb128 0x18
 7318 0e00 AB0D0000 		.4byte	.LASF34
 7319 0e04 01       		.byte	0x1
 7320 0e05 090C     		.2byte	0xc09
 7321 0e07 22070000 		.4byte	0x722
 7322 0e0b 02       		.uleb128 0x2
 7323 0e0c 91       		.byte	0x91
 7324 0e0d 70       		.sleb128 -16
 7325 0e0e 18       		.uleb128 0x18
 7326 0e0f 3E020000 		.4byte	.LASF158
 7327 0e13 01       		.byte	0x1
 7328 0e14 090C     		.2byte	0xc09
 7329 0e16 22070000 		.4byte	0x722
 7330 0e1a 02       		.uleb128 0x2
 7331 0e1b 91       		.byte	0x91
 7332 0e1c 6C       		.sleb128 -20
 7333 0e1d 00       		.byte	0
 7334 0e1e 17       		.uleb128 0x17
 7335 0e1f 040C0000 		.4byte	.LASF160
 7336 0e23 01       		.byte	0x1
 7337 0e24 420C     		.2byte	0xc42
 7338 0e26 77010000 		.4byte	0x177
 7339 0e2a 00000000 		.4byte	.LFB95
 7340 0e2e A8000000 		.4byte	.LFE95-.LFB95
 7341 0e32 01       		.uleb128 0x1
 7342 0e33 9C       		.byte	0x9c
 7343 0e34 660E0000 		.4byte	0xe66
 7344 0e38 18       		.uleb128 0x18
 7345 0e39 F0060000 		.4byte	.LASF157
 7346 0e3d 01       		.byte	0x1
 7347 0e3e 420C     		.2byte	0xc42
 7348 0e40 660E0000 		.4byte	0xe66
 7349 0e44 02       		.uleb128 0x2
 7350 0e45 91       		.byte	0x91
 7351 0e46 6C       		.sleb128 -20
 7352 0e47 19       		.uleb128 0x19
 7353 0e48 4F0A0000 		.4byte	.LASF161
 7354 0e4c 01       		.byte	0x1
 7355 0e4d 440C     		.2byte	0xc44
 7356 0e4f 7B050000 		.4byte	0x57b
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 228
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 228
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 7357 0e53 02       		.uleb128 0x2
 7358 0e54 91       		.byte	0x91
 7359 0e55 70       		.sleb128 -16
 7360 0e56 19       		.uleb128 0x19
 7361 0e57 2D050000 		.4byte	.LASF98
 7362 0e5b 01       		.byte	0x1
 7363 0e5c 450C     		.2byte	0xc45
 7364 0e5e 77010000 		.4byte	0x177
 7365 0e62 02       		.uleb128 0x2
 7366 0e63 91       		.byte	0x91
 7367 0e64 74       		.sleb128 -12
 7368 0e65 00       		.byte	0
 7369 0e66 07       		.uleb128 0x7
 7370 0e67 D1070000 		.4byte	0x7d1
 7371 0e6b 1D       		.uleb128 0x1d
 7372 0e6c 380F0000 		.4byte	.LASF162
 7373 0e70 01       		.byte	0x1
 7374 0e71 860C     		.2byte	0xc86
 7375 0e73 00000000 		.4byte	.LFB96
 7376 0e77 84000000 		.4byte	.LFE96-.LFB96
 7377 0e7b 01       		.uleb128 0x1
 7378 0e7c 9C       		.byte	0x9c
 7379 0e7d AF0E0000 		.4byte	0xeaf
 7380 0e81 18       		.uleb128 0x18
 7381 0e82 990C0000 		.4byte	.LASF163
 7382 0e86 01       		.byte	0x1
 7383 0e87 860C     		.2byte	0xc86
 7384 0e89 70020000 		.4byte	0x270
 7385 0e8d 02       		.uleb128 0x2
 7386 0e8e 91       		.byte	0x91
 7387 0e8f 6C       		.sleb128 -20
 7388 0e90 18       		.uleb128 0x18
 7389 0e91 AB0D0000 		.4byte	.LASF34
 7390 0e95 01       		.byte	0x1
 7391 0e96 860C     		.2byte	0xc86
 7392 0e98 22070000 		.4byte	0x722
 7393 0e9c 02       		.uleb128 0x2
 7394 0e9d 91       		.byte	0x91
 7395 0e9e 68       		.sleb128 -24
 7396 0e9f 19       		.uleb128 0x19
 7397 0ea0 4F0A0000 		.4byte	.LASF161
 7398 0ea4 01       		.byte	0x1
 7399 0ea5 880C     		.2byte	0xc88
 7400 0ea7 7B050000 		.4byte	0x57b
 7401 0eab 02       		.uleb128 0x2
 7402 0eac 91       		.byte	0x91
 7403 0ead 74       		.sleb128 -12
 7404 0eae 00       		.byte	0
 7405 0eaf 1D       		.uleb128 0x1d
 7406 0eb0 F30E0000 		.4byte	.LASF164
 7407 0eb4 01       		.byte	0x1
 7408 0eb5 B60C     		.2byte	0xcb6
 7409 0eb7 00000000 		.4byte	.LFB97
 7410 0ebb 30000000 		.4byte	.LFE97-.LFB97
 7411 0ebf 01       		.uleb128 0x1
 7412 0ec0 9C       		.byte	0x9c
 7413 0ec1 D50E0000 		.4byte	0xed5
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 229
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 229
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 7414 0ec5 18       		.uleb128 0x18
 7415 0ec6 C3010000 		.4byte	.LASF165
 7416 0eca 01       		.byte	0x1
 7417 0ecb B60C     		.2byte	0xcb6
 7418 0ecd DB0E0000 		.4byte	0xedb
 7419 0ed1 02       		.uleb128 0x2
 7420 0ed2 91       		.byte	0x91
 7421 0ed3 74       		.sleb128 -12
 7422 0ed4 00       		.byte	0
 7423 0ed5 06       		.uleb128 0x6
 7424 0ed6 04       		.byte	0x4
 7425 0ed7 B7030000 		.4byte	0x3b7
 7426 0edb 07       		.uleb128 0x7
 7427 0edc D50E0000 		.4byte	0xed5
 7428 0ee0 27       		.uleb128 0x27
 7429 0ee1 860D0000 		.4byte	.LASF166
 7430 0ee5 01       		.byte	0x1
 7431 0ee6 C20C     		.2byte	0xcc2
 7432 0ee8 00000000 		.4byte	.LFB98
 7433 0eec 2C000000 		.4byte	.LFE98-.LFB98
 7434 0ef0 01       		.uleb128 0x1
 7435 0ef1 9C       		.byte	0x9c
 7436 0ef2 060F0000 		.4byte	0xf06
 7437 0ef6 18       		.uleb128 0x18
 7438 0ef7 C3010000 		.4byte	.LASF165
 7439 0efb 01       		.byte	0x1
 7440 0efc C20C     		.2byte	0xcc2
 7441 0efe DB0E0000 		.4byte	0xedb
 7442 0f02 02       		.uleb128 0x2
 7443 0f03 91       		.byte	0x91
 7444 0f04 74       		.sleb128 -12
 7445 0f05 00       		.byte	0
 7446 0f06 17       		.uleb128 0x17
 7447 0f07 840C0000 		.4byte	.LASF167
 7448 0f0b 01       		.byte	0x1
 7449 0f0c CA0C     		.2byte	0xcca
 7450 0f0e 77010000 		.4byte	0x177
 7451 0f12 00000000 		.4byte	.LFB99
 7452 0f16 8C000000 		.4byte	.LFE99-.LFB99
 7453 0f1a 01       		.uleb128 0x1
 7454 0f1b 9C       		.byte	0x9c
 7455 0f1c 760F0000 		.4byte	0xf76
 7456 0f20 18       		.uleb128 0x18
 7457 0f21 C3010000 		.4byte	.LASF165
 7458 0f25 01       		.byte	0x1
 7459 0f26 CA0C     		.2byte	0xcca
 7460 0f28 DB0E0000 		.4byte	0xedb
 7461 0f2c 02       		.uleb128 0x2
 7462 0f2d 91       		.byte	0x91
 7463 0f2e 64       		.sleb128 -28
 7464 0f2f 18       		.uleb128 0x18
 7465 0f30 130E0000 		.4byte	.LASF168
 7466 0f34 01       		.byte	0x1
 7467 0f35 CA0C     		.2byte	0xcca
 7468 0f37 1D070000 		.4byte	0x71d
 7469 0f3b 02       		.uleb128 0x2
 7470 0f3c 91       		.byte	0x91
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 230
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 230
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 7471 0f3d 60       		.sleb128 -32
 7472 0f3e 19       		.uleb128 0x19
 7473 0f3f 2D050000 		.4byte	.LASF98
 7474 0f43 01       		.byte	0x1
 7475 0f44 CC0C     		.2byte	0xccc
 7476 0f46 77010000 		.4byte	0x177
 7477 0f4a 02       		.uleb128 0x2
 7478 0f4b 91       		.byte	0x91
 7479 0f4c 74       		.sleb128 -12
 7480 0f4d 1A       		.uleb128 0x1a
 7481 0f4e 0E000000 		.4byte	.LBB49
 7482 0f52 68000000 		.4byte	.LBE49-.LBB49
 7483 0f56 19       		.uleb128 0x19
 7484 0f57 35050000 		.4byte	.LASF112
 7485 0f5b 01       		.byte	0x1
 7486 0f5c D40C     		.2byte	0xcd4
 7487 0f5e 22070000 		.4byte	0x722
 7488 0f62 02       		.uleb128 0x2
 7489 0f63 91       		.byte	0x91
 7490 0f64 70       		.sleb128 -16
 7491 0f65 19       		.uleb128 0x19
 7492 0f66 52070000 		.4byte	.LASF169
 7493 0f6a 01       		.byte	0x1
 7494 0f6b D50C     		.2byte	0xcd5
 7495 0f6d 22070000 		.4byte	0x722
 7496 0f71 02       		.uleb128 0x2
 7497 0f72 91       		.byte	0x91
 7498 0f73 6C       		.sleb128 -20
 7499 0f74 00       		.byte	0
 7500 0f75 00       		.byte	0
 7501 0f76 24       		.uleb128 0x24
 7502 0f77 EE0A0000 		.4byte	.LASF171
 7503 0f7b 01       		.byte	0x1
 7504 0f7c 090D     		.2byte	0xd09
 7505 0f7e 00000000 		.4byte	.LFB100
 7506 0f82 18000000 		.4byte	.LFE100-.LFB100
 7507 0f86 01       		.uleb128 0x1
 7508 0f87 9C       		.byte	0x9c
 7509 0f88 1B       		.uleb128 0x1b
 7510 0f89 46070000 		.4byte	.LASF172
 7511 0f8d 01       		.byte	0x1
 7512 0f8e 400D     		.2byte	0xd40
 7513 0f90 00000000 		.4byte	.LFB101
 7514 0f94 0E000000 		.4byte	.LFE101-.LFB101
 7515 0f98 01       		.uleb128 0x1
 7516 0f99 9C       		.byte	0x9c
 7517 0f9a AE0F0000 		.4byte	0xfae
 7518 0f9e 18       		.uleb128 0x18
 7519 0f9f C8050000 		.4byte	.LASF95
 7520 0fa3 01       		.byte	0x1
 7521 0fa4 400D     		.2byte	0xd40
 7522 0fa6 B0000000 		.4byte	0xb0
 7523 0faa 02       		.uleb128 0x2
 7524 0fab 91       		.byte	0x91
 7525 0fac 74       		.sleb128 -12
 7526 0fad 00       		.byte	0
 7527 0fae 1B       		.uleb128 0x1b
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 231
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 231
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 7528 0faf 630F0000 		.4byte	.LASF173
 7529 0fb3 01       		.byte	0x1
 7530 0fb4 170E     		.2byte	0xe17
 7531 0fb6 00000000 		.4byte	.LFB102
 7532 0fba 80000000 		.4byte	.LFE102-.LFB102
 7533 0fbe 01       		.uleb128 0x1
 7534 0fbf 9C       		.byte	0x9c
 7535 0fc0 D40F0000 		.4byte	0xfd4
 7536 0fc4 19       		.uleb128 0x19
 7537 0fc5 A30E0000 		.4byte	.LASF52
 7538 0fc9 01       		.byte	0x1
 7539 0fca 190E     		.2byte	0xe19
 7540 0fcc 82010000 		.4byte	0x182
 7541 0fd0 02       		.uleb128 0x2
 7542 0fd1 91       		.byte	0x91
 7543 0fd2 74       		.sleb128 -12
 7544 0fd3 00       		.byte	0
 7545 0fd4 1B       		.uleb128 0x1b
 7546 0fd5 630B0000 		.4byte	.LASF174
 7547 0fd9 01       		.byte	0x1
 7548 0fda 370E     		.2byte	0xe37
 7549 0fdc 00000000 		.4byte	.LFB103
 7550 0fe0 58000000 		.4byte	.LFE103-.LFB103
 7551 0fe4 01       		.uleb128 0x1
 7552 0fe5 9C       		.byte	0x9c
 7553 0fe6 04100000 		.4byte	0x1004
 7554 0fea 1A       		.uleb128 0x1a
 7555 0feb 06000000 		.4byte	.LBB50
 7556 0fef 3E000000 		.4byte	.LBE50-.LBB50
 7557 0ff3 19       		.uleb128 0x19
 7558 0ff4 3B060000 		.4byte	.LASF104
 7559 0ff8 01       		.byte	0x1
 7560 0ff9 3E0E     		.2byte	0xe3e
 7561 0ffb 7B050000 		.4byte	0x57b
 7562 0fff 02       		.uleb128 0x2
 7563 1000 91       		.byte	0x91
 7564 1001 74       		.sleb128 -12
 7565 1002 00       		.byte	0
 7566 1003 00       		.byte	0
 7567 1004 23       		.uleb128 0x23
 7568 1005 EB090000 		.4byte	.LASF176
 7569 1009 01       		.byte	0x1
 7570 100a D70E     		.2byte	0xed7
 7571 100c D5000000 		.4byte	0xd5
 7572 1010 00000000 		.4byte	.LFB104
 7573 1014 36000000 		.4byte	.LFE104-.LFB104
 7574 1018 01       		.uleb128 0x1
 7575 1019 9C       		.byte	0x9c
 7576 101a 3D100000 		.4byte	0x103d
 7577 101e 18       		.uleb128 0x18
 7578 101f 2C070000 		.4byte	.LASF177
 7579 1023 01       		.byte	0x1
 7580 1024 D70E     		.2byte	0xed7
 7581 1026 3D100000 		.4byte	0x103d
 7582 102a 02       		.uleb128 0x2
 7583 102b 91       		.byte	0x91
 7584 102c 6C       		.sleb128 -20
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 232
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 232
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 7585 102d 19       		.uleb128 0x19
 7586 102e 80080000 		.4byte	.LASF178
 7587 1032 01       		.byte	0x1
 7588 1033 D90E     		.2byte	0xed9
 7589 1035 EB000000 		.4byte	0xeb
 7590 1039 02       		.uleb128 0x2
 7591 103a 91       		.byte	0x91
 7592 103b 74       		.sleb128 -12
 7593 103c 00       		.byte	0
 7594 103d 06       		.uleb128 0x6
 7595 103e 04       		.byte	0x4
 7596 103f 43100000 		.4byte	0x1043
 7597 1043 07       		.uleb128 0x7
 7598 1044 CA000000 		.4byte	0xca
 7599 1048 17       		.uleb128 0x17
 7600 1049 AE0E0000 		.4byte	.LASF179
 7601 104d 01       		.byte	0x1
 7602 104e 130F     		.2byte	0xf13
 7603 1050 82010000 		.4byte	0x182
 7604 1054 00000000 		.4byte	.LFB105
 7605 1058 38000000 		.4byte	.LFE105-.LFB105
 7606 105c 01       		.uleb128 0x1
 7607 105d 9C       		.byte	0x9c
 7608 105e 9F100000 		.4byte	0x109f
 7609 1062 18       		.uleb128 0x18
 7610 1063 830B0000 		.4byte	.LASF117
 7611 1067 01       		.byte	0x1
 7612 1068 130F     		.2byte	0xf13
 7613 106a 81020000 		.4byte	0x281
 7614 106e 02       		.uleb128 0x2
 7615 106f 91       		.byte	0x91
 7616 1070 64       		.sleb128 -28
 7617 1071 19       		.uleb128 0x19
 7618 1072 3B060000 		.4byte	.LASF104
 7619 1076 01       		.byte	0x1
 7620 1077 150F     		.2byte	0xf15
 7621 1079 7B050000 		.4byte	0x57b
 7622 107d 02       		.uleb128 0x2
 7623 107e 91       		.byte	0x91
 7624 107f 74       		.sleb128 -12
 7625 1080 19       		.uleb128 0x19
 7626 1081 CD030000 		.4byte	.LASF180
 7627 1085 01       		.byte	0x1
 7628 1086 160F     		.2byte	0xf16
 7629 1088 98010000 		.4byte	0x198
 7630 108c 02       		.uleb128 0x2
 7631 108d 91       		.byte	0x91
 7632 108e 70       		.sleb128 -16
 7633 108f 19       		.uleb128 0x19
 7634 1090 BA060000 		.4byte	.LASF123
 7635 1094 01       		.byte	0x1
 7636 1095 170F     		.2byte	0xf17
 7637 1097 82010000 		.4byte	0x182
 7638 109b 02       		.uleb128 0x2
 7639 109c 91       		.byte	0x91
 7640 109d 6C       		.sleb128 -20
 7641 109e 00       		.byte	0
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 233
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 233
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 7642 109f 1B       		.uleb128 0x1b
 7643 10a0 39070000 		.4byte	.LASF181
 7644 10a4 01       		.byte	0x1
 7645 10a5 2F0F     		.2byte	0xf2f
 7646 10a7 00000000 		.4byte	.LFB106
 7647 10ab 20000000 		.4byte	.LFE106-.LFB106
 7648 10af 01       		.uleb128 0x1
 7649 10b0 9C       		.byte	0x9c
 7650 10b1 C5100000 		.4byte	0x10c5
 7651 10b5 18       		.uleb128 0x18
 7652 10b6 3B060000 		.4byte	.LASF104
 7653 10ba 01       		.byte	0x1
 7654 10bb 2F0F     		.2byte	0xf2f
 7655 10bd 7B050000 		.4byte	0x57b
 7656 10c1 02       		.uleb128 0x2
 7657 10c2 91       		.byte	0x91
 7658 10c3 74       		.sleb128 -12
 7659 10c4 00       		.byte	0
 7660 10c5 28       		.uleb128 0x28
 7661 10c6 27040000 		.4byte	.LASF182
 7662 10ca 01       		.byte	0x1
 7663 10cb 670F     		.2byte	0xf67
 7664 10cd 00000000 		.4byte	.LFB107
 7665 10d1 40000000 		.4byte	.LFE107-.LFB107
 7666 10d5 01       		.uleb128 0x1
 7667 10d6 9C       		.byte	0x9c
 7668 10d7 EB100000 		.4byte	0x10eb
 7669 10db 19       		.uleb128 0x19
 7670 10dc 3B060000 		.4byte	.LASF104
 7671 10e0 01       		.byte	0x1
 7672 10e1 690F     		.2byte	0xf69
 7673 10e3 7B050000 		.4byte	0x57b
 7674 10e7 02       		.uleb128 0x2
 7675 10e8 91       		.byte	0x91
 7676 10e9 74       		.sleb128 -12
 7677 10ea 00       		.byte	0
 7678 10eb 1E       		.uleb128 0x1e
 7679 10ec 2C080000 		.4byte	.LASF183
 7680 10f0 01       		.byte	0x1
 7681 10f1 810F     		.2byte	0xf81
 7682 10f3 81020000 		.4byte	0x281
 7683 10f7 00000000 		.4byte	.LFB108
 7684 10fb 1C000000 		.4byte	.LFE108-.LFB108
 7685 10ff 01       		.uleb128 0x1
 7686 1100 9C       		.byte	0x9c
 7687 1101 15110000 		.4byte	0x1115
 7688 1105 19       		.uleb128 0x19
 7689 1106 2D050000 		.4byte	.LASF98
 7690 110a 01       		.byte	0x1
 7691 110b 830F     		.2byte	0xf83
 7692 110d 81020000 		.4byte	0x281
 7693 1111 02       		.uleb128 0x2
 7694 1112 91       		.byte	0x91
 7695 1113 74       		.sleb128 -12
 7696 1114 00       		.byte	0
 7697 1115 17       		.uleb128 0x17
<<<<<<< HEAD
 7698 1116 BD0C0000 		.4byte	.LASF184
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 234
=======
 7698 1116 BF0C0000 		.4byte	.LASF184
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 234
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 7699 111a 01       		.byte	0x1
 7700 111b AE0F     		.2byte	0xfae
 7701 111d 77010000 		.4byte	0x177
 7702 1121 00000000 		.4byte	.LFB109
 7703 1125 EC000000 		.4byte	.LFE109-.LFB109
 7704 1129 01       		.uleb128 0x1
 7705 112a 9C       		.byte	0x9c
 7706 112b 5D110000 		.4byte	0x115d
 7707 112f 18       		.uleb128 0x18
 7708 1130 7D070000 		.4byte	.LASF185
 7709 1134 01       		.byte	0x1
 7710 1135 AE0F     		.2byte	0xfae
 7711 1137 34080000 		.4byte	0x834
 7712 113b 02       		.uleb128 0x2
 7713 113c 91       		.byte	0x91
 7714 113d 6C       		.sleb128 -20
 7715 113e 19       		.uleb128 0x19
 7716 113f FD010000 		.4byte	.LASF186
 7717 1143 01       		.byte	0x1
 7718 1144 B00F     		.2byte	0xfb0
 7719 1146 FB090000 		.4byte	0x9fb
 7720 114a 02       		.uleb128 0x2
 7721 114b 91       		.byte	0x91
 7722 114c 70       		.sleb128 -16
 7723 114d 19       		.uleb128 0x19
 7724 114e 2D050000 		.4byte	.LASF98
 7725 1152 01       		.byte	0x1
 7726 1153 B10F     		.2byte	0xfb1
 7727 1155 77010000 		.4byte	0x177
 7728 1159 02       		.uleb128 0x2
 7729 115a 91       		.byte	0x91
 7730 115b 74       		.sleb128 -12
 7731 115c 00       		.byte	0
 7732 115d 17       		.uleb128 0x17
 7733 115e 8B0E0000 		.4byte	.LASF187
 7734 1162 01       		.byte	0x1
 7735 1163 0810     		.2byte	0x1008
 7736 1165 77010000 		.4byte	0x177
 7737 1169 00000000 		.4byte	.LFB110
 7738 116d C8000000 		.4byte	.LFE110-.LFB110
 7739 1171 01       		.uleb128 0x1
 7740 1172 9C       		.byte	0x9c
 7741 1173 A5110000 		.4byte	0x11a5
 7742 1177 18       		.uleb128 0x18
 7743 1178 7D070000 		.4byte	.LASF185
 7744 117c 01       		.byte	0x1
 7745 117d 0810     		.2byte	0x1008
 7746 117f 34080000 		.4byte	0x834
 7747 1183 02       		.uleb128 0x2
 7748 1184 91       		.byte	0x91
 7749 1185 6C       		.sleb128 -20
 7750 1186 19       		.uleb128 0x19
 7751 1187 3B060000 		.4byte	.LASF104
 7752 118b 01       		.byte	0x1
 7753 118c 0A10     		.2byte	0x100a
 7754 118e FB090000 		.4byte	0x9fb
 7755 1192 02       		.uleb128 0x2
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 235
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 235
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 7756 1193 91       		.byte	0x91
 7757 1194 70       		.sleb128 -16
 7758 1195 19       		.uleb128 0x19
 7759 1196 2D050000 		.4byte	.LASF98
 7760 119a 01       		.byte	0x1
 7761 119b 0B10     		.2byte	0x100b
 7762 119d 77010000 		.4byte	0x177
 7763 11a1 02       		.uleb128 0x2
 7764 11a2 91       		.byte	0x91
 7765 11a3 74       		.sleb128 -12
 7766 11a4 00       		.byte	0
 7767 11a5 1D       		.uleb128 0x1d
 7768 11a6 00090000 		.4byte	.LASF188
 7769 11aa 01       		.byte	0x1
 7770 11ab 5810     		.2byte	0x1058
 7771 11ad 00000000 		.4byte	.LFB111
 7772 11b1 DC000000 		.4byte	.LFE111-.LFB111
 7773 11b5 01       		.uleb128 0x1
 7774 11b6 9C       		.byte	0x9c
 7775 11b7 16120000 		.4byte	0x1216
 7776 11bb 18       		.uleb128 0x18
 7777 11bc 7D070000 		.4byte	.LASF185
 7778 11c0 01       		.byte	0x1
 7779 11c1 5810     		.2byte	0x1058
 7780 11c3 34080000 		.4byte	0x834
 7781 11c7 02       		.uleb128 0x2
 7782 11c8 91       		.byte	0x91
 7783 11c9 64       		.sleb128 -28
 7784 11ca 18       		.uleb128 0x18
 7785 11cb B6070000 		.4byte	.LASF189
 7786 11cf 01       		.byte	0x1
 7787 11d0 5810     		.2byte	0x1058
 7788 11d2 82010000 		.4byte	0x182
 7789 11d6 02       		.uleb128 0x2
 7790 11d7 91       		.byte	0x91
 7791 11d8 60       		.sleb128 -32
 7792 11d9 19       		.uleb128 0x19
 7793 11da 3B060000 		.4byte	.LASF104
 7794 11de 01       		.byte	0x1
 7795 11df 5A10     		.2byte	0x105a
 7796 11e1 FB090000 		.4byte	0x9fb
 7797 11e5 02       		.uleb128 0x2
 7798 11e6 91       		.byte	0x91
 7799 11e7 70       		.sleb128 -16
 7800 11e8 19       		.uleb128 0x19
 7801 11e9 28020000 		.4byte	.LASF129
 7802 11ed 01       		.byte	0x1
 7803 11ee 5B10     		.2byte	0x105b
 7804 11f0 82010000 		.4byte	0x182
 7805 11f4 02       		.uleb128 0x2
 7806 11f5 91       		.byte	0x91
 7807 11f6 68       		.sleb128 -24
 7808 11f7 19       		.uleb128 0x19
 7809 11f8 CA0E0000 		.4byte	.LASF190
 7810 11fc 01       		.byte	0x1
 7811 11fd 5B10     		.2byte	0x105b
 7812 11ff 82010000 		.4byte	0x182
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 236
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 236
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 7813 1203 02       		.uleb128 0x2
 7814 1204 91       		.byte	0x91
 7815 1205 74       		.sleb128 -12
 7816 1206 19       		.uleb128 0x19
 7817 1207 0E0B0000 		.4byte	.LASF191
 7818 120b 01       		.byte	0x1
 7819 120c 5C10     		.2byte	0x105c
 7820 120e 16120000 		.4byte	0x1216
 7821 1212 02       		.uleb128 0x2
 7822 1213 91       		.byte	0x91
 7823 1214 6C       		.sleb128 -20
 7824 1215 00       		.byte	0
 7825 1216 07       		.uleb128 0x7
 7826 1217 82010000 		.4byte	0x182
 7827 121b 1E       		.uleb128 0x1e
 7828 121c 8F000000 		.4byte	.LASF192
 7829 1220 01       		.byte	0x1
 7830 1221 FA11     		.2byte	0x11fa
 7831 1223 8D010000 		.4byte	0x18d
 7832 1227 00000000 		.4byte	.LFB112
 7833 122b 30000000 		.4byte	.LFE112-.LFB112
 7834 122f 01       		.uleb128 0x1
 7835 1230 9C       		.byte	0x9c
 7836 1231 45120000 		.4byte	0x1245
 7837 1235 19       		.uleb128 0x19
 7838 1236 BA060000 		.4byte	.LASF123
 7839 123a 01       		.byte	0x1
 7840 123b FC11     		.2byte	0x11fc
 7841 123d 8D010000 		.4byte	0x18d
 7842 1241 02       		.uleb128 0x2
 7843 1242 91       		.byte	0x91
 7844 1243 74       		.sleb128 -12
 7845 1244 00       		.byte	0
 7846 1245 25       		.uleb128 0x25
 7847 1246 1D0C0000 		.4byte	.LASF194
 7848 124a 01       		.byte	0x1
 7849 124b 0A12     		.2byte	0x120a
 7850 124d 81020000 		.4byte	0x281
 7851 1251 00000000 		.4byte	.LFB113
 7852 1255 28000000 		.4byte	.LFE113-.LFB113
 7853 1259 01       		.uleb128 0x1
 7854 125a 9C       		.byte	0x9c
 7855 125b 17       		.uleb128 0x17
 7856 125c 230D0000 		.4byte	.LASF195
 7857 1260 01       		.byte	0x1
 7858 1261 1B12     		.2byte	0x121b
 7859 1263 EB000000 		.4byte	0xeb
 7860 1267 00000000 		.4byte	.LFB114
 7861 126b 90000000 		.4byte	.LFE114-.LFB114
 7862 126f 01       		.uleb128 0x1
 7863 1270 9C       		.byte	0x9c
 7864 1271 A3120000 		.4byte	0x12a3
 7865 1275 18       		.uleb128 0x18
 7866 1276 60020000 		.4byte	.LASF196
 7867 127a 01       		.byte	0x1
 7868 127b 1B12     		.2byte	0x121b
 7869 127d 77010000 		.4byte	0x177
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 237
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 237
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 7870 1281 02       		.uleb128 0x2
 7871 1282 91       		.byte	0x91
 7872 1283 6C       		.sleb128 -20
 7873 1284 18       		.uleb128 0x18
 7874 1285 3E020000 		.4byte	.LASF158
 7875 1289 01       		.byte	0x1
 7876 128a 1B12     		.2byte	0x121b
 7877 128c 8D010000 		.4byte	0x18d
 7878 1290 02       		.uleb128 0x2
 7879 1291 91       		.byte	0x91
 7880 1292 68       		.sleb128 -24
 7881 1293 19       		.uleb128 0x19
 7882 1294 720E0000 		.4byte	.LASF197
 7883 1298 01       		.byte	0x1
 7884 1299 1D12     		.2byte	0x121d
 7885 129b EB000000 		.4byte	0xeb
 7886 129f 02       		.uleb128 0x2
 7887 12a0 91       		.byte	0x91
 7888 12a1 74       		.sleb128 -12
 7889 12a2 00       		.byte	0
 7890 12a3 17       		.uleb128 0x17
 7891 12a4 620E0000 		.4byte	.LASF198
 7892 12a8 01       		.byte	0x1
 7893 12a9 5F12     		.2byte	0x125f
 7894 12ab 77010000 		.4byte	0x177
 7895 12af 00000000 		.4byte	.LFB115
 7896 12b3 B4000000 		.4byte	.LFE115-.LFB115
 7897 12b7 01       		.uleb128 0x1
 7898 12b8 9C       		.byte	0x9c
 7899 12b9 09130000 		.4byte	0x1309
 7900 12bd 18       		.uleb128 0x18
 7901 12be 50060000 		.4byte	.LASF199
 7902 12c2 01       		.byte	0x1
 7903 12c3 5F12     		.2byte	0x125f
 7904 12c5 EB000000 		.4byte	0xeb
 7905 12c9 02       		.uleb128 0x2
 7906 12ca 91       		.byte	0x91
 7907 12cb 6C       		.sleb128 -20
 7908 12cc 18       		.uleb128 0x18
 7909 12cd 080F0000 		.4byte	.LASF200
 7910 12d1 01       		.byte	0x1
 7911 12d2 5F12     		.2byte	0x125f
 7912 12d4 EB000000 		.4byte	0xeb
 7913 12d8 02       		.uleb128 0x2
 7914 12d9 91       		.byte	0x91
 7915 12da 68       		.sleb128 -24
 7916 12db 18       		.uleb128 0x18
 7917 12dc 32090000 		.4byte	.LASF201
 7918 12e0 01       		.byte	0x1
 7919 12e1 5F12     		.2byte	0x125f
 7920 12e3 09130000 		.4byte	0x1309
 7921 12e7 02       		.uleb128 0x2
 7922 12e8 91       		.byte	0x91
 7923 12e9 64       		.sleb128 -28
 7924 12ea 18       		.uleb128 0x18
 7925 12eb 3E020000 		.4byte	.LASF158
 7926 12ef 01       		.byte	0x1
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 238
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 238
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 7927 12f0 5F12     		.2byte	0x125f
 7928 12f2 8D010000 		.4byte	0x18d
 7929 12f6 02       		.uleb128 0x2
 7930 12f7 91       		.byte	0x91
 7931 12f8 60       		.sleb128 -32
 7932 12f9 19       		.uleb128 0x19
 7933 12fa 2D050000 		.4byte	.LASF98
 7934 12fe 01       		.byte	0x1
 7935 12ff 6112     		.2byte	0x1261
 7936 1301 77010000 		.4byte	0x177
 7937 1305 02       		.uleb128 0x2
 7938 1306 91       		.byte	0x91
 7939 1307 74       		.sleb128 -12
 7940 1308 00       		.byte	0
 7941 1309 06       		.uleb128 0x6
 7942 130a 04       		.byte	0x4
 7943 130b EB000000 		.4byte	0xeb
 7944 130f 17       		.uleb128 0x17
 7945 1310 680D0000 		.4byte	.LASF202
 7946 1314 01       		.byte	0x1
 7947 1315 AF12     		.2byte	0x12af
 7948 1317 77010000 		.4byte	0x177
 7949 131b 00000000 		.4byte	.LFB116
 7950 131f 10010000 		.4byte	.LFE116-.LFB116
 7951 1323 01       		.uleb128 0x1
 7952 1324 9C       		.byte	0x9c
 7953 1325 93130000 		.4byte	0x1393
 7954 1329 18       		.uleb128 0x18
 7955 132a AD050000 		.4byte	.LASF203
 7956 132e 01       		.byte	0x1
 7957 132f AF12     		.2byte	0x12af
 7958 1331 81020000 		.4byte	0x281
 7959 1335 02       		.uleb128 0x2
 7960 1336 91       		.byte	0x91
 7961 1337 64       		.sleb128 -28
 7962 1338 18       		.uleb128 0x18
 7963 1339 87000000 		.4byte	.LASF204
 7964 133d 01       		.byte	0x1
 7965 133e AF12     		.2byte	0x12af
 7966 1340 EB000000 		.4byte	0xeb
 7967 1344 02       		.uleb128 0x2
 7968 1345 91       		.byte	0x91
 7969 1346 60       		.sleb128 -32
 7970 1347 18       		.uleb128 0x18
 7971 1348 98020000 		.4byte	.LASF205
 7972 134c 01       		.byte	0x1
 7973 134d AF12     		.2byte	0x12af
 7974 134f 87030000 		.4byte	0x387
 7975 1353 02       		.uleb128 0x2
 7976 1354 91       		.byte	0x91
 7977 1355 5F       		.sleb128 -33
 7978 1356 18       		.uleb128 0x18
 7979 1357 FE030000 		.4byte	.LASF206
 7980 135b 01       		.byte	0x1
 7981 135c AF12     		.2byte	0x12af
 7982 135e 09130000 		.4byte	0x1309
 7983 1362 02       		.uleb128 0x2
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 239
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 239
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 7984 1363 91       		.byte	0x91
 7985 1364 58       		.sleb128 -40
 7986 1365 19       		.uleb128 0x19
 7987 1366 3B060000 		.4byte	.LASF104
 7988 136a 01       		.byte	0x1
 7989 136b B112     		.2byte	0x12b1
 7990 136d 7B050000 		.4byte	0x57b
 7991 1371 02       		.uleb128 0x2
 7992 1372 91       		.byte	0x91
 7993 1373 70       		.sleb128 -16
 7994 1374 19       		.uleb128 0x19
 7995 1375 2D050000 		.4byte	.LASF98
 7996 1379 01       		.byte	0x1
 7997 137a B212     		.2byte	0x12b2
 7998 137c 77010000 		.4byte	0x177
 7999 1380 02       		.uleb128 0x2
 8000 1381 91       		.byte	0x91
 8001 1382 74       		.sleb128 -12
 8002 1383 19       		.uleb128 0x19
 8003 1384 F6020000 		.4byte	.LASF207
 8004 1388 01       		.byte	0x1
 8005 1389 B312     		.2byte	0x12b3
 8006 138b CA000000 		.4byte	0xca
 8007 138f 02       		.uleb128 0x2
 8008 1390 91       		.byte	0x91
 8009 1391 6F       		.sleb128 -17
 8010 1392 00       		.byte	0
 8011 1393 17       		.uleb128 0x17
 8012 1394 AF040000 		.4byte	.LASF208
 8013 1398 01       		.byte	0x1
 8014 1399 2113     		.2byte	0x1321
 8015 139b 77010000 		.4byte	0x177
 8016 139f 00000000 		.4byte	.LFB117
 8017 13a3 4C010000 		.4byte	.LFE117-.LFB117
 8018 13a7 01       		.uleb128 0x1
 8019 13a8 9C       		.byte	0x9c
 8020 13a9 7D140000 		.4byte	0x147d
 8021 13ad 18       		.uleb128 0x18
 8022 13ae AD050000 		.4byte	.LASF203
 8023 13b2 01       		.byte	0x1
 8024 13b3 2113     		.2byte	0x1321
 8025 13b5 81020000 		.4byte	0x281
 8026 13b9 02       		.uleb128 0x2
 8027 13ba 91       		.byte	0x91
 8028 13bb 54       		.sleb128 -44
 8029 13bc 18       		.uleb128 0x18
 8030 13bd 87000000 		.4byte	.LASF204
 8031 13c1 01       		.byte	0x1
 8032 13c2 2113     		.2byte	0x1321
 8033 13c4 EB000000 		.4byte	0xeb
 8034 13c8 02       		.uleb128 0x2
 8035 13c9 91       		.byte	0x91
 8036 13ca 50       		.sleb128 -48
 8037 13cb 18       		.uleb128 0x18
 8038 13cc 98020000 		.4byte	.LASF205
 8039 13d0 01       		.byte	0x1
 8040 13d1 2113     		.2byte	0x1321
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 240
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 240
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 8041 13d3 87030000 		.4byte	0x387
 8042 13d7 02       		.uleb128 0x2
 8043 13d8 91       		.byte	0x91
 8044 13d9 4F       		.sleb128 -49
 8045 13da 18       		.uleb128 0x18
 8046 13db FE030000 		.4byte	.LASF206
 8047 13df 01       		.byte	0x1
 8048 13e0 2113     		.2byte	0x1321
 8049 13e2 09130000 		.4byte	0x1309
 8050 13e6 02       		.uleb128 0x2
 8051 13e7 91       		.byte	0x91
 8052 13e8 48       		.sleb128 -56
 8053 13e9 18       		.uleb128 0x18
 8054 13ea D5050000 		.4byte	.LASF209
 8055 13ee 01       		.byte	0x1
 8056 13ef 2113     		.2byte	0x1321
 8057 13f1 7D140000 		.4byte	0x147d
 8058 13f5 02       		.uleb128 0x2
 8059 13f6 91       		.byte	0x91
 8060 13f7 00       		.sleb128 0
 8061 13f8 19       		.uleb128 0x19
 8062 13f9 3B060000 		.4byte	.LASF104
 8063 13fd 01       		.byte	0x1
 8064 13fe 2313     		.2byte	0x1323
 8065 1400 7B050000 		.4byte	0x57b
 8066 1404 02       		.uleb128 0x2
 8067 1405 91       		.byte	0x91
 8068 1406 70       		.sleb128 -16
 8069 1407 19       		.uleb128 0x19
 8070 1408 F6020000 		.4byte	.LASF207
 8071 140c 01       		.byte	0x1
 8072 140d 2413     		.2byte	0x1324
 8073 140f CA000000 		.4byte	0xca
 8074 1413 02       		.uleb128 0x2
 8075 1414 91       		.byte	0x91
 8076 1415 67       		.sleb128 -25
 8077 1416 19       		.uleb128 0x19
 8078 1417 2D050000 		.4byte	.LASF98
 8079 141b 01       		.byte	0x1
 8080 141c 2513     		.2byte	0x1325
 8081 141e 77010000 		.4byte	0x177
 8082 1422 02       		.uleb128 0x2
 8083 1423 91       		.byte	0x91
 8084 1424 74       		.sleb128 -12
 8085 1425 19       		.uleb128 0x19
 8086 1426 360B0000 		.4byte	.LASF136
 8087 142a 01       		.byte	0x1
 8088 142b 2613     		.2byte	0x1326
 8089 142d 82010000 		.4byte	0x182
 8090 1431 02       		.uleb128 0x2
 8091 1432 91       		.byte	0x91
 8092 1433 68       		.sleb128 -24
 8093 1434 1F       		.uleb128 0x1f
 8094 1435 3C040000 		.4byte	0x43c
 8095 1439 18000000 		.4byte	.LBB51
 8096 143d 1A000000 		.4byte	.LBE51-.LBB51
 8097 1441 01       		.byte	0x1
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 241
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 241
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 8098 1442 3E13     		.2byte	0x133e
 8099 1444 63140000 		.4byte	0x1463
 8100 1448 1A       		.uleb128 0x1a
 8101 1449 18000000 		.4byte	.LBB52
 8102 144d 1A000000 		.4byte	.LBE52-.LBB52
 8103 1451 20       		.uleb128 0x20
 8104 1452 4C040000 		.4byte	0x44c
 8105 1456 02       		.uleb128 0x2
 8106 1457 91       		.byte	0x91
 8107 1458 60       		.sleb128 -32
 8108 1459 20       		.uleb128 0x20
 8109 145a 57040000 		.4byte	0x457
 8110 145e 02       		.uleb128 0x2
 8111 145f 91       		.byte	0x91
 8112 1460 5C       		.sleb128 -36
 8113 1461 00       		.byte	0
 8114 1462 00       		.byte	0
 8115 1463 21       		.uleb128 0x21
 8116 1464 63040000 		.4byte	0x463
 8117 1468 24010000 		.4byte	.LBB53
 8118 146c 06000000 		.4byte	.LBE53-.LBB53
 8119 1470 01       		.byte	0x1
 8120 1471 9813     		.2byte	0x1398
 8121 1473 22       		.uleb128 0x22
 8122 1474 6F040000 		.4byte	0x46f
 8123 1478 02       		.uleb128 0x2
 8124 1479 91       		.byte	0x91
 8125 147a 6C       		.sleb128 -20
 8126 147b 00       		.byte	0
 8127 147c 00       		.byte	0
 8128 147d 06       		.uleb128 0x6
 8129 147e 04       		.byte	0x4
 8130 147f 77010000 		.4byte	0x177
 8131 1483 1D       		.uleb128 0x1d
 8132 1484 E8070000 		.4byte	.LASF210
 8133 1488 01       		.byte	0x1
 8134 1489 A213     		.2byte	0x13a2
 8135 148b 00000000 		.4byte	.LFB118
 8136 148f E4000000 		.4byte	.LFE118-.LFB118
 8137 1493 01       		.uleb128 0x1
 8138 1494 9C       		.byte	0x9c
 8139 1495 2D150000 		.4byte	0x152d
 8140 1499 18       		.uleb128 0x18
 8141 149a AD050000 		.4byte	.LASF203
 8142 149e 01       		.byte	0x1
 8143 149f A213     		.2byte	0x13a2
 8144 14a1 81020000 		.4byte	0x281
 8145 14a5 02       		.uleb128 0x2
 8146 14a6 91       		.byte	0x91
 8147 14a7 5C       		.sleb128 -36
 8148 14a8 18       		.uleb128 0x18
 8149 14a9 D5050000 		.4byte	.LASF209
 8150 14ad 01       		.byte	0x1
 8151 14ae A213     		.2byte	0x13a2
 8152 14b0 7D140000 		.4byte	0x147d
 8153 14b4 02       		.uleb128 0x2
 8154 14b5 91       		.byte	0x91
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 242
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 242
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 8155 14b6 58       		.sleb128 -40
 8156 14b7 19       		.uleb128 0x19
 8157 14b8 3B060000 		.4byte	.LASF104
 8158 14bc 01       		.byte	0x1
 8159 14bd A413     		.2byte	0x13a4
 8160 14bf 7B050000 		.4byte	0x57b
 8161 14c3 02       		.uleb128 0x2
 8162 14c4 91       		.byte	0x91
 8163 14c5 74       		.sleb128 -12
 8164 14c6 19       		.uleb128 0x19
 8165 14c7 F6020000 		.4byte	.LASF207
 8166 14cb 01       		.byte	0x1
 8167 14cc A513     		.2byte	0x13a5
 8168 14ce CA000000 		.4byte	0xca
 8169 14d2 02       		.uleb128 0x2
 8170 14d3 91       		.byte	0x91
 8171 14d4 6B       		.sleb128 -21
 8172 14d5 19       		.uleb128 0x19
 8173 14d6 360B0000 		.4byte	.LASF136
 8174 14da 01       		.byte	0x1
 8175 14db A613     		.2byte	0x13a6
 8176 14dd 82010000 		.4byte	0x182
 8177 14e1 02       		.uleb128 0x2
 8178 14e2 91       		.byte	0x91
 8179 14e3 6C       		.sleb128 -20
 8180 14e4 1F       		.uleb128 0x1f
 8181 14e5 3C040000 		.4byte	0x43c
 8182 14e9 0E000000 		.4byte	.LBB55
 8183 14ed 1A000000 		.4byte	.LBE55-.LBB55
 8184 14f1 01       		.byte	0x1
 8185 14f2 BE13     		.2byte	0x13be
 8186 14f4 13150000 		.4byte	0x1513
 8187 14f8 1A       		.uleb128 0x1a
 8188 14f9 0E000000 		.4byte	.LBB56
 8189 14fd 1A000000 		.4byte	.LBE56-.LBB56
 8190 1501 20       		.uleb128 0x20
 8191 1502 4C040000 		.4byte	0x44c
 8192 1506 02       		.uleb128 0x2
 8193 1507 91       		.byte	0x91
 8194 1508 64       		.sleb128 -28
 8195 1509 20       		.uleb128 0x20
 8196 150a 57040000 		.4byte	0x457
 8197 150e 02       		.uleb128 0x2
 8198 150f 91       		.byte	0x91
 8199 1510 60       		.sleb128 -32
 8200 1511 00       		.byte	0
 8201 1512 00       		.byte	0
 8202 1513 21       		.uleb128 0x21
 8203 1514 63040000 		.4byte	0x463
 8204 1518 BC000000 		.4byte	.LBB57
 8205 151c 06000000 		.4byte	.LBE57-.LBB57
 8206 1520 01       		.byte	0x1
 8207 1521 F013     		.2byte	0x13f0
 8208 1523 22       		.uleb128 0x22
 8209 1524 6F040000 		.4byte	0x46f
 8210 1528 02       		.uleb128 0x2
 8211 1529 91       		.byte	0x91
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 243
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 243
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 8212 152a 70       		.sleb128 -16
 8213 152b 00       		.byte	0
 8214 152c 00       		.byte	0
 8215 152d 17       		.uleb128 0x17
 8216 152e 7B010000 		.4byte	.LASF211
 8217 1532 01       		.byte	0x1
 8218 1533 F813     		.2byte	0x13f8
 8219 1535 77010000 		.4byte	0x177
 8220 1539 00000000 		.4byte	.LFB119
 8221 153d 4C000000 		.4byte	.LFE119-.LFB119
 8222 1541 01       		.uleb128 0x1
 8223 1542 9C       		.byte	0x9c
 8224 1543 75150000 		.4byte	0x1575
 8225 1547 18       		.uleb128 0x18
 8226 1548 830B0000 		.4byte	.LASF117
 8227 154c 01       		.byte	0x1
 8228 154d F813     		.2byte	0x13f8
 8229 154f 81020000 		.4byte	0x281
 8230 1553 02       		.uleb128 0x2
 8231 1554 91       		.byte	0x91
 8232 1555 6C       		.sleb128 -20
 8233 1556 19       		.uleb128 0x19
 8234 1557 3B060000 		.4byte	.LASF104
 8235 155b 01       		.byte	0x1
 8236 155c FA13     		.2byte	0x13fa
 8237 155e 7B050000 		.4byte	0x57b
 8238 1562 02       		.uleb128 0x2
 8239 1563 91       		.byte	0x91
 8240 1564 70       		.sleb128 -16
 8241 1565 19       		.uleb128 0x19
 8242 1566 2D050000 		.4byte	.LASF98
 8243 156a 01       		.byte	0x1
 8244 156b FB13     		.2byte	0x13fb
 8245 156d 77010000 		.4byte	0x177
 8246 1571 02       		.uleb128 0x2
 8247 1572 91       		.byte	0x91
 8248 1573 74       		.sleb128 -12
 8249 1574 00       		.byte	0
 8250 1575 17       		.uleb128 0x17
 8251 1576 15070000 		.4byte	.LASF212
 8252 157a 01       		.byte	0x1
 8253 157b 1714     		.2byte	0x1417
 8254 157d EB000000 		.4byte	0xeb
 8255 1581 00000000 		.4byte	.LFB120
 8256 1585 48000000 		.4byte	.LFE120-.LFB120
 8257 1589 01       		.uleb128 0x1
 8258 158a 9C       		.byte	0x9c
 8259 158b CC150000 		.4byte	0x15cc
 8260 158f 18       		.uleb128 0x18
 8261 1590 830B0000 		.4byte	.LASF117
 8262 1594 01       		.byte	0x1
 8263 1595 1714     		.2byte	0x1417
 8264 1597 81020000 		.4byte	0x281
 8265 159b 02       		.uleb128 0x2
 8266 159c 91       		.byte	0x91
 8267 159d 6C       		.sleb128 -20
 8268 159e 18       		.uleb128 0x18
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 244
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 244
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 8269 159f E8020000 		.4byte	.LASF213
 8270 15a3 01       		.byte	0x1
 8271 15a4 1714     		.2byte	0x1417
 8272 15a6 EB000000 		.4byte	0xeb
 8273 15aa 02       		.uleb128 0x2
 8274 15ab 91       		.byte	0x91
 8275 15ac 68       		.sleb128 -24
 8276 15ad 19       		.uleb128 0x19
 8277 15ae 3B060000 		.4byte	.LASF104
 8278 15b2 01       		.byte	0x1
 8279 15b3 1914     		.2byte	0x1419
 8280 15b5 7B050000 		.4byte	0x57b
 8281 15b9 02       		.uleb128 0x2
 8282 15ba 91       		.byte	0x91
 8283 15bb 74       		.sleb128 -12
 8284 15bc 19       		.uleb128 0x19
 8285 15bd 720E0000 		.4byte	.LASF197
 8286 15c1 01       		.byte	0x1
 8287 15c2 1A14     		.2byte	0x141a
 8288 15c4 EB000000 		.4byte	0xeb
 8289 15c8 02       		.uleb128 0x2
 8290 15c9 91       		.byte	0x91
 8291 15ca 70       		.sleb128 -16
 8292 15cb 00       		.byte	0
 8293 15cc 1B       		.uleb128 0x1b
 8294 15cd D20B0000 		.4byte	.LASF214
 8295 15d1 01       		.byte	0x1
 8296 15d2 3914     		.2byte	0x1439
 8297 15d4 00000000 		.4byte	.LFB121
 8298 15d8 CC000000 		.4byte	.LFE121-.LFB121
 8299 15dc 01       		.uleb128 0x1
 8300 15dd 9C       		.byte	0x9c
 8301 15de 1F160000 		.4byte	0x161f
 8302 15e2 18       		.uleb128 0x18
 8303 15e3 3E020000 		.4byte	.LASF158
 8304 15e7 01       		.byte	0x1
 8305 15e8 3914     		.2byte	0x1439
 8306 15ea 8D010000 		.4byte	0x18d
 8307 15ee 02       		.uleb128 0x2
 8308 15ef 91       		.byte	0x91
 8309 15f0 6C       		.sleb128 -20
 8310 15f1 18       		.uleb128 0x18
 8311 15f2 0B000000 		.4byte	.LASF215
 8312 15f6 01       		.byte	0x1
 8313 15f7 3914     		.2byte	0x1439
 8314 15f9 1F160000 		.4byte	0x161f
 8315 15fd 02       		.uleb128 0x2
 8316 15fe 91       		.byte	0x91
 8317 15ff 68       		.sleb128 -24
 8318 1600 19       		.uleb128 0x19
 8319 1601 A7010000 		.4byte	.LASF109
 8320 1605 01       		.byte	0x1
 8321 1606 3B14     		.2byte	0x143b
 8322 1608 8D010000 		.4byte	0x18d
 8323 160c 02       		.uleb128 0x2
 8324 160d 91       		.byte	0x91
 8325 160e 70       		.sleb128 -16
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 245
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 245
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 8326 160f 19       		.uleb128 0x19
 8327 1610 35050000 		.4byte	.LASF112
 8328 1614 01       		.byte	0x1
 8329 1615 3C14     		.2byte	0x143c
 8330 1617 22070000 		.4byte	0x722
 8331 161b 02       		.uleb128 0x2
 8332 161c 91       		.byte	0x91
 8333 161d 74       		.sleb128 -12
 8334 161e 00       		.byte	0
 8335 161f 07       		.uleb128 0x7
 8336 1620 77010000 		.4byte	0x177
 8337 1624 11       		.uleb128 0x11
 8338 1625 76020000 		.4byte	0x276
 8339 1629 34160000 		.4byte	0x1634
 8340 162d 12       		.uleb128 0x12
 8341 162e A9000000 		.4byte	0xa9
 8342 1632 04       		.byte	0x4
 8343 1633 00       		.byte	0
 8344 1634 19       		.uleb128 0x19
 8345 1635 ED0C0000 		.4byte	.LASF216
 8346 1639 01       		.byte	0x1
 8347 163a 5701     		.2byte	0x157
 8348 163c 24160000 		.4byte	0x1624
 8349 1640 05       		.uleb128 0x5
 8350 1641 03       		.byte	0x3
 8351 1642 04000000 		.4byte	pxReadyTasksLists
 8352 1646 19       		.uleb128 0x19
 8353 1647 340D0000 		.4byte	.LASF217
 8354 164b 01       		.byte	0x1
 8355 164c 5801     		.2byte	0x158
 8356 164e 76020000 		.4byte	0x276
 8357 1652 05       		.uleb128 0x5
 8358 1653 03       		.byte	0x3
 8359 1654 68000000 		.4byte	xDelayedTaskList1
 8360 1658 19       		.uleb128 0x19
 8361 1659 460D0000 		.4byte	.LASF218
 8362 165d 01       		.byte	0x1
 8363 165e 5901     		.2byte	0x159
 8364 1660 76020000 		.4byte	0x276
 8365 1664 05       		.uleb128 0x5
 8366 1665 03       		.byte	0x3
 8367 1666 7C000000 		.4byte	xDelayedTaskList2
 8368 166a 19       		.uleb128 0x19
 8369 166b CC060000 		.4byte	.LASF219
 8370 166f 01       		.byte	0x1
 8371 1670 5A01     		.2byte	0x15a
 8372 1672 7C160000 		.4byte	0x167c
 8373 1676 05       		.uleb128 0x5
 8374 1677 03       		.byte	0x3
 8375 1678 90000000 		.4byte	pxDelayedTaskList
 8376 167c 09       		.uleb128 0x9
 8377 167d EB0C0000 		.4byte	0xceb
 8378 1681 19       		.uleb128 0x19
 8379 1682 93070000 		.4byte	.LASF220
 8380 1686 01       		.byte	0x1
 8381 1687 5B01     		.2byte	0x15b
 8382 1689 7C160000 		.4byte	0x167c
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 246
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 246
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 8383 168d 05       		.uleb128 0x5
 8384 168e 03       		.byte	0x3
 8385 168f 94000000 		.4byte	pxOverflowDelayedTaskList
 8386 1693 19       		.uleb128 0x19
 8387 1694 FF070000 		.4byte	.LASF221
 8388 1698 01       		.byte	0x1
 8389 1699 5C01     		.2byte	0x15c
 8390 169b 76020000 		.4byte	0x276
 8391 169f 05       		.uleb128 0x5
 8392 16a0 03       		.byte	0x3
 8393 16a1 98000000 		.4byte	xPendingReadyList
 8394 16a5 19       		.uleb128 0x19
 8395 16a6 BD020000 		.4byte	.LASF222
 8396 16aa 01       		.byte	0x1
 8397 16ab 6001     		.2byte	0x160
 8398 16ad 76020000 		.4byte	0x276
 8399 16b1 05       		.uleb128 0x5
 8400 16b2 03       		.byte	0x3
 8401 16b3 AC000000 		.4byte	xTasksWaitingTermination
 8402 16b7 19       		.uleb128 0x19
 8403 16b8 3B0C0000 		.4byte	.LASF223
 8404 16bc 01       		.byte	0x1
 8405 16bd 6101     		.2byte	0x161
 8406 16bf 6B020000 		.4byte	0x26b
 8407 16c3 05       		.uleb128 0x5
 8408 16c4 03       		.byte	0x3
 8409 16c5 C0000000 		.4byte	uxDeletedTasksWaitingCleanUp
 8410 16c9 19       		.uleb128 0x19
 8411 16ca CF000000 		.4byte	.LASF224
 8412 16ce 01       		.byte	0x1
 8413 16cf 6701     		.2byte	0x167
 8414 16d1 76020000 		.4byte	0x276
 8415 16d5 05       		.uleb128 0x5
 8416 16d6 03       		.byte	0x3
 8417 16d7 C4000000 		.4byte	xSuspendedTaskList
 8418 16db 19       		.uleb128 0x19
 8419 16dc 70000000 		.4byte	.LASF225
 8420 16e0 01       		.byte	0x1
 8421 16e1 7201     		.2byte	0x172
 8422 16e3 6B020000 		.4byte	0x26b
 8423 16e7 05       		.uleb128 0x5
 8424 16e8 03       		.byte	0x3
 8425 16e9 D8000000 		.4byte	uxCurrentNumberOfTasks
 8426 16ed 19       		.uleb128 0x19
 8427 16ee 7B0D0000 		.4byte	.LASF226
 8428 16f2 01       		.byte	0x1
 8429 16f3 7301     		.2byte	0x173
 8430 16f5 FF160000 		.4byte	0x16ff
 8431 16f9 05       		.uleb128 0x5
 8432 16fa 03       		.byte	0x3
 8433 16fb DC000000 		.4byte	xTickCount
 8434 16ff 09       		.uleb128 0x9
 8435 1700 8D010000 		.4byte	0x18d
 8436 1704 19       		.uleb128 0x19
 8437 1705 AF080000 		.4byte	.LASF227
 8438 1709 01       		.byte	0x1
 8439 170a 7401     		.2byte	0x174
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 247
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 247
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 8440 170c 6B020000 		.4byte	0x26b
 8441 1710 05       		.uleb128 0x5
 8442 1711 03       		.byte	0x3
 8443 1712 E0000000 		.4byte	uxTopReadyPriority
 8444 1716 19       		.uleb128 0x19
 8445 1717 7F0A0000 		.4byte	.LASF228
 8446 171b 01       		.byte	0x1
 8447 171c 7501     		.2byte	0x175
 8448 171e 28170000 		.4byte	0x1728
 8449 1722 05       		.uleb128 0x5
 8450 1723 03       		.byte	0x3
 8451 1724 E4000000 		.4byte	xSchedulerRunning
 8452 1728 09       		.uleb128 0x9
 8453 1729 77010000 		.4byte	0x177
 8454 172d 19       		.uleb128 0x19
 8455 172e 65060000 		.4byte	.LASF229
 8456 1732 01       		.byte	0x1
 8457 1733 7601     		.2byte	0x176
 8458 1735 FF160000 		.4byte	0x16ff
 8459 1739 05       		.uleb128 0x5
 8460 173a 03       		.byte	0x3
 8461 173b E8000000 		.4byte	xPendedTicks
 8462 173f 19       		.uleb128 0x19
 8463 1740 A9000000 		.4byte	.LASF230
 8464 1744 01       		.byte	0x1
 8465 1745 7701     		.2byte	0x177
 8466 1747 28170000 		.4byte	0x1728
 8467 174b 05       		.uleb128 0x5
 8468 174c 03       		.byte	0x3
 8469 174d EC000000 		.4byte	xYieldPending
 8470 1751 19       		.uleb128 0x19
 8471 1752 580D0000 		.4byte	.LASF231
 8472 1756 01       		.byte	0x1
 8473 1757 7801     		.2byte	0x178
 8474 1759 28170000 		.4byte	0x1728
 8475 175d 05       		.uleb128 0x5
 8476 175e 03       		.byte	0x3
 8477 175f F0000000 		.4byte	xNumOfOverflows
 8478 1763 19       		.uleb128 0x19
 8479 1764 A90C0000 		.4byte	.LASF232
 8480 1768 01       		.byte	0x1
 8481 1769 7901     		.2byte	0x179
 8482 176b 82010000 		.4byte	0x182
 8483 176f 05       		.uleb128 0x5
 8484 1770 03       		.byte	0x3
 8485 1771 F4000000 		.4byte	uxTaskNumber
 8486 1775 19       		.uleb128 0x19
 8487 1776 4B020000 		.4byte	.LASF233
 8488 177a 01       		.byte	0x1
 8489 177b 7A01     		.2byte	0x17a
 8490 177d FF160000 		.4byte	0x16ff
 8491 1781 05       		.uleb128 0x5
 8492 1782 03       		.byte	0x3
 8493 1783 F8000000 		.4byte	xNextTaskUnblockTime
 8494 1787 19       		.uleb128 0x19
 8495 1788 D20C0000 		.4byte	.LASF234
 8496 178c 01       		.byte	0x1
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 248
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 248
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 8497 178d 7B01     		.2byte	0x17b
 8498 178f 81020000 		.4byte	0x281
 8499 1793 05       		.uleb128 0x5
 8500 1794 03       		.byte	0x3
 8501 1795 FC000000 		.4byte	xIdleTaskHandle
 8502 1799 19       		.uleb128 0x19
 8503 179a F8040000 		.4byte	.LASF235
 8504 179e 01       		.byte	0x1
 8505 179f 8501     		.2byte	0x185
 8506 17a1 6B020000 		.4byte	0x26b
 8507 17a5 05       		.uleb128 0x5
 8508 17a6 03       		.byte	0x3
 8509 17a7 00010000 		.4byte	uxSchedulerSuspended
 8510 17ab 11       		.uleb128 0x11
 8511 17ac 21010000 		.4byte	0x121
 8512 17b0 BB170000 		.4byte	0x17bb
 8513 17b4 12       		.uleb128 0x12
 8514 17b5 A9000000 		.4byte	0xa9
 8515 17b9 07       		.byte	0x7
 8516 17ba 00       		.byte	0
 8517 17bb 29       		.uleb128 0x29
 8518 17bc DD090000 		.4byte	.LASF236
 8519 17c0 07       		.byte	0x7
 8520 17c1 34       		.byte	0x34
 8521 17c2 AB170000 		.4byte	0x17ab
 8522 17c6 05       		.uleb128 0x5
 8523 17c7 03       		.byte	0x3
 8524 17c8 00000000 		.4byte	DS18x8_Sensor
 8525 17cc 29       		.uleb128 0x29
 8526 17cd 82090000 		.4byte	.LASF237
 8527 17d1 07       		.byte	0x7
 8528 17d2 39       		.byte	0x39
 8529 17d3 1C010000 		.4byte	0x11c
 8530 17d7 05       		.uleb128 0x5
 8531 17d8 03       		.byte	0x3
 8532 17d9 00000000 		.4byte	DS18x8_DataReady
 8533 17dd 2A       		.uleb128 0x2a
 8534 17de D6010000 		.4byte	.LASF238
 8535 17e2 0B       		.byte	0xb
 8536 17e3 1207     		.2byte	0x712
 8537 17e5 E9170000 		.4byte	0x17e9
 8538 17e9 09       		.uleb128 0x9
 8539 17ea E0000000 		.4byte	0xe0
 8540 17ee 2B       		.uleb128 0x2b
 8541 17ef AD060000 		.4byte	.LASF239
 8542 17f3 01       		.byte	0x1
 8543 17f4 5101     		.2byte	0x151
 8544 17f6 00180000 		.4byte	0x1800
 8545 17fa 05       		.uleb128 0x5
 8546 17fb 03       		.byte	0x3
 8547 17fc 00000000 		.4byte	pxCurrentTCB
 8548 1800 09       		.uleb128 0x9
 8549 1801 7B050000 		.4byte	0x57b
 8550 1805 00       		.byte	0
 8551              		.section	.debug_abbrev,"",%progbits
 8552              	.Ldebug_abbrev0:
 8553 0000 01       		.uleb128 0x1
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 249
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 249
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 8554 0001 11       		.uleb128 0x11
 8555 0002 01       		.byte	0x1
 8556 0003 25       		.uleb128 0x25
 8557 0004 0E       		.uleb128 0xe
 8558 0005 13       		.uleb128 0x13
 8559 0006 0B       		.uleb128 0xb
 8560 0007 03       		.uleb128 0x3
 8561 0008 0E       		.uleb128 0xe
 8562 0009 1B       		.uleb128 0x1b
 8563 000a 0E       		.uleb128 0xe
 8564 000b 55       		.uleb128 0x55
 8565 000c 17       		.uleb128 0x17
 8566 000d 11       		.uleb128 0x11
 8567 000e 01       		.uleb128 0x1
 8568 000f 10       		.uleb128 0x10
 8569 0010 17       		.uleb128 0x17
 8570 0011 00       		.byte	0
 8571 0012 00       		.byte	0
 8572 0013 02       		.uleb128 0x2
 8573 0014 16       		.uleb128 0x16
 8574 0015 00       		.byte	0
 8575 0016 03       		.uleb128 0x3
 8576 0017 0E       		.uleb128 0xe
 8577 0018 3A       		.uleb128 0x3a
 8578 0019 0B       		.uleb128 0xb
 8579 001a 3B       		.uleb128 0x3b
 8580 001b 0B       		.uleb128 0xb
 8581 001c 49       		.uleb128 0x49
 8582 001d 13       		.uleb128 0x13
 8583 001e 00       		.byte	0
 8584 001f 00       		.byte	0
 8585 0020 03       		.uleb128 0x3
 8586 0021 24       		.uleb128 0x24
 8587 0022 00       		.byte	0
 8588 0023 0B       		.uleb128 0xb
 8589 0024 0B       		.uleb128 0xb
 8590 0025 3E       		.uleb128 0x3e
 8591 0026 0B       		.uleb128 0xb
 8592 0027 03       		.uleb128 0x3
 8593 0028 0E       		.uleb128 0xe
 8594 0029 00       		.byte	0
 8595 002a 00       		.byte	0
 8596 002b 04       		.uleb128 0x4
 8597 002c 24       		.uleb128 0x24
 8598 002d 00       		.byte	0
 8599 002e 0B       		.uleb128 0xb
 8600 002f 0B       		.uleb128 0xb
 8601 0030 3E       		.uleb128 0x3e
 8602 0031 0B       		.uleb128 0xb
 8603 0032 03       		.uleb128 0x3
 8604 0033 08       		.uleb128 0x8
 8605 0034 00       		.byte	0
 8606 0035 00       		.byte	0
 8607 0036 05       		.uleb128 0x5
 8608 0037 0F       		.uleb128 0xf
 8609 0038 00       		.byte	0
 8610 0039 0B       		.uleb128 0xb
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 250
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 250
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 8611 003a 0B       		.uleb128 0xb
 8612 003b 00       		.byte	0
 8613 003c 00       		.byte	0
 8614 003d 06       		.uleb128 0x6
 8615 003e 0F       		.uleb128 0xf
 8616 003f 00       		.byte	0
 8617 0040 0B       		.uleb128 0xb
 8618 0041 0B       		.uleb128 0xb
 8619 0042 49       		.uleb128 0x49
 8620 0043 13       		.uleb128 0x13
 8621 0044 00       		.byte	0
 8622 0045 00       		.byte	0
 8623 0046 07       		.uleb128 0x7
 8624 0047 26       		.uleb128 0x26
 8625 0048 00       		.byte	0
 8626 0049 49       		.uleb128 0x49
 8627 004a 13       		.uleb128 0x13
 8628 004b 00       		.byte	0
 8629 004c 00       		.byte	0
 8630 004d 08       		.uleb128 0x8
 8631 004e 16       		.uleb128 0x16
 8632 004f 00       		.byte	0
 8633 0050 03       		.uleb128 0x3
 8634 0051 0E       		.uleb128 0xe
 8635 0052 3A       		.uleb128 0x3a
 8636 0053 0B       		.uleb128 0xb
 8637 0054 3B       		.uleb128 0x3b
 8638 0055 05       		.uleb128 0x5
 8639 0056 49       		.uleb128 0x49
 8640 0057 13       		.uleb128 0x13
 8641 0058 00       		.byte	0
 8642 0059 00       		.byte	0
 8643 005a 09       		.uleb128 0x9
 8644 005b 35       		.uleb128 0x35
 8645 005c 00       		.byte	0
 8646 005d 49       		.uleb128 0x49
 8647 005e 13       		.uleb128 0x13
 8648 005f 00       		.byte	0
 8649 0060 00       		.byte	0
 8650 0061 0A       		.uleb128 0xa
 8651 0062 13       		.uleb128 0x13
 8652 0063 01       		.byte	0x1
 8653 0064 03       		.uleb128 0x3
 8654 0065 0E       		.uleb128 0xe
 8655 0066 0B       		.uleb128 0xb
 8656 0067 0B       		.uleb128 0xb
 8657 0068 3A       		.uleb128 0x3a
 8658 0069 0B       		.uleb128 0xb
 8659 006a 3B       		.uleb128 0x3b
 8660 006b 0B       		.uleb128 0xb
 8661 006c 01       		.uleb128 0x1
 8662 006d 13       		.uleb128 0x13
 8663 006e 00       		.byte	0
 8664 006f 00       		.byte	0
 8665 0070 0B       		.uleb128 0xb
 8666 0071 0D       		.uleb128 0xd
 8667 0072 00       		.byte	0
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 251
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 251
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 8668 0073 03       		.uleb128 0x3
 8669 0074 0E       		.uleb128 0xe
 8670 0075 3A       		.uleb128 0x3a
 8671 0076 0B       		.uleb128 0xb
 8672 0077 3B       		.uleb128 0x3b
 8673 0078 0B       		.uleb128 0xb
 8674 0079 49       		.uleb128 0x49
 8675 007a 13       		.uleb128 0x13
 8676 007b 38       		.uleb128 0x38
 8677 007c 0B       		.uleb128 0xb
 8678 007d 00       		.byte	0
 8679 007e 00       		.byte	0
 8680 007f 0C       		.uleb128 0xc
 8681 0080 15       		.uleb128 0x15
 8682 0081 01       		.byte	0x1
 8683 0082 27       		.uleb128 0x27
 8684 0083 19       		.uleb128 0x19
 8685 0084 01       		.uleb128 0x1
 8686 0085 13       		.uleb128 0x13
 8687 0086 00       		.byte	0
 8688 0087 00       		.byte	0
 8689 0088 0D       		.uleb128 0xd
 8690 0089 05       		.uleb128 0x5
 8691 008a 00       		.byte	0
 8692 008b 49       		.uleb128 0x49
 8693 008c 13       		.uleb128 0x13
 8694 008d 00       		.byte	0
 8695 008e 00       		.byte	0
 8696 008f 0E       		.uleb128 0xe
 8697 0090 0D       		.uleb128 0xd
 8698 0091 00       		.byte	0
 8699 0092 03       		.uleb128 0x3
 8700 0093 0E       		.uleb128 0xe
 8701 0094 3A       		.uleb128 0x3a
 8702 0095 0B       		.uleb128 0xb
 8703 0096 3B       		.uleb128 0x3b
 8704 0097 05       		.uleb128 0x5
 8705 0098 49       		.uleb128 0x49
 8706 0099 13       		.uleb128 0x13
 8707 009a 38       		.uleb128 0x38
 8708 009b 0B       		.uleb128 0xb
 8709 009c 00       		.byte	0
 8710 009d 00       		.byte	0
 8711 009e 0F       		.uleb128 0xf
 8712 009f 04       		.uleb128 0x4
 8713 00a0 01       		.byte	0x1
 8714 00a1 0B       		.uleb128 0xb
 8715 00a2 0B       		.uleb128 0xb
 8716 00a3 49       		.uleb128 0x49
 8717 00a4 13       		.uleb128 0x13
 8718 00a5 3A       		.uleb128 0x3a
 8719 00a6 0B       		.uleb128 0xb
 8720 00a7 3B       		.uleb128 0x3b
 8721 00a8 0B       		.uleb128 0xb
 8722 00a9 01       		.uleb128 0x1
 8723 00aa 13       		.uleb128 0x13
 8724 00ab 00       		.byte	0
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 252
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 252
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 8725 00ac 00       		.byte	0
 8726 00ad 10       		.uleb128 0x10
 8727 00ae 28       		.uleb128 0x28
 8728 00af 00       		.byte	0
 8729 00b0 03       		.uleb128 0x3
 8730 00b1 0E       		.uleb128 0xe
 8731 00b2 1C       		.uleb128 0x1c
 8732 00b3 0B       		.uleb128 0xb
 8733 00b4 00       		.byte	0
 8734 00b5 00       		.byte	0
 8735 00b6 11       		.uleb128 0x11
 8736 00b7 01       		.uleb128 0x1
 8737 00b8 01       		.byte	0x1
 8738 00b9 49       		.uleb128 0x49
 8739 00ba 13       		.uleb128 0x13
 8740 00bb 01       		.uleb128 0x1
 8741 00bc 13       		.uleb128 0x13
 8742 00bd 00       		.byte	0
 8743 00be 00       		.byte	0
 8744 00bf 12       		.uleb128 0x12
 8745 00c0 21       		.uleb128 0x21
 8746 00c1 00       		.byte	0
 8747 00c2 49       		.uleb128 0x49
 8748 00c3 13       		.uleb128 0x13
 8749 00c4 2F       		.uleb128 0x2f
 8750 00c5 0B       		.uleb128 0xb
 8751 00c6 00       		.byte	0
 8752 00c7 00       		.byte	0
 8753 00c8 13       		.uleb128 0x13
 8754 00c9 2E       		.uleb128 0x2e
 8755 00ca 01       		.byte	0x1
 8756 00cb 03       		.uleb128 0x3
 8757 00cc 0E       		.uleb128 0xe
 8758 00cd 3A       		.uleb128 0x3a
 8759 00ce 0B       		.uleb128 0xb
 8760 00cf 3B       		.uleb128 0x3b
 8761 00d0 0B       		.uleb128 0xb
 8762 00d1 27       		.uleb128 0x27
 8763 00d2 19       		.uleb128 0x19
 8764 00d3 49       		.uleb128 0x49
 8765 00d4 13       		.uleb128 0x13
 8766 00d5 20       		.uleb128 0x20
 8767 00d6 0B       		.uleb128 0xb
 8768 00d7 01       		.uleb128 0x1
 8769 00d8 13       		.uleb128 0x13
 8770 00d9 00       		.byte	0
 8771 00da 00       		.byte	0
 8772 00db 14       		.uleb128 0x14
 8773 00dc 34       		.uleb128 0x34
 8774 00dd 00       		.byte	0
 8775 00de 03       		.uleb128 0x3
 8776 00df 0E       		.uleb128 0xe
 8777 00e0 3A       		.uleb128 0x3a
 8778 00e1 0B       		.uleb128 0xb
 8779 00e2 3B       		.uleb128 0x3b
 8780 00e3 0B       		.uleb128 0xb
 8781 00e4 49       		.uleb128 0x49
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 253
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 253
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 8782 00e5 13       		.uleb128 0x13
 8783 00e6 00       		.byte	0
 8784 00e7 00       		.byte	0
 8785 00e8 15       		.uleb128 0x15
 8786 00e9 2E       		.uleb128 0x2e
 8787 00ea 01       		.byte	0x1
 8788 00eb 03       		.uleb128 0x3
 8789 00ec 0E       		.uleb128 0xe
 8790 00ed 3A       		.uleb128 0x3a
 8791 00ee 0B       		.uleb128 0xb
 8792 00ef 3B       		.uleb128 0x3b
 8793 00f0 0B       		.uleb128 0xb
 8794 00f1 27       		.uleb128 0x27
 8795 00f2 19       		.uleb128 0x19
 8796 00f3 20       		.uleb128 0x20
 8797 00f4 0B       		.uleb128 0xb
 8798 00f5 01       		.uleb128 0x1
 8799 00f6 13       		.uleb128 0x13
 8800 00f7 00       		.byte	0
 8801 00f8 00       		.byte	0
 8802 00f9 16       		.uleb128 0x16
 8803 00fa 05       		.uleb128 0x5
 8804 00fb 00       		.byte	0
 8805 00fc 03       		.uleb128 0x3
 8806 00fd 0E       		.uleb128 0xe
 8807 00fe 3A       		.uleb128 0x3a
 8808 00ff 0B       		.uleb128 0xb
 8809 0100 3B       		.uleb128 0x3b
 8810 0101 0B       		.uleb128 0xb
 8811 0102 49       		.uleb128 0x49
 8812 0103 13       		.uleb128 0x13
 8813 0104 00       		.byte	0
 8814 0105 00       		.byte	0
 8815 0106 17       		.uleb128 0x17
 8816 0107 2E       		.uleb128 0x2e
 8817 0108 01       		.byte	0x1
 8818 0109 3F       		.uleb128 0x3f
 8819 010a 19       		.uleb128 0x19
 8820 010b 03       		.uleb128 0x3
 8821 010c 0E       		.uleb128 0xe
 8822 010d 3A       		.uleb128 0x3a
 8823 010e 0B       		.uleb128 0xb
 8824 010f 3B       		.uleb128 0x3b
 8825 0110 05       		.uleb128 0x5
 8826 0111 27       		.uleb128 0x27
 8827 0112 19       		.uleb128 0x19
 8828 0113 49       		.uleb128 0x49
 8829 0114 13       		.uleb128 0x13
 8830 0115 11       		.uleb128 0x11
 8831 0116 01       		.uleb128 0x1
 8832 0117 12       		.uleb128 0x12
 8833 0118 06       		.uleb128 0x6
 8834 0119 40       		.uleb128 0x40
 8835 011a 18       		.uleb128 0x18
 8836 011b 9642     		.uleb128 0x2116
 8837 011d 19       		.uleb128 0x19
 8838 011e 01       		.uleb128 0x1
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 254
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 254
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 8839 011f 13       		.uleb128 0x13
 8840 0120 00       		.byte	0
 8841 0121 00       		.byte	0
 8842 0122 18       		.uleb128 0x18
 8843 0123 05       		.uleb128 0x5
 8844 0124 00       		.byte	0
 8845 0125 03       		.uleb128 0x3
 8846 0126 0E       		.uleb128 0xe
 8847 0127 3A       		.uleb128 0x3a
 8848 0128 0B       		.uleb128 0xb
 8849 0129 3B       		.uleb128 0x3b
 8850 012a 05       		.uleb128 0x5
 8851 012b 49       		.uleb128 0x49
 8852 012c 13       		.uleb128 0x13
 8853 012d 02       		.uleb128 0x2
 8854 012e 18       		.uleb128 0x18
 8855 012f 00       		.byte	0
 8856 0130 00       		.byte	0
 8857 0131 19       		.uleb128 0x19
 8858 0132 34       		.uleb128 0x34
 8859 0133 00       		.byte	0
 8860 0134 03       		.uleb128 0x3
 8861 0135 0E       		.uleb128 0xe
 8862 0136 3A       		.uleb128 0x3a
 8863 0137 0B       		.uleb128 0xb
 8864 0138 3B       		.uleb128 0x3b
 8865 0139 05       		.uleb128 0x5
 8866 013a 49       		.uleb128 0x49
 8867 013b 13       		.uleb128 0x13
 8868 013c 02       		.uleb128 0x2
 8869 013d 18       		.uleb128 0x18
 8870 013e 00       		.byte	0
 8871 013f 00       		.byte	0
 8872 0140 1A       		.uleb128 0x1a
 8873 0141 0B       		.uleb128 0xb
 8874 0142 01       		.byte	0x1
 8875 0143 11       		.uleb128 0x11
 8876 0144 01       		.uleb128 0x1
 8877 0145 12       		.uleb128 0x12
 8878 0146 06       		.uleb128 0x6
 8879 0147 00       		.byte	0
 8880 0148 00       		.byte	0
 8881 0149 1B       		.uleb128 0x1b
 8882 014a 2E       		.uleb128 0x2e
 8883 014b 01       		.byte	0x1
 8884 014c 03       		.uleb128 0x3
 8885 014d 0E       		.uleb128 0xe
 8886 014e 3A       		.uleb128 0x3a
 8887 014f 0B       		.uleb128 0xb
 8888 0150 3B       		.uleb128 0x3b
 8889 0151 05       		.uleb128 0x5
 8890 0152 27       		.uleb128 0x27
 8891 0153 19       		.uleb128 0x19
 8892 0154 11       		.uleb128 0x11
 8893 0155 01       		.uleb128 0x1
 8894 0156 12       		.uleb128 0x12
 8895 0157 06       		.uleb128 0x6
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 255
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 255
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 8896 0158 40       		.uleb128 0x40
 8897 0159 18       		.uleb128 0x18
 8898 015a 9642     		.uleb128 0x2116
 8899 015c 19       		.uleb128 0x19
 8900 015d 01       		.uleb128 0x1
 8901 015e 13       		.uleb128 0x13
 8902 015f 00       		.byte	0
 8903 0160 00       		.byte	0
 8904 0161 1C       		.uleb128 0x1c
 8905 0162 34       		.uleb128 0x34
 8906 0163 00       		.byte	0
 8907 0164 03       		.uleb128 0x3
 8908 0165 08       		.uleb128 0x8
 8909 0166 3A       		.uleb128 0x3a
 8910 0167 0B       		.uleb128 0xb
 8911 0168 3B       		.uleb128 0x3b
 8912 0169 05       		.uleb128 0x5
 8913 016a 49       		.uleb128 0x49
 8914 016b 13       		.uleb128 0x13
 8915 016c 02       		.uleb128 0x2
 8916 016d 18       		.uleb128 0x18
 8917 016e 00       		.byte	0
 8918 016f 00       		.byte	0
 8919 0170 1D       		.uleb128 0x1d
 8920 0171 2E       		.uleb128 0x2e
 8921 0172 01       		.byte	0x1
 8922 0173 3F       		.uleb128 0x3f
 8923 0174 19       		.uleb128 0x19
 8924 0175 03       		.uleb128 0x3
 8925 0176 0E       		.uleb128 0xe
 8926 0177 3A       		.uleb128 0x3a
 8927 0178 0B       		.uleb128 0xb
 8928 0179 3B       		.uleb128 0x3b
 8929 017a 05       		.uleb128 0x5
 8930 017b 27       		.uleb128 0x27
 8931 017c 19       		.uleb128 0x19
 8932 017d 11       		.uleb128 0x11
 8933 017e 01       		.uleb128 0x1
 8934 017f 12       		.uleb128 0x12
 8935 0180 06       		.uleb128 0x6
 8936 0181 40       		.uleb128 0x40
 8937 0182 18       		.uleb128 0x18
 8938 0183 9642     		.uleb128 0x2116
 8939 0185 19       		.uleb128 0x19
 8940 0186 01       		.uleb128 0x1
 8941 0187 13       		.uleb128 0x13
 8942 0188 00       		.byte	0
 8943 0189 00       		.byte	0
 8944 018a 1E       		.uleb128 0x1e
 8945 018b 2E       		.uleb128 0x2e
 8946 018c 01       		.byte	0x1
 8947 018d 3F       		.uleb128 0x3f
 8948 018e 19       		.uleb128 0x19
 8949 018f 03       		.uleb128 0x3
 8950 0190 0E       		.uleb128 0xe
 8951 0191 3A       		.uleb128 0x3a
 8952 0192 0B       		.uleb128 0xb
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 256
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 256
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 8953 0193 3B       		.uleb128 0x3b
 8954 0194 05       		.uleb128 0x5
 8955 0195 27       		.uleb128 0x27
 8956 0196 19       		.uleb128 0x19
 8957 0197 49       		.uleb128 0x49
 8958 0198 13       		.uleb128 0x13
 8959 0199 11       		.uleb128 0x11
 8960 019a 01       		.uleb128 0x1
 8961 019b 12       		.uleb128 0x12
 8962 019c 06       		.uleb128 0x6
 8963 019d 40       		.uleb128 0x40
 8964 019e 18       		.uleb128 0x18
 8965 019f 9742     		.uleb128 0x2117
 8966 01a1 19       		.uleb128 0x19
 8967 01a2 01       		.uleb128 0x1
 8968 01a3 13       		.uleb128 0x13
 8969 01a4 00       		.byte	0
 8970 01a5 00       		.byte	0
 8971 01a6 1F       		.uleb128 0x1f
 8972 01a7 1D       		.uleb128 0x1d
 8973 01a8 01       		.byte	0x1
 8974 01a9 31       		.uleb128 0x31
 8975 01aa 13       		.uleb128 0x13
 8976 01ab 11       		.uleb128 0x11
 8977 01ac 01       		.uleb128 0x1
 8978 01ad 12       		.uleb128 0x12
 8979 01ae 06       		.uleb128 0x6
 8980 01af 58       		.uleb128 0x58
 8981 01b0 0B       		.uleb128 0xb
 8982 01b1 59       		.uleb128 0x59
 8983 01b2 05       		.uleb128 0x5
 8984 01b3 01       		.uleb128 0x1
 8985 01b4 13       		.uleb128 0x13
 8986 01b5 00       		.byte	0
 8987 01b6 00       		.byte	0
 8988 01b7 20       		.uleb128 0x20
 8989 01b8 34       		.uleb128 0x34
 8990 01b9 00       		.byte	0
 8991 01ba 31       		.uleb128 0x31
 8992 01bb 13       		.uleb128 0x13
 8993 01bc 02       		.uleb128 0x2
 8994 01bd 18       		.uleb128 0x18
 8995 01be 00       		.byte	0
 8996 01bf 00       		.byte	0
 8997 01c0 21       		.uleb128 0x21
 8998 01c1 1D       		.uleb128 0x1d
 8999 01c2 01       		.byte	0x1
 9000 01c3 31       		.uleb128 0x31
 9001 01c4 13       		.uleb128 0x13
 9002 01c5 11       		.uleb128 0x11
 9003 01c6 01       		.uleb128 0x1
 9004 01c7 12       		.uleb128 0x12
 9005 01c8 06       		.uleb128 0x6
 9006 01c9 58       		.uleb128 0x58
 9007 01ca 0B       		.uleb128 0xb
 9008 01cb 59       		.uleb128 0x59
 9009 01cc 05       		.uleb128 0x5
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 257
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 257
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 9010 01cd 00       		.byte	0
 9011 01ce 00       		.byte	0
 9012 01cf 22       		.uleb128 0x22
 9013 01d0 05       		.uleb128 0x5
 9014 01d1 00       		.byte	0
 9015 01d2 31       		.uleb128 0x31
 9016 01d3 13       		.uleb128 0x13
 9017 01d4 02       		.uleb128 0x2
 9018 01d5 18       		.uleb128 0x18
 9019 01d6 00       		.byte	0
 9020 01d7 00       		.byte	0
 9021 01d8 23       		.uleb128 0x23
 9022 01d9 2E       		.uleb128 0x2e
 9023 01da 01       		.byte	0x1
 9024 01db 03       		.uleb128 0x3
 9025 01dc 0E       		.uleb128 0xe
 9026 01dd 3A       		.uleb128 0x3a
 9027 01de 0B       		.uleb128 0xb
 9028 01df 3B       		.uleb128 0x3b
 9029 01e0 05       		.uleb128 0x5
 9030 01e1 27       		.uleb128 0x27
 9031 01e2 19       		.uleb128 0x19
 9032 01e3 49       		.uleb128 0x49
 9033 01e4 13       		.uleb128 0x13
 9034 01e5 11       		.uleb128 0x11
 9035 01e6 01       		.uleb128 0x1
 9036 01e7 12       		.uleb128 0x12
 9037 01e8 06       		.uleb128 0x6
 9038 01e9 40       		.uleb128 0x40
 9039 01ea 18       		.uleb128 0x18
 9040 01eb 9742     		.uleb128 0x2117
 9041 01ed 19       		.uleb128 0x19
 9042 01ee 01       		.uleb128 0x1
 9043 01ef 13       		.uleb128 0x13
 9044 01f0 00       		.byte	0
 9045 01f1 00       		.byte	0
 9046 01f2 24       		.uleb128 0x24
 9047 01f3 2E       		.uleb128 0x2e
 9048 01f4 00       		.byte	0
 9049 01f5 3F       		.uleb128 0x3f
 9050 01f6 19       		.uleb128 0x19
 9051 01f7 03       		.uleb128 0x3
 9052 01f8 0E       		.uleb128 0xe
 9053 01f9 3A       		.uleb128 0x3a
 9054 01fa 0B       		.uleb128 0xb
 9055 01fb 3B       		.uleb128 0x3b
 9056 01fc 05       		.uleb128 0x5
 9057 01fd 27       		.uleb128 0x27
 9058 01fe 19       		.uleb128 0x19
 9059 01ff 11       		.uleb128 0x11
 9060 0200 01       		.uleb128 0x1
 9061 0201 12       		.uleb128 0x12
 9062 0202 06       		.uleb128 0x6
 9063 0203 40       		.uleb128 0x40
 9064 0204 18       		.uleb128 0x18
 9065 0205 9742     		.uleb128 0x2117
 9066 0207 19       		.uleb128 0x19
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 258
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 258
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 9067 0208 00       		.byte	0
 9068 0209 00       		.byte	0
 9069 020a 25       		.uleb128 0x25
 9070 020b 2E       		.uleb128 0x2e
 9071 020c 00       		.byte	0
 9072 020d 3F       		.uleb128 0x3f
 9073 020e 19       		.uleb128 0x19
 9074 020f 03       		.uleb128 0x3
 9075 0210 0E       		.uleb128 0xe
 9076 0211 3A       		.uleb128 0x3a
 9077 0212 0B       		.uleb128 0xb
 9078 0213 3B       		.uleb128 0x3b
 9079 0214 05       		.uleb128 0x5
 9080 0215 27       		.uleb128 0x27
 9081 0216 19       		.uleb128 0x19
 9082 0217 49       		.uleb128 0x49
 9083 0218 13       		.uleb128 0x13
 9084 0219 11       		.uleb128 0x11
 9085 021a 01       		.uleb128 0x1
 9086 021b 12       		.uleb128 0x12
 9087 021c 06       		.uleb128 0x6
 9088 021d 40       		.uleb128 0x40
 9089 021e 18       		.uleb128 0x18
 9090 021f 9742     		.uleb128 0x2117
 9091 0221 19       		.uleb128 0x19
 9092 0222 00       		.byte	0
 9093 0223 00       		.byte	0
 9094 0224 26       		.uleb128 0x26
 9095 0225 0B       		.uleb128 0xb
 9096 0226 01       		.byte	0x1
 9097 0227 11       		.uleb128 0x11
 9098 0228 01       		.uleb128 0x1
 9099 0229 12       		.uleb128 0x12
 9100 022a 06       		.uleb128 0x6
 9101 022b 01       		.uleb128 0x1
 9102 022c 13       		.uleb128 0x13
 9103 022d 00       		.byte	0
 9104 022e 00       		.byte	0
 9105 022f 27       		.uleb128 0x27
 9106 0230 2E       		.uleb128 0x2e
 9107 0231 01       		.byte	0x1
 9108 0232 3F       		.uleb128 0x3f
 9109 0233 19       		.uleb128 0x19
 9110 0234 03       		.uleb128 0x3
 9111 0235 0E       		.uleb128 0xe
 9112 0236 3A       		.uleb128 0x3a
 9113 0237 0B       		.uleb128 0xb
 9114 0238 3B       		.uleb128 0x3b
 9115 0239 05       		.uleb128 0x5
 9116 023a 27       		.uleb128 0x27
 9117 023b 19       		.uleb128 0x19
 9118 023c 11       		.uleb128 0x11
 9119 023d 01       		.uleb128 0x1
 9120 023e 12       		.uleb128 0x12
 9121 023f 06       		.uleb128 0x6
 9122 0240 40       		.uleb128 0x40
 9123 0241 18       		.uleb128 0x18
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 259
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 259
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 9124 0242 9742     		.uleb128 0x2117
 9125 0244 19       		.uleb128 0x19
 9126 0245 01       		.uleb128 0x1
 9127 0246 13       		.uleb128 0x13
 9128 0247 00       		.byte	0
 9129 0248 00       		.byte	0
 9130 0249 28       		.uleb128 0x28
 9131 024a 2E       		.uleb128 0x2e
 9132 024b 01       		.byte	0x1
 9133 024c 03       		.uleb128 0x3
 9134 024d 0E       		.uleb128 0xe
 9135 024e 3A       		.uleb128 0x3a
 9136 024f 0B       		.uleb128 0xb
 9137 0250 3B       		.uleb128 0x3b
 9138 0251 05       		.uleb128 0x5
 9139 0252 27       		.uleb128 0x27
 9140 0253 19       		.uleb128 0x19
 9141 0254 11       		.uleb128 0x11
 9142 0255 01       		.uleb128 0x1
 9143 0256 12       		.uleb128 0x12
 9144 0257 06       		.uleb128 0x6
 9145 0258 40       		.uleb128 0x40
 9146 0259 18       		.uleb128 0x18
 9147 025a 9742     		.uleb128 0x2117
 9148 025c 19       		.uleb128 0x19
 9149 025d 01       		.uleb128 0x1
 9150 025e 13       		.uleb128 0x13
 9151 025f 00       		.byte	0
 9152 0260 00       		.byte	0
 9153 0261 29       		.uleb128 0x29
 9154 0262 34       		.uleb128 0x34
 9155 0263 00       		.byte	0
 9156 0264 03       		.uleb128 0x3
 9157 0265 0E       		.uleb128 0xe
 9158 0266 3A       		.uleb128 0x3a
 9159 0267 0B       		.uleb128 0xb
 9160 0268 3B       		.uleb128 0x3b
 9161 0269 0B       		.uleb128 0xb
 9162 026a 49       		.uleb128 0x49
 9163 026b 13       		.uleb128 0x13
 9164 026c 3F       		.uleb128 0x3f
 9165 026d 19       		.uleb128 0x19
 9166 026e 02       		.uleb128 0x2
 9167 026f 18       		.uleb128 0x18
 9168 0270 00       		.byte	0
 9169 0271 00       		.byte	0
 9170 0272 2A       		.uleb128 0x2a
 9171 0273 34       		.uleb128 0x34
 9172 0274 00       		.byte	0
 9173 0275 03       		.uleb128 0x3
 9174 0276 0E       		.uleb128 0xe
 9175 0277 3A       		.uleb128 0x3a
 9176 0278 0B       		.uleb128 0xb
 9177 0279 3B       		.uleb128 0x3b
 9178 027a 05       		.uleb128 0x5
 9179 027b 49       		.uleb128 0x49
 9180 027c 13       		.uleb128 0x13
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 260
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 260
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 9181 027d 3F       		.uleb128 0x3f
 9182 027e 19       		.uleb128 0x19
 9183 027f 3C       		.uleb128 0x3c
 9184 0280 19       		.uleb128 0x19
 9185 0281 00       		.byte	0
 9186 0282 00       		.byte	0
 9187 0283 2B       		.uleb128 0x2b
 9188 0284 34       		.uleb128 0x34
 9189 0285 00       		.byte	0
 9190 0286 03       		.uleb128 0x3
 9191 0287 0E       		.uleb128 0xe
 9192 0288 3A       		.uleb128 0x3a
 9193 0289 0B       		.uleb128 0xb
 9194 028a 3B       		.uleb128 0x3b
 9195 028b 05       		.uleb128 0x5
 9196 028c 49       		.uleb128 0x49
 9197 028d 13       		.uleb128 0x13
 9198 028e 3F       		.uleb128 0x3f
 9199 028f 19       		.uleb128 0x19
 9200 0290 02       		.uleb128 0x2
 9201 0291 18       		.uleb128 0x18
 9202 0292 00       		.byte	0
 9203 0293 00       		.byte	0
 9204 0294 00       		.byte	0
 9205              		.section	.debug_aranges,"",%progbits
 9206 0000 C4010000 		.4byte	0x1c4
 9207 0004 0200     		.2byte	0x2
 9208 0006 00000000 		.4byte	.Ldebug_info0
 9209 000a 04       		.byte	0x4
 9210 000b 00       		.byte	0
 9211 000c 0000     		.2byte	0
 9212 000e 0000     		.2byte	0
 9213 0010 00000000 		.4byte	.LFB68
 9214 0014 82000000 		.4byte	.LFE68-.LFB68
 9215 0018 00000000 		.4byte	.LFB69
 9216 001c FE000000 		.4byte	.LFE69-.LFB69
 9217 0020 00000000 		.4byte	.LFB70
 9218 0024 D4000000 		.4byte	.LFE70-.LFB70
 9219 0028 00000000 		.4byte	.LFB71
 9220 002c FC000000 		.4byte	.LFE71-.LFB71
 9221 0030 00000000 		.4byte	.LFB72
 9222 0034 A0000000 		.4byte	.LFE72-.LFB72
 9223 0038 00000000 		.4byte	.LFB73
 9224 003c 48000000 		.4byte	.LFE73-.LFB73
 9225 0040 00000000 		.4byte	.LFB74
 9226 0044 B0000000 		.4byte	.LFE74-.LFB74
 9227 0048 00000000 		.4byte	.LFB75
 9228 004c 34000000 		.4byte	.LFE75-.LFB75
 9229 0050 00000000 		.4byte	.LFB76
 9230 0054 54000000 		.4byte	.LFE76-.LFB76
 9231 0058 00000000 		.4byte	.LFB77
 9232 005c 38010000 		.4byte	.LFE77-.LFB77
 9233 0060 00000000 		.4byte	.LFB78
 9234 0064 04010000 		.4byte	.LFE78-.LFB78
 9235 0068 00000000 		.4byte	.LFB79
 9236 006c 44000000 		.4byte	.LFE79-.LFB79
 9237 0070 00000000 		.4byte	.LFB80
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 261
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 261
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 9238 0074 A0000000 		.4byte	.LFE80-.LFB80
 9239 0078 00000000 		.4byte	.LFB81
 9240 007c C0000000 		.4byte	.LFE81-.LFB81
 9241 0080 00000000 		.4byte	.LFB82
 9242 0084 6C000000 		.4byte	.LFE82-.LFB82
 9243 0088 00000000 		.4byte	.LFB83
 9244 008c 30000000 		.4byte	.LFE83-.LFB83
 9245 0090 00000000 		.4byte	.LFB84
 9246 0094 1C000000 		.4byte	.LFE84-.LFB84
 9247 0098 00000000 		.4byte	.LFB85
 9248 009c 1C010000 		.4byte	.LFE85-.LFB85
 9249 00a0 00000000 		.4byte	.LFB86
 9250 00a4 1C000000 		.4byte	.LFE86-.LFB86
 9251 00a8 00000000 		.4byte	.LFB87
 9252 00ac 20000000 		.4byte	.LFE87-.LFB87
 9253 00b0 00000000 		.4byte	.LFB88
 9254 00b4 14000000 		.4byte	.LFE88-.LFB88
 9255 00b8 00000000 		.4byte	.LFB89
 9256 00bc 2C000000 		.4byte	.LFE89-.LFB89
 9257 00c0 00000000 		.4byte	.LFB90
 9258 00c4 30000000 		.4byte	.LFE90-.LFB90
 9259 00c8 00000000 		.4byte	.LFB91
 9260 00cc 50010000 		.4byte	.LFE91-.LFB91
 9261 00d0 00000000 		.4byte	.LFB92
 9262 00d4 D8000000 		.4byte	.LFE92-.LFB92
 9263 00d8 00000000 		.4byte	.LFB93
 9264 00dc 2C000000 		.4byte	.LFE93-.LFB93
 9265 00e0 00000000 		.4byte	.LFB94
 9266 00e4 3C000000 		.4byte	.LFE94-.LFB94
 9267 00e8 00000000 		.4byte	.LFB95
 9268 00ec A8000000 		.4byte	.LFE95-.LFB95
 9269 00f0 00000000 		.4byte	.LFB96
 9270 00f4 84000000 		.4byte	.LFE96-.LFB96
 9271 00f8 00000000 		.4byte	.LFB97
 9272 00fc 30000000 		.4byte	.LFE97-.LFB97
 9273 0100 00000000 		.4byte	.LFB98
 9274 0104 2C000000 		.4byte	.LFE98-.LFB98
 9275 0108 00000000 		.4byte	.LFB99
 9276 010c 8C000000 		.4byte	.LFE99-.LFB99
 9277 0110 00000000 		.4byte	.LFB100
 9278 0114 18000000 		.4byte	.LFE100-.LFB100
 9279 0118 00000000 		.4byte	.LFB101
 9280 011c 0E000000 		.4byte	.LFE101-.LFB101
 9281 0120 00000000 		.4byte	.LFB102
 9282 0124 80000000 		.4byte	.LFE102-.LFB102
 9283 0128 00000000 		.4byte	.LFB103
 9284 012c 58000000 		.4byte	.LFE103-.LFB103
 9285 0130 00000000 		.4byte	.LFB104
 9286 0134 36000000 		.4byte	.LFE104-.LFB104
 9287 0138 00000000 		.4byte	.LFB105
 9288 013c 38000000 		.4byte	.LFE105-.LFB105
 9289 0140 00000000 		.4byte	.LFB106
 9290 0144 20000000 		.4byte	.LFE106-.LFB106
 9291 0148 00000000 		.4byte	.LFB107
 9292 014c 40000000 		.4byte	.LFE107-.LFB107
 9293 0150 00000000 		.4byte	.LFB108
 9294 0154 1C000000 		.4byte	.LFE108-.LFB108
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 262
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 262
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 9295 0158 00000000 		.4byte	.LFB109
 9296 015c EC000000 		.4byte	.LFE109-.LFB109
 9297 0160 00000000 		.4byte	.LFB110
 9298 0164 C8000000 		.4byte	.LFE110-.LFB110
 9299 0168 00000000 		.4byte	.LFB111
 9300 016c DC000000 		.4byte	.LFE111-.LFB111
 9301 0170 00000000 		.4byte	.LFB112
 9302 0174 30000000 		.4byte	.LFE112-.LFB112
 9303 0178 00000000 		.4byte	.LFB113
 9304 017c 28000000 		.4byte	.LFE113-.LFB113
 9305 0180 00000000 		.4byte	.LFB114
 9306 0184 90000000 		.4byte	.LFE114-.LFB114
 9307 0188 00000000 		.4byte	.LFB115
 9308 018c B4000000 		.4byte	.LFE115-.LFB115
 9309 0190 00000000 		.4byte	.LFB116
 9310 0194 10010000 		.4byte	.LFE116-.LFB116
 9311 0198 00000000 		.4byte	.LFB117
 9312 019c 4C010000 		.4byte	.LFE117-.LFB117
 9313 01a0 00000000 		.4byte	.LFB118
 9314 01a4 E4000000 		.4byte	.LFE118-.LFB118
 9315 01a8 00000000 		.4byte	.LFB119
 9316 01ac 4C000000 		.4byte	.LFE119-.LFB119
 9317 01b0 00000000 		.4byte	.LFB120
 9318 01b4 48000000 		.4byte	.LFE120-.LFB120
 9319 01b8 00000000 		.4byte	.LFB121
 9320 01bc CC000000 		.4byte	.LFE121-.LFB121
 9321 01c0 00000000 		.4byte	0
 9322 01c4 00000000 		.4byte	0
 9323              		.section	.debug_ranges,"",%progbits
 9324              	.Ldebug_ranges0:
 9325 0000 00000000 		.4byte	.LFB68
 9326 0004 82000000 		.4byte	.LFE68
 9327 0008 00000000 		.4byte	.LFB69
 9328 000c FE000000 		.4byte	.LFE69
 9329 0010 00000000 		.4byte	.LFB70
 9330 0014 D4000000 		.4byte	.LFE70
 9331 0018 00000000 		.4byte	.LFB71
 9332 001c FC000000 		.4byte	.LFE71
 9333 0020 00000000 		.4byte	.LFB72
 9334 0024 A0000000 		.4byte	.LFE72
 9335 0028 00000000 		.4byte	.LFB73
 9336 002c 48000000 		.4byte	.LFE73
 9337 0030 00000000 		.4byte	.LFB74
 9338 0034 B0000000 		.4byte	.LFE74
 9339 0038 00000000 		.4byte	.LFB75
 9340 003c 34000000 		.4byte	.LFE75
 9341 0040 00000000 		.4byte	.LFB76
 9342 0044 54000000 		.4byte	.LFE76
 9343 0048 00000000 		.4byte	.LFB77
 9344 004c 38010000 		.4byte	.LFE77
 9345 0050 00000000 		.4byte	.LFB78
 9346 0054 04010000 		.4byte	.LFE78
 9347 0058 00000000 		.4byte	.LFB79
 9348 005c 44000000 		.4byte	.LFE79
 9349 0060 00000000 		.4byte	.LFB80
 9350 0064 A0000000 		.4byte	.LFE80
 9351 0068 00000000 		.4byte	.LFB81
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 263
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 263
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 9352 006c C0000000 		.4byte	.LFE81
 9353 0070 00000000 		.4byte	.LFB82
 9354 0074 6C000000 		.4byte	.LFE82
 9355 0078 00000000 		.4byte	.LFB83
 9356 007c 30000000 		.4byte	.LFE83
 9357 0080 00000000 		.4byte	.LFB84
 9358 0084 1C000000 		.4byte	.LFE84
 9359 0088 00000000 		.4byte	.LFB85
 9360 008c 1C010000 		.4byte	.LFE85
 9361 0090 00000000 		.4byte	.LFB86
 9362 0094 1C000000 		.4byte	.LFE86
 9363 0098 00000000 		.4byte	.LFB87
 9364 009c 20000000 		.4byte	.LFE87
 9365 00a0 00000000 		.4byte	.LFB88
 9366 00a4 14000000 		.4byte	.LFE88
 9367 00a8 00000000 		.4byte	.LFB89
 9368 00ac 2C000000 		.4byte	.LFE89
 9369 00b0 00000000 		.4byte	.LFB90
 9370 00b4 30000000 		.4byte	.LFE90
 9371 00b8 00000000 		.4byte	.LFB91
 9372 00bc 50010000 		.4byte	.LFE91
 9373 00c0 00000000 		.4byte	.LFB92
 9374 00c4 D8000000 		.4byte	.LFE92
 9375 00c8 00000000 		.4byte	.LFB93
 9376 00cc 2C000000 		.4byte	.LFE93
 9377 00d0 00000000 		.4byte	.LFB94
 9378 00d4 3C000000 		.4byte	.LFE94
 9379 00d8 00000000 		.4byte	.LFB95
 9380 00dc A8000000 		.4byte	.LFE95
 9381 00e0 00000000 		.4byte	.LFB96
 9382 00e4 84000000 		.4byte	.LFE96
 9383 00e8 00000000 		.4byte	.LFB97
 9384 00ec 30000000 		.4byte	.LFE97
 9385 00f0 00000000 		.4byte	.LFB98
 9386 00f4 2C000000 		.4byte	.LFE98
 9387 00f8 00000000 		.4byte	.LFB99
 9388 00fc 8C000000 		.4byte	.LFE99
 9389 0100 00000000 		.4byte	.LFB100
 9390 0104 18000000 		.4byte	.LFE100
 9391 0108 00000000 		.4byte	.LFB101
 9392 010c 0E000000 		.4byte	.LFE101
 9393 0110 00000000 		.4byte	.LFB102
 9394 0114 80000000 		.4byte	.LFE102
 9395 0118 00000000 		.4byte	.LFB103
 9396 011c 58000000 		.4byte	.LFE103
 9397 0120 00000000 		.4byte	.LFB104
 9398 0124 36000000 		.4byte	.LFE104
 9399 0128 00000000 		.4byte	.LFB105
 9400 012c 38000000 		.4byte	.LFE105
 9401 0130 00000000 		.4byte	.LFB106
 9402 0134 20000000 		.4byte	.LFE106
 9403 0138 00000000 		.4byte	.LFB107
 9404 013c 40000000 		.4byte	.LFE107
 9405 0140 00000000 		.4byte	.LFB108
 9406 0144 1C000000 		.4byte	.LFE108
 9407 0148 00000000 		.4byte	.LFB109
 9408 014c EC000000 		.4byte	.LFE109
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 264
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 264
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 9409 0150 00000000 		.4byte	.LFB110
 9410 0154 C8000000 		.4byte	.LFE110
 9411 0158 00000000 		.4byte	.LFB111
 9412 015c DC000000 		.4byte	.LFE111
 9413 0160 00000000 		.4byte	.LFB112
 9414 0164 30000000 		.4byte	.LFE112
 9415 0168 00000000 		.4byte	.LFB113
 9416 016c 28000000 		.4byte	.LFE113
 9417 0170 00000000 		.4byte	.LFB114
 9418 0174 90000000 		.4byte	.LFE114
 9419 0178 00000000 		.4byte	.LFB115
 9420 017c B4000000 		.4byte	.LFE115
 9421 0180 00000000 		.4byte	.LFB116
 9422 0184 10010000 		.4byte	.LFE116
 9423 0188 00000000 		.4byte	.LFB117
 9424 018c 4C010000 		.4byte	.LFE117
 9425 0190 00000000 		.4byte	.LFB118
 9426 0194 E4000000 		.4byte	.LFE118
 9427 0198 00000000 		.4byte	.LFB119
 9428 019c 4C000000 		.4byte	.LFE119
 9429 01a0 00000000 		.4byte	.LFB120
 9430 01a4 48000000 		.4byte	.LFE120
 9431 01a8 00000000 		.4byte	.LFB121
 9432 01ac CC000000 		.4byte	.LFE121
 9433 01b0 00000000 		.4byte	0
 9434 01b4 00000000 		.4byte	0
 9435              		.section	.debug_line,"",%progbits
 9436              	.Ldebug_line0:
 9437 0000 E90A0000 		.section	.debug_str,"MS",%progbits,1
 9437      02004202 
 9437      00000201 
 9437      FB0E0D00 
 9437      01010101 
 9438              	.LASF62:
 9439 0000 65537573 		.ascii	"eSuspended\000"
 9439      70656E64 
 9439      656400
 9440              	.LASF215:
 9441 000b 7843616E 		.ascii	"xCanBlockIndefinitely\000"
 9441      426C6F63 
 9441      6B496E64 
 9441      6566696E 
 9441      6974656C 
 9442              	.LASF91:
 9443 0021 75635265 		.ascii	"ucReturn\000"
 9443      7475726E 
 9443      00
 9444              	.LASF83:
 9445 002a 756C4F72 		.ascii	"ulOriginalBASEPRI\000"
 9445      6967696E 
 9445      616C4241 
 9445      53455052 
 9445      4900
 9446              	.LASF142:
 9447 003c 78546963 		.ascii	"xTicks\000"
 9447      6B7300
 9448              	.LASF131:
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 265
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 265
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 9449 0043 76546173 		.ascii	"vTaskSuspend\000"
 9449      6B537573 
 9449      70656E64 
 9449      00
 9450              	.LASF4:
 9451 0050 73697A65 		.ascii	"size_t\000"
 9451      5F7400
 9452              	.LASF45:
 9453 0057 4D696E69 		.ascii	"MiniListItem_t\000"
 9453      4C697374 
 9453      4974656D 
 9453      5F7400
 9454              	.LASF75:
 9455 0066 54696D65 		.ascii	"TimeOut_t\000"
 9455      4F75745F 
 9455      7400
 9456              	.LASF225:
 9457 0070 75784375 		.ascii	"uxCurrentNumberOfTasks\000"
 9457      7272656E 
 9457      744E756D 
 9457      6265724F 
 9457      66546173 
 9458              	.LASF204:
 9459 0087 756C5661 		.ascii	"ulValue\000"
 9459      6C756500 
 9460              	.LASF192:
 9461 008f 75785461 		.ascii	"uxTaskResetEventItemValue\000"
 9461      736B5265 
 9461      73657445 
 9461      76656E74 
 9461      4974656D 
 9462              	.LASF230:
 9463 00a9 78596965 		.ascii	"xYieldPending\000"
 9463      6C645065 
 9463      6E64696E 
 9463      6700
 9464              	.LASF5:
 9465 00b7 5F5F7569 		.ascii	"__uint8_t\000"
 9465      6E74385F 
 9465      7400
 9466              	.LASF77:
 9467 00c1 70764261 		.ascii	"pvBaseAddress\000"
 9467      73654164 
 9467      64726573 
 9467      7300
 9468              	.LASF224:
 9469 00cf 78537573 		.ascii	"xSuspendedTaskList\000"
 9469      70656E64 
 9469      65645461 
 9469      736B4C69 
 9469      737400
 9470              	.LASF113:
 9471 00e2 76546173 		.ascii	"vTaskDelay\000"
 9471      6B44656C 
 9471      617900
 9472              	.LASF240:
 9473 00ed 474E5520 		.ascii	"GNU C11 5.4.1 20160609 (release) [ARM/embedded-5-br"
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 266
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 266
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 9473      43313120 
 9473      352E342E 
 9473      31203230 
 9473      31363036 
 9474 0120 616E6368 		.ascii	"anch revision 237715] -mcpu=cortex-m3 -mthumb -g -O"
 9474      20726576 
 9474      6973696F 
 9474      6E203233 
 9474      37373135 
 9475 0153 30202D66 		.ascii	"0 -ffunction-sections -ffat-lto-objects\000"
 9475      66756E63 
 9475      74696F6E 
 9475      2D736563 
 9475      74696F6E 
 9476              	.LASF211:
 9477 017b 78546173 		.ascii	"xTaskNotifyStateClear\000"
 9477      6B4E6F74 
 9477      69667953 
 9477      74617465 
 9477      436C6561 
 9478              	.LASF84:
 9479 0191 756C4E65 		.ascii	"ulNewBASEPRI\000"
 9479      77424153 
 9479      45505249 
 9479      00
 9480              	.LASF61:
 9481 019e 65426C6F 		.ascii	"eBlocked\000"
 9481      636B6564 
 9481      00
 9482              	.LASF109:
 9483 01a7 7854696D 		.ascii	"xTimeToWake\000"
 9483      65546F57 
 9483      616B6500 
 9484              	.LASF110:
 9485 01b3 78416C72 		.ascii	"xAlreadyYielded\000"
 9485      65616479 
 9485      5969656C 
 9485      64656400 
 9486              	.LASF165:
 9487 01c3 70785469 		.ascii	"pxTimeOut\000"
 9487      6D654F75 
 9487      7400
 9488              	.LASF42:
 9489 01cd 784C6973 		.ascii	"xListEnd\000"
 9489      74456E64 
 9489      00
 9490              	.LASF238:
 9491 01d6 49544D5F 		.ascii	"ITM_RxBuffer\000"
 9491      52784275 
 9491      66666572 
 9491      00
 9492              	.LASF72:
 9493 01e3 7854494D 		.ascii	"xTIME_OUT\000"
 9493      455F4F55 
 9493      5400
 9494              	.LASF44:
 9495 01ed 784D494E 		.ascii	"xMINI_LIST_ITEM\000"
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 267
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 267
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 9495      495F4C49 
 9495      53545F49 
 9495      54454D00 
 9496              	.LASF186:
 9497 01fd 70784D75 		.ascii	"pxMutexHolderTCB\000"
 9497      74657848 
 9497      6F6C6465 
 9497      72544342 
 9497      00
 9498              	.LASF1:
 9499 020e 6C6F6E67 		.ascii	"long long int\000"
 9499      206C6F6E 
 9499      6720696E 
 9499      7400
 9500              	.LASF3:
 9501 021c 7369676E 		.ascii	"signed char\000"
 9501      65642063 
 9501      68617200 
 9502              	.LASF129:
 9503 0228 75785072 		.ascii	"uxPriorityUsedOnEntry\000"
 9503      696F7269 
 9503      74795573 
 9503      65644F6E 
 9503      456E7472 
 9504              	.LASF158:
 9505 023e 78546963 		.ascii	"xTicksToWait\000"
 9505      6B73546F 
 9505      57616974 
 9505      00
 9506              	.LASF233:
 9507 024b 784E6578 		.ascii	"xNextTaskUnblockTime\000"
 9507      74546173 
 9507      6B556E62 
 9507      6C6F636B 
 9507      54696D65 
 9508              	.LASF196:
 9509 0260 78436C65 		.ascii	"xClearCountOnExit\000"
 9509      6172436F 
 9509      756E744F 
 9509      6E457869 
 9509      7400
 9510              	.LASF14:
 9511 0272 6C6F6E67 		.ascii	"long long unsigned int\000"
 9511      206C6F6E 
 9511      6720756E 
 9511      7369676E 
 9511      65642069 
 9512              	.LASF50:
 9513 0289 78537461 		.ascii	"xStateListItem\000"
 9513      74654C69 
 9513      73744974 
 9513      656D00
 9514              	.LASF205:
 9515 0298 65416374 		.ascii	"eAction\000"
 9515      696F6E00 
 9516              	.LASF11:
 9517 02a0 6C6F6E67 		.ascii	"long int\000"
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 268
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 268
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 9517      20696E74 
 9517      00
 9518              	.LASF48:
 9519 02a9 74736B54 		.ascii	"tskTaskControlBlock\000"
 9519      61736B43 
 9519      6F6E7472 
 9519      6F6C426C 
 9519      6F636B00 
 9520              	.LASF222:
 9521 02bd 78546173 		.ascii	"xTasksWaitingTermination\000"
 9521      6B735761 
 9521      6974696E 
 9521      67546572 
 9521      6D696E61 
 9522              	.LASF97:
 9523 02d6 70784E65 		.ascii	"pxNewTCB\000"
 9523      77544342 
 9523      00
 9524              	.LASF67:
 9525 02df 65536574 		.ascii	"eSetBits\000"
 9525      42697473 
 9525      00
 9526              	.LASF213:
 9527 02e8 756C4269 		.ascii	"ulBitsToClear\000"
 9527      7473546F 
 9527      436C6561 
 9527      7200
 9528              	.LASF207:
 9529 02f6 75634F72 		.ascii	"ucOriginalNotifyState\000"
 9529      6967696E 
 9529      616C4E6F 
 9529      74696679 
 9529      53746174 
 9530              	.LASF143:
 9531 030c 78546173 		.ascii	"xTaskGetTickCountFromISR\000"
 9531      6B476574 
 9531      5469636B 
 9531      436F756E 
 9531      7446726F 
 9532              	.LASF47:
 9533 0325 5461736B 		.ascii	"TaskHandle_t\000"
 9533      48616E64 
 9533      6C655F74 
 9533      00
 9534              	.LASF241:
 9535 0332 536F7572 		.ascii	"Source\\tasks.c\000"
 9535      63655C74 
 9535      61736B73 
 9535      2E6300
 9536              	.LASF21:
 9537 0341 75696E74 		.ascii	"uint8\000"
 9537      3800
 9538              	.LASF31:
 9539 0347 5469636B 		.ascii	"TickType_t\000"
 9539      54797065 
 9539      5F7400
 9540              	.LASF7:
<<<<<<< HEAD
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 269
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 269
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 9541 0352 73686F72 		.ascii	"short int\000"
 9541      7420696E 
 9541      7400
 9542              	.LASF80:
 9543 035c 4D656D6F 		.ascii	"MemoryRegion_t\000"
 9543      72795265 
 9543      67696F6E 
 9543      5F7400
<<<<<<< HEAD
 9544              	.LASF242:
 9545 036b 433A5C55 		.ascii	"C:\\Users\\Gusta\\OneDrive\\Dokumenter\\GitHub\\P4_"
 9545      73657273 
 9545      5C477573 
 9545      74615C4F 
 9545      6E654472 
 9546 0398 56657274 		.ascii	"Vertical_farm\\RTOS_TEMPLATE-master\\PlanteModul.cy"
 9546      6963616C 
 9546      5F666172 
 9546      6D5C5254 
 9546      4F535F54 
 9547 03c9 64736E00 		.ascii	"dsn\000"
 9548              	.LASF180:
 9549 03cd 70756345 		.ascii	"pucEndOfStack\000"
 9549      6E644F66 
 9549      53746163 
 9549      6B00
 9550              	.LASF29:
 9551 03db 42617365 		.ascii	"BaseType_t\000"
 9551      54797065 
 9551      5F7400
 9552              	.LASF118:
 9553 03e6 65526574 		.ascii	"eReturn\000"
 9553      75726E00 
 9554              	.LASF149:
 9555 03ee 78537769 		.ascii	"xSwitchRequired\000"
 9555      74636852 
 9555      65717569 
 9555      72656400 
 9556              	.LASF206:
 9557 03fe 70756C50 		.ascii	"pulPreviousNotificationValue\000"
 9557      72657669 
 9557      6F75734E 
 9557      6F746966 
 9557      69636174 
 9558              	.LASF119:
 9559 041b 70785374 		.ascii	"pxStateList\000"
 9559      6174654C 
 9559      69737400 
 9560              	.LASF182:
 9561 0427 70727652 		.ascii	"prvResetNextTaskUnblockTime\000"
 9561      65736574 
 9561      4E657874 
 9561      5461736B 
 9561      556E626C 
 9562              	.LASF8:
 9563 0443 5F5F7569 		.ascii	"__uint16_t\000"
 9563      6E743136 
 9563      5F7400
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 270


 9564              	.LASF94:
 9565 044e 75735374 		.ascii	"usStackDepth\000"
 9565      61636B44 
 9565      65707468 
=======
 9544              	.LASF18:
 9545 036b 75696E74 		.ascii	"uint16_t\000"
 9545      31365F74 
 9545      00
 9546              	.LASF180:
 9547 0374 70756345 		.ascii	"pucEndOfStack\000"
 9547      6E644F66 
 9547      53746163 
 9547      6B00
 9548              	.LASF29:
 9549 0382 42617365 		.ascii	"BaseType_t\000"
 9549      54797065 
 9549      5F7400
 9550              	.LASF118:
 9551 038d 65526574 		.ascii	"eReturn\000"
 9551      75726E00 
 9552              	.LASF149:
 9553 0395 78537769 		.ascii	"xSwitchRequired\000"
 9553      74636852 
 9553      65717569 
 9553      72656400 
 9554              	.LASF206:
 9555 03a5 70756C50 		.ascii	"pulPreviousNotificationValue\000"
 9555      72657669 
 9555      6F75734E 
 9555      6F746966 
 9555      69636174 
 9556              	.LASF119:
 9557 03c2 70785374 		.ascii	"pxStateList\000"
 9557      6174654C 
 9557      69737400 
 9558              	.LASF182:
 9559 03ce 70727652 		.ascii	"prvResetNextTaskUnblockTime\000"
 9559      65736574 
 9559      4E657874 
 9559      5461736B 
 9559      556E626C 
 9560              	.LASF8:
 9561 03ea 5F5F7569 		.ascii	"__uint16_t\000"
 9561      6E743136 
 9561      5F7400
 9562              	.LASF94:
 9563 03f5 75735374 		.ascii	"usStackDepth\000"
 9563      61636B44 
 9563      65707468 
 9563      00
 9564              	.LASF145:
 9565 0402 78546173 		.ascii	"xTaskToQuery\000"
 9565      6B546F51 
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 270


 9565      75657279 
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754
 9565      00
 9566              	.LASF145:
 9567 045b 78546173 		.ascii	"xTaskToQuery\000"
 9567      6B546F51 
 9567      75657279 
 9567      00
<<<<<<< HEAD
 9568              	.LASF126:
 9569 0468 76546173 		.ascii	"vTaskPrioritySet\000"
 9569      6B507269 
 9569      6F726974 
 9569      79536574 
 9569      00
 9570              	.LASF73:
 9571 0479 784F7665 		.ascii	"xOverflowCount\000"
 9571      72666C6F 
 9571      77436F75 
 9571      6E7400
 9572              	.LASF137:
 9573 0488 76546173 		.ascii	"vTaskStartScheduler\000"
 9573      6B537461 
 9573      72745363 
 9573      68656475 
 9573      6C657200 
 9574              	.LASF148:
 9575 049c 78546173 		.ascii	"xTaskIncrementTick\000"
 9575      6B496E63 
 9575      72656D65 
 9575      6E745469 
 9575      636B00
 9576              	.LASF208:
 9577 04af 78546173 		.ascii	"xTaskGenericNotifyFromISR\000"
 9577      6B47656E 
 9577      65726963 
 9577      4E6F7469 
 9577      66794672 
 9578              	.LASF156:
 9579 04c9 76546173 		.ascii	"vTaskPlaceOnEventList\000"
 9579      6B506C61 
 9579      63654F6E 
 9579      4576656E 
 9579      744C6973 
 9580              	.LASF58:
 9581 04df 75634E6F 		.ascii	"ucNotifyState\000"
 9581      74696679 
 9581      53746174 
 9581      6500
 9582              	.LASF12:
 9583 04ed 5F5F7569 		.ascii	"__uint32_t\000"
 9583      6E743332 
 9583      5F7400
 9584              	.LASF235:
 9585 04f8 75785363 		.ascii	"uxSchedulerSuspended\000"
 9585      68656475 
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 271


 9585      6C657253 
 9585      75737065 
 9585      6E646564 
 9586              	.LASF135:
 9587 050d 78546173 		.ascii	"xTaskResumeFromISR\000"
 9587      6B526573 
 9587      756D6546 
 9587      726F6D49 
 9587      535200
 9588              	.LASF0:
 9589 0520 756E7369 		.ascii	"unsigned int\000"
 9589      676E6564 
 9589      20696E74 
 9589      00
 9590              	.LASF98:
 9591 052d 78526574 		.ascii	"xReturn\000"
 9591      75726E00 
 9592              	.LASF112:
 9593 0535 78436F6E 		.ascii	"xConstTickCount\000"
 9593      73745469 
 9593      636B436F 
 9593      756E7400 
 9594              	.LASF146:
 9595 0545 78546173 		.ascii	"xTaskCatchUpTicks\000"
 9595      6B436174 
 9595      63685570 
 9595      5469636B 
 9595      7300
 9596              	.LASF159:
 9597 0557 76546173 		.ascii	"vTaskPlaceOnUnorderedEventList\000"
 9597      6B506C61 
 9597      63654F6E 
 9597      556E6F72 
 9597      64657265 
 9598              	.LASF96:
 9599 0576 70784372 		.ascii	"pxCreatedTask\000"
 9599      65617465 
 9599      64546173 
 9599      6B00
 9600              	.LASF40:
 9601 0584 75784E75 		.ascii	"uxNumberOfItems\000"
 9601      6D626572 
 9601      4F664974 
 9601      656D7300 
 9602              	.LASF13:
 9603 0594 6C6F6E67 		.ascii	"long unsigned int\000"
 9603      20756E73 
 9603      69676E65 
 9603      6420696E 
 9603      7400
 9604              	.LASF60:
 9605 05a6 65526561 		.ascii	"eReady\000"
 9605      647900
 9606              	.LASF203:
 9607 05ad 78546173 		.ascii	"xTaskToNotify\000"
 9607      6B546F4E 
 9607      6F746966 
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 272


 9607      7900
 9608              	.LASF49:
 9609 05bb 7078546F 		.ascii	"pxTopOfStack\000"
 9609      704F6653 
 9609      7461636B 
 9609      00
 9610              	.LASF95:
 9611 05c8 70765061 		.ascii	"pvParameters\000"
 9611      72616D65 
 9611      74657273 
 9611      00
 9612              	.LASF209:
 9613 05d5 70784869 		.ascii	"pxHigherPriorityTaskWoken\000"
 9613      67686572 
 9613      5072696F 
 9613      72697479 
 9613      5461736B 
 9614              	.LASF81:
 9615 05ef 74736B54 		.ascii	"tskTCB\000"
 9615      434200
 9616              	.LASF70:
 9617 05f6 65536574 		.ascii	"eSetValueWithoutOverwrite\000"
 9617      56616C75 
 9617      65576974 
 9617      686F7574 
 9617      4F766572 
 9618              	.LASF155:
 9619 0610 7078436F 		.ascii	"pxConstList\000"
 9619      6E73744C 
 9619      69737400 
 9620              	.LASF9:
 9621 061c 73686F72 		.ascii	"short unsigned int\000"
 9621      7420756E 
 9621      7369676E 
 9621      65642069 
 9621      6E7400
 9622              	.LASF28:
 9623 062f 53746163 		.ascii	"StackType_t\000"
 9623      6B547970 
 9623      655F7400 
 9624              	.LASF104:
 9625 063b 70785443 		.ascii	"pxTCB\000"
 9625      4200
 9626              	.LASF130:
 9627 0641 78596965 		.ascii	"xYieldRequired\000"
 9627      6C645265 
 9627      71756972 
 9627      656400
 9628              	.LASF199:
 9629 0650 756C4269 		.ascii	"ulBitsToClearOnEntry\000"
 9629      7473546F 
 9629      436C6561 
 9629      724F6E45 
 9629      6E747279 
 9630              	.LASF229:
 9631 0665 7850656E 		.ascii	"xPendedTicks\000"
 9631      64656454 
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 273


 9631      69636B73 
 9631      00
 9632              	.LASF26:
 9633 0672 70726573 		.ascii	"present\000"
 9633      656E7400 
 9634              	.LASF102:
 9635 067a 70727641 		.ascii	"prvAddNewTaskToReadyList\000"
 9635      64644E65 
 9635      77546173 
 9635      6B546F52 
 9635      65616479 
 9636              	.LASF133:
 9637 0693 76546173 		.ascii	"vTaskResume\000"
 9637      6B526573 
 9637      756D6500 
 9638              	.LASF120:
 9639 069f 70784465 		.ascii	"pxDelayedList\000"
 9639      6C617965 
 9639      644C6973 
 9639      7400
 9640              	.LASF239:
 9641 06ad 70784375 		.ascii	"pxCurrentTCB\000"
 9641      7272656E 
 9641      74544342 
 9641      00
 9642              	.LASF123:
 9643 06ba 75785265 		.ascii	"uxReturn\000"
 9643      7475726E 
 9643      00
 9644              	.LASF18:
 9645 06c3 75696E74 		.ascii	"uint16_t\000"
 9645      31365F74 
 9645      00
 9646              	.LASF219:
 9647 06cc 70784465 		.ascii	"pxDelayedTaskList\000"
 9647      6C617965 
 9647      64546173 
 9647      6B4C6973 
 9647      7400
 9648              	.LASF141:
 9649 06de 78546173 		.ascii	"xTaskGetTickCount\000"
 9649      6B476574 
 9649      5469636B 
 9649      436F756E 
 9649      7400
 9650              	.LASF157:
 9651 06f0 70784576 		.ascii	"pxEventList\000"
 9651      656E744C 
 9651      69737400 
 9652              	.LASF86:
 9653 06fc 76506F72 		.ascii	"vPortRaiseBASEPRI\000"
 9653      74526169 
 9653      73654241 
 9653      53455052 
 9653      4900
 9654              	.LASF46:
 9655 070e 4C697374 		.ascii	"List_t\000"
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 274


 9655      5F7400
 9656              	.LASF212:
 9657 0715 756C5461 		.ascii	"ulTaskNotifyValueClear\000"
 9657      736B4E6F 
 9657      74696679 
 9657      56616C75 
 9657      65436C65 
 9658              	.LASF177:
 9659 072c 70756353 		.ascii	"pucStackByte\000"
 9659      7461636B 
 9659      42797465 
 9659      00
 9660              	.LASF181:
 9661 0739 70727644 		.ascii	"prvDeleteTCB\000"
 9661      656C6574 
 9661      65544342 
 9661      00
 9662              	.LASF172:
 9663 0746 70727649 		.ascii	"prvIdleTask\000"
 9663      646C6554 
 9663      61736B00 
 9664              	.LASF169:
 9665 0752 78456C61 		.ascii	"xElapsedTime\000"
 9665      70736564 
 9665      54696D65 
 9665      00
 9666              	.LASF151:
 9667 075f 76546173 		.ascii	"vTaskSwitchContext\000"
 9667      6B537769 
 9667      74636843 
 9667      6F6E7465 
 9667      787400
 9668              	.LASF68:
 9669 0772 65496E63 		.ascii	"eIncrement\000"
 9669      72656D65 
 9669      6E7400
 9670              	.LASF185:
 9671 077d 70784D75 		.ascii	"pxMutexHolder\000"
 9671      74657848 
 9671      6F6C6465 
 9671      7200
 9672              	.LASF53:
 9673 078b 70785374 		.ascii	"pxStack\000"
 9673      61636B00 
 9674              	.LASF220:
 9675 0793 70784F76 		.ascii	"pxOverflowDelayedTaskList\000"
 9675      6572666C 
 9675      6F774465 
 9675      6C617965 
 9675      64546173 
 9676              	.LASF15:
 9677 07ad 73697A65 		.ascii	"sizetype\000"
 9677      74797065 
 9677      00
 9678              	.LASF189:
 9679 07b6 75784869 		.ascii	"uxHighestPriorityWaitingTask\000"
 9679      67686573 
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 275


 9679      74507269 
 9679      6F726974 
 9679      79576169 
 9680              	.LASF2:
 9681 07d3 6C6F6E67 		.ascii	"long double\000"
 9681      20646F75 
 9681      626C6500 
 9682              	.LASF100:
 9683 07df 78526567 		.ascii	"xRegions\000"
 9683      696F6E73 
 9683      00
 9684              	.LASF210:
 9685 07e8 76546173 		.ascii	"vTaskNotifyGiveFromISR\000"
 9685      6B4E6F74 
 9685      69667947 
 9685      69766546 
 9685      726F6D49 
 9686              	.LASF221:
 9687 07ff 7850656E 		.ascii	"xPendingReadyList\000"
 9687      64696E67 
 9687      52656164 
 9687      794C6973 
 9687      7400
 9688              	.LASF115:
 9689 0811 78546173 		.ascii	"xTaskCreate\000"
 9689      6B437265 
 9689      61746500 
 9690              	.LASF132:
 9691 081d 78546173 		.ascii	"xTaskToSuspend\000"
 9691      6B546F53 
 9691      75737065 
 9691      6E6400
 9692              	.LASF183:
 9693 082c 78546173 		.ascii	"xTaskGetCurrentTaskHandle\000"
 9693      6B476574 
 9693      43757272 
 9693      656E7454 
 9693      61736B48 
 9694              	.LASF92:
 9695 0846 70785461 		.ascii	"pxTaskCode\000"
 9695      736B436F 
 9695      646500
 9696              	.LASF99:
 9697 0851 756C5374 		.ascii	"ulStackDepth\000"
 9697      61636B44 
 9697      65707468 
 9697      00
 9698              	.LASF87:
 9699 085e 756C506F 		.ascii	"ulPortRaiseBASEPRI\000"
 9699      72745261 
 9699      69736542 
 9699      41534550 
 9699      524900
 9700              	.LASF51:
 9701 0871 78457665 		.ascii	"xEventListItem\000"
 9701      6E744C69 
 9701      73744974 
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 276


 9701      656D00
 9702              	.LASF178:
 9703 0880 756C436F 		.ascii	"ulCount\000"
 9703      756E7400 
 9704              	.LASF69:
 9705 0888 65536574 		.ascii	"eSetValueWithOverwrite\000"
 9705      56616C75 
 9705      65576974 
 9705      684F7665 
 9705      72777269 
 9706              	.LASF147:
 9707 089f 78546963 		.ascii	"xTicksToCatchUp\000"
 9707      6B73546F 
 9707      43617463 
 9707      68557000 
 9708              	.LASF227:
 9709 08af 7578546F 		.ascii	"uxTopReadyPriority\000"
 9709      70526561 
 9709      64795072 
 9709      696F7269 
 9709      747900
 9710              	.LASF107:
 9711 08c2 70785072 		.ascii	"pxPreviousWakeTime\000"
 9711      6576696F 
 9711      75735761 
 9711      6B655469 
 9711      6D6500
 9712              	.LASF78:
 9713 08d5 756C4C65 		.ascii	"ulLengthInBytes\000"
 9713      6E677468 
 9713      496E4279 
 9713      74657300 
 9714              	.LASF85:
 9715 08e5 76506F72 		.ascii	"vPortSetBASEPRI\000"
 9715      74536574 
 9715      42415345 
 9715      50524900 
 9716              	.LASF43:
 9717 08f5 4C697374 		.ascii	"ListItem_t\000"
 9717      4974656D 
 9717      5F7400
 9718              	.LASF188:
 9719 0900 76546173 		.ascii	"vTaskPriorityDisinheritAfterTimeout\000"
 9719      6B507269 
 9719      6F726974 
 9719      79446973 
 9719      696E6865 
 9720              	.LASF154:
 9721 0924 7578546F 		.ascii	"uxTopPriority\000"
 9721      70507269 
 9721      6F726974 
 9721      7900
 9722              	.LASF201:
 9723 0932 70756C4E 		.ascii	"pulNotificationValue\000"
 9723      6F746966 
 9723      69636174 
 9723      696F6E56 
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 277


 9723      616C7565 
 9724              	.LASF36:
 9725 0947 70785072 		.ascii	"pxPrevious\000"
 9725      6576696F 
 9725      757300
 9726              	.LASF103:
 9727 0952 78546173 		.ascii	"xTaskToDelete\000"
 9727      6B546F44 
 9727      656C6574 
 9727      6500
 9728              	.LASF127:
 9729 0960 75784E65 		.ascii	"uxNewPriority\000"
 9729      77507269 
 9729      6F726974 
 9729      7900
 9730              	.LASF23:
 9731 096e 666C6F61 		.ascii	"float\000"
 9731      7400
 9732              	.LASF140:
 9733 0974 7850656E 		.ascii	"xPendedCounts\000"
 9733      64656443 
 9733      6F756E74 
 9733      7300
 9734              	.LASF237:
 9735 0982 44533138 		.ascii	"DS18x8_DataReady\000"
 9735      78385F44 
 9735      61746152 
 9735      65616479 
 9735      00
 9736              	.LASF41:
 9737 0993 7078496E 		.ascii	"pxIndex\000"
 9737      64657800 
 9738              	.LASF38:
 9739 099b 7076436F 		.ascii	"pvContainer\000"
 9739      6E746169 
 9739      6E657200 
 9740              	.LASF63:
 9741 09a7 6544656C 		.ascii	"eDeleted\000"
 9741      65746564 
 9741      00
 9742              	.LASF116:
 9743 09b0 65546173 		.ascii	"eTaskGetState\000"
 9743      6B476574 
 9743      53746174 
 9743      6500
 9744              	.LASF76:
 9745 09be 784D454D 		.ascii	"xMEMORY_REGION\000"
 9745      4F52595F 
 9745      52454749 
 9745      4F4E00
 9746              	.LASF106:
 9747 09cd 76546173 		.ascii	"vTaskDelayUntil\000"
 9747      6B44656C 
 9747      6179556E 
 9747      74696C00 
 9748              	.LASF236:
 9749 09dd 44533138 		.ascii	"DS18x8_Sensor\000"
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 278


 9749      78385F53 
 9749      656E736F 
 9749      7200
 9750              	.LASF176:
 9751 09eb 70727654 		.ascii	"prvTaskCheckFreeStackSpace\000"
 9751      61736B43 
 9751      6865636B 
 9751      46726565 
 9751      53746163 
 9752              	.LASF19:
 9753 0a06 696E7433 		.ascii	"int32_t\000"
 9753      325F7400 
 9754              	.LASF6:
 9755 0a0e 756E7369 		.ascii	"unsigned char\000"
 9755      676E6564 
 9755      20636861 
 9755      7200
 9756              	.LASF57:
 9757 0a1c 756C4E6F 		.ascii	"ulNotifiedValue\000"
 9757      74696669 
 9757      65645661 
 9757      6C756500 
 9758              	.LASF22:
 9759 0a2c 75696E74 		.ascii	"uint16\000"
 9759      313600
 9760              	.LASF128:
 9761 0a33 75784375 		.ascii	"uxCurrentBasePriority\000"
 9761      7272656E 
 9761      74426173 
 9761      65507269 
 9761      6F726974 
 9762              	.LASF82:
 9763 0a49 5443425F 		.ascii	"TCB_t\000"
 9763      7400
 9764              	.LASF161:
 9765 0a4f 7078556E 		.ascii	"pxUnblockedTCB\000"
 9765      626C6F63 
 9765      6B656454 
 9765      434200
 9766              	.LASF90:
 9767 0a5e 756C4269 		.ascii	"ulBitmap\000"
 9767      746D6170 
 9767      00
 9768              	.LASF121:
 9769 0a67 70784F76 		.ascii	"pxOverflowedDelayedList\000"
 9769      6572666C 
 9769      6F776564 
 9769      44656C61 
 9769      7965644C 
 9770              	.LASF228:
 9771 0a7f 78536368 		.ascii	"xSchedulerRunning\000"
 9771      6564756C 
 9771      65725275 
 9771      6E6E696E 
 9771      6700
 9772              	.LASF138:
 9773 0a91 76546173 		.ascii	"vTaskEndScheduler\000"
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 279


 9773      6B456E64 
 9773      53636865 
 9773      64756C65 
 9773      7200
 9774              	.LASF134:
 9775 0aa3 78546173 		.ascii	"xTaskToResume\000"
 9775      6B546F52 
 9775      6573756D 
 9775      6500
 9776              	.LASF139:
 9777 0ab1 78546173 		.ascii	"xTaskResumeAll\000"
 9777      6B526573 
 9777      756D6541 
 9777      6C6C00
 9778              	.LASF27:
 9779 0ac0 5461736B 		.ascii	"TaskFunction_t\000"
 9779      46756E63 
 9779      74696F6E 
 9779      5F7400
 9780              	.LASF39:
 9781 0acf 784C4953 		.ascii	"xLIST\000"
 9781      5400
 9782              	.LASF124:
 9783 0ad5 75785461 		.ascii	"uxTaskPriorityGetFromISR\000"
 9783      736B5072 
 9783      696F7269 
 9783      74794765 
 9783      7446726F 
 9784              	.LASF171:
 9785 0aee 76546173 		.ascii	"vTaskMissedYield\000"
 9785      6B4D6973 
 9785      73656459 
 9785      69656C64 
 9785      00
 9786              	.LASF55:
 9787 0aff 75784261 		.ascii	"uxBasePriority\000"
 9787      73655072 
 9787      696F7269 
 9787      747900
 9788              	.LASF191:
 9789 0b0e 75784F6E 		.ascii	"uxOnlyOneMutexHeld\000"
 9789      6C794F6E 
 9789      654D7574 
 9789      65784865 
 9789      6C6400
 9790              	.LASF101:
 9791 0b21 70727649 		.ascii	"prvInitialiseNewTask\000"
 9791      6E697469 
 9791      616C6973 
 9791      654E6577 
 9791      5461736B 
 9792              	.LASF136:
 9793 0b36 75785361 		.ascii	"uxSavedInterruptStatus\000"
 9793      76656449 
 9793      6E746572 
 9793      72757074 
 9793      53746174 
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 280


 9794              	.LASF111:
 9795 0b4d 7853686F 		.ascii	"xShouldDelay\000"
 9795      756C6444 
 9795      656C6179 
=======
 9568              	.LASF73:
 9569 0420 784F7665 		.ascii	"xOverflowCount\000"
 9569      72666C6F 
 9569      77436F75 
 9569      6E7400
 9570              	.LASF137:
 9571 042f 76546173 		.ascii	"vTaskStartScheduler\000"
 9571      6B537461 
 9571      72745363 
 9571      68656475 
 9571      6C657200 
 9572              	.LASF148:
 9573 0443 78546173 		.ascii	"xTaskIncrementTick\000"
 9573      6B496E63 
 9573      72656D65 
 9573      6E745469 
 9573      636B00
 9574              	.LASF208:
 9575 0456 78546173 		.ascii	"xTaskGenericNotifyFromISR\000"
 9575      6B47656E 
 9575      65726963 
 9575      4E6F7469 
 9575      66794672 
 9576              	.LASF156:
 9577 0470 76546173 		.ascii	"vTaskPlaceOnEventList\000"
 9577      6B506C61 
 9577      63654F6E 
 9577      4576656E 
 9577      744C6973 
 9578              	.LASF58:
 9579 0486 75634E6F 		.ascii	"ucNotifyState\000"
 9579      74696679 
 9579      53746174 
 9579      6500
 9580              	.LASF12:
 9581 0494 5F5F7569 		.ascii	"__uint32_t\000"
 9581      6E743332 
 9581      5F7400
 9582              	.LASF235:
 9583 049f 75785363 		.ascii	"uxSchedulerSuspended\000"
 9583      68656475 
 9583      6C657253 
 9583      75737065 
 9583      6E646564 
 9584              	.LASF135:
 9585 04b4 78546173 		.ascii	"xTaskResumeFromISR\000"
 9585      6B526573 
 9585      756D6546 
 9585      726F6D49 
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 271


 9585      535200
 9586              	.LASF0:
 9587 04c7 756E7369 		.ascii	"unsigned int\000"
 9587      676E6564 
 9587      20696E74 
 9587      00
 9588              	.LASF98:
 9589 04d4 78526574 		.ascii	"xReturn\000"
 9589      75726E00 
 9590              	.LASF112:
 9591 04dc 78436F6E 		.ascii	"xConstTickCount\000"
 9591      73745469 
 9591      636B436F 
 9591      756E7400 
 9592              	.LASF146:
 9593 04ec 78546173 		.ascii	"xTaskCatchUpTicks\000"
 9593      6B436174 
 9593      63685570 
 9593      5469636B 
 9593      7300
 9594              	.LASF159:
 9595 04fe 76546173 		.ascii	"vTaskPlaceOnUnorderedEventList\000"
 9595      6B506C61 
 9595      63654F6E 
 9595      556E6F72 
 9595      64657265 
 9596              	.LASF96:
 9597 051d 70784372 		.ascii	"pxCreatedTask\000"
 9597      65617465 
 9597      64546173 
 9597      6B00
 9598              	.LASF40:
 9599 052b 75784E75 		.ascii	"uxNumberOfItems\000"
 9599      6D626572 
 9599      4F664974 
 9599      656D7300 
 9600              	.LASF13:
 9601 053b 6C6F6E67 		.ascii	"long unsigned int\000"
 9601      20756E73 
 9601      69676E65 
 9601      6420696E 
 9601      7400
 9602              	.LASF60:
 9603 054d 65526561 		.ascii	"eReady\000"
 9603      647900
 9604              	.LASF203:
 9605 0554 78546173 		.ascii	"xTaskToNotify\000"
 9605      6B546F4E 
 9605      6F746966 
 9605      7900
 9606              	.LASF49:
 9607 0562 7078546F 		.ascii	"pxTopOfStack\000"
 9607      704F6653 
 9607      7461636B 
 9607      00
 9608              	.LASF95:
 9609 056f 70765061 		.ascii	"pvParameters\000"
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 272


 9609      72616D65 
 9609      74657273 
 9609      00
 9610              	.LASF209:
 9611 057c 70784869 		.ascii	"pxHigherPriorityTaskWoken\000"
 9611      67686572 
 9611      5072696F 
 9611      72697479 
 9611      5461736B 
 9612              	.LASF81:
 9613 0596 74736B54 		.ascii	"tskTCB\000"
 9613      434200
 9614              	.LASF70:
 9615 059d 65536574 		.ascii	"eSetValueWithoutOverwrite\000"
 9615      56616C75 
 9615      65576974 
 9615      686F7574 
 9615      4F766572 
 9616              	.LASF155:
 9617 05b7 7078436F 		.ascii	"pxConstList\000"
 9617      6E73744C 
 9617      69737400 
 9618              	.LASF9:
 9619 05c3 73686F72 		.ascii	"short unsigned int\000"
 9619      7420756E 
 9619      7369676E 
 9619      65642069 
 9619      6E7400
 9620              	.LASF28:
 9621 05d6 53746163 		.ascii	"StackType_t\000"
 9621      6B547970 
 9621      655F7400 
 9622              	.LASF104:
 9623 05e2 70785443 		.ascii	"pxTCB\000"
 9623      4200
 9624              	.LASF130:
 9625 05e8 78596965 		.ascii	"xYieldRequired\000"
 9625      6C645265 
 9625      71756972 
 9625      656400
 9626              	.LASF199:
 9627 05f7 756C4269 		.ascii	"ulBitsToClearOnEntry\000"
 9627      7473546F 
 9627      436C6561 
 9627      724F6E45 
 9627      6E747279 
 9628              	.LASF229:
 9629 060c 7850656E 		.ascii	"xPendedTicks\000"
 9629      64656454 
 9629      69636B73 
 9629      00
 9630              	.LASF26:
 9631 0619 70726573 		.ascii	"present\000"
 9631      656E7400 
 9632              	.LASF102:
 9633 0621 70727641 		.ascii	"prvAddNewTaskToReadyList\000"
 9633      64644E65 
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 273


 9633      77546173 
 9633      6B546F52 
 9633      65616479 
 9634              	.LASF133:
 9635 063a 76546173 		.ascii	"vTaskResume\000"
 9635      6B526573 
 9635      756D6500 
 9636              	.LASF120:
 9637 0646 70784465 		.ascii	"pxDelayedList\000"
 9637      6C617965 
 9637      644C6973 
 9637      7400
 9638              	.LASF239:
 9639 0654 70784375 		.ascii	"pxCurrentTCB\000"
 9639      7272656E 
 9639      74544342 
 9639      00
 9640              	.LASF123:
 9641 0661 75785265 		.ascii	"uxReturn\000"
 9641      7475726E 
 9641      00
 9642              	.LASF219:
 9643 066a 70784465 		.ascii	"pxDelayedTaskList\000"
 9643      6C617965 
 9643      64546173 
 9643      6B4C6973 
 9643      7400
 9644              	.LASF141:
 9645 067c 78546173 		.ascii	"xTaskGetTickCount\000"
 9645      6B476574 
 9645      5469636B 
 9645      436F756E 
 9645      7400
 9646              	.LASF157:
 9647 068e 70784576 		.ascii	"pxEventList\000"
 9647      656E744C 
 9647      69737400 
 9648              	.LASF86:
 9649 069a 76506F72 		.ascii	"vPortRaiseBASEPRI\000"
 9649      74526169 
 9649      73654241 
 9649      53455052 
 9649      4900
 9650              	.LASF46:
 9651 06ac 4C697374 		.ascii	"List_t\000"
 9651      5F7400
 9652              	.LASF212:
 9653 06b3 756C5461 		.ascii	"ulTaskNotifyValueClear\000"
 9653      736B4E6F 
 9653      74696679 
 9653      56616C75 
 9653      65436C65 
 9654              	.LASF177:
 9655 06ca 70756353 		.ascii	"pucStackByte\000"
 9655      7461636B 
 9655      42797465 
 9655      00
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 274


 9656              	.LASF181:
 9657 06d7 70727644 		.ascii	"prvDeleteTCB\000"
 9657      656C6574 
 9657      65544342 
 9657      00
 9658              	.LASF172:
 9659 06e4 70727649 		.ascii	"prvIdleTask\000"
 9659      646C6554 
 9659      61736B00 
 9660              	.LASF169:
 9661 06f0 78456C61 		.ascii	"xElapsedTime\000"
 9661      70736564 
 9661      54696D65 
 9661      00
 9662              	.LASF151:
 9663 06fd 76546173 		.ascii	"vTaskSwitchContext\000"
 9663      6B537769 
 9663      74636843 
 9663      6F6E7465 
 9663      787400
 9664              	.LASF68:
 9665 0710 65496E63 		.ascii	"eIncrement\000"
 9665      72656D65 
 9665      6E7400
 9666              	.LASF185:
 9667 071b 70784D75 		.ascii	"pxMutexHolder\000"
 9667      74657848 
 9667      6F6C6465 
 9667      7200
 9668              	.LASF53:
 9669 0729 70785374 		.ascii	"pxStack\000"
 9669      61636B00 
 9670              	.LASF220:
 9671 0731 70784F76 		.ascii	"pxOverflowDelayedTaskList\000"
 9671      6572666C 
 9671      6F774465 
 9671      6C617965 
 9671      64546173 
 9672              	.LASF15:
 9673 074b 73697A65 		.ascii	"sizetype\000"
 9673      74797065 
 9673      00
 9674              	.LASF189:
 9675 0754 75784869 		.ascii	"uxHighestPriorityWaitingTask\000"
 9675      67686573 
 9675      74507269 
 9675      6F726974 
 9675      79576169 
 9676              	.LASF2:
 9677 0771 6C6F6E67 		.ascii	"long double\000"
 9677      20646F75 
 9677      626C6500 
 9678              	.LASF100:
 9679 077d 78526567 		.ascii	"xRegions\000"
 9679      696F6E73 
 9679      00
 9680              	.LASF210:
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 275


 9681 0786 76546173 		.ascii	"vTaskNotifyGiveFromISR\000"
 9681      6B4E6F74 
 9681      69667947 
 9681      69766546 
 9681      726F6D49 
 9682              	.LASF221:
 9683 079d 7850656E 		.ascii	"xPendingReadyList\000"
 9683      64696E67 
 9683      52656164 
 9683      794C6973 
 9683      7400
 9684              	.LASF115:
 9685 07af 78546173 		.ascii	"xTaskCreate\000"
 9685      6B437265 
 9685      61746500 
 9686              	.LASF132:
 9687 07bb 78546173 		.ascii	"xTaskToSuspend\000"
 9687      6B546F53 
 9687      75737065 
 9687      6E6400
 9688              	.LASF183:
 9689 07ca 78546173 		.ascii	"xTaskGetCurrentTaskHandle\000"
 9689      6B476574 
 9689      43757272 
 9689      656E7454 
 9689      61736B48 
 9690              	.LASF92:
 9691 07e4 70785461 		.ascii	"pxTaskCode\000"
 9691      736B436F 
 9691      646500
 9692              	.LASF99:
 9693 07ef 756C5374 		.ascii	"ulStackDepth\000"
 9693      61636B44 
 9693      65707468 
 9693      00
 9694              	.LASF87:
 9695 07fc 756C506F 		.ascii	"ulPortRaiseBASEPRI\000"
 9695      72745261 
 9695      69736542 
 9695      41534550 
 9695      524900
 9696              	.LASF51:
 9697 080f 78457665 		.ascii	"xEventListItem\000"
 9697      6E744C69 
 9697      73744974 
 9697      656D00
 9698              	.LASF178:
 9699 081e 756C436F 		.ascii	"ulCount\000"
 9699      756E7400 
 9700              	.LASF69:
 9701 0826 65536574 		.ascii	"eSetValueWithOverwrite\000"
 9701      56616C75 
 9701      65576974 
 9701      684F7665 
 9701      72777269 
 9702              	.LASF147:
 9703 083d 78546963 		.ascii	"xTicksToCatchUp\000"
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 276


 9703      6B73546F 
 9703      43617463 
 9703      68557000 
 9704              	.LASF227:
 9705 084d 7578546F 		.ascii	"uxTopReadyPriority\000"
 9705      70526561 
 9705      64795072 
 9705      696F7269 
 9705      747900
 9706              	.LASF107:
 9707 0860 70785072 		.ascii	"pxPreviousWakeTime\000"
 9707      6576696F 
 9707      75735761 
 9707      6B655469 
 9707      6D6500
 9708              	.LASF78:
 9709 0873 756C4C65 		.ascii	"ulLengthInBytes\000"
 9709      6E677468 
 9709      496E4279 
 9709      74657300 
 9710              	.LASF85:
 9711 0883 76506F72 		.ascii	"vPortSetBASEPRI\000"
 9711      74536574 
 9711      42415345 
 9711      50524900 
 9712              	.LASF43:
 9713 0893 4C697374 		.ascii	"ListItem_t\000"
 9713      4974656D 
 9713      5F7400
 9714              	.LASF188:
 9715 089e 76546173 		.ascii	"vTaskPriorityDisinheritAfterTimeout\000"
 9715      6B507269 
 9715      6F726974 
 9715      79446973 
 9715      696E6865 
 9716              	.LASF154:
 9717 08c2 7578546F 		.ascii	"uxTopPriority\000"
 9717      70507269 
 9717      6F726974 
 9717      7900
 9718              	.LASF201:
 9719 08d0 70756C4E 		.ascii	"pulNotificationValue\000"
 9719      6F746966 
 9719      69636174 
 9719      696F6E56 
 9719      616C7565 
 9720              	.LASF36:
 9721 08e5 70785072 		.ascii	"pxPrevious\000"
 9721      6576696F 
 9721      757300
 9722              	.LASF103:
 9723 08f0 78546173 		.ascii	"xTaskToDelete\000"
 9723      6B546F44 
 9723      656C6574 
 9723      6500
 9724              	.LASF127:
 9725 08fe 75784E65 		.ascii	"uxNewPriority\000"
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 277


 9725      77507269 
 9725      6F726974 
 9725      7900
 9726              	.LASF23:
 9727 090c 666C6F61 		.ascii	"float\000"
 9727      7400
 9728              	.LASF140:
 9729 0912 7850656E 		.ascii	"xPendedCounts\000"
 9729      64656443 
 9729      6F756E74 
 9729      7300
 9730              	.LASF237:
 9731 0920 44533138 		.ascii	"DS18x8_DataReady\000"
 9731      78385F44 
 9731      61746152 
 9731      65616479 
 9731      00
 9732              	.LASF41:
 9733 0931 7078496E 		.ascii	"pxIndex\000"
 9733      64657800 
 9734              	.LASF38:
 9735 0939 7076436F 		.ascii	"pvContainer\000"
 9735      6E746169 
 9735      6E657200 
 9736              	.LASF63:
 9737 0945 6544656C 		.ascii	"eDeleted\000"
 9737      65746564 
 9737      00
 9738              	.LASF116:
 9739 094e 65546173 		.ascii	"eTaskGetState\000"
 9739      6B476574 
 9739      53746174 
 9739      6500
 9740              	.LASF76:
 9741 095c 784D454D 		.ascii	"xMEMORY_REGION\000"
 9741      4F52595F 
 9741      52454749 
 9741      4F4E00
 9742              	.LASF106:
 9743 096b 76546173 		.ascii	"vTaskDelayUntil\000"
 9743      6B44656C 
 9743      6179556E 
 9743      74696C00 
 9744              	.LASF236:
 9745 097b 44533138 		.ascii	"DS18x8_Sensor\000"
 9745      78385F53 
 9745      656E736F 
 9745      7200
 9746              	.LASF176:
 9747 0989 70727654 		.ascii	"prvTaskCheckFreeStackSpace\000"
 9747      61736B43 
 9747      6865636B 
 9747      46726565 
 9747      53746163 
 9748              	.LASF170:
 9749 09a4 76546173 		.ascii	"vTaskSuspendAll\000"
 9749      6B537573 
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 278


 9749      70656E64 
 9749      416C6C00 
 9750              	.LASF19:
 9751 09b4 696E7433 		.ascii	"int32_t\000"
 9751      325F7400 
 9752              	.LASF6:
 9753 09bc 756E7369 		.ascii	"unsigned char\000"
 9753      676E6564 
 9753      20636861 
 9753      7200
 9754              	.LASF57:
 9755 09ca 756C4E6F 		.ascii	"ulNotifiedValue\000"
 9755      74696669 
 9755      65645661 
 9755      6C756500 
 9756              	.LASF22:
 9757 09da 75696E74 		.ascii	"uint16\000"
 9757      313600
 9758              	.LASF128:
 9759 09e1 75784375 		.ascii	"uxCurrentBasePriority\000"
 9759      7272656E 
 9759      74426173 
 9759      65507269 
 9759      6F726974 
 9760              	.LASF82:
 9761 09f7 5443425F 		.ascii	"TCB_t\000"
 9761      7400
 9762              	.LASF161:
 9763 09fd 7078556E 		.ascii	"pxUnblockedTCB\000"
 9763      626C6F63 
 9763      6B656454 
 9763      434200
 9764              	.LASF90:
 9765 0a0c 756C4269 		.ascii	"ulBitmap\000"
 9765      746D6170 
 9765      00
 9766              	.LASF121:
 9767 0a15 70784F76 		.ascii	"pxOverflowedDelayedList\000"
 9767      6572666C 
 9767      6F776564 
 9767      44656C61 
 9767      7965644C 
 9768              	.LASF228:
 9769 0a2d 78536368 		.ascii	"xSchedulerRunning\000"
 9769      6564756C 
 9769      65725275 
 9769      6E6E696E 
 9769      6700
 9770              	.LASF138:
 9771 0a3f 76546173 		.ascii	"vTaskEndScheduler\000"
 9771      6B456E64 
 9771      53636865 
 9771      64756C65 
 9771      7200
 9772              	.LASF134:
 9773 0a51 78546173 		.ascii	"xTaskToResume\000"
 9773      6B546F52 
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 279


 9773      6573756D 
 9773      6500
 9774              	.LASF139:
 9775 0a5f 78546173 		.ascii	"xTaskResumeAll\000"
 9775      6B526573 
 9775      756D6541 
 9775      6C6C00
 9776              	.LASF27:
 9777 0a6e 5461736B 		.ascii	"TaskFunction_t\000"
 9777      46756E63 
 9777      74696F6E 
 9777      5F7400
 9778              	.LASF39:
 9779 0a7d 784C4953 		.ascii	"xLIST\000"
 9779      5400
 9780              	.LASF124:
 9781 0a83 75785461 		.ascii	"uxTaskPriorityGetFromISR\000"
 9781      736B5072 
 9781      696F7269 
 9781      74794765 
 9781      7446726F 
 9782              	.LASF171:
 9783 0a9c 76546173 		.ascii	"vTaskMissedYield\000"
 9783      6B4D6973 
 9783      73656459 
 9783      69656C64 
 9783      00
 9784              	.LASF55:
 9785 0aad 75784261 		.ascii	"uxBasePriority\000"
 9785      73655072 
 9785      696F7269 
 9785      747900
 9786              	.LASF191:
 9787 0abc 75784F6E 		.ascii	"uxOnlyOneMutexHeld\000"
 9787      6C794F6E 
 9787      654D7574 
 9787      65784865 
 9787      6C6400
 9788              	.LASF101:
 9789 0acf 70727649 		.ascii	"prvInitialiseNewTask\000"
 9789      6E697469 
 9789      616C6973 
 9789      654E6577 
 9789      5461736B 
 9790              	.LASF136:
 9791 0ae4 75785361 		.ascii	"uxSavedInterruptStatus\000"
 9791      76656449 
 9791      6E746572 
 9791      72757074 
 9791      53746174 
 9792              	.LASF111:
 9793 0afb 7853686F 		.ascii	"xShouldDelay\000"
 9793      756C6444 
 9793      656C6179 
 9793      00
 9794              	.LASF59:
 9795 0b08 6552756E 		.ascii	"eRunning\000"
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 280


 9795      6E696E67 
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754
 9795      00
 9796              	.LASF59:
 9797 0b5a 6552756E 		.ascii	"eRunning\000"
 9797      6E696E67 
 9797      00
 9798              	.LASF174:
 9799 0b63 70727643 		.ascii	"prvCheckTasksWaitingTermination\000"
 9799      6865636B 
 9799      5461736B 
 9799      73576169 
 9799      74696E67 
 9800              	.LASF117:
 9801 0b83 78546173 		.ascii	"xTask\000"
 9801      6B00
 9802              	.LASF79:
 9803 0b89 756C5061 		.ascii	"ulParameters\000"
 9803      72616D65 
 9803      74657273 
 9803      00
 9804              	.LASF32:
 9805 0b96 44533138 		.ascii	"DS18x8_TSensor\000"
 9805      78385F54 
 9805      53656E73 
 9805      6F7200
 9806              	.LASF170:
 9807 0ba5 76546173 		.ascii	"vTaskSuspendAll\000"
 9807      6B537573 
 9807      70656E64 
 9807      416C6C00 
 9808              	.LASF56:
 9809 0bb5 75784D75 		.ascii	"uxMutexesHeld\000"
 9809      74657865 
 9809      7348656C 
 9809      6400
 9810              	.LASF89:
 9811 0bc3 756C4E65 		.ascii	"ulNewMaskValue\000"
 9811      774D6173 
 9811      6B56616C 
 9811      756500
 9812              	.LASF214:
 9813 0bd2 70727641 		.ascii	"prvAddCurrentTaskToDelayedList\000"
 9813      64644375 
 9813      7272656E 
 9813      74546173 
 9813      6B546F44 
 9814              	.LASF16:
 9815 0bf1 63686172 		.ascii	"char\000"
 9815      00
 9816              	.LASF144:
 9817 0bf6 70635461 		.ascii	"pcTaskGetName\000"
 9817      736B4765 
 9817      744E616D 
<<<<<<< HEAD
 9817      6500
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 281
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 281
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 9818              	.LASF160:
 9819 0c04 78546173 		.ascii	"xTaskRemoveFromEventList\000"
 9819      6B52656D 
 9819      6F766546 
 9819      726F6D45 
 9819      76656E74 
 9820              	.LASF194:
 9821 0c1d 70765461 		.ascii	"pvTaskIncrementMutexHeldCount\000"
 9821      736B496E 
 9821      6372656D 
 9821      656E744D 
 9821      75746578 
 9822              	.LASF223:
 9823 0c3b 75784465 		.ascii	"uxDeletedTasksWaitingCleanUp\000"
 9823      6C657465 
 9823      64546173 
 9823      6B735761 
 9823      6974696E 
 9824              	.LASF105:
 9825 0c58 76546173 		.ascii	"vTaskDelete\000"
 9825      6B44656C 
 9825      65746500 
 9826              	.LASF125:
 9827 0c64 75785361 		.ascii	"uxSavedInterruptState\000"
 9827      76656449 
 9827      6E746572 
 9827      72757074 
 9827      53746174 
 9828              	.LASF10:
 9829 0c7a 5F5F696E 		.ascii	"__int32_t\000"
 9829      7433325F 
 9829      7400
 9830              	.LASF167:
 9831 0c84 78546173 		.ascii	"xTaskCheckForTimeOut\000"
 9831      6B436865 
 9831      636B466F 
 9831      7254696D 
 9831      654F7574 
 9832              	.LASF163:
 9833 0c99 70784576 		.ascii	"pxEventListItem\000"
 9833      656E744C 
 9833      69737449 
 9833      74656D00 
 9834              	.LASF232:
 9835 0ca9 75785461 		.ascii	"uxTaskNumber\000"
 9835      736B4E75 
 9835      6D626572 
 9835      00
 9836              	.LASF150:
 9837 0cb6 70785465 		.ascii	"pxTemp\000"
 9837      6D7000
 9838              	.LASF184:
 9839 0cbd 78546173 		.ascii	"xTaskPriorityInherit\000"
 9839      6B507269 
 9839      6F726974 
 9839      79496E68 
<<<<<<< HEAD
 9839      65726974 
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 282
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 282
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 9840              	.LASF234:
 9841 0cd2 7849646C 		.ascii	"xIdleTaskHandle\000"
 9841      65546173 
 9841      6B48616E 
 9841      646C6500 
 9842              	.LASF33:
 9843 0ce2 784C4953 		.ascii	"xLIST_ITEM\000"
 9843      545F4954 
 9843      454D00
 9844              	.LASF216:
 9845 0ced 70785265 		.ascii	"pxReadyTasksLists\000"
 9845      61647954 
 9845      61736B73 
 9845      4C697374 
 9845      7300
 9846              	.LASF193:
 9847 0cff 75785461 		.ascii	"uxTaskGetNumberOfTasks\000"
 9847      736B4765 
 9847      744E756D 
 9847      6265724F 
 9847      66546173 
 9848              	.LASF153:
 9849 0d16 756C4368 		.ascii	"ulCheckValue\000"
 9849      65636B56 
 9849      616C7565 
 9849      00
 9850              	.LASF195:
 9851 0d23 756C5461 		.ascii	"ulTaskNotifyTake\000"
 9851      736B4E6F 
 9851      74696679 
 9851      54616B65 
 9851      00
 9852              	.LASF217:
 9853 0d34 7844656C 		.ascii	"xDelayedTaskList1\000"
 9853      61796564 
 9853      5461736B 
 9853      4C697374 
 9853      3100
 9854              	.LASF218:
 9855 0d46 7844656C 		.ascii	"xDelayedTaskList2\000"
 9855      61796564 
 9855      5461736B 
 9855      4C697374 
 9855      3200
 9856              	.LASF231:
 9857 0d58 784E756D 		.ascii	"xNumOfOverflows\000"
 9857      4F664F76 
 9857      6572666C 
 9857      6F777300 
 9858              	.LASF202:
 9859 0d68 78546173 		.ascii	"xTaskGenericNotify\000"
 9859      6B47656E 
 9859      65726963 
 9859      4E6F7469 
 9859      667900
 9860              	.LASF226:
<<<<<<< HEAD
 9861 0d7b 78546963 		.ascii	"xTickCount\000"
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 283
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 283
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 9861      6B436F75 
 9861      6E7400
 9862              	.LASF166:
 9863 0d86 76546173 		.ascii	"vTaskInternalSetTimeOutState\000"
 9863      6B496E74 
 9863      65726E61 
 9863      6C536574 
 9863      54696D65 
 9864              	.LASF37:
 9865 0da3 70764F77 		.ascii	"pvOwner\000"
 9865      6E657200 
 9866              	.LASF34:
 9867 0dab 78497465 		.ascii	"xItemValue\000"
 9867      6D56616C 
 9867      756500
 9868              	.LASF88:
 9869 0db6 7563506F 		.ascii	"ucPortCountLeadingZeros\000"
 9869      7274436F 
 9869      756E744C 
 9869      65616469 
 9869      6E675A65 
 9870              	.LASF114:
 9871 0dce 78546963 		.ascii	"xTicksToDelay\000"
 9871      6B73546F 
 9871      44656C61 
 9871      7900
 9872              	.LASF108:
 9873 0ddc 7854696D 		.ascii	"xTimeIncrement\000"
 9873      65496E63 
 9873      72656D65 
 9873      6E7400
 9874              	.LASF25:
 9875 0deb 54656D70 		.ascii	"Temperature\000"
 9875      65726174 
 9875      75726500 
 9876              	.LASF64:
 9877 0df7 65496E76 		.ascii	"eInvalid\000"
 9877      616C6964 
 9877      00
 9878              	.LASF54:
 9879 0e00 70635461 		.ascii	"pcTaskName\000"
 9879      736B4E61 
 9879      6D6500
 9880              	.LASF17:
 9881 0e0b 75696E74 		.ascii	"uint8_t\000"
 9881      385F7400 
 9882              	.LASF168:
 9883 0e13 70785469 		.ascii	"pxTicksToWait\000"
 9883      636B7354 
 9883      6F576169 
 9883      7400
 9884              	.LASF175:
 9885 0e21 70727654 		.ascii	"prvTaskIsTaskSuspended\000"
 9885      61736B49 
 9885      73546173 
 9885      6B537573 
<<<<<<< HEAD
 9885      70656E64 
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 284
=======
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 284
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 9886              	.LASF66:
 9887 0e38 654E6F41 		.ascii	"eNoAction\000"
 9887      6374696F 
 9887      6E00
 9888              	.LASF35:
 9889 0e42 70784E65 		.ascii	"pxNext\000"
 9889      787400
 9890              	.LASF65:
 9891 0e49 65546173 		.ascii	"eTaskState\000"
 9891      6B537461 
 9891      746500
 9892              	.LASF71:
 9893 0e54 654E6F74 		.ascii	"eNotifyAction\000"
 9893      69667941 
 9893      6374696F 
 9893      6E00
 9894              	.LASF198:
 9895 0e62 78546173 		.ascii	"xTaskNotifyWait\000"
 9895      6B4E6F74 
 9895      69667957 
 9895      61697400 
 9896              	.LASF197:
 9897 0e72 756C5265 		.ascii	"ulReturn\000"
 9897      7475726E 
 9897      00
 9898              	.LASF74:
 9899 0e7b 7854696D 		.ascii	"xTimeOnEntering\000"
 9899      654F6E45 
 9899      6E746572 
 9899      696E6700 
 9900              	.LASF187:
 9901 0e8b 78546173 		.ascii	"xTaskPriorityDisinherit\000"
 9901      6B507269 
 9901      6F726974 
 9901      79446973 
 9901      696E6865 
 9902              	.LASF52:
 9903 0ea3 75785072 		.ascii	"uxPriority\000"
 9903      696F7269 
 9903      747900
 9904              	.LASF179:
 9905 0eae 75785461 		.ascii	"uxTaskGetStackHighWaterMark\000"
 9905      736B4765 
 9905      74537461 
 9905      636B4869 
 9905      67685761 
 9906              	.LASF190:
 9907 0eca 75785072 		.ascii	"uxPriorityToUse\000"
 9907      696F7269 
 9907      7479546F 
 9907      55736500 
 9908              	.LASF93:
 9909 0eda 70634E61 		.ascii	"pcName\000"
 9909      6D6500
 9910              	.LASF122:
<<<<<<< HEAD
 9911 0ee1 75785461 		.ascii	"uxTaskPriorityGet\000"
 9911      736B5072 
ARM GAS  C:\Users\Gusta\AppData\Local\Temp\ccKuB3iQ.s 			page 285
=======
 9911 0ee3 75785461 		.ascii	"uxTaskPriorityGet\000"
ARM GAS  C:\Users\mag94\AppData\Local\Temp\ccuBIIa1.s 			page 285
>>>>>>> e8e69b4d3ec318abfa601bc443398956ad360754


 9911      696F7269 
 9911      74794765 
 9911      7400
 9912              	.LASF164:
 9913 0ef3 76546173 		.ascii	"vTaskSetTimeOutState\000"
 9913      6B536574 
 9913      54696D65 
 9913      4F757453 
 9913      74617465 
 9914              	.LASF200:
 9915 0f08 756C4269 		.ascii	"ulBitsToClearOnExit\000"
 9915      7473546F 
 9915      436C6561 
 9915      724F6E45 
 9915      78697400 
 9916              	.LASF30:
 9917 0f1c 55426173 		.ascii	"UBaseType_t\000"
 9917      65547970 
 9917      655F7400 
 9918              	.LASF24:
 9919 0f28 646F7562 		.ascii	"double\000"
 9919      6C6500
 9920              	.LASF20:
 9921 0f2f 75696E74 		.ascii	"uint32_t\000"
 9921      33325F74 
 9921      00
 9922              	.LASF162:
 9923 0f38 76546173 		.ascii	"vTaskRemoveFromUnorderedEventList\000"
 9923      6B52656D 
 9923      6F766546 
 9923      726F6D55 
 9923      6E6F7264 
 9924              	.LASF152:
 9925 0f5a 70756C53 		.ascii	"pulStack\000"
 9925      7461636B 
 9925      00
 9926              	.LASF173:
 9927 0f63 70727649 		.ascii	"prvInitialiseTaskLists\000"
 9927      6E697469 
 9927      616C6973 
 9927      65546173 
 9927      6B4C6973 
 9928              		.ident	"GCC: (GNU Tools for ARM Embedded Processors) 5.4.1 20160609 (release) [ARM/embedded-5-bran
